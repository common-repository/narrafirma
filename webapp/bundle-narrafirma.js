define('js/nls/applicationMessages',["require", "exports"], function (require, exports) {
    "use strict";
    var messages = {
        root: {
            // Do not translate text in double braces since they are identifiers looked up and replaced by the program at runtime
            // For example: {{total}} should stay the same in the translation
            dashboard_status_label: "reminders:",
            question_not_yet_answered: "(Not Yet Entered)",
            // Translation of buttons
            button_home: "Home",
            button_home_title: "Go home to main dashboard",
            button_previousPage: "Previous Page",
            button_nextPage: "Next Page",
            button_loadLatest: "Load latest",
            button_loadVersion: "Load version",
            button_save: "Save",
            button_debug: "Debug",
            button_importExport: "Import/Export",
            // Grid buttons
            button_OK: "OK",
            button_Cancel: "Cancel",
            button_Done: "Done",
            button_View: "View",
            button_Add: "Add",
            button_Remove: "Remove",
            button_Edit: "Edit",
            button_Duplicate: "Duplicate",
            button_Up: "Move Up",
            button_Down: "Move Down",
            button_navigateStart: "First",
            button_navigatePrevious: "Previous",
            button_navigateNext: "Next",
            button_navigateEnd: "Last",
            button_navigateRandom: "Random",
            // Story browser button
            button_Filter: "Filter -- show only stories where both questions have the selected values",
            // Used for test of survey in main.js
            "surveySubmit": "Submit Survey",
            "surveyCancel": "Cancel",
            "button_tellAnotherStory": "Tell another story",
            "button_dontTellAnotherStory": "Done with adding stories",
            // select widgets
            selection_has_not_been_made: " -- select -- ",
            // calculations
            calculate_quizScoreResult_template: "{{total}} of {{possibleTotal}} ({{percent}}%)",
            // other
            copyDraftPNIQuestion_template: "Copied {{copiedAnswersCount}} answers.\n\n(Note that blank draft answers are not copied, and non-blank final answers are not replaced.)",
            no_questions_answered_on_page: "(No questions answered on this page)",
            // Used for boolean choice widget
            boolean_choice_yes: "yes",
            boolean_choice_no: "no",
            // Used for graph browser
            updateGraph: "Update Graph",
            // Used for templates
            button_chooseATemplateToInsert: "Choose a template to insert...",
            title_chooseATemplate: "Choose a template",
            // eliciting or questions
            "category::shortName": "Category",
            "id::shortName": "ID",
            "shortName::shortName": "Short name",
            "text::shortName": "Text",
            "type::shortName": "Type",
            "options::shortName": "Options",
            "category::prompt": "Category",
            "id::prompt": "ID",
            "shortName::prompt": "Short name",
            "text::prompt": "Text",
            "type::prompt": "Type",
            "options::prompt": "Options",
            // activities
            "name::shortName": "Name",
            // duplicated above for questions: "type::shortName": "type",
            "plan::shortName": "Plan",
            "optionalParts::shortName": "Optional parts",
            "duration::shortName": "Duration",
            "recording::shortName": "Recording",
            "materials::shortName": "Materials",
            "spaces::shortName": "Spaces",
            "facilitation::shortName": "Facilitation",
            "name::prompt": "Name",
            // duplicated above for questions: "type::prompt": "type",
            "plan::prompt": "Plan",
            "optionalParts::prompt": "Optional parts",
            "duration::prompt": "Duration",
            "recording::prompt": "Recording",
            "materials::prompt": "Materials",
            "spaces::prompt": "Spaces",
            "facilitation::prompt": "Facilitation",
            "button_UseTemplate": "Use template",
            // use for recommendations table
            button_showRecommendationsTable: "Show recommendations table",
            title_recommendationsTable: "Recommendations table",
            // For clustering diagram
            clusterDiagramSource_titleID: "Cluster Diagram Source",
            clusterDiagramSource_okButtonID: "Update",
            // For project import/export dialog
            projectImportExportDialog_title: "Project Design Import/Export",
            projectImportExportDialog_okButtonText: "Import",
            // For theming
            button_addTheme: "Add theme",
            // For general recommendations:
            "participantGroup_status::shortName": "Status",
            "participantGroup_confidence::shortName": "Self-confidence",
            "participantGroup_time::shortName": "Free time",
            "participantGroup_education::shortName": "Education level",
            "participantGroup_physicalDisabilities::shortName": "Physical disabilities",
            "participantGroup_emotionalImpairments::shortName": "Emotional impairments",
            "participantGroup_performing::shortName": "Performance",
            "participantGroup_conforming::shortName": "Conformance",
            "participantGroup_promoting::shortName": "Self-promotion",
            "participantGroup_venting::shortName": "Speaking out",
            "participantGroup_interest::shortName": "Motivated",
            "participantGroup_feelings_project::shortName": "Feelings about project",
            "participantGroup_feelings_facilitator::shortName": "Feelings about you",
            "participantGroup_feelings_stories::shortName": "Feelings about stories",
            "participantGroup_topic_feeling::shortName": "Feelings about topic",
            "participantGroup_topic_private::shortName": "Privacy of topic",
            "participantGroup_topic_articulate::shortName": "How articulate",
            "participantGroup_topic_timeframe::shortName": "Timeframe",
            "aboutYou_experience::shortName": "Your experience with PNI",
            "aboutYou_help::shortName": "Your available help",
            "aboutYou_tech::shortName": "Your technology experience",
            // For interventions recommendations
            "outcomes_peopleFeltHeard::shortName": "Felt heard",
            "outcomes_peopleFeltInvolved::shortName": "Felt involved",
            "outcomes_peopleLearnedAboutCommOrg::shortName": "Learned about community",
            "outcomes_peopleWantedToTellMoreStories::shortName": "Wanted to tell more",
            "outcomes_peopleWantedToShareMoreStoriesWithEachOther::shortName": "Wanted to share more",
            "outcomes_peopleFeltStoriesNeededToBeHeard::shortName": "Felt that stories needed to be heard",
            "outcomes_peopleFeltNobodyCares::shortName": "Felt that nobody cares",
            "outcomes_peopleFeltNobodyCanMeetNeeds::shortName": "Needs could not be met",
            "outcomes_peopleFeltTheyNeedNewStories::shortName": "Needed to tell themselves new stories",
            "outcomes_peopleWantedToKeepExploring::shortName": "Wanted more exploration",
            "outcomes_crisisPointsWereFound::shortName": "Crisis points",
            "outcomes_issuesWereBeyondWords::shortName": "Beyond words",
            "outcomes_peopleLearnedAboutTopic::shortName": "Learned about topic",
            "outcomes_issuesNewMembersStruggleWith::shortName": "New members needed help",
            "outcomes_foundInfoWithoutUnderstanding::shortName": "Had more information than understanding",
            "outcomes_foundOverConfidence::shortName": "Had more confidence than skill",
            "outcomes_peopleCuriousAboutStoryWork::shortName": "Wanted to learn about story work"
        }
    };
    return messages;
});

define('js/panelBuilder/browser',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // launchApplication function inspired by: http://stackoverflow.com/questions/528671/javascript-window-open-only-if-the-window-does-not-already-exist
    var openedWindows = {};
    function launchApplication(url, windowName) {
        var openedWindowInfo = openedWindows[windowName];
        if (openedWindowInfo && !openedWindowInfo.window.closed) {
            if (openedWindowInfo.url !== url) {
                openedWindowInfo.window.location.replace(url);
            }
        }
        if (typeof openedWindowInfo === 'undefined' || openedWindowInfo.window.closed) {
            var openedWindow = window.open(url, windowName, "");
            openedWindowInfo = { window: openedWindow, url: url };
            openedWindows[windowName] = openedWindowInfo;
        }
        else {
            openedWindowInfo.window.focus();
        }
    }
    exports.launchApplication = launchApplication;
});

!function() {
  var d3 = {
    version: "3.5.5"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.slice(0, i);
        name = name.slice(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
            exitNodes[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues[i] = keyValue;
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = nodes;
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged && d3.event.target === target);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
    var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
    function interpolate(t) {
      var s = t * S;
      if (dr) {
        var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      }
      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
    }
    interpolate.duration = S * 1e3;
    return interpolate;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: +_
      };
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      });
      center0 = null;
    }
    function mousedowned() {
      var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged && d3.event.target === target);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else translate0 = location(center0 = center || d3.mouse(this)), 
      d3_selection_interrupt.call(this), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/i.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format.toLowerCase())) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      f: false,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now();
    d3_timer_active = d3_timer_queueHead;
    while (d3_timer_active) {
      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
      d3_timer_active = d3_timer_active.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.f) {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      } else {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
  }
  d3.geo.bounds = function() {
    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dλSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
        range[0] = λ0, range[1] = λ1;
      }
    };
    function point(λ, φ) {
      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
      if (φ < φ0) φ0 = φ;
      if (φ > φ1) φ1 = φ;
    }
    function linePoint(λ, φ) {
      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = inflection[1] * d3_degrees;
          if (φi > φ1) φ1 = φi;
        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = -inflection[1] * d3_degrees;
          if (φi < φ0) φ0 = φi;
        } else {
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        if (antimeridian) {
          if (λ < λ_) {
            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
          } else {
            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
          }
        } else {
          if (λ1 >= λ0) {
            if (λ < λ0) λ0 = λ;
            if (λ > λ1) λ1 = λ;
          } else {
            if (λ > λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          }
        }
      } else {
        point(λ, φ);
      }
      p0 = p, λ_ = λ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = λ0, range[1] = λ1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(λ, φ) {
      if (p0) {
        var dλ = λ - λ_;
        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
      } else λ__ = λ, φ__ = φ;
      d3_geo_area.point(λ, φ);
      linePoint(λ, φ);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(λ__, φ__);
      d3_geo_area.lineEnd();
      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
      range[0] = λ0, range[1] = λ1;
      p0 = null;
    }
    function angle(λ0, λ1) {
      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      φ1 = λ1 = -(λ0 = φ0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dλ;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
        }
      }
      ranges = range = null;
      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < ε2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < ε2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00, x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ00 = λ, φ00 = φ;
      d3_geo_centroid.point = nextPoint;
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(λ00, φ00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        var point = rotate(λ, φ);
        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        var point = rotate(λ, φ);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(λ, φ) {
        ring.push([ λ, φ ]);
        var point = rotate(λ, φ);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
        if (abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * halfπ;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (abs(from[0] - to[0]) > ε) {
      var s = from[0] < to[0] ? π : -π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
      }
    }
    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(λ, φ) {
      var r = smallRadius ? radius : π - radius, code = 0;
      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function forward(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, τ);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(λ, φ) {
        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(λ, φ) {
    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * τ;
      } else {
        from = radius + direction * τ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), t = function(φ) {
      return Math.tan(π / 4 + φ / 2);
    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(λ, φ) {
      if (F > 0) {
        if (φ < -halfπ + ε) φ = -halfπ + ε;
      } else {
        if (φ > halfπ - ε) φ = halfπ - ε;
      }
      var ρ = F / Math.pow(t(φ), n);
      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
    if (abs(n) < ε) return d3_geo_equirectangular;
    function forward(λ, φ) {
      var ρ = G - φ;
      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = G - y;
      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(λ, φ) {
    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = π * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(λ, φ) {
    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransform(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
      Math.floor), e;
      return function(d) {
        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
        if (x1 != null) {
          var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - halfπ;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, active;
      if ((lock = this[ns]) && (active = lock[lock.active])) {
        if (--lock.count) delete lock[lock.active]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id];
    if (!transition) {
      var time = inherit.time;
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
      d3.timer(function(elapsed) {
        var delay = transition.delay, duration, ease, timer = d3_timer_active, tweened = [];
        timer.t = delay + time;
        if (delay <= elapsed) return start(elapsed - delay);
        timer.c = start;
        function start(elapsed) {
          if (lock.active > id) return stop();
          var active = lock[lock.active];
          if (active) {
            --lock.count;
            delete lock[lock.active];
            active.event && active.event.interrupt.call(node, node.__data__, active.index);
          }
          lock.active = id;
          transition.event && transition.event.start.call(node, node.__data__, i);
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, node.__data__, i)) {
              tweened.push(value);
            }
          });
          ease = transition.ease;
          duration = transition.duration;
          d3.timer(function() {
            timer.c = tick(elapsed || 1) ? d3_true : tick;
            return 1;
          }, 0, time);
        }
        function tick(elapsed) {
          if (lock.active !== id) return 1;
          var t = elapsed / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            transition.event && transition.event.end.call(node, node.__data__, i);
            return stop();
          }
        }
        function stop() {
          if (--lock.count) delete lock[id]; else delete node[ns];
          return 1;
        }
      }, 0, time);
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (typeof define === "function" && define.amd) define('d3',d3); else if (typeof module === "object" && module.exports) module.exports = d3;
  this.d3 = d3;
}();
define('js/pointrel20150417/generateRandomUuid',["require", "exports"], function (require, exports) {
    "use strict";
    function generateRandomUuid(className) {
        // summary:
        //        This function generates random UUIDs, meaning "version 4" UUIDs.
        // description:
        //        A typical generated value would be something like this:
        //        "3b12f1df-5232-4804-897e-917bf397618a"
        //
        //        For more information about random UUIDs, see sections 4.4 and
        //        4.5 of RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.4
        //
        //        This generator function is designed to be small and fast,
        //        but not necessarily good.
        //
        //        Small: This generator has a small footprint. Once comments are
        //        stripped, it's only about 25 lines of code, and it doesn't
        //        dojo.require() any other modules.
        //
        //        Fast: This generator can generate lots of new UUIDs fairly quickly
        //        (at least, more quickly than the other dojo UUID generators).
        //
        //        Not necessarily good: We use Math.random() as our source
        //        of randomness, which may or may not provide much randomness.
        // examples:
        //        const string = dojox.uuid.generateRandomUuid();
        var HEX_RADIX = 16;
        function _generateRandomEightCharacterHexString() {
            // Make random32bitNumber be a randomly generated floating point number
            // between 0 and (4,294,967,296 - 1), inclusive.
            var random32bitNumber = Math.floor((Math.random() % 1) * Math.pow(2, 32));
            var eightCharacterHexString = random32bitNumber.toString(HEX_RADIX);
            while (eightCharacterHexString.length < 8) {
                eightCharacterHexString = "0" + eightCharacterHexString;
            }
            return eightCharacterHexString; // for example: "3B12F1DF"
        }
        var hyphen = "-";
        var versionCodeForRandomlyGeneratedUuids = "4"; // 8 == binary2hex("0100")
        var variantCodeForDCEUuids = "8"; // 8 == binary2hex("1000")
        var a = _generateRandomEightCharacterHexString();
        var b = _generateRandomEightCharacterHexString();
        b = b.substring(0, 4) + hyphen + versionCodeForRandomlyGeneratedUuids + b.substring(5, 8);
        var c = _generateRandomEightCharacterHexString();
        c = variantCodeForDCEUuids + c.substring(1, 4) + hyphen + c.substring(4, 8);
        var d = _generateRandomEightCharacterHexString();
        var returnValue = a + hyphen + b + hyphen + c + d;
        returnValue = returnValue.toLowerCase();
        return className + "_" + returnValue; // String
    }
    return generateRandomUuid;
});

define('js/panelBuilder/PanelSpecificationCollection',["require", "exports"], function (require, exports) {
    "use strict";
    var PanelSpecificationCollection = (function () {
        function PanelSpecificationCollection() {
            // TODO: Think about whether can refactor to remove need for allFieldSpecifications array and/or map
            // Keep all questions together for use by things like calculating derived values from options for quiz score results
            this.allFieldSpecifications = [];
            this.fieldIDToFieldSpecificationMap = {};
            this.allPanels = [];
            this.panelIDToPanelSpecificationMap = {};
            this.allPages = [];
            this.pageIDToPageSpecificatiomMap = {};
            this.childPageIDListForHeaderID = {};
            this.modelClassToModelFieldSpecificationsMap = {};
            // For use while building pages; this assumes pages are added in some linear order where headers are added before child pages
            this.lastHeader = null;
        }
        // TODO: Maybe should remove this function? Currently only used by one test
        PanelSpecificationCollection.prototype.addPanelSpecificationFromJSONText = function (panelSpecificationJSONText) {
            var panelSpecification = JSON.parse(panelSpecificationJSONText);
            this.addPanelSpecification(panelSpecification);
            return panelSpecification;
        };
        PanelSpecificationCollection.prototype.addPanelSpecification = function (panelSpecification) {
            // TODO: Maybe should copy panelSpecification to ensure it won't change if changed latar by caller?
            this.allPanels.push(panelSpecification);
            this.panelIDToPanelSpecificationMap[panelSpecification.id] = panelSpecification;
            if (panelSpecification.displayType === "page") {
                this.allPages.push(panelSpecification);
                this.pageIDToPageSpecificatiomMap[panelSpecification.id] = panelSpecification;
                if (!panelSpecification.isHeader) {
                    var list = this.childPageIDListForHeaderID[this.lastHeader] || [];
                    list.push(panelSpecification.id);
                    this.childPageIDListForHeaderID[this.lastHeader] = list;
                }
                else {
                    this.lastHeader = panelSpecification.id;
                }
            }
            var modelClass = panelSpecification.modelClass;
            if (modelClass) {
                var model = this.modelClassToModelFieldSpecificationsMap[modelClass];
                if (!model) {
                    model = [];
                    this.modelClassToModelFieldSpecificationsMap[modelClass] = model;
                }
            }
            for (var i = 0; i < panelSpecification.panelFields.length; i++) {
                var fieldSpecification = panelSpecification.panelFields[i];
                this.addFieldSpecification(modelClass, fieldSpecification);
            }
        };
        PanelSpecificationCollection.prototype.addFieldSpecification = function (modelClass, fieldSpecification) {
            var model = this.modelClassToModelFieldSpecificationsMap[modelClass];
            // TODO: Is this modelClass line still needed?
            fieldSpecification.modelClass = modelClass;
            this.allFieldSpecifications.push(fieldSpecification);
            this.fieldIDToFieldSpecificationMap[fieldSpecification.id] = fieldSpecification;
            if (model)
                model.push(fieldSpecification);
        };
        PanelSpecificationCollection.prototype.addFieldSpecificationToPanelSpecification = function (panelSpecification, fieldSpecification) {
            panelSpecification.panelFields.push(fieldSpecification);
            // Assumes the model has already been created if needed when the panel was added
            this.addFieldSpecification(panelSpecification.modelClass, fieldSpecification);
        };
        PanelSpecificationCollection.prototype.initialDataForField = function (fieldSpecification) {
            var valueType = fieldSpecification.valueType;
            if (valueType === "string")
                return "";
            if (valueType === "array")
                return [];
            if (valueType === "dictionary")
                return {};
            if (valueType === "object")
                return {};
            if (valueType === "boolean")
                return false;
            if (valueType === "set")
                return {};
            console.log("ERROR: Unsupported model field valueType", valueType, fieldSpecification);
            throw new Error("Unsupported model field valueType: " + valueType + " for field: " + fieldSpecification.id);
        };
        // This builds a specific model based on the name of the model, using data from one or more pages or panels that define that model
        PanelSpecificationCollection.prototype.buildModel = function (modelName) {
            var model = { __type: modelName };
            var modelFieldSpecifications = this.modelClassToModelFieldSpecificationsMap[modelName];
            if (!modelFieldSpecifications) {
                console.log("ERROR: No model defined for model name", modelName);
                throw new Error("No model defined for model name: " + modelName);
            }
            for (var i = 0; i < modelFieldSpecifications.length; i++) {
                var fieldSpecification = modelFieldSpecifications[i];
                if (!fieldSpecification.valueType)
                    console.log("WARNING: Missing valueType for fieldSpecification", fieldSpecification);
                if (fieldSpecification.valueType && fieldSpecification.valueType !== "none") {
                    model[fieldSpecification.id] = this.initialDataForField(fieldSpecification);
                }
            }
            return model;
        };
        // This ignores the model type for the page or panel and just puts all the model fields into the supplied model
        PanelSpecificationCollection.prototype.addFieldsToModel = function (model, fieldSpecifications) {
            for (var i = 0; i < fieldSpecifications.length; i++) {
                var fieldSpecification = fieldSpecifications[i];
                if (!fieldSpecification.valueType)
                    console.log("WARNING: Missing valueType for fieldSpecification", fieldSpecification);
                if (fieldSpecification.valueType && fieldSpecification.valueType !== "none") {
                    model[fieldSpecification.id] = this.initialDataForField(fieldSpecification);
                }
            }
            return model;
        };
        PanelSpecificationCollection.prototype.buildListOfPages = function () {
            return this.allPages;
        };
        PanelSpecificationCollection.prototype.buildListOfPanels = function () {
            return this.allPanels;
        };
        PanelSpecificationCollection.prototype.getPageSpecificationForPageID = function (pageID) {
            return this.pageIDToPageSpecificatiomMap[pageID];
        };
        PanelSpecificationCollection.prototype.getPanelSpecificationForPanelID = function (panelID) {
            return this.panelIDToPanelSpecificationMap[panelID];
        };
        PanelSpecificationCollection.prototype.getFieldSpecificationForFieldID = function (fieldID) {
            return this.fieldIDToFieldSpecificationMap[fieldID];
        };
        PanelSpecificationCollection.prototype.getChildPageIDListForHeaderID = function (fieldID) {
            return this.childPageIDListForHeaderID[fieldID];
        };
        return PanelSpecificationCollection;
    }());
    return PanelSpecificationCollection;
});

define('js/panelBuilder/translate',["require", "exports"], function (require, exports) {
    "use strict";
    // Messages used by pages and created from design
    var pageMessages = {};
    // Messages specific to the editing application
    var applicationMessages = {};
    // Dynamically added extra translations like for survey questions
    var extraTranslations = {};
    var debugTranslations = false;
    function lookupTranslation(id) {
        var result = pageMessages[id];
        if (!result && result !== "")
            result = applicationMessages[id];
        if (!result && result !== "")
            result = extraTranslations[id];
        return result;
    }
    // if the tag field has a leading "#", it is parsed into an id and a default string by splitting at the first pipe
    function translate(tag, defaultText) {
        if (defaultText === void 0) { defaultText = undefined; }
        if (debugTranslations)
            console.log("translating", tag);
        if (tag === undefined || tag === "#undefined::prompt")
            throw new Error("bad translation tag using undefined which is likely a programming error");
        // if (debugTranslations && tag.charAt(0) !== "#") throw new Error("translation tag should have leading #  for: " + tag);
        // Kludge for extra domain translations for testing
        if (!tag) {
            if (debugTranslations)
                console.log("translating with no tag, so returning defaultText or empty string", defaultText);
            return defaultText || "";
        }
        if (tag.charAt(0) !== "#") {
            var translation = lookupTranslation(tag);
            if (translation)
                return translation;
            if (debugTranslations)
                console.log("no translation available for:", tag);
            if (defaultText !== null && typeof defaultText !== 'undefined')
                return defaultText;
            return tag;
        }
        // Special translation is done if tag starts with a hash mark, where can also supply optional translation string at end
        var id = tag.substring(1);
        var suppliedText = "";
        var splitPoint = id.indexOf("|");
        if (splitPoint !== -1) {
            suppliedText = id.substring(splitPoint + 1);
            id = id.substring(0, splitPoint);
        }
        var result = lookupTranslation(id);
        if (result === undefined) {
            if (suppliedText) {
                result = suppliedText;
            }
            else if (defaultText !== null && typeof defaultText !== 'undefined') {
                result = defaultText;
            }
            else {
                // Just return the tag, which starts with a # which should indicate an issue
                var error = "ERROR: missing text for: " + tag;
                console.log("translate problem", error);
                if (debugTranslations) {
                    result = error;
                }
                else {
                    result = tag;
                }
            }
        }
        if (debugTranslations)
            console.log("translating result: ", result, tag);
        return result;
    }
    function configure(pageMessagesNew, applicationMessagesNew) {
        pageMessages = pageMessagesNew;
        applicationMessages = applicationMessagesNew;
    }
    function addExtraTranslation(id, text) {
        extraTranslations[id] = text;
    }
    // Adding these to function just so can keep previous code the same as direct call to translate module
    translate["configure"] = configure;
    translate["addExtraTranslation"] = addExtraTranslation;
    return translate;
});

define('js/tips',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getRandomTip() {
        // TODO: Translate
        var tips = [
            // Getting started
            "One way to get started with NarraFirma is to page through its help system, one page a time, just to see what you can do with it.",
            "If you aren't sure whether you need or want to use any page, click the Help button to read about its purpose.",
            "If you aren't sure how any page in NarraFirma will affect what happens on other pages, click the Help button and look for the section called \"Connections to other pages.\"",
            "Click the Help button on any NarraFirma page to find out how the page is connected to other NarraFirma pages.",
            "The FAQ page at narrafirma.com has more answers to frequently asked questions.",
            "To see more tips, go to another NarraFirma page. To read all of the tips, go to the Home page, click Help, and look for a link to \"NarraFirma Tips\".",
            // General
            "You can safely ignore all of the pages of the types \"plan\" and \"journal.\". (But don't discount them! They might be useful.)",
            "Use the reminder at the bottom of any page to leave yourself a note. Reminders appear on section pages.",
            "On section pages (Planning, etc), if you don't like the page descriptions and page-type icons, you can hide them in Home - Project administration - Project options.",
            "You can print a whole-project report in Project administration - Print.",
            "You can use simple HTML codes (b, i, ul/li, etc) on most NarraFirma fields that end up in exported or printed reports.",
            "We recommend <a href=\"https://pandoc.org\">pandoc</a> for converting all of NarraFirma's HTML reports to other formats.",
            // Technical
            "Everything you enter into NarraFirma is saved as soon as you leave each field.",
            "You can export your whole project to a file, then import it into another NarraFirma installation.",
            "You can export a project file from a WordPress NarraFirma installation and import it into a Node.js NarraFirma installation (and vice versa).",
            "It's useful to occasionally back up your NarraFirma project (Project administration - Import &amp; Export).",
            "If you load a new version of NarraFirma and your browser doesn't show any changes, try clearing your browser cache.",
            "If you hover your mouse over the word \"NarraFirma\" in the upper left corner of any NarraFirma page, you will see the version of NarraFirma you have installed.",
            "If you type something into NarraFirma, then delete it, you might be able to find it again. On Node.js, look in the most recent files under server-data. In WordPress, find a plugin that shows you your table data.",
            // Bugs
            "If you find a bug in NarraFirma, tell us about it on the <a href=\"https://github.com/pdfernhout/narrafirma/issues\">GitHub issues page</a>.",
            "If NarraFirma isn't working the way it should, look at your browser's development console to see if there is an error message there.",
            "To report a NarraFirma bug, tell us as much as you can remember about what you were doing and what happened. Screenshots (especially of your browser's development console) are extra helpful.",
            // Planning
            "The Planning pages of NarraFirma can help you think through your project as you are getting started.",
            "None of the Planning pages in NarraFirma limit what you can do on other pages. They are just there to help you think.",
            "When you are clustering items on the \"Create project story elements\" page, two people can move items at the same time.",
            // Collection - General
            "You can enter stories into NarraFirma in three ways: using a web survey, by entering each story yourself, and by importing a CSV spreadsheet file.",
            "You can create printable agendas for your in-person or online story-sharing sessions.",
            "If you are importing data from another surveying system, click Help, then Collection, then find the Guide to Importing Data.",
            // Collection - Building story forms
            "The order of questions on the \"Write questions about\" pages does not matter. Only the order on the story form matters.",
            "The short names you give to questions will appear on your graphs. Make them brief but clear.",
            "You can include a video introduction in a story form.",
            "Checkboxes questions can include images.",
            "Write-in answers are particularly useful in pilot projects.",
            "Keep your slider labels (left and right) short but meaningful.",
            "Multiple-answer questions (of the checkboxes type) are often useful, but they cannot be used in some statistical tests because they are not mutually exclusive.",
            "When you look at question recommendations, it doesn't change your questions. It's just to help you think.",
            "You can give your survey participants the option to copy their contribution. Look at \"Finishing the form.\"",
            "You can use custom CSS to change how your survey looks.",
            "If you want to, you can build your entire story form in a CSV spreadsheet, then import it.",
            "To use the same story form in multiple projects, export it to a CSV file from one project, then import it into the other.",
            "If you want to translate your story form into multiple languages, build and test the form in one language first, then translate it.",
            "It's a good idea to export your story collection to an external CSV file, just in case you want to see it outside of NarraFirma later.",
            // Collection - Managing story collections
            "If you make major changes to your story form (e.g., changing a question's type or short name) after you start collecting stories, it is best to create a new story collection so your data matches your form.",
            "If you make so many test story collections that they slow down project loading, you can remove them by resetting the project (carefully!) in Project administration - Import &amp; Export.",
            "After you update the story form in an active story collection, you must deactivate, then activate the collection before the change will take effect.",
            "You can change the story form you are using to gather data in a story collection. NarraFirma will warn you if by doing so you will invalidate any of your existing data.",
            "When you create a new story collection, NarraFirma makes a snapshot copy of the story form you choose for it as it stands at that moment and stores it in the collection.",
            "Question data in different story collections can be graphed together as long as the question short names, types, and lists of available answers are the same.",
            "If you collect some answers to a question, then decide to change the type of data it collects, click Help on the \"Start story collection\" page for some pointers.",
            "To prevent accidental data loss, you cannot delete stories. But you can mark them to be ignored on the  \"Review incoming stories\" page.",
            "You can edit story names, texts, and answers to questions on the \"Review incoming stories\" page. Just be careful!",
            "If your stories do not have names, you can give them names on the \"Review incoming stories\" page.",
            "On the \"Review incoming stories\" page, you can see (and change) subsets of your stories as well as all of them.",
            "Use the \"Review graphs\" page to check over incoming stories to look for gaps in your coverage.",
            "You can look at patterns across multiple story collections on the \"Review graphs\" page.",
            "Stories in an exported story collection are in the same order as they are shown in the \"Review incoming stories\" page.",
            // Catalysis - General
            "What's catalysis? It's the same thing as analysis, but it generates questions to ponder, not conclusions to accept or reject.",
            "Save time during catalysis by unchecking questions with too little variation, leaving them out of your consideration.",
            "As you explore patterns in your data, you can use display lumping to merge similar answers.",
            "A catalysis report can include multiple story collections and multiple story forms.",
            "When you are clustering items on the \"Cluster interpretations and/or observations\" page, two people can move items at the same time.",
            "If you turn off a type of graph on the \"Configure catalysis report\" page, any observations linked to graphs of that type will still exist. You just won't be able to see them.",
            "Clustered observations or interpretations become the headings of your catalysis report.",
            "You can export observations, interpretations, and ideas from one catalysis report and import them into another one.",
            "On the \"Print catalysis report\" page, you can export all of your graphs to PNG, SVG, or CSV.",
            "You can change every English-language element of your catalysis report to your own language.",
            "You can use custom CSS to change how your catalysis report looks.",
            "We recommend <a href=\"https://pandoc.org\">pandoc</a> for converting NarraFirma's HTML catalysis reports to other formats.",
            // Catalysis - Annotating stories
            "You can use an annotation question to convert a free-text question to a fixed-list question (by reading and clustering the things people wrote in).",
            "You can use an annotation question to mark and count your observations of storytelling patterns and styles.",
            "You can use an annotation question to mark and count themes you find in your stories.",
            "You can enter answers to annotation questions in NarraFirma or import them from a CSV spreadsheet file.",
            "When annotating stories, you can use the Random button to code a randomly chosen subset of a large story collection.",
            "Annotation questions are not connected to particular story forms. They are available to the whole project.",
            "You can change the order your annotation questions appear on the \"Annotate stories\" page.",
            // Catalysis - Exploring patterns
            "The \"Explore patterns\" page is the most complicated page in NarraFirma. Budget some time to take it in and read its Help page.",
            "On the \"Explore patterns\" page, you can copy and paste excerpts from any story into an observation, interpretation, or idea.",
            "On the \"Explore patterns\" page, you can sort your patterns by statistical significance.",
            "On the \"Explore patterns\" page, you can sort your patterns by observation strength.",
            "If few people picked one answer to a question, you might be able to lump it in with another answer using the \"display lumping\" feature.",
            "You can override your general setting for display lumping on particular graphs.",
            "You can hide or show how many people chose not to answer questions.",
            "You can override your general setting for showing \"No answer\" counts on particular graphs.",
            "When you are looking at a graph on the Explore Patterns page, you can save it as a CSV spreadsheet or an image.",
            "When you are looking at a graph on the \"Explore patterns\" page, you can generate random subsets of selected stories. These are useful for reports.",
            // Sensemaking, Intervention, and Return
            "You can use the filtering function to print only some story cards.",
            "You can use display lumping to merge similar answers in your story cards.",
            "When you print your story cards, you can truncate especially long stories.",
            "In story cards, for choice questions, you can print all the answers (with the selected answers in bold) or only the selected answers.",
            "Story cards can include all or only some of the questions you asked about stories and participants.",
            "You can use multiple columns to make your story cards easier to use in sensemaking.",
            "You can copy your generated HTML story cards and paste them into most word processors.",
            "You can create highly customized story cards.",
            "You can create printable agendas for your in-person or online sensemaking workshops.",
            "We recommend <a href=\"https://pandoc.org\">pandoc</a> for converting NarraFirma's HTML story cards to other formats.",
        ];
        var randomIndex = Math.max(0, Math.min(tips.length - 1, Math.round(Math.random() * tips.length) - 1));
        var tip = "Tip: " + tips[randomIndex] + " <a href=\"help/administration/help_page_tips.html\" target=\"blank\">(More tips)</a>";
        return tip;
    }
    exports.getRandomTip = getRandomTip;
});

var m = (function app(window, undefined) {
	var OBJECT = "[object Object]", ARRAY = "[object Array]", STRING = "[object String]", FUNCTION = "function";
	var type = {}.toString;
	var parser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[.+?\])/g, attrParser = /\[(.+?)(?:=("|'|)(.*?)\2)?\]/;
	var voidElements = /^(AREA|BASE|BR|COL|COMMAND|EMBED|HR|IMG|INPUT|KEYGEN|LINK|META|PARAM|SOURCE|TRACK|WBR)$/;
	var noop = function() {}

	// caching commonly used variables
	var $document, $location, $requestAnimationFrame, $cancelAnimationFrame;

	// self invoking function needed because of the way mocks work
	function initialize(window){
		$document = window.document;
		$location = window.location;
		$cancelAnimationFrame = window.cancelAnimationFrame || window.clearTimeout;
		$requestAnimationFrame = window.requestAnimationFrame || window.setTimeout;
	}

	initialize(window);


	/**
	 * @typedef {String} Tag
	 * A string that looks like -> div.classname#id[param=one][param2=two]
	 * Which describes a DOM node
	 */

	/**
	 *
	 * @param {Tag} The DOM node tag
	 * @param {Object=[]} optional key-value pairs to be mapped to DOM attrs
	 * @param {...mNode=[]} Zero or more Mithril child nodes. Can be an array, or splat (optional)
	 *
	 */
	function m() {
		var args = [].slice.call(arguments);
		var hasAttrs = args[1] != null && type.call(args[1]) === OBJECT && !("tag" in args[1] || "view" in args[1]) && !("subtree" in args[1]);
		var attrs = hasAttrs ? args[1] : {};
		var classAttrName = "class" in attrs ? "class" : "className";
		var cell = {tag: "div", attrs: {}};
		var match, classes = [];
		if (type.call(args[0]) != STRING) throw new Error("selector in m(selector, attrs, children) should be a string")
		while (match = parser.exec(args[0])) {
			if (match[1] === "" && match[2]) cell.tag = match[2];
			else if (match[1] === "#") cell.attrs.id = match[2];
			else if (match[1] === ".") classes.push(match[2]);
			else if (match[3][0] === "[") {
				var pair = attrParser.exec(match[3]);
				cell.attrs[pair[1]] = pair[3] || (pair[2] ? "" :true)
			}
		}

		var children = hasAttrs ? args.slice(2) : args.slice(1);
		if (children.length === 1 && type.call(children[0]) === ARRAY) {
			cell.children = children[0]
		}
		else {
			cell.children = children
		}
		
		for (var attrName in attrs) {
			if (attrs.hasOwnProperty(attrName)) {
				if (attrName === classAttrName && attrs[attrName] != null && attrs[attrName] !== "") {
					classes.push(attrs[attrName])
					cell.attrs[attrName] = "" //create key in correct iteration order
				}
				else cell.attrs[attrName] = attrs[attrName]
			}
		}
		if (classes.length > 0) cell.attrs[classAttrName] = classes.join(" ");
		
		return cell
	}
	function build(parentElement, parentTag, parentCache, parentIndex, data, cached, shouldReattach, index, editable, namespace, configs) {
		//`build` is a recursive function that manages creation/diffing/removal of DOM elements based on comparison between `data` and `cached`
		//the diff algorithm can be summarized as this:
		//1 - compare `data` and `cached`
		//2 - if they are different, copy `data` to `cached` and update the DOM based on what the difference is
		//3 - recursively apply this algorithm for every array and for the children of every virtual element

		//the `cached` data structure is essentially the same as the previous redraw's `data` data structure, with a few additions:
		//- `cached` always has a property called `nodes`, which is a list of DOM elements that correspond to the data represented by the respective virtual element
		//- in order to support attaching `nodes` as a property of `cached`, `cached` is *always* a non-primitive object, i.e. if the data was a string, then cached is a String instance. If data was `null` or `undefined`, cached is `new String("")`
		//- `cached also has a `configContext` property, which is the state storage object exposed by config(element, isInitialized, context)
		//- when `cached` is an Object, it represents a virtual element; when it's an Array, it represents a list of elements; when it's a String, Number or Boolean, it represents a text node

		//`parentElement` is a DOM element used for W3C DOM API calls
		//`parentTag` is only used for handling a corner case for textarea values
		//`parentCache` is used to remove nodes in some multi-node cases
		//`parentIndex` and `index` are used to figure out the offset of nodes. They're artifacts from before arrays started being flattened and are likely refactorable
		//`data` and `cached` are, respectively, the new and old nodes being diffed
		//`shouldReattach` is a flag indicating whether a parent node was recreated (if so, and if this node is reused, then this node must reattach itself to the new parent)
		//`editable` is a flag that indicates whether an ancestor is contenteditable
		//`namespace` indicates the closest HTML namespace as it cascades down from an ancestor
		//`configs` is a list of config functions to run after the topmost `build` call finishes running

		//there's logic that relies on the assumption that null and undefined data are equivalent to empty strings
		//- this prevents lifecycle surprises from procedural helpers that mix implicit and explicit return statements (e.g. function foo() {if (cond) return m("div")}
		//- it simplifies diffing code
		//data.toString() might throw or return null if data is the return value of Console.log in Firefox (behavior depends on version)
		try {if (data == null || data.toString() == null) data = "";} catch (e) {data = ""}
		if (data.subtree === "retain") return cached;
		var cachedType = type.call(cached), dataType = type.call(data);
		if (cached == null || cachedType !== dataType) {
			if (cached != null) {
				if (parentCache && parentCache.nodes) {
					var offset = index - parentIndex;
					var end = offset + (dataType === ARRAY ? data : cached.nodes).length;
					clear(parentCache.nodes.slice(offset, end), parentCache.slice(offset, end))
				}
				else if (cached.nodes) clear(cached.nodes, cached)
			}
			cached = new data.constructor;
			if (cached.tag) cached = {}; //if constructor creates a virtual dom element, use a blank object as the base cached node instead of copying the virtual el (#277)
			cached.nodes = []
		}

		if (dataType === ARRAY) {
			//recursively flatten array
			for (var i = 0, len = data.length; i < len; i++) {
				if (type.call(data[i]) === ARRAY) {
					data = data.concat.apply([], data);
					i-- //check current index again and flatten until there are no more nested arrays at that index
					len = data.length
				}
			}
			
			var nodes = [], intact = cached.length === data.length, subArrayCount = 0;

			//keys algorithm: sort elements without recreating them if keys are present
			//1) create a map of all existing keys, and mark all for deletion
			//2) add new keys to map and mark them for addition
			//3) if key exists in new list, change action from deletion to a move
			//4) for each key, handle its corresponding action as marked in previous steps
			var DELETION = 1, INSERTION = 2 , MOVE = 3;
			var existing = {}, shouldMaintainIdentities = false;
			for (var i = 0; i < cached.length; i++) {
				if (cached[i] && cached[i].attrs && cached[i].attrs.key != null) {
					shouldMaintainIdentities = true;
					existing[cached[i].attrs.key] = {action: DELETION, index: i}
				}
			}
			
			var guid = 0
			for (var i = 0, len = data.length; i < len; i++) {
				if (data[i] && data[i].attrs && data[i].attrs.key != null) {
					for (var j = 0, len = data.length; j < len; j++) {
						if (data[j] && data[j].attrs && data[j].attrs.key == null) data[j].attrs.key = "__mithril__" + guid++
					}
					break
				}
			}
			
			if (shouldMaintainIdentities) {
				var keysDiffer = false
				if (data.length != cached.length) keysDiffer = true
				else for (var i = 0, cachedCell, dataCell; cachedCell = cached[i], dataCell = data[i]; i++) {
					if (cachedCell.attrs && dataCell.attrs && cachedCell.attrs.key != dataCell.attrs.key) {
						keysDiffer = true
						break
					}
				}
				
				if (keysDiffer) {
					for (var i = 0, len = data.length; i < len; i++) {
						if (data[i] && data[i].attrs) {
							if (data[i].attrs.key != null) {
								var key = data[i].attrs.key;
								if (!existing[key]) existing[key] = {action: INSERTION, index: i};
								else existing[key] = {
									action: MOVE,
									index: i,
									from: existing[key].index,
									element: cached.nodes[existing[key].index] || $document.createElement("div")
								}
							}
						}
					}
					var actions = []
					for (var prop in existing) actions.push(existing[prop])
					var changes = actions.sort(sortChanges);
					var newCached = new Array(cached.length)
					newCached.nodes = cached.nodes.slice()

					for (var i = 0, change; change = changes[i]; i++) {
						if (change.action === DELETION) {
							clear(cached[change.index].nodes, cached[change.index]);
							newCached.splice(change.index, 1)
						}
						if (change.action === INSERTION) {
							var dummy = $document.createElement("div");
							dummy.key = data[change.index].attrs.key;
							parentElement.insertBefore(dummy, parentElement.childNodes[change.index] || null);
							newCached.splice(change.index, 0, {attrs: {key: data[change.index].attrs.key}, nodes: [dummy]})
							newCached.nodes[change.index] = dummy
						}

						if (change.action === MOVE) {
							if (parentElement.childNodes[change.index] !== change.element && change.element !== null) {
								parentElement.insertBefore(change.element, parentElement.childNodes[change.index] || null)
							}
							newCached[change.index] = cached[change.from]
							newCached.nodes[change.index] = change.element
						}
					}
					cached = newCached;
				}
			}
			//end key algorithm

			for (var i = 0, cacheCount = 0, len = data.length; i < len; i++) {
				//diff each item in the array
				var item = build(parentElement, parentTag, cached, index, data[i], cached[cacheCount], shouldReattach, index + subArrayCount || subArrayCount, editable, namespace, configs);
				if (item === undefined) continue;
				if (!item.nodes.intact) intact = false;
				if (item.$trusted) {
					//fix offset of next element if item was a trusted string w/ more than one html element
					//the first clause in the regexp matches elements
					//the second clause (after the pipe) matches text nodes
					subArrayCount += (item.match(/<[^\/]|\>\s*[^<]/g) || [0]).length
				}
				else subArrayCount += type.call(item) === ARRAY ? item.length : 1;
				cached[cacheCount++] = item
			}
			if (!intact) {
				//diff the array itself
				
				//update the list of DOM nodes by collecting the nodes from each item
				for (var i = 0, len = data.length; i < len; i++) {
					if (cached[i] != null) nodes.push.apply(nodes, cached[i].nodes)
				}
				//remove items from the end of the array if the new array is shorter than the old one
				//if errors ever happen here, the issue is most likely a bug in the construction of the `cached` data structure somewhere earlier in the program
				for (var i = 0, node; node = cached.nodes[i]; i++) {
					if (node.parentNode != null && nodes.indexOf(node) < 0) clear([node], [cached[i]])
				}
				if (data.length < cached.length) cached.length = data.length;
				cached.nodes = nodes
			}
		}
		else if (data != null && dataType === OBJECT) {
			var views = [], controllers = []
			while (data.view) {
				var view = data.view.$original || data.view
				var controllerIndex = m.redraw.strategy() == "diff" && cached.views ? cached.views.indexOf(view) : -1
				var controller = controllerIndex > -1 ? cached.controllers[controllerIndex] : new (data.controller || noop)
				var key = data && data.attrs && data.attrs.key
				data = pendingRequests == 0 || (cached && cached.controllers && cached.controllers.indexOf(controller) > -1) ? data.view(controller) : {tag: "placeholder"}
				if (data.subtree === "retain") return cached;
				if (key) {
					if (!data.attrs) data.attrs = {}
					data.attrs.key = key
				}
				if (controller.onunload) unloaders.push({controller: controller, handler: controller.onunload})
				views.push(view)
				controllers.push(controller)
			}
			if (!data.tag && controllers.length) throw new Error("Component template must return a virtual element, not an array, string, etc.")
			if (!data.attrs) data.attrs = {};
			if (!cached.attrs) cached.attrs = {};

			var dataAttrKeys = Object.keys(data.attrs)
			var hasKeys = dataAttrKeys.length > ("key" in data.attrs ? 1 : 0)
			//if an element is different enough from the one in cache, recreate it
			if (data.tag != cached.tag || dataAttrKeys.sort().join() != Object.keys(cached.attrs).sort().join() || data.attrs.id != cached.attrs.id || data.attrs.key != cached.attrs.key || (m.redraw.strategy() == "all" && (!cached.configContext || cached.configContext.retain !== true)) || (m.redraw.strategy() == "diff" && cached.configContext && cached.configContext.retain === false)) {
				if (cached.nodes.length) clear(cached.nodes);
				if (cached.configContext && typeof cached.configContext.onunload === FUNCTION) cached.configContext.onunload()
				if (cached.controllers) {
					for (var i = 0, controller; controller = cached.controllers[i]; i++) {
						if (typeof controller.onunload === FUNCTION) controller.onunload({preventDefault: noop})
					}
				}
			}
			if (type.call(data.tag) != STRING) return;

			var node, isNew = cached.nodes.length === 0;
			if (data.attrs.xmlns) namespace = data.attrs.xmlns;
			else if (data.tag === "svg") namespace = "http://www.w3.org/2000/svg";
			else if (data.tag === "math") namespace = "http://www.w3.org/1998/Math/MathML";
			
			if (isNew) {
				if (data.attrs.is) node = namespace === undefined ? $document.createElement(data.tag, data.attrs.is) : $document.createElementNS(namespace, data.tag, data.attrs.is);
				else node = namespace === undefined ? $document.createElement(data.tag) : $document.createElementNS(namespace, data.tag);
				cached = {
					tag: data.tag,
					//set attributes first, then create children
					attrs: hasKeys ? setAttributes(node, data.tag, data.attrs, {}, namespace) : data.attrs,
					children: data.children != null && data.children.length > 0 ?
						build(node, data.tag, undefined, undefined, data.children, cached.children, true, 0, data.attrs.contenteditable ? node : editable, namespace, configs) :
						data.children,
					nodes: [node]
				};
				if (controllers.length) {
					cached.views = views
					cached.controllers = controllers
					for (var i = 0, controller; controller = controllers[i]; i++) {
						if (controller.onunload && controller.onunload.$old) controller.onunload = controller.onunload.$old
						if (pendingRequests && controller.onunload) {
							var onunload = controller.onunload
							controller.onunload = noop
							controller.onunload.$old = onunload
						}
					}
				}
				
				if (cached.children && !cached.children.nodes) cached.children.nodes = [];
				//edge case: setting value on <select> doesn't work before children exist, so set it again after children have been created
				if (data.tag === "select" && "value" in data.attrs) setAttributes(node, data.tag, {value: data.attrs.value}, {}, namespace);
				parentElement.insertBefore(node, parentElement.childNodes[index] || null)
			}
			else {
				node = cached.nodes[0];
				if (hasKeys) setAttributes(node, data.tag, data.attrs, cached.attrs, namespace);
				cached.children = build(node, data.tag, undefined, undefined, data.children, cached.children, false, 0, data.attrs.contenteditable ? node : editable, namespace, configs);
				cached.nodes.intact = true;
				if (controllers.length) {
					cached.views = views
					cached.controllers = controllers
				}
				if (shouldReattach === true && node != null) parentElement.insertBefore(node, parentElement.childNodes[index] || null)
			}
			//schedule configs to be called. They are called after `build` finishes running
			if (typeof data.attrs["config"] === FUNCTION) {
				var context = cached.configContext = cached.configContext || {};

				// bind
				var callback = function(data, args) {
					return function() {
						return data.attrs["config"].apply(data, args)
					}
				};
				configs.push(callback(data, [node, !isNew, context, cached]))
			}
		}
		else if (typeof data != FUNCTION) {
			//handle text nodes
			var nodes;
			if (cached.nodes.length === 0) {
				if (data.$trusted) {
					nodes = injectHTML(parentElement, index, data)
				}
				else {
					nodes = [$document.createTextNode(data)];
					if (!parentElement.nodeName.match(voidElements)) parentElement.insertBefore(nodes[0], parentElement.childNodes[index] || null)
				}
				cached = "string number boolean".indexOf(typeof data) > -1 ? new data.constructor(data) : data;
				cached.nodes = nodes
			}
			else if (cached.valueOf() !== data.valueOf() || shouldReattach === true) {
				nodes = cached.nodes;
				if (!editable || editable !== $document.activeElement) {
					if (data.$trusted) {
						clear(nodes, cached);
						nodes = injectHTML(parentElement, index, data)
					}
					else {
						//corner case: replacing the nodeValue of a text node that is a child of a textarea/contenteditable doesn't work
						//we need to update the value property of the parent textarea or the innerHTML of the contenteditable element instead
						if (parentTag === "textarea") parentElement.value = data;
						else if (editable) editable.innerHTML = data;
						else {
							if (nodes[0].nodeType === 1 || nodes.length > 1) { //was a trusted string
								clear(cached.nodes, cached);
								nodes = [$document.createTextNode(data)]
							}
							parentElement.insertBefore(nodes[0], parentElement.childNodes[index] || null);
							nodes[0].nodeValue = data
						}
					}
				}
				cached = new data.constructor(data);
				cached.nodes = nodes
			}
			else cached.nodes.intact = true
		}

		return cached
	}
	function sortChanges(a, b) {return a.action - b.action || a.index - b.index}
	function setAttributes(node, tag, dataAttrs, cachedAttrs, namespace) {
		for (var attrName in dataAttrs) {
			var dataAttr = dataAttrs[attrName];
			var cachedAttr = cachedAttrs[attrName];
			if (!(attrName in cachedAttrs) || (cachedAttr !== dataAttr)) {
				cachedAttrs[attrName] = dataAttr;
				try {
					//`config` isn't a real attributes, so ignore it
					if (attrName === "config" || attrName == "key") continue;
					//hook event handlers to the auto-redrawing system
					else if (typeof dataAttr === FUNCTION && attrName.indexOf("on") === 0) {
						node[attrName] = autoredraw(dataAttr, node)
					}
					//handle `style: {...}`
					else if (attrName === "style" && dataAttr != null && type.call(dataAttr) === OBJECT) {
						for (var rule in dataAttr) {
							if (cachedAttr == null || cachedAttr[rule] !== dataAttr[rule]) node.style[rule] = dataAttr[rule]
						}
						for (var rule in cachedAttr) {
							if (!(rule in dataAttr)) node.style[rule] = ""
						}
					}
					//handle SVG
					else if (namespace != null) {
						if (attrName === "href") node.setAttributeNS("http://www.w3.org/1999/xlink", "href", dataAttr);
						else if (attrName === "className") node.setAttribute("class", dataAttr);
						else node.setAttribute(attrName, dataAttr)
					}
					//handle cases that are properties (but ignore cases where we should use setAttribute instead)
					//- list and form are typically used as strings, but are DOM element references in js
					//- when using CSS selectors (e.g. `m("[style='']")`), style is used as a string, but it's an object in js
					else if (attrName in node && !(attrName === "list" || attrName === "style" || attrName === "form" || attrName === "type" || attrName === "width" || attrName === "height")) {
						//#348 don't set the value if not needed otherwise cursor placement breaks in Chrome
						if (tag !== "input" || node[attrName] !== dataAttr) node[attrName] = dataAttr
					}
					else node.setAttribute(attrName, dataAttr)
				}
				catch (e) {
					//swallow IE's invalid argument errors to mimic HTML's fallback-to-doing-nothing-on-invalid-attributes behavior
					if (e.message.indexOf("Invalid argument") < 0) throw e
				}
			}
			//#348 dataAttr may not be a string, so use loose comparison (double equal) instead of strict (triple equal)
			// PDF fix for issue #701 https://github.com/lhorie/mithril.js/issues/701
            //#348 dataAttr may not be a string, so use loose comparison (double equal) instead of strict (triple equal)
            // PDF updates per Mithril issue #691 and Issue #701
			else if (attrName === "value" && (tag === "input" || tag === "textarea") && node.value != dataAttr) {
			    node[attrName] = dataAttr;
			}
			// The below fixes seem to break selects (the "selected" parts) so backing it all out for now, except for the textarea addition above
			/*
			else if (attrName === "checked" || attrName === "selected") node[attrName] = !!dataAttr; 
			else if (node[attrName] != dataAttr) node[attrName] = dataAttr;
			*/
			/*
            else if (attrName === "value" && (tag === "input" || tag === "textarea" || tag === "select") && node.value != dataAttr) {
                node.value = dataAttr;
            }
            else if (attrName === "checked" && (tag === "input") && node.checked != dataAttr) {
                // TODO: Maybe this case should be more selective to checkbox and radio?
                node.checked = !!dataAttr;
            }
            else if (attrName === "selected" && (tag === "option") && node.selected != dataAttr) {
                node.selected = !!dataAttr;
            }
            else if (attrName === "selectionStart" && (tag === "input" || tag === "textarea") && node.selectionStart != dataAttr) {
                node.selectionStart = dataAttr;
            }
            else if (attrName === "selectionEnd" && (tag === "input" || tag === "textarea") && node.selectionEnd != dataAttr) {
                node.selectionEnd = dataAttr;
            }
            else if (attrName === "selectionDirection" && (tag === "input" || tag === "textarea") && node.selectionDirection != dataAttr) {
                node.selectionDirection = dataAttr;
            }
            else if (attrName === "scrollTop" && node.scrollTop != dataAttr) {
                // TODO: Maybe this case should be more selective?
                node.scrollTop = dataAttr;
            }
            else if (tag === "keygen") {
                throw new Error("keygen support unfininshed");
            }
            */
		}
		return cachedAttrs
	}
	function clear(nodes, cached) {
		for (var i = nodes.length - 1; i > -1; i--) {
			if (nodes[i] && nodes[i].parentNode) {
				try {nodes[i].parentNode.removeChild(nodes[i])}
				catch (e) {} //ignore if this fails due to order of events (see http://stackoverflow.com/questions/21926083/failed-to-execute-removechild-on-node)
				cached = [].concat(cached);
				if (cached[i]) unload(cached[i])
			}
		}
		if (nodes.length != 0) nodes.length = 0
	}
	function unload(cached) {
		if (cached.configContext && typeof cached.configContext.onunload === FUNCTION) {
			cached.configContext.onunload();
			cached.configContext.onunload = null
		}
		if (cached.controllers) {
			for (var i = 0, controller; controller = cached.controllers[i]; i++) {
				if (typeof controller.onunload === FUNCTION) controller.onunload({preventDefault: noop});
			}
		}
		if (cached.children) {
			if (type.call(cached.children) === ARRAY) {
				for (var i = 0, child; child = cached.children[i]; i++) unload(child)
			}
			else if (cached.children.tag) unload(cached.children)
		}
	}
	function injectHTML(parentElement, index, data) {
		var nextSibling = parentElement.childNodes[index];
		if (nextSibling) {
			var isElement = nextSibling.nodeType != 1;
			var placeholder = $document.createElement("span");
			if (isElement) {
				parentElement.insertBefore(placeholder, nextSibling || null);
				placeholder.insertAdjacentHTML("beforebegin", data);
				parentElement.removeChild(placeholder)
			}
			else nextSibling.insertAdjacentHTML("beforebegin", data)
		}
		else parentElement.insertAdjacentHTML("beforeend", data);
		var nodes = [];
		while (parentElement.childNodes[index] !== nextSibling) {
			nodes.push(parentElement.childNodes[index]);
			index++
		}
		return nodes
	}
	function autoredraw(callback, object) {
		return function(e) {
			e = e || event;
			m.redraw.strategy("diff");
			m.startComputation();
			try {return callback.call(object, e)}
			finally {
				endFirstComputation()
			}
		}
	}

	var html;
	var documentNode = {
		appendChild: function(node) {
			if (html === undefined) html = $document.createElement("html");
			if ($document.documentElement && $document.documentElement !== node) {
				$document.replaceChild(node, $document.documentElement)
			}
			else $document.appendChild(node);
			this.childNodes = $document.childNodes
		},
		insertBefore: function(node) {
			this.appendChild(node)
		},
		childNodes: []
	};
	var nodeCache = [], cellCache = {};
	m.render = function(root, cell, forceRecreation) {
		var configs = [];
		if (!root) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");
		var id = getCellCacheKey(root);
		var isDocumentRoot = root === $document;
		var node = isDocumentRoot || root === $document.documentElement ? documentNode : root;
		if (isDocumentRoot && cell.tag != "html") cell = {tag: "html", attrs: {}, children: cell};
		if (cellCache[id] === undefined) clear(node.childNodes);
		if (forceRecreation === true) reset(root);
		cellCache[id] = build(node, null, undefined, undefined, cell, cellCache[id], false, 0, null, undefined, configs);
		for (var i = 0, len = configs.length; i < len; i++) configs[i]()
	};
	function getCellCacheKey(element) {
		var index = nodeCache.indexOf(element);
		return index < 0 ? nodeCache.push(element) - 1 : index
	}

	m.trust = function(value) {
		value = new String(value);
		value.$trusted = true;
		return value
	};

	function gettersetter(store) {
		var prop = function() {
			if (arguments.length) store = arguments[0];
			return store
		};

		prop.toJSON = function() {
			return store
		};

		return prop
	}

	m.prop = function (store) {
		//note: using non-strict equality check here because we're checking if store is null OR undefined
		if (((store != null && type.call(store) === OBJECT) || typeof store === FUNCTION) && typeof store.then === FUNCTION) {
			return propify(store)
		}

		return gettersetter(store)
	};

	var roots = [], components = [], controllers = [], lastRedrawId = null, lastRedrawCallTime = 0, computePreRedrawHook = null, computePostRedrawHook = null, prevented = false, topComponent, unloaders = [];
	var FRAME_BUDGET = 16; //60 frames per second = 1 call per 16 ms
	function parameterize(component, args) {
		var controller = function() {
			return (component.controller || noop).apply(this, args) || this
		}
		var view = function(ctrl) {
			if (arguments.length > 1) args = args.concat([].slice.call(arguments, 1))
			return component.view.apply(component, args ? [ctrl].concat(args) : [ctrl])
		}
		view.$original = component.view
		var output = {controller: controller, view: view}
		if (args[0] && args[0].key != null) output.attrs = {key: args[0].key}
		return output
	}
	m.component = function(component) {
		return parameterize(component, [].slice.call(arguments, 1))
	}
	m.mount = m.module = function(root, component) {
		if (!root) throw new Error("Please ensure the DOM element exists before rendering a template into it.");
		var index = roots.indexOf(root);
		if (index < 0) index = roots.length;
		
		var isPrevented = false;
		var event = {preventDefault: function() {
			isPrevented = true;
			computePreRedrawHook = computePostRedrawHook = null;
		}};
		for (var i = 0, unloader; unloader = unloaders[i]; i++) {
			unloader.handler.call(unloader.controller, event)
			unloader.controller.onunload = null
		}
		if (isPrevented) {
			for (var i = 0, unloader; unloader = unloaders[i]; i++) unloader.controller.onunload = unloader.handler
		}
		else unloaders = []
		
		if (controllers[index] && typeof controllers[index].onunload === FUNCTION) {
			controllers[index].onunload(event)
		}
		
		if (!isPrevented) {
			m.redraw.strategy("all");
			m.startComputation();
			roots[index] = root;
			if (arguments.length > 2) component = subcomponent(component, [].slice.call(arguments, 2))
			var currentComponent = topComponent = component = component || {controller: function() {}};
			var constructor = component.controller || noop
			var controller = new constructor;
			//controllers may call m.mount recursively (via m.route redirects, for example)
			//this conditional ensures only the last recursive m.mount call is applied
			if (currentComponent === topComponent) {
				controllers[index] = controller;
				components[index] = component
			}
			endFirstComputation();
			return controllers[index]
		}
	};
	var redrawing = false
	m.redraw = function(force) {
		if (redrawing) return
		redrawing = true
		//lastRedrawId is a positive number if a second redraw is requested before the next animation frame
		//lastRedrawID is null if it's the first redraw and not an event handler
		if (lastRedrawId && force !== true) {
			//when setTimeout: only reschedule redraw if time between now and previous redraw is bigger than a frame, otherwise keep currently scheduled timeout
			//when rAF: always reschedule redraw
			if ($requestAnimationFrame === window.requestAnimationFrame || new Date - lastRedrawCallTime > FRAME_BUDGET) {
				if (lastRedrawId > 0) $cancelAnimationFrame(lastRedrawId);
				lastRedrawId = $requestAnimationFrame(redraw, FRAME_BUDGET)
			}
		}
		else {
			redraw();
			lastRedrawId = $requestAnimationFrame(function() {lastRedrawId = null}, FRAME_BUDGET)
		}
		redrawing = false
	};
	m.redraw.strategy = m.prop();
	function redraw() {
		if (computePreRedrawHook) {
			computePreRedrawHook()
			computePreRedrawHook = null
		}
		for (var i = 0, root; root = roots[i]; i++) {
			if (controllers[i]) {
				var args = components[i].controller && components[i].controller.$$args ? [controllers[i]].concat(components[i].controller.$$args) : [controllers[i]]
				m.render(root, components[i].view ? components[i].view(controllers[i], args) : "")
			}
		}
		//after rendering within a routed context, we need to scroll back to the top, and fetch the document title for history.pushState
		if (computePostRedrawHook) {
			computePostRedrawHook();
			computePostRedrawHook = null
		}
		lastRedrawId = null;
		lastRedrawCallTime = new Date;
		m.redraw.strategy("diff")
	}

	var pendingRequests = 0;
	m.startComputation = function() {pendingRequests++};
	m.endComputation = function() {
		pendingRequests = Math.max(pendingRequests - 1, 0);
		if (pendingRequests === 0) m.redraw()
	};
	var endFirstComputation = function() {
		if (m.redraw.strategy() == "none") {
			pendingRequests--
			m.redraw.strategy("diff")
		}
		else m.endComputation();
	}

	m.withAttr = function(prop, withAttrCallback) {
		return function(e) {
			e = e || event;
			var currentTarget = e.currentTarget || this;
			withAttrCallback(prop in currentTarget ? currentTarget[prop] : currentTarget.getAttribute(prop))
		}
	};

	//routing
	var modes = {pathname: "", hash: "#", search: "?"};
	var redirect = noop, routeParams, currentRoute, isDefaultRoute = false;
	m.route = function() {
		//m.route()
		if (arguments.length === 0) return currentRoute;
		//m.route(el, defaultRoute, routes)
		else if (arguments.length === 3 && type.call(arguments[1]) === STRING) {
			var root = arguments[0], defaultRoute = arguments[1], router = arguments[2];
			redirect = function(source) {
				var path = currentRoute = normalizeRoute(source);
				if (!routeByValue(root, router, path)) {
					if (isDefaultRoute) throw new Error("Ensure the default route matches one of the routes defined in m.route")
					isDefaultRoute = true
					m.route(defaultRoute, true)
					isDefaultRoute = false
				}
			};
			var listener = m.route.mode === "hash" ? "onhashchange" : "onpopstate";
			window[listener] = function() {
				var path = $location[m.route.mode]
				if (m.route.mode === "pathname") path += $location.search
				if (currentRoute != normalizeRoute(path)) {
					redirect(path)
				}
			};
			computePreRedrawHook = setScroll;
			window[listener]()
		}
		//config: m.route
		else if (arguments[0].addEventListener || arguments[0].attachEvent) {
			var element = arguments[0];
			var isInitialized = arguments[1];
			var context = arguments[2];
			var vdom = arguments[3];
			element.href = (m.route.mode !== 'pathname' ? $location.pathname : '') + modes[m.route.mode] + vdom.attrs.href;
			if (element.addEventListener) {
				element.removeEventListener("click", routeUnobtrusive);
				element.addEventListener("click", routeUnobtrusive)
			}
			else {
				element.detachEvent("onclick", routeUnobtrusive);
				element.attachEvent("onclick", routeUnobtrusive)
			}
		}
		//m.route(route, params, shouldReplaceHistoryEntry)
		else if (type.call(arguments[0]) === STRING) {
			var oldRoute = currentRoute;
			currentRoute = arguments[0];
			var args = arguments[1] || {}
			var queryIndex = currentRoute.indexOf("?")
			var params = queryIndex > -1 ? parseQueryString(currentRoute.slice(queryIndex + 1)) : {}
			for (var i in args) params[i] = args[i]
			var querystring = buildQueryString(params)
			var currentPath = queryIndex > -1 ? currentRoute.slice(0, queryIndex) : currentRoute
			if (querystring) currentRoute = currentPath + (currentPath.indexOf("?") === -1 ? "?" : "&") + querystring;

			var shouldReplaceHistoryEntry = (arguments.length === 3 ? arguments[2] : arguments[1]) === true || oldRoute === arguments[0];

			if (window.history.pushState) {
				computePreRedrawHook = setScroll
				computePostRedrawHook = function() {
					window.history[shouldReplaceHistoryEntry ? "replaceState" : "pushState"](null, $document.title, modes[m.route.mode] + currentRoute);
				};
				redirect(modes[m.route.mode] + currentRoute)
			}
			else {
				$location[m.route.mode] = currentRoute
				redirect(modes[m.route.mode] + currentRoute)
			}
		}
	};
	m.route.param = function(key) {
		if (!routeParams) throw new Error("You must call m.route(element, defaultRoute, routes) before calling m.route.param()")
		return routeParams[key]
	};
	m.route.mode = "search";
	function normalizeRoute(route) {
		return route.slice(modes[m.route.mode].length)
	}
	function routeByValue(root, router, path) {
		routeParams = {};

		var queryStart = path.indexOf("?");
		if (queryStart !== -1) {
			routeParams = parseQueryString(path.substr(queryStart + 1, path.length));
			path = path.substr(0, queryStart)
		}

		// Get all routes and check if there's
		// an exact match for the current path
		var keys = Object.keys(router);
		var index = keys.indexOf(path);
		if(index !== -1){
			m.mount(root, router[keys [index]]);
			return true;
		}

		for (var route in router) {
			if (route === path) {
				m.mount(root, router[route]);
				return true
			}

			var matcher = new RegExp("^" + route.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$");

			if (matcher.test(path)) {
				path.replace(matcher, function() {
					var keys = route.match(/:[^\/]+/g) || [];
					var values = [].slice.call(arguments, 1, -2);
					for (var i = 0, len = keys.length; i < len; i++) routeParams[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i])
					m.mount(root, router[route])
				});
				return true
			}
		}
	}
	function routeUnobtrusive(e) {
		e = e || event;
		if (e.ctrlKey || e.metaKey || e.which === 2) return;
		if (e.preventDefault) e.preventDefault();
		else e.returnValue = false;
		var currentTarget = e.currentTarget || e.srcElement;
		var args = m.route.mode === "pathname" && currentTarget.search ? parseQueryString(currentTarget.search.slice(1)) : {};
		while (currentTarget && currentTarget.nodeName.toUpperCase() != "A") currentTarget = currentTarget.parentNode
		m.route(currentTarget[m.route.mode].slice(modes[m.route.mode].length), args)
	}
	function setScroll() {
		if (m.route.mode != "hash" && $location.hash) $location.hash = $location.hash;
		else window.scrollTo(0, 0)
	}
	function buildQueryString(object, prefix) {
		var duplicates = {}
		var str = []
		for (var prop in object) {
			var key = prefix ? prefix + "[" + prop + "]" : prop
			var value = object[prop]
			var valueType = type.call(value)
			var pair = (value === null) ? encodeURIComponent(key) :
				valueType === OBJECT ? buildQueryString(value, key) :
				valueType === ARRAY ? value.reduce(function(memo, item) {
					if (!duplicates[key]) duplicates[key] = {}
					if (!duplicates[key][item]) {
						duplicates[key][item] = true
						return memo.concat(encodeURIComponent(key) + "=" + encodeURIComponent(item))
					}
					return memo
				}, []).join("&") :
				encodeURIComponent(key) + "=" + encodeURIComponent(value)
			if (value !== undefined) str.push(pair)
		}
		return str.join("&")
	}
	function parseQueryString(str) {
		if (str.charAt(0) === "?") str = str.substring(1);
		
		var pairs = str.split("&"), params = {};
		for (var i = 0, len = pairs.length; i < len; i++) {
			var pair = pairs[i].split("=");
			var key = decodeURIComponent(pair[0])
			var value = pair.length == 2 ? decodeURIComponent(pair[1]) : null
			if (params[key] != null) {
				if (type.call(params[key]) !== ARRAY) params[key] = [params[key]]
				params[key].push(value)
			}
			else params[key] = value
		}
		return params
	}
	m.route.buildQueryString = buildQueryString
	m.route.parseQueryString = parseQueryString
	
	function reset(root) {
		var cacheKey = getCellCacheKey(root);
		clear(root.childNodes, cellCache[cacheKey]);
		cellCache[cacheKey] = undefined
	}

	m.deferred = function () {
		var deferred = new Deferred();
		deferred.promise = propify(deferred.promise);
		return deferred
	};
	function propify(promise, initialValue) {
		var prop = m.prop(initialValue);
		promise.then(prop);
		prop.then = function(resolve, reject) {
			return propify(promise.then(resolve, reject), initialValue)
		};
		return prop
	}
	//Promiz.mithril.js | Zolmeister | MIT
	//a modified version of Promiz.js, which does not conform to Promises/A+ for two reasons:
	//1) `then` callbacks are called synchronously (because setTimeout is too slow, and the setImmediate polyfill is too big
	//2) throwing subclasses of Error cause the error to be bubbled up instead of triggering rejection (because the spec does not account for the important use case of default browser error handling, i.e. message w/ line number)
	function Deferred(successCallback, failureCallback) {
		var RESOLVING = 1, REJECTING = 2, RESOLVED = 3, REJECTED = 4;
		var self = this, state = 0, promiseValue = 0, next = [];

		self["promise"] = {};

		self["resolve"] = function(value) {
			if (!state) {
				promiseValue = value;
				state = RESOLVING;

				fire()
			}
			return this
		};

		self["reject"] = function(value) {
			if (!state) {
				promiseValue = value;
				state = REJECTING;

				fire()
			}
			return this
		};

		self.promise["then"] = function(successCallback, failureCallback) {
			var deferred = new Deferred(successCallback, failureCallback);
			if (state === RESOLVED) {
				deferred.resolve(promiseValue)
			}
			else if (state === REJECTED) {
				deferred.reject(promiseValue)
			}
			else {
				next.push(deferred)
			}
			return deferred.promise
		};

		function finish(type) {
			state = type || REJECTED;
			next.map(function(deferred) {
				state === RESOLVED && deferred.resolve(promiseValue) || deferred.reject(promiseValue)
			})
		}

		function thennable(then, successCallback, failureCallback, notThennableCallback) {
			if (((promiseValue != null && type.call(promiseValue) === OBJECT) || typeof promiseValue === FUNCTION) && typeof then === FUNCTION) {
				try {
					// count protects against abuse calls from spec checker
					var count = 0;
					then.call(promiseValue, function(value) {
						if (count++) return;
						promiseValue = value;
						successCallback()
					}, function (value) {
						if (count++) return;
						promiseValue = value;
						failureCallback()
					})
				}
				catch (e) {
					m.deferred.onerror(e);
					promiseValue = e;
					failureCallback()
				}
			} else {
				notThennableCallback()
			}
		}

		function fire() {
			// check if it's a thenable
			var then;
			try {
				then = promiseValue && promiseValue.then
			}
			catch (e) {
				m.deferred.onerror(e);
				promiseValue = e;
				state = REJECTING;
				return fire()
			}
			thennable(then, function() {
				state = RESOLVING;
				fire()
			}, function() {
				state = REJECTING;
				fire()
			}, function() {
				try {
					if (state === RESOLVING && typeof successCallback === FUNCTION) {
						promiseValue = successCallback(promiseValue)
					}
					else if (state === REJECTING && typeof failureCallback === "function") {
						promiseValue = failureCallback(promiseValue);
						state = RESOLVING
					}
				}
				catch (e) {
					m.deferred.onerror(e);
					promiseValue = e;
					return finish()
				}

				if (promiseValue === self) {
					promiseValue = TypeError();
					finish()
				}
				else {
					thennable(then, function () {
						finish(RESOLVED)
					}, finish, function () {
						finish(state === RESOLVING && RESOLVED)
					})
				}
			})
		}
	}
	m.deferred.onerror = function(e) {
		if (type.call(e) === "[object Error]" && !e.constructor.toString().match(/ Error/)) throw e
	};

	m.sync = function(args) {
		var method = "resolve";
		function synchronizer(pos, resolved) {
			return function(value) {
				results[pos] = value;
				if (!resolved) method = "reject";
				if (--outstanding === 0) {
					deferred.promise(results);
					deferred[method](results)
				}
				return value
			}
		}

		var deferred = m.deferred();
		var outstanding = args.length;
		var results = new Array(outstanding);
		if (args.length > 0) {
			for (var i = 0; i < args.length; i++) {
				args[i].then(synchronizer(i, true), synchronizer(i, false))
			}
		}
		else deferred.resolve([]);

		return deferred.promise
	};
	function identity(value) {return value}

	function ajax(options) {
		if (options.dataType && options.dataType.toLowerCase() === "jsonp") {
			var callbackKey = "mithril_callback_" + new Date().getTime() + "_" + (Math.round(Math.random() * 1e16)).toString(36);
			var script = $document.createElement("script");

			window[callbackKey] = function(resp) {
				script.parentNode.removeChild(script);
				options.onload({
					type: "load",
					target: {
						responseText: resp
					}
				});
				window[callbackKey] = undefined
			};

			script.onerror = function(e) {
				script.parentNode.removeChild(script);

				options.onerror({
					type: "error",
					target: {
						status: 500,
						responseText: JSON.stringify({error: "Error making jsonp request"})
					}
				});
				window[callbackKey] = undefined;

				return false
			};

			script.onload = function(e) {
				return false
			};

			script.src = options.url
				+ (options.url.indexOf("?") > 0 ? "&" : "?")
				+ (options.callbackKey ? options.callbackKey : "callback")
				+ "=" + callbackKey
				+ "&" + buildQueryString(options.data || {});
			$document.body.appendChild(script)
		}
		else {
			var xhr = new window.XMLHttpRequest;
			xhr.open(options.method, options.url, true, options.user, options.password);
			xhr.onreadystatechange = function() {
				if (xhr.readyState === 4) {
					if (xhr.status >= 200 && xhr.status < 300) options.onload({type: "load", target: xhr});
					else options.onerror({type: "error", target: xhr})
				}
			};
			if (options.serialize === JSON.stringify && options.data && options.method !== "GET") {
				xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")
			}
			if (options.deserialize === JSON.parse) {
				xhr.setRequestHeader("Accept", "application/json, text/*");
			}
			if (typeof options.config === FUNCTION) {
				var maybeXhr = options.config(xhr, options);
				if (maybeXhr != null) xhr = maybeXhr
			}

			var data = options.method === "GET" || !options.data ? "" : options.data
			if (data && (type.call(data) != STRING && data.constructor != window.FormData)) {
				throw "Request data should be either be a string or FormData. Check the `serialize` option in `m.request`";
			}
			xhr.send(data);
			return xhr
		}
	}
	function bindData(xhrOptions, data, serialize) {
		if (xhrOptions.method === "GET" && xhrOptions.dataType != "jsonp") {
			var prefix = xhrOptions.url.indexOf("?") < 0 ? "?" : "&";
			var querystring = buildQueryString(data);
			xhrOptions.url = xhrOptions.url + (querystring ? prefix + querystring : "")
		}
		else xhrOptions.data = serialize(data);
		return xhrOptions
	}
	function parameterizeUrl(url, data) {
		var tokens = url.match(/:[a-z]\w+/gi);
		if (tokens && data) {
			for (var i = 0; i < tokens.length; i++) {
				var key = tokens[i].slice(1);
				url = url.replace(tokens[i], data[key]);
				delete data[key]
			}
		}
		return url
	}

	m.request = function(xhrOptions) {
		if (xhrOptions.background !== true) m.startComputation();
		var deferred = new Deferred();
		var isJSONP = xhrOptions.dataType && xhrOptions.dataType.toLowerCase() === "jsonp";
		var serialize = xhrOptions.serialize = isJSONP ? identity : xhrOptions.serialize || JSON.stringify;
		var deserialize = xhrOptions.deserialize = isJSONP ? identity : xhrOptions.deserialize || JSON.parse;
		var extract = isJSONP ? function(jsonp) {return jsonp.responseText} : xhrOptions.extract || function(xhr) {
			return xhr.responseText.length === 0 && deserialize === JSON.parse ? null : xhr.responseText
		};
		xhrOptions.method = (xhrOptions.method || 'GET').toUpperCase();
		xhrOptions.url = parameterizeUrl(xhrOptions.url, xhrOptions.data);
		xhrOptions = bindData(xhrOptions, xhrOptions.data, serialize);
		xhrOptions.onload = xhrOptions.onerror = function(e) {
			try {
				e = e || event;
				var unwrap = (e.type === "load" ? xhrOptions.unwrapSuccess : xhrOptions.unwrapError) || identity;
				var response = unwrap(deserialize(extract(e.target, xhrOptions)), e.target);
				if (e.type === "load") {
					if (type.call(response) === ARRAY && xhrOptions.type) {
						for (var i = 0; i < response.length; i++) response[i] = new xhrOptions.type(response[i])
					}
					else if (xhrOptions.type) response = new xhrOptions.type(response)
				}
				deferred[e.type === "load" ? "resolve" : "reject"](response)
			}
			catch (e) {
				m.deferred.onerror(e);
				deferred.reject(e)
			}
			if (xhrOptions.background !== true) m.endComputation()
		};
		ajax(xhrOptions);
		deferred.promise = propify(deferred.promise, xhrOptions.initialValue);
		return deferred.promise
	};

	//testing API
	m.deps = function(mock) {
		initialize(window = mock || window);
		return window;
	};
	//for internal testing only, do not use `m.deps.factory`
	m.deps.factory = app;

	return m
})(typeof window != "undefined" ? window : {});

if (typeof module != "undefined" && module !== null && module.exports) module.exports = m;
else if (typeof define === "function" && define.amd) define('mithril',[],function() {return m});

define('js/PanelSetup',["require", "exports", "./panelBuilder/PanelSpecificationCollection", "./panelBuilder/translate", "./tips", "mithril"], function (require, exports, PanelSpecificationCollection, translate, tips, m) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    // The home page -- should be a constant
    var _startPage = "page_dashboard";
    // This will hold information about all the panels used
    var _panelSpecificationCollection = new PanelSpecificationCollection();
    function startPage() {
        return _startPage;
    }
    exports.startPage = startPage;
    function panelSpecificationCollection() {
        return _panelSpecificationCollection;
    }
    exports.panelSpecificationCollection = panelSpecificationCollection;
    function addExtraFieldSpecificationsForPageSpecification(pageID, pageSpecification) {
        function addPageChangeButton(newPageID, idExtra, prompt, displayIconClass) {
            // TODO: Translate
            if (displayIconClass !== "homeButtonImage") {
                var sectionPageSpecification = _panelSpecificationCollection.getPageSpecificationForPageID(newPageID);
                prompt += sectionPageSpecification.displayName;
            }
            var iconPosition = (displayIconClass === "rightButtonImage") ? "right" : "left";
            var returnToDashboardButtonSpecification = {
                "id": pageID + idExtra,
                "valueType": "none",
                "displayPrompt": prompt,
                "displayType": "button",
                "displayClass": "narrafirma-page-change-button",
                "displayConfiguration": {
                    "action": "guiOpenSection",
                    "section": newPageID
                },
                displayIconClass: "buttonWithTextImage " + displayIconClass,
                displayPreventBreak: true,
                displayIconPosition: iconPosition
            };
            _panelSpecificationCollection.addFieldSpecificationToPanelSpecification(pageSpecification, returnToDashboardButtonSpecification);
        }
        function addTip() {
            var prompt = tips.getRandomTip();
            var tipSpecification = {
                "id": pageID + "_tip",
                "valueType": "none",
                "displayPrompt": prompt,
                "displayType": "html",
                "displayClass": "narrafirma-tip",
            };
            _panelSpecificationCollection.addFieldSpecificationToPanelSpecification(pageSpecification, tipSpecification);
        }
        function addReadOnlyWarning() {
            var readOnlyWarningSpecification = {
                "id": pageID + "_readOnlyWarning",
                "valueType": "none",
                "displayPrompt": "You have read-only access to this project. You can make local changes, but they will not be saved to the server.",
                "displayType": "html",
                "displayClass": "narrafirma-read-only-warning",
            };
            _panelSpecificationCollection.addFieldSpecificationToPanelSpecification(pageSpecification, readOnlyWarningSpecification);
        }
        if (pageSpecification.section !== "dashboard") {
            if (!pageSpecification.isHeader) {
                // TODO: Change the id of this field to have notes or reminder
                // Regular page -- add a footer where the page status can be set
                var statusEntryID = pageID + "_reminders";
                var completionStatusEntryFieldSpecification = {
                    id: statusEntryID,
                    valueType: "string",
                    displayType: "textarea",
                    displayName: "Reminders",
                    displayClass: "narrafirma-reminder",
                    displayPrompt: translate("#dashboard_status_entry::prompt", "You can enter <strong>reminders</strong> about this page here. They will appear on this section's home page.")
                };
                _panelSpecificationCollection.addFieldSpecificationToPanelSpecification(pageSpecification, completionStatusEntryFieldSpecification);
            }
            else {
                // Dashboard page
                // Put in dashboard
                var childPageIDs = _panelSpecificationCollection.getChildPageIDListForHeaderID(pageID);
                if (!childPageIDs)
                    childPageIDs = [];
                // Add a link (plus explanation) to this page for each child page in the section
                for (var childPageIndex = 0; childPageIndex < childPageIDs.length; childPageIndex++) {
                    var childPageID = childPageIDs[childPageIndex];
                    var statusViewID = childPageID + "_reminders_dashboard";
                    var childPageSpecification = _panelSpecificationCollection.getPageSpecificationForPageID(childPageID);
                    if (!childPageSpecification)
                        console.log("Error: problem finding page definition for", childPageID);
                    if (childPageSpecification && childPageSpecification.displayType === "page") {
                        var prompt_1 = translate(childPageID + "::title", childPageSpecification.displayName);
                        var properties = { href: "javascript:narrafirma_openPage('" + childPageID + "')" };
                        var pageExplanationWithCategoryImages = [];
                        var categories = childPageSpecification.pageCategories.split(", ");
                        var allowedPageCategories = ["manage", "plan", "journal", "enter", "review", "export"];
                        for (var categoryIndex in categories) {
                            var category = categories[categoryIndex];
                            if (allowedPageCategories.indexOf(category) >= 0) {
                                var imageSpan = m("span", { class: "pageCategoryImage " + category + "CategoryImage", key: "pageCategoryImage" + childPageIndex, title: category });
                                pageExplanationWithCategoryImages.push(imageSpan);
                            }
                            else {
                                console.log("Error: Unrecognized page category: ", category);
                            }
                        }
                        pageExplanationWithCategoryImages.push(childPageSpecification.pageExplanation);
                        var explanationDiv = m("div.narrafirma-dashboard-page-link-explanation", pageExplanationWithCategoryImages);
                        prompt_1 = m("div.narrafirma-dashboard-page-link", [m("a", properties, prompt_1), explanationDiv]);
                        if (childPageSpecification.headerAbove) {
                            prompt_1 = [m("div.narrafirma-dashboard-header", childPageSpecification.headerAbove), prompt_1];
                        }
                        // + " " + translate("#dashboard_status_label", "reminders:")
                        // prompt = prompt  + " ";
                        var completionStatusDisplayFieldSpecification = {
                            id: statusViewID,
                            valueType: "none",
                            displayType: "questionAnswer",
                            displayPrompt: prompt_1,
                            displayConfiguration: childPageID + "_reminders"
                        };
                        _panelSpecificationCollection.addFieldSpecificationToPanelSpecification(pageSpecification, completionStatusDisplayFieldSpecification);
                    }
                }
            }
            // Add button at bottom of each page to move to previous
            if (pageSpecification.previousPageID) {
                // TODO: Translate
                addPageChangeButton(pageSpecification.previousPageID, "_previousPageButton", "", "leftButtonImage");
            }
            else {
                addPageChangeButton(_startPage, "_returnToDashboardButton", "Home", "homeButtonImage");
            }
            // Add button at bottom of each page to move forward
            if (pageSpecification.nextPageID) {
                addPageChangeButton(pageSpecification.nextPageID, "_nextPageButton", "", "rightButtonImage");
            }
            else {
                addPageChangeButton(_startPage, "_returnToDashboardButton", "Home", "homeButtonImage");
            }
        }
        addTip();
        addReadOnlyWarning();
    }
    function processAllPanels() {
        var panels = _panelSpecificationCollection.buildListOfPanels();
        var lastPageID = null;
        var panelIndex;
        var panel;
        // Loop to setup navigation
        for (panelIndex = 0; panelIndex < panels.length; panelIndex++) {
            panel = panels[panelIndex];
            // For panels that are a "page", add to top level pages choices and set up navigation
            if (panel.displayType === "page") {
                // Make it easy to lookup previous and next pages from a page
                if (!panel.isHeader) {
                    var previousPage = _panelSpecificationCollection.getPageSpecificationForPageID(lastPageID);
                    previousPage.nextPageID = panel.id;
                    panel.previousPageID = lastPageID;
                }
                lastPageID = panel.id;
            }
        }
        var lastHeader = null;
        var lastSection = null;
        // A separate loop is needed here to ensure page navigation links have been set up when determining additional buttons for pages
        for (panelIndex = 0; panelIndex < panels.length; panelIndex++) {
            panel = panels[panelIndex];
            if (panel.isHeader) {
                lastHeader = panel.id;
                lastSection = panel.section;
            }
            // For panels that are a "page", add extra buttons
            if (panel.displayType === "page") {
                addExtraFieldSpecificationsForPageSpecification(panel.id, panel);
            }
            panel.helpSection = lastSection;
            panel.helpPage = panel.id;
            panel.sectionHeaderPageID = lastHeader;
            for (var fieldIndex = 0; fieldIndex < panel.panelFields.length; fieldIndex++) {
                var fieldSpec = panel.panelFields[fieldIndex];
                fieldSpec.helpSection = lastSection;
                fieldSpec.helpPage = panel.id;
            }
        }
    }
    exports.processAllPanels = processAllPanels;
    // TODO: Temporary for generating JSON navigation data from AMD module
    function generateNavigationDataInJSON() {
        var sections = [];
        var sectionBeingProcessed;
        var pageBeingProcessed;
        var allPanels = _panelSpecificationCollection.buildListOfPanels();
        allPanels.forEach(function (panel) {
            if (panel.isHeader) {
                if (sectionBeingProcessed)
                    sections.push(sectionBeingProcessed);
                sectionBeingProcessed = {
                    section: panel.section,
                    sectionName: panel.displayName,
                    pages: []
                };
            }
            var navigationInfo = {
                panelID: panel.id,
                panelName: panel.displayName
            };
            if (panel.displayType === "page") {
                sectionBeingProcessed.pages.push(navigationInfo);
                pageBeingProcessed = navigationInfo;
            }
            else {
                if (!pageBeingProcessed.extraPanels)
                    pageBeingProcessed.extraPanels = [];
                pageBeingProcessed.extraPanels.push(navigationInfo);
            }
        });
    }
    // TODO: For helping create all the models -- temporary
    function printModels() {
        console.log("-------------------------------------------------");
        console.log("panelSpecificationCollection", _panelSpecificationCollection);
        console.log("models", _panelSpecificationCollection.modelClassToModelFieldSpecificationsMap);
        var allModels = JSON.stringify(_panelSpecificationCollection.modelClassToModelFieldSpecificationsMap, null, 4);
        console.log("models JSON", allModels);
        // window.open('data:text/plain;charset=utf-8,' + escape(allModels));
        console.log("stop");
        console.log("-------------------------------------------------");
    }
});

define('js/ClientState',["require", "exports", "./PanelSetup"], function (require, exports, PanelSetup) {
    "use strict";
    "use strict";
    // m.route.mode = "hash";
    function hash(newValue) {
        if (newValue === void 0) { newValue = null; }
        if (newValue === null)
            return window.location.hash.substr(1);
        if (history.pushState) {
            history.pushState(null, null, "#" + newValue);
        }
        else {
            location.hash = "#" + newValue;
        }
    }
    // getHashParameters derived from: http://stackoverflow.com/questions/4197591/parsing-url-hash-fragment-identifier-with-javascript
    function getHashParameters(hash) {
        var result = {};
        var match;
        // Regex for replacing addition symbol with a space
        var plusMatcher = /\+/g;
        var parameterSplitter = /([^&;=]+)=?([^&;]*)/g;
        var decode = function (s) { return decodeURIComponent(s.replace(plusMatcher, " ")); };
        while (true) {
            match = parameterSplitter.exec(hash);
            if (!match)
                break;
            result[decode(match[1])] = decode(match[2]);
        }
        return result;
    }
    var ClientState = (function () {
        function ClientState() {
            this._projectIdentifier = null;
            this._pageIdentifier = null;
            this._storyCollectionName = null;
            this._catalysisReportName = null;
            this._storyFormName = null;
            this._observationAccessor = null;
            this._debugMode = null;
            this._serverStatus = "narrafirma-serverstatus-ok";
            this._serverStatusText = "";
            this._redrawingDueToIncomingMessage = null;
            this._cachedOverwrittenTexts = {};
            this._showAdvancedOptions = false;
            this._showImportOptions = false;
            // This should only be set by Globals
            this._project = null;
        }
        ClientState.prototype.projectIdentifier = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._projectIdentifier = newValue;
            }
            return this._projectIdentifier;
        };
        ClientState.prototype.pageIdentifier = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._pageIdentifier = newValue;
            }
            return this._pageIdentifier;
        };
        ClientState.prototype.storyCollectionName = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._storyCollectionName = newValue;
            }
            return this._storyCollectionName;
        };
        // Read-only convenience accessor
        ClientState.prototype.storyCollectionIdentifier = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue)
                throw new Error("storyCollectionIdentifier: setting value is not supported");
            var storyCollectionIdentifier = this._project.findStoryCollectionID(this._storyCollectionName);
            if (!storyCollectionIdentifier)
                return null;
            return storyCollectionIdentifier;
        };
        ClientState.prototype.haveStoryCollectionAndShowingAdvancedOptions = function () {
            var storyCollectionIdentifier = this._project.findStoryCollectionID(this._storyCollectionName);
            if (!storyCollectionIdentifier)
                return null;
            return this._showAdvancedOptions;
        };
        ClientState.prototype.atLeastOneAnnotationQuestionExists = function () {
            if (!this._project)
                return false;
            var questions = this._project.collectAllAnnotationQuestions();
            return questions.length > 0;
        };
        ClientState.prototype.csvDelimiter = function () {
            var defaultValue = ",";
            if (!this._project)
                return defaultValue;
            var value = this._project.tripleStore.queryLatestC(this._project.projectIdentifier, "projectOptions_csvDelimiter");
            if (value) {
                switch (value) {
                    case "comma":
                        return ",";
                    case "semicolon":
                        return ";";
                    case "tab":
                        return "\t";
                    default:
                        alert("ERROR: Unexpected value for csv delimiter: " + value);
                        return defaultValue;
                }
            }
            else {
                return defaultValue;
            }
        };
        ClientState.prototype.catalysisReportName = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._catalysisReportName = newValue;
            }
            return this._catalysisReportName;
        };
        // Read-only convenience accessor
        ClientState.prototype.catalysisReportIdentifier = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue)
                throw new Error("catalysisReportIdentifier: setting value is not supported");
            var catalysisReportIdentifier = this._project.findCatalysisReport(this._catalysisReportName);
            if (!catalysisReportIdentifier)
                return null;
            return catalysisReportIdentifier;
        };
        ClientState.prototype.haveCatalysisReportAndShowingAdvancedOptions = function () {
            var catalysisReportIdentifier = this._project.findCatalysisReport(this._catalysisReportName);
            if (!catalysisReportIdentifier)
                return null;
            return this._showAdvancedOptions;
        };
        ClientState.prototype.storyFormName = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._storyFormName = newValue;
            }
            return this._storyFormName;
        };
        ClientState.prototype.storyFormIdentifier = function () {
            var storyFormIdentifier = this._project.findStoryFormID(this._storyFormName);
            if (!storyFormIdentifier)
                return null;
            return storyFormIdentifier;
        };
        ClientState.prototype.haveStoryFormAndShowingAdvancedOptions = function () {
            var storyFormIdentifier = this._project.findStoryFormID(this._storyFormName);
            if (!storyFormIdentifier)
                return null;
            return this._showAdvancedOptions;
        };
        ClientState.prototype.observationAccessor = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._observationAccessor = newValue;
            }
            return this._observationAccessor;
        };
        ClientState.prototype.leavingPageCallback = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._leavingPageCallback = newValue;
            }
            return this._leavingPageCallback;
        };
        ClientState.prototype.redrawingDueToIncomingMessage = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._redrawingDueToIncomingMessage = newValue;
            }
            return this._redrawingDueToIncomingMessage;
        };
        ClientState.prototype.cachedOverwrittenTexts = function (fieldID, newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (fieldID === undefined)
                return null;
            if (newValue === null) {
                delete this._cachedOverwrittenTexts[fieldID];
            }
            else if (newValue !== undefined) {
                this._cachedOverwrittenTexts[fieldID] = newValue;
            }
            return this._cachedOverwrittenTexts[fieldID];
        };
        ClientState.prototype.showAdvancedOptions = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._showAdvancedOptions = newValue;
            }
            return this._showAdvancedOptions;
        };
        ClientState.prototype.showImportOptions = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._showImportOptions = newValue;
            }
            return this._showImportOptions;
        };
        ClientState.prototype.debugMode = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._debugMode = newValue;
            }
            return this._debugMode;
        };
        ClientState.prototype.serverStatus = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._serverStatus = newValue;
            }
            return this._serverStatus;
        };
        ClientState.prototype.serverStatusText = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._serverStatusText = newValue;
            }
            return this._serverStatusText;
        };
        ClientState.prototype.initialize = function () {
            var fragment = hash();
            var initialHashParameters = getHashParameters(fragment);
            if (initialHashParameters["project"])
                this._projectIdentifier = initialHashParameters["project"];
            if (initialHashParameters["page"])
                this._pageIdentifier = "page_" + initialHashParameters["page"];
            if (initialHashParameters["storyCollection"])
                this._storyCollectionName = initialHashParameters["storyCollection"];
            if (initialHashParameters["catalysisReport"])
                this._catalysisReportName = initialHashParameters["catalysisReport"];
            if (initialHashParameters["debugMode"])
                this._debugMode = initialHashParameters["debugMode"];
            // Ensure defaults
            if (!initialHashParameters["page"])
                this._pageIdentifier = PanelSetup.startPage();
        };
        ClientState.prototype.hashStringForClientState = function () {
            var result = "";
            var fields = [
                { id: "_projectIdentifier", key: "project" },
                { id: "_pageIdentifier", key: "page" },
                { id: "_storyCollectionName", key: "storyCollection" },
                { id: "_catalysisReportName", key: "catalysisReport" },
                { id: "_debugMode", key: "debugMode" }
            ];
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i];
                var value = this[field.id];
                if (!value)
                    continue;
                if (field.key === "page" && value)
                    value = value.substring("page_".length);
                if (result)
                    result += "&";
                result += field.key + "=" + encodeURIComponent(value);
            }
            return result;
        };
        ClientState.prototype.urlHashFragmentChanged = function (pageDisplayer) {
            var newHash = hash();
            console.log("urlHashFragmentChanged", newHash);
            var hashParameters = getHashParameters(newHash);
            var currentProjectIdentifier = this._projectIdentifier;
            if (currentProjectIdentifier) {
                if (hashParameters.project && hashParameters.project !== currentProjectIdentifier) {
                    // Force a complete page reload for now, as needs to create a new Pointrel client
                    // TODO: Should we shut down the current Pointrel client first?
                    alert("About to trigger page reload for changed project");
                    location.reload();
                    return;
                }
            }
            else {
                this._projectIdentifier = hashParameters.project;
            }
            var selectedPage = hashParameters.page;
            if (!selectedPage) {
                selectedPage = PanelSetup.startPage();
            }
            else {
                selectedPage = "page_" + selectedPage;
            }
            if (selectedPage !== this._pageIdentifier) {
                this._pageIdentifier = selectedPage;
            }
            if (hashParameters.storyCollection && hashParameters.storyCollection !== this._storyCollectionName) {
                this._storyCollectionName = hashParameters.storyCollection;
            }
            if (hashParameters.catalysisReport && hashParameters.catalysisReport !== this._catalysisReportName) {
                this._catalysisReportName = hashParameters.catalysisReport;
            }
            if (hashParameters.debugMode && hashParameters.debugMode !== this._debugMode) {
                this._debugMode = hashParameters.debugMode;
            }
            // Page displayer will handle cases where the hash is not valid and also optimizing out page redraws if staying on same page
            pageDisplayer.showPage(this._pageIdentifier);
        };
        ClientState.prototype.updateHashIfNeededForChangedClientState = function () {
            var newHash = this.hashStringForClientState();
            if (newHash !== hash())
                hash(newHash);
        };
        return ClientState;
    }());
    return ClientState;
});

define('js/Globals',["require", "exports", "./ClientState"], function (require, exports, ClientState) {
    "use strict";
    "use strict";
    var Globals = (function () {
        function Globals() {
        }
        Globals.clientState = function () {
            return Globals._clientState;
        };
        Globals.project = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                if (Globals._project)
                    throw new Error("Global project was previously initalized");
                Globals._project = newValue;
                Globals._clientState._project = newValue;
            }
            return Globals._project;
        };
        Globals.panelSpecificationCollection = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                if (Globals._panelSpecificationCollection)
                    throw new Error("Global panelSpecificationCollection was previously initalized");
                Globals._panelSpecificationCollection = newValue;
            }
            return Globals._panelSpecificationCollection;
        };
        // ClientState is for this local instance only (not shared with other users or other browser tabs)
        Globals._clientState = new ClientState();
        return Globals;
    }());
    return Globals;
});

define('js/sanitizeHTML',["require", "exports", "mithril"], function (require, exports, m) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    // This constructs a nested Mithril object with only specific HTML tags allowed
    // No attributes are allowed.
    // A css class (from a short approved list) can be set on a tag using a ".className" after the opening tag name.
    // For example: <span.narrafirma-special-warning>Warning!!!<span>
    // 1 is normal tag that needs to be closed; 2 is self-closing tag (br and hr)
    var allowedHTMLTags = {
        // a
        address: 1,
        article: 1,
        b: 1,
        big: 1,
        blockquote: 1,
        br: 2,
        caption: 1,
        cite: 1,
        code: 1,
        del: 1,
        div: 1,
        dd: 1,
        d1: 1,
        dt: 1,
        em: 1,
        h1: 1,
        h2: 1,
        h3: 1,
        h4: 1,
        h5: 1,
        h6: 1,
        hr: 2,
        i: 1,
        // img
        kbd: 1,
        li: 1,
        ol: 1,
        p: 1,
        pre: 1,
        s: 1,
        small: 1,
        span: 1,
        sup: 1,
        sub: 1,
        strong: 1,
        strike: 1,
        table: 1,
        td: 1,
        th: 1,
        tr: 1,
        u: 1,
        ul: 1
    };
    var smallerSubsetOfAllowedHTMLTags = {
        b: 1,
        big: 1,
        em: 1,
        i: 1,
        s: 1,
        small: 1,
        sup: 1,
        sub: 1,
        strong: 1,
        strike: 1,
        u: 1
    };
    var allowedCSSClasses = {
        "narrafirma-special-warning": 1,
        "narrafirma-centered-label": 1
    };
    function generateSanitizedHTMLForMithril(html) {
        return generateSpecificTypeOfSanitizedHTMLForMithril(html, allowedHTMLTags);
    }
    exports.generateSanitizedHTMLForMithril = generateSanitizedHTMLForMithril;
    function generateSmallerSetOfSanitizedHTMLForMithril(html) {
        return generateSpecificTypeOfSanitizedHTMLForMithril(html, smallerSubsetOfAllowedHTMLTags);
    }
    exports.generateSmallerSetOfSanitizedHTMLForMithril = generateSmallerSetOfSanitizedHTMLForMithril;
    function generateSpecificTypeOfSanitizedHTMLForMithril(html, specifiedHTMLTags) {
        if (html === undefined || html === null) {
            console.log("Undefined or null html", html);
            html = "";
        }
        // Handle case where is already a Mithril object
        if (html.tag)
            return html;
        var hasMarkup = html.indexOf("<") !== -1;
        if (!hasMarkup)
            return html;
        // Use a fake div tag as a conceptual placeholder
        var tags = [{ tagName: "div", cssClass: undefined }];
        var output = [[]];
        var text = "";
        for (var i = 0, length_1 = html.length; i < length_1; i++) {
            var char = html.charAt(i);
            if (char === "<") {
                if (text !== "") {
                    output[output.length - 1].push(text);
                    text = "";
                }
                var closing = html.charAt(i + 1) === "/";
                if (closing)
                    i++;
                var positionOfClosingAngleBracket = -1;
                if (i < length_1 - 1) {
                    positionOfClosingAngleBracket = html.indexOf(">", i + 1);
                }
                if (positionOfClosingAngleBracket < 0) {
                    text = text + char;
                    // special case: sometimes people want just a < in an answer text
                    // such as for an age range of "<25"
                    // so I have changed this to NOT throw an error - instead, we will just show the unmatched bracket in the HTML text
                    // and hopefully, if they did want an html tag, they will see the unmatched bracket and fix it
                    // throw new Error('For the text "' + html + '", no closing angle bracket was found after position: ' + i);
                }
                else {
                    var tagName = html.substring(i + 1, positionOfClosingAngleBracket);
                    i = positionOfClosingAngleBracket;
                    var cssClass = void 0;
                    var parts = tagName.split(".");
                    if (parts.length > 1) {
                        tagName = parts[0];
                        cssClass = parts[1];
                    }
                    else {
                        cssClass = undefined;
                    }
                    if (/[^A-Za-z0-9]/.test(tagName)) {
                        throw new Error("Tag is not alphanumeric: " + tagName);
                    }
                    if (cssClass && !allowedCSSClasses[cssClass]) {
                        throw new Error("CSS class is not allowed: " + cssClass);
                    }
                    if (closing) {
                        var startTag = tags.pop();
                        if (startTag.tagName !== tagName) {
                            throw new Error("Closing tag does not match opening tag for: " + tagName);
                        }
                        cssClass = startTag.cssClass;
                    }
                    if (!specifiedHTMLTags[tagName]) {
                        throw new Error("Tag is not allowed: " + tagName);
                    }
                    if (specifiedHTMLTags[tagName] === 2) {
                        // self-closing tag like BR
                        output.push([]);
                        closing = true;
                    }
                    if (closing) {
                        var newTag = void 0;
                        if (cssClass) {
                            newTag = m(tagName, { "class": cssClass }, output.pop());
                        }
                        else {
                            newTag = m(tagName, output.pop());
                        }
                        output[output.length - 1].push(newTag);
                    }
                    else {
                        tags.push({ tagName: tagName, cssClass: cssClass });
                        output.push([]);
                    }
                }
            }
            else {
                text = text + char;
            }
        }
        if (text)
            output[output.length - 1].push(text);
        if (tags.length !== 1 || output.length !== 1) {
            throw new Error("Unmatched start tag: " + tags.pop());
        }
        // Don't return the fake div tag, just the contents
        return output.pop();
    }
    exports.generateSpecificTypeOfSanitizedHTMLForMithril = generateSpecificTypeOfSanitizedHTMLForMithril;
    function removeHTMLTags(text) {
        var cleanedText = "";
        var inTag = false;
        for (var i = 0; i < text.length; i++) {
            if (text[i] === "<") {
                inTag = true;
            }
            else if (text[i] === ">") {
                inTag = false;
            }
            else {
                if (!inTag) {
                    cleanedText += text[i];
                }
            }
        }
        return cleanedText;
    }
    exports.removeHTMLTags = removeHTMLTags;
});

define('js/surveyBuilderMithril',["require", "exports", "mithril", "./pointrel20150417/generateRandomUuid", "./sanitizeHTML"], function (require, exports, m, generateRandomUuid, sanitizeHTML) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    var writeInTag = "WriteInEntry_";
    // TODO: Fix overly long lines and remove next line disabling check
    /* tslint:disable:max-line-length */
    var idsMade = {};
    var idCount = 0;
    var currentLanguage = "";
    exports.defaultFormTexts = {
        startText: 'Please help by taking a short survey. The data you enter will be sent to the server only at the end when you press the "submit survey" button.',
        sliderValuePrompt: "Type a new value",
        sliderDoesNotApply: "Does not apply",
        selectNoChoiceName: "-- select --",
        booleanYesNoNames: "yes/no",
        maxNumAnswersPrompt: "(Please choose up to # answers.)",
        endText: "Thank you for taking the survey.",
        thankYouPopupText: "Your contribution has been added to the story collection. Thank you.",
        chooseQuestionText: "Please choose a question to which you would like to respond.",
        enterStoryText: "Please enter your response in the box below.",
        nameStoryText: "Please give your story a name.",
        aboutYouText: "About you",
        errorMessage_noElicitationQuestionChosen: "Please select the question to which story # is a response.",
        errorMessage_noStoryText: "Please enter some text for story #.",
        errorMessage_noStoryName: "Please give story # a name.",
        deleteStoryButtonText: "Delete this story",
        deleteStoryDialogPrompt: "Are you sure you want to delete this story?",
        submitSurveyButtonText: "Submit Survey",
        couldNotSaveSurveyText: "The server could not save your survey. Please try again.",
        sendingSurveyResultsText: "Now sending survey result to server. Please wait . . .",
        resubmitSurveyButtonText: "Resubmit Survey",
        surveyStoredText: "Your survey has been accepted and stored.",
        surveyResultPaneHeader: "Here are the stories you contributed. You can copy this text and paste it somewhere else to keep your own copy of what you said.",
        tellAnotherStoryText: "Would you like to tell another story?",
        tellAnotherStoryButtonText: "Yes, I'd like to tell another story",
    };
    function translate(storyForm, language, text) {
        if (!language)
            return text;
        if (!storyForm.translationDictionary)
            return text;
        if (!storyForm.translationDictionary[text])
            return text;
        if (!storyForm.translationDictionary[text][language])
            return text;
        return storyForm.translationDictionary[text][language];
    }
    function getIdForText(text) {
        if (!idsMade["$" + text]) {
            idsMade["$" + text] = idCount++;
        }
        return "panelField_" + idsMade["$" + text];
    }
    function loadCSS(document, cssText) {
        var styleElement = document.createElement("style");
        styleElement.type = "text/css";
        document.getElementsByTagName("head")[0].appendChild(styleElement);
        if (styleElement.styleSheet) {
            styleElement.styleSheet.cssText = cssText;
        }
        else {
            styleElement.innerHTML = cssText;
        }
    }
    exports.loadCSS = loadCSS;
    function stringUpTo(aString, upToWhat) {
        if (upToWhat !== "") {
            return aString.split(upToWhat)[0];
        }
        else {
            return aString;
        }
    }
    function stringBeyond(aString, beyondWhat) {
        if (beyondWhat !== "") {
            return aString.split(beyondWhat).pop();
        }
        else {
            return aString;
        }
    }
    function stringBetween(wholeString, startString, endString) {
        if (wholeString.indexOf(startString) < 0 || wholeString.indexOf(endString) < 0)
            return "";
        return stringUpTo(stringBeyond(wholeString.trim(), startString), endString);
    }
    function mithrilForVideoInfo(videoInfoString) {
        if (!videoInfoString)
            return m("div");
        if (videoInfoString.indexOf("iframe") >= 0) {
            var width = stringBetween(videoInfoString, 'width="', '"');
            var height = stringBetween(videoInfoString, 'height="', '"');
            var source = stringBetween(videoInfoString, 'src="', '"');
            var title = stringBetween(videoInfoString, 'title="', '"');
            var allow = stringBetween(videoInfoString, 'allow="', '"');
            return m("iframe", {
                src: source,
                width: width || 560,
                title: title || "Introductory video",
                height: height || 315,
                class: "narrafirma-survey-introductory-video-streaming",
                allow: allow,
            });
        }
        else {
            return m("video", {
                src: videoInfoString,
                type: "video/mp4",
                controls: "controls",
                class: "narrafirma-survey-introductory-video-mp4"
            });
        }
    }
    // Redrawing
    var globalRedrawCallback;
    function setGlobalRedrawFunction(callback) {
        globalRedrawCallback = callback;
    }
    exports.setGlobalRedrawFunction = setGlobalRedrawFunction;
    function globalRedraw(source) {
        if (source === void 0) { source = undefined; }
        globalRedrawCallback(source);
    }
    function addAllowedHTMLToPrompt(text) {
        var result;
        try {
            result = sanitizeHTML.generateSanitizedHTMLForMithril(text);
            return result;
        }
        catch (error) {
            alert(error);
            return text;
        }
    }
    // Builder is used by main application, and is passed in for compatibility
    function displayQuestion(builder, model, fieldSpecification, storyForm) {
        function buildQuestionLabel(fieldSpecification, storyForm) {
            var displayPrompt = tr(fieldSpecification.displayPrompt);
            if (fieldSpecification.displayType === "checkboxes" && fieldSpecification.displayConfiguration) {
                if (storyForm.maxNumAnswersPrompt) {
                    displayPrompt += " " + tr(storyForm.maxNumAnswersPrompt).replace("#", fieldSpecification.displayConfiguration);
                }
                else {
                    displayPrompt += " " + tr(exports.defaultFormTexts.maxNumAnswersPrompt).replace("#", fieldSpecification.displayConfiguration);
                }
            }
            return [
                // TODO: Generalize this css class name
                m("span", { "class": "narrafirma-survey-prompt" }, addAllowedHTMLToPrompt(displayPrompt)),
                m("br")
            ];
        }
        var fieldID = fieldSpecification.id;
        if (model) {
            fieldID = (model.storyID || model.participantID) + "__" + fieldID;
        }
        var questionLabel = buildQuestionLabel(fieldSpecification, storyForm);
        var parts = [];
        var value = null;
        if (model)
            value = model[fieldSpecification.id];
        if (value === undefined)
            value = "";
        function tr(text) {
            return translate(storyForm, currentLanguage, text);
        }
        function standardChangeMethod(event, value) {
            if (event)
                value = event.target.value;
            model[fieldSpecification.id] = value;
            // TODO: redraw on value change seems not needed in this survey case, since values do not affect anything about rest of application?
            // redraw();
            // Except for one case. Could there be more?
            if (fieldSpecification.id === "storyName")
                globalRedraw();
            // yes, there is one more case - the slider needs to interact with the "Does not apply" checkbox
            if (fieldSpecification.displayType === "slider")
                globalRedraw();
        }
        var standardValueOptions = {
            value: value,
            id: getIdForText(fieldID),
            onchange: standardChangeMethod
        };
        //////////////////////////////////////////////////////////////// text, textarea ////////////////////////////////////////////////////////////////
        function displayTextOrTextAreaQuestion(type) {
            questionLabel[0].attrs["for"] = getIdForText(fieldID);
            questionLabel[0].tag = "label";
            if (type === "input") {
                var lengthAsNumber = Number(fieldSpecification.displayConfiguration);
                if (!isNaN(lengthAsNumber)) {
                    if (window.innerWidth < 500) {
                        lengthAsNumber = Math.min(98, lengthAsNumber * 4);
                    }
                    else if (window.innerWidth < 700) {
                        lengthAsNumber = Math.min(98, lengthAsNumber * 3);
                    }
                    else if (window.innerWidth < 900) {
                        lengthAsNumber = Math.min(98, lengthAsNumber * 2);
                    }
                    var valueOptionsWithWidth = {
                        value: value,
                        style: "width: " + lengthAsNumber + "%",
                        id: getIdForText(fieldID),
                        onchange: standardChangeMethod,
                    };
                    return [m(type, valueOptionsWithWidth), m("br")];
                }
                else {
                    return [m(type, standardValueOptions), m("br")];
                }
            }
            else {
                return [m(type, standardValueOptions), m("br")];
            }
        }
        //////////////////////////////////////////////////////////////// one checkbox ////////////////////////////////////////////////////////////////
        function displayCheckBoxQuestion() {
            questionLabel[0].attrs["for"] = getIdForText(fieldID);
            questionLabel[0].tag = "label";
            return [
                m("input[type=checkbox]", {
                    id: getIdForText(fieldID),
                    checked: value,
                    onchange: function (event) { standardChangeMethod(null, event.target.checked); }
                }),
                m("label", { "for": getIdForText(fieldID) }, tr(fieldSpecification.displayConfiguration || "")),
                m("br")
            ];
        }
        //////////////////////////////////////////////////////////////// set of checkboxes ////////////////////////////////////////////////////////////////
        function displayCheckboxesQuestion() {
            function disableUncheckedBoxesIfReachedMaxNumAnswers(checkBoxIDs) {
                var numOptionsChecked = 0;
                checkBoxIDs.map(function (anOptionID, index) {
                    if (document.querySelector('#' + anOptionID + ':checked'))
                        numOptionsChecked++;
                });
                var maxAsNumber = Number(fieldSpecification.displayConfiguration);
                if (isNaN(maxAsNumber))
                    maxAsNumber = null;
                var disableUncheckedBoxes = (maxAsNumber && numOptionsChecked >= maxAsNumber);
                checkBoxIDs.map(function (anOptionID, index) {
                    var element = document.querySelector('#' + anOptionID);
                    if (element && !element.checked) {
                        element.disabled = disableUncheckedBoxes;
                        var label = document.querySelector('label[for="' + anOptionID + '"]');
                        if (label)
                            label.setAttribute("style", "opacity: " + (disableUncheckedBoxes ? "0.5" : "1.0"));
                    }
                });
            }
            delete questionLabel[0].attrs["for"];
            if (!value) {
                value = {};
                model[fieldSpecification.id] = value;
            }
            if (!fieldSpecification.valueOptions || fieldSpecification.valueOptions.length < 1) {
                return [m("p", "Survey error: No options were created for this question.")];
            }
            var checkBoxIDsForThisQuestion = [];
            if (fieldSpecification.displayConfiguration) {
                fieldSpecification.valueOptions.map(function (option, index) {
                    var optionID = getIdForText(fieldID + "_" + option);
                    checkBoxIDsForThisQuestion.push(optionID);
                });
            }
            var questionParts = [
                fieldSpecification.valueOptions.map(function (option, index) {
                    var optionName = (typeof option === "string") ? option : option.name;
                    var optionValue = (typeof option === "string") ? option : option.value;
                    var optionID = getIdForText(fieldID + "_" + option);
                    var checkboxPart = m("input[type=checkbox]", {
                        id: optionID,
                        checked: !!value[optionValue],
                        onchange: function (event) {
                            value[optionValue] = event.target.checked;
                            standardChangeMethod(null, value);
                            if (fieldSpecification.displayConfiguration) {
                                disableUncheckedBoxesIfReachedMaxNumAnswers(checkBoxIDsForThisQuestion);
                            }
                        }
                    });
                    var optionParts = [];
                    if (fieldSpecification.optionImageLinks && index < fieldSpecification.optionImageLinks.length) {
                        var imageHTML = "";
                        imageHTML = "img[src='" + fieldSpecification.optionImageLinks[index] + "'][class='narrafirma-survey-answer-image']";
                        if (fieldSpecification.optionImagesWidth)
                            imageHTML += '[style="width: ' + fieldSpecification.optionImagesWidth + 'px"]';
                        optionParts = [m("td.narrafirma-survey-answer-images", [
                                checkboxPart,
                                m("label", { "for": optionID }, sanitizeHTML.generateSmallerSetOfSanitizedHTMLForMithril(tr(optionName)), m("br"), m(imageHTML), m("br"))
                            ])
                        ];
                    }
                    else {
                        optionParts = [
                            checkboxPart,
                            m("label", { "for": optionID }, sanitizeHTML.generateSmallerSetOfSanitizedHTMLForMithril(tr(optionName))), m("br")
                        ];
                    }
                    return optionParts;
                })
            ];
            if (fieldSpecification.optionImageLinks) {
                questionParts = [m("table.narrafirma-survey-answer-images", m("tr.narrafirma-survey-answer-images", questionParts))];
            }
            questionParts.unshift(m("legend", questionLabel[0]));
            questionLabel = [];
            return questionParts;
        }
        //////////////////////////////////////////////////////////////// radio buttons ////////////////////////////////////////////////////////////////
        function displayRadioButtonsQuestion() {
            delete questionLabel[0].attrs["for"];
            var questionParts = [];
            questionParts = [
                fieldSpecification.valueOptions.map(function (option, index) {
                    var optionName = (typeof option === "string") ? option : option.name;
                    var optionValue = (typeof option === "string") ? option : option.value;
                    var optionID = getIdForText(fieldID + "_" + optionValue);
                    var optionParts = [];
                    if (fieldSpecification.optionImageLinks && index < fieldSpecification.optionImageLinks.length) {
                        var imageHTML = "";
                        imageHTML = "img[src='" + fieldSpecification.optionImageLinks[index] + "'][class='narrafirma-survey-answer-image']";
                        if (fieldSpecification.optionImagesWidth)
                            imageHTML += '[style="width: ' + fieldSpecification.optionImagesWidth + 'px"]';
                        optionParts = [m("td.narrafirma-survey-answer-images", [
                                m("input[type=radio]", {
                                    id: optionID,
                                    key: optionID,
                                    value: optionValue,
                                    name: fieldID,
                                    checked: value === optionValue,
                                    onchange: function (event) { standardChangeMethod(null, optionValue); }
                                }),
                                m("label", { "for": optionID }, sanitizeHTML.generateSmallerSetOfSanitizedHTMLForMithril(tr(optionName)), m("br"), m(imageHTML), m("br"))
                            ])
                        ];
                    }
                    else {
                        optionParts = [
                            m("input[type=radio]", {
                                id: optionID,
                                key: optionID,
                                value: optionValue,
                                name: fieldID,
                                checked: value === optionValue,
                                onchange: function (event) { standardChangeMethod(null, optionValue); }
                            }),
                            m("label", { "for": optionID }, sanitizeHTML.generateSmallerSetOfSanitizedHTMLForMithril(tr(optionName))), m("br")
                        ];
                    }
                    return optionParts;
                })
            ];
            if (fieldSpecification.optionImageLinks) {
                questionParts = [m("table.narrafirma-survey-answer-images", m("tr.narrafirma-survey-answer-images", questionParts))];
            }
            questionParts.unshift(m("legend", questionLabel[0]));
            questionLabel = [];
            return questionParts;
        }
        //////////////////////////////////////////////////////////////// boolean ////////////////////////////////////////////////////////////////
        function displayBooleanQuestion() {
            delete questionLabel[0].attrs["for"];
            var yesName = "yes";
            var noName = "no";
            var yesNoParts = tr(storyForm.booleanYesNoNames || exports.defaultFormTexts.booleanYesNoNames).split("/");
            if (yesNoParts.length > 0)
                yesName = yesNoParts[0];
            if (yesNoParts.length > 1)
                noName = yesNoParts[1];
            var questionParts = [
                m("input[type=radio]", {
                    id: getIdForText(fieldID + "_yes"),
                    value: true,
                    name: fieldID,
                    checked: value === true,
                    onchange: standardChangeMethod.bind(null, null, true)
                }),
                m("label", { "for": getIdForText(fieldID + "_yes") }, yesName),
                m("br"),
                m("input[type=radio]", {
                    id: getIdForText(fieldID + "_no"),
                    value: false,
                    name: fieldID,
                    checked: value === false,
                    onchange: standardChangeMethod.bind(null, null, false)
                }),
                m("label", { "for": getIdForText(fieldID + "_no") }, noName),
                m("br")
            ];
            questionParts.unshift(m("legend", questionLabel[0]));
            questionLabel = [];
            return questionParts;
        }
        //////////////////////////////////////////////////////////////// select ////////////////////////////////////////////////////////////////
        function displaySelectQuestion() {
            questionLabel[0].attrs["for"] = getIdForText(fieldID);
            questionLabel[0].tag = "label";
            var selectOptions = [];
            var defaultOptions = { name: '', value: '', selected: undefined };
            if (!value)
                defaultOptions.selected = 'selected';
            if (!fieldSpecification.displayConfiguration) {
                selectOptions.push(m("option", defaultOptions, tr(storyForm.selectNoChoiceName || exports.defaultFormTexts.selectNoChoiceName)));
            }
            selectOptions = selectOptions.concat(fieldSpecification.valueOptions.map(function (option, index) {
                var optionName = (typeof option === "string") ? option : option.name;
                var optionValue = (typeof option === "string") ? option : option.value;
                var optionOptions = { value: optionValue, selected: undefined };
                if (optionValue === value)
                    optionOptions.selected = 'selected';
                return m("option", optionOptions, tr(optionName));
            }));
            var sizeAsNumber = Number(fieldSpecification.displayConfiguration);
            if (!isNaN(sizeAsNumber))
                standardValueOptions["size"] = sizeAsNumber;
            var questionParts = [
                m("select", standardValueOptions, selectOptions),
                m("br")
            ];
            return questionParts;
        }
        //////////////////////////////////////////////////////////////// slider ////////////////////////////////////////////////////////////////
        function displaySliderQuestion() {
            function setSliderValueWithPopup(event, valuePrompt, value, sliderValueOptions, fieldSpecification, model) {
                var newValueText = prompt(valuePrompt, value);
                var newValue = parseInt(newValueText);
                if (newValue && newValue >= 0 && newValue <= 100) {
                    sliderValueOptions.value = newValue;
                    model[fieldSpecification.id] = "" + newValue;
                    globalRedraw();
                }
            }
            function isEmpty(value) {
                return value === undefined || value === null || value === "";
            }
            questionLabel[0].attrs["for"] = getIdForText(fieldID);
            questionLabel[0].tag = "label";
            var checkboxID = getIdForText(fieldID) + "_doesNotApply";
            var popupPrompt = tr(storyForm.sliderValuePrompt || exports.defaultFormTexts.sliderValuePrompt);
            var doesNotApplyTranslatedText = tr(storyForm.sliderDoesNotApply || exports.defaultFormTexts.sliderDoesNotApply);
            var leftSideText = "";
            var rightSideText = "";
            if (fieldSpecification.displayConfiguration) {
                if (fieldSpecification.displayConfiguration.length > 1) {
                    leftSideText = fieldSpecification.displayConfiguration[0];
                    rightSideText = fieldSpecification.displayConfiguration[1];
                }
                // fieldSpecification.displayConfiguration[2] can exist but be undefined
                if (fieldSpecification.displayConfiguration.length > 2 && fieldSpecification.displayConfiguration[2]) {
                    doesNotApplyTranslatedText = tr(fieldSpecification.displayConfiguration[2]);
                }
            }
            // Could suggest 0-100 to support <IE10 that don't have range input -- or could do polyfill
            // if (fieldSpecification.displayPrompt) questionLabel[0].children = fieldSpecification.displayPrompt + " (0-100)";
            var sliderValueOptions = { value: value, id: getIdForText(fieldID), onchange: standardChangeMethod, min: 0, max: 100, step: 1 };
            var questionParts = [
                m("span", { "class": "narrafirma-survey-low-arrow" }, "◀ "),
                m("span", { "class": "narrafirma-survey-low" }, tr(leftSideText)),
                m('span', { "class": "narrafirma-survey-slider" }, m('input[type="range"]', sliderValueOptions)),
                m('span', { "class": "narrafirma-survey-high" }, tr(rightSideText)),
                m('span', { "class": "narrafirma-survey-high-arrow" }, " ▶"),
                m("span", { "class": "narrafirma-survey-value", "tabindex": "0",
                    onclick: function (event) { setSliderValueWithPopup(event, popupPrompt, value, sliderValueOptions, fieldSpecification, model); },
                    onkeypress: function (event) { if (event.keyCode == 13)
                        setSliderValueWithPopup(event, popupPrompt, value, sliderValueOptions, fieldSpecification, model); }
                }, value),
                m("br"),
                m('input[type="checkbox"]', {
                    "class": "narrafirma-survey-does-not-apply",
                    id: checkboxID,
                    checked: isEmpty(sliderValueOptions.value),
                    onclick: function (event) {
                        var isChecked = event.target.checked;
                        if (isChecked) {
                            model[fieldSpecification.id] = "";
                            globalRedraw();
                        }
                        else {
                            model[fieldSpecification.id] = "50";
                            globalRedraw();
                        }
                    }
                }),
                m("label", { "for": checkboxID }, doesNotApplyTranslatedText)
            ];
            return questionParts;
        }
        ///////////////////////////////////////////////////////////////////// write-in (extra) text box ///////////////////////////////////////////////////////////
        function displayWriteInQuestion() {
            if (!model.hasOwnProperty("writeInTexts"))
                model["writeInTexts"] = {};
            var label = tr(fieldSpecification.writeInTextBoxLabel);
            var mString = "input[type=text].narrafirma-survey-write-in-input";
            if (label.indexOf("**") == 0) {
                mString = "textarea.narrafirma-survey-write-in-textarea";
                label = label.replace("**", "");
            }
            var writeInDivParts = [
                m("span.narrafirma-survey-write-in-prompt"), addAllowedHTMLToPrompt(tr(label)),
                m(mString, {
                    id: getIdForText(fieldID + "_writeIn"),
                    value: model[writeInTag + fieldSpecification.id] || "",
                    onchange: function (event) {
                        if (event && event.target.value) {
                            model[writeInTag + fieldSpecification.id] = event.target.value;
                        }
                    }
                }),
                m("br")
            ];
            return m("div.narrafirma-survey-write-in-div", writeInDivParts);
        }
        ///////////////////////////////////////////////////////////////////// now call the methods ///////////////////////////////////////////////////////////////
        if (fieldSpecification.displayType === "label") {
            // Nothing to do
        }
        else if (fieldSpecification.displayType === "header") {
            // Nothing to do; bolding done using style
        }
        else if (fieldSpecification.displayType === "text") {
            parts = displayTextOrTextAreaQuestion("input");
        }
        else if (fieldSpecification.displayType === "textarea") {
            parts = displayTextOrTextAreaQuestion("textarea");
        }
        else if (fieldSpecification.displayType === "checkbox") {
            parts = displayCheckBoxQuestion();
        }
        else if (fieldSpecification.displayType === "checkboxes") {
            parts = [m("fieldset", displayCheckboxesQuestion())];
        }
        else if (fieldSpecification.displayType === "radiobuttons") {
            parts = [m("fieldset", displayRadioButtonsQuestion())];
        }
        else if (fieldSpecification.displayType === "boolean") {
            parts = [m("fieldset", displayBooleanQuestion())];
        }
        else if (fieldSpecification.displayType === "select") {
            parts = displaySelectQuestion();
        }
        else if (fieldSpecification.displayType === "slider") {
            parts = displaySliderQuestion();
        }
        else {
            parts = [
                m("span", { style: { "font-weight": "bold" } }, "UNFINISHED: " + fieldSpecification.displayType),
                m("br")
            ];
        }
        if (fieldSpecification.writeInTextBoxLabel) {
            parts.push(displayWriteInQuestion());
        }
        if (parts.length) {
            parts = m("div", { "class": "narrafirma-survey-question-internal" }, parts);
        }
        if (questionLabel) {
            parts = questionLabel.concat(parts);
        }
        var classString = "narrafirma-survey-question-external narrafirma-survey-question-type-" + fieldSpecification.displayType;
        if (fieldSpecification.displayClass) {
            classString += " " + fieldSpecification.displayClass;
        }
        return m("div", { key: fieldID, "class": classString }, parts);
    }
    function buildSurveyForm(surveyDiv, storyForm, doneCallback, surveyOptions) {
        if (surveyOptions === void 0) { surveyOptions = {}; }
        function tr(text) {
            return translate(storyForm, currentLanguage, text);
        }
        // console.log("buildSurveyForm questions", storyForm);
        var startQuestions = [];
        if (surveyOptions.previewMode) {
            startQuestions.push({ id: "previewMode_header", displayName: "previewMode", displayClass: "narrafirma-preview", displayPrompt: "Previewing story form; results will not be saved.", displayType: "header", valueOptions: [] });
        }
        if (storyForm.title) {
            startQuestions.push({ id: "title_header", displayName: "title", displayPrompt: tr(storyForm.title), displayType: "header", valueOptions: [], displayClass: "narrafirma-survey-title" });
            if (!surveyOptions.ignoreTitleChange)
                document.title = sanitizeHTML.removeHTMLTags(tr(storyForm.title));
        }
        var startText = tr(storyForm.startText || exports.defaultFormTexts.startText);
        startQuestions.push({ id: "startText_label", displayName: "startText", displayPrompt: startText, displayType: "label", valueOptions: [], displayClass: "narrafirma-survey-start-text" });
        var endText = tr(storyForm.endText || exports.defaultFormTexts.endText);
        var endQuestions = [];
        endQuestions.push({ id: "endText_label", displayName: "endText", displayPrompt: endText, displayType: "label", valueOptions: [], displayClass: "narrafirma-survey-end-text" });
        // TODO: What about idea of having IDs that go with eliciting questions so store reference to ID not text prompt?
        var elicitingQuestionOptions = [];
        for (var elicitingQuestionIndex in storyForm.elicitingQuestions) {
            var elicitingQuestionSpecification = storyForm.elicitingQuestions[elicitingQuestionIndex];
            var value = elicitingQuestionSpecification.id || elicitingQuestionSpecification.text;
            var option = { name: tr(elicitingQuestionSpecification.text), value: value };
            elicitingQuestionOptions.push(option);
        }
        // TODO: What if these IDs for storyText and storyName are not unique?
        var initialStoryQuestions = [];
        var singlePrompt = null;
        if (elicitingQuestionOptions.length !== 1) {
            var chooseQuestionText = tr(storyForm.chooseQuestionText || exports.defaultFormTexts.chooseQuestionText);
            initialStoryQuestions.push({ id: "elicitingQuestion", displayName: "elicitingQuestion", displayPrompt: chooseQuestionText, displayType: "radiobuttons", valueOptions: elicitingQuestionOptions, displayClass: "narrafirma-eliciting-questions" });
            var enterStoryText = tr(storyForm.enterStoryText || exports.defaultFormTexts.enterStoryText);
            initialStoryQuestions.push({ id: "storyText", displayName: "storyText", displayPrompt: enterStoryText, displayType: "textarea", valueOptions: [], displayClass: "narrafirma-story-text" });
        }
        else {
            singlePrompt = elicitingQuestionOptions[0];
            initialStoryQuestions.push({ id: "storyText", displayName: "storyText", displayPrompt: tr(singlePrompt.name), displayType: "textarea", valueOptions: [], displayClass: "narrafirma-story-text" });
        }
        var nameStoryText = tr(storyForm.nameStoryText || exports.defaultFormTexts.nameStoryText);
        initialStoryQuestions.push({ id: "storyName", displayName: "storyName", displayPrompt: nameStoryText, displayType: "text", valueOptions: [], displayConfiguration: "40", displayClass: "narrafirma-story-name" });
        var allStoryQuestions = initialStoryQuestions.concat(storyForm.storyQuestions);
        var aboutYouText = tr(storyForm.aboutYouText || exports.defaultFormTexts.aboutYouText);
        var participantQuestions = [];
        if (storyForm.participantQuestions.length > 0) {
            participantQuestions = [{ id: "participantHeader", displayName: "participantHeader", displayPrompt: aboutYouText, displayType: "header", valueOptions: [], displayClass: "narrafirma-participant-header" }];
            participantQuestions = participantQuestions.concat(storyForm.participantQuestions);
        }
        var timestampStart = new Date();
        var surveyResult = {
            __type: "org.workingwithstories.storyFormResponse",
            // TODO: Think about whether to include entire storyForm or something else perhaps
            questionnaire: storyForm,
            responseID: generateRandomUuid("storyFormResponse"),
            stories: [],
            language: currentLanguage,
            participantData: null,
            timestampStart: "" + timestampStart.toISOString()
        };
        var participantID = generateRandomUuid("Participant");
        var participantDataModel = {
            __type: "org.workingwithstories.ParticipantData",
            participantID: participantID
        };
        surveyResult.participantData = participantDataModel;
        // m.render(surveyDiv, m("div", ["Hello survey ============== b", "More!!"]));
        var stories = surveyResult.stories;
        function addStory() {
            var storyQuestionsModel = {
                __type: "org.workingwithstories.Story",
                storyID: generateRandomUuid("Story"),
                participantID: participantID,
                elicitingQuestion: undefined
            };
            if (singlePrompt)
                storyQuestionsModel.elicitingQuestion = singlePrompt.value;
            stories.push(storyQuestionsModel);
        }
        addStory();
        function makeLabelForStory(story, index) {
            var storyLabel = story.storyName;
            if (storyLabel)
                storyLabel = storyLabel.trim();
            if (!storyLabel) {
                storyLabel = 'Untitled story #' + (index + 1);
            }
            else {
                storyLabel = '"' + storyLabel + '"';
            }
            return storyLabel;
        }
        // submitted can be one of: "never", "pending", "failed", "success"
        var submitted = "never";
        function submitSurvey(surveyResult, wizardPane, doneCallback) {
            console.log("submitting survey...");
            var timestampEnd = new Date();
            surveyResult.timestampEnd = timestampEnd.toISOString();
            surveyResult.timeDuration_ms = timestampEnd.getTime() - timestampStart.getTime();
            console.log("survey answers", surveyResult);
            doneCallback("submitted", surveyResult, wizardPane);
        }
        function validateStoryQuestionsModel(storyQuestionsModel, index) {
            var elicitingQuestion = storyQuestionsModel.elicitingQuestion;
            var storyName = storyQuestionsModel.storyName;
            var storyText = storyQuestionsModel.storyText;
            if (!elicitingQuestion) {
                var prompt_1 = tr(storyForm.errorMessage_noElicitationQuestionChosen || exports.defaultFormTexts.errorMessage_noElicitationQuestionChosen);
                prompt_1 = prompt_1.replace("#", index + 1);
                alert(prompt_1);
                return false;
            }
            if (!storyText) {
                var prompt_2 = tr(storyForm.errorMessage_noStoryText || exports.defaultFormTexts.errorMessage_noStoryText);
                prompt_2 = prompt_2.replace("#", index + 1);
                alert(prompt_2);
                return false;
            }
            if (!storyName) {
                var prompt_3 = tr(storyForm.errorMessage_noStoryName || exports.defaultFormTexts.errorMessage_noStoryName);
                prompt_3 = prompt_3.replace("#", index + 1);
                alert(prompt_3);
                return false;
            }
            return true;
        }
        function displayStoryQuestions(story, index) {
            var storylabel = makeLabelForStory(story, index);
            var storyQuestionsPart = allStoryQuestions.map(function (question, index) {
                return displayQuestion(null, story, question, storyForm);
            });
            var deleteStoryButtonText = tr(storyForm.deleteStoryButtonText || exports.defaultFormTexts.deleteStoryButtonText);
            var deleteStoryPrompt = tr(storyForm.deleteStoryDialogPrompt || exports.defaultFormTexts.deleteStoryDialogPrompt);
            var result = [
                m("button", {
                    "class": "narrafirma-survey-delete-story-button",
                    onclick: function () {
                        if (!confirm(deleteStoryPrompt + " (" + storylabel + ")"))
                            return;
                        stories.splice(index, 1);
                        redraw();
                    }
                }, deleteStoryButtonText),
                m("hr"),
                storyQuestionsPart
            ];
            // invert even and odd to match up with numbers starting at 1, not zero
            var evenOrOdd = (index % 2 === 1) ? "narrafirma-survey-story-even" : "narrafirma-survey-story-odd";
            // A locally unique key needs to be defined so Mithril can track deletions and inserts without rebuilding DOM nodes
            return m("div", { key: story.storyID, id: story.storyID, "class": "narrafirma-survey-story " + evenOrOdd }, result);
        }
        function validate() {
            // TODO: Improve validation
            if (!stories.length) {
                alert("Please add at least one story before proceeding."); // this is never used?
                return false;
            }
            for (var i = 0; i < stories.length; i++) {
                if (!validateStoryQuestionsModel(stories[i], i))
                    return false;
            }
            return true;
        }
        function calculateDerivedFields() {
            stories.forEach(function (story) {
                story.numStoriesTold = "" + stories.length;
            });
        }
        function submitButtonPressed() {
            if (!validate())
                return;
            calculateDerivedFields();
            console.log("Submit survey validated");
            // TODO: Fix no-longer-correct name from Dojo version
            var wizardPane = {
                forward: function () {
                    console.log("survey sending success" + (surveyOptions.previewMode ? " (preview)" : ""));
                    submitted = "success";
                    var thankYouPopupText = tr(storyForm.thankYouPopupText || exports.defaultFormTexts.thankYouPopupText);
                    alert(thankYouPopupText);
                    redraw("network");
                },
                failed: function () {
                    console.log("survey sending failed");
                    submitted = "failed";
                    // TODO: Translate
                    alert("Problem saving survey result; check the console for details.\nPlease try to submit the survey result later.");
                    redraw("network");
                }
            };
            submitted = "pending";
            submitSurvey(surveyResult, wizardPane, doneCallback);
            redraw();
        }
        function submitButtonOrWaitOrFinal() {
            var submitSurveyButtonText = tr(storyForm.submitSurveyButtonText || exports.defaultFormTexts.submitSurveyButtonText);
            var couldNotSaveSurveyText = tr(storyForm.couldNotSaveSurveyText || exports.defaultFormTexts.couldNotSaveSurveyText);
            var sendingSurveyResultsText = tr(storyForm.sendingSurveyResultsText || exports.defaultFormTexts.sendingSurveyResultsText);
            if (submitted === "never") {
                return m("button", { "class": "narrafirma-survey-submit-survey-button", onclick: submitButtonPressed }, submitSurveyButtonText + (surveyOptions.previewMode ? " (preview)" : ""));
            }
            else if (submitted === "failed") {
                var resubmitSurveyButtonText = tr(storyForm.resubmitSurveyButtonText || exports.defaultFormTexts.resubmitSurveyButtonText);
                return m("div.narrafirma-could-not-save-survey", [
                    couldNotSaveSurveyText,
                    m("br"),
                    m("button", { "class": "narrafirma-survey-submit-survey-button", onclick: submitButtonPressed }, resubmitSurveyButtonText + (surveyOptions.previewMode ? " (preview)" : ""))
                ]);
            }
            else if (submitted === "pending") {
                return m("div.narrafirma-sending-survey", m("br"), [sendingSurveyResultsText]);
            }
            else {
                var surveyStoredText_1 = tr(storyForm.surveyStoredText || exports.defaultFormTexts.surveyStoredText);
                return endQuestions.map(function (question, index) {
                    return m("div", [
                        m("br"),
                        m("div.narrafirma-survey-accepted", [surveyStoredText_1,
                            m("br"),
                            displayQuestion(null, null, question, storyForm),
                            m("br")
                        ])
                    ]);
                });
            }
        }
        function questionNameForResultsPane(question) {
            var questionName = "";
            if (question.displayType !== "header" && question.displayType !== "label") {
                questionName = "* " + tr(question.displayPrompt);
            }
            if (question.displayType === "slider") {
                if (question.displayConfiguration) {
                    if (question.displayConfiguration.length > 1) {
                        questionName += " (0 = " + tr(question.displayConfiguration[0]) + "; 100 = " + tr(question.displayConfiguration[1]) + ")";
                    }
                }
                else if (question.valueOptions) {
                    if (question.valueOptions.length > 1) {
                        questionName += " (0 = " + tr(question.valueOptions[0]) + "; 100 = " + tr(question.valueOptions[1]) + ")";
                    }
                }
            }
            return questionName;
        }
        function surveyResultPane() {
            var parts = [];
            stories.forEach(function (story) {
                allStoryQuestions.forEach(function (question) {
                    var questionName = tr(questionNameForResultsPane(question));
                    if (questionName)
                        parts.push(questionName);
                    if (question.id in story) {
                        var response = story[question.id];
                        if (typeof response == "object") {
                            var answers = Object.keys(response);
                            for (var _i = 0, answers_1 = answers; _i < answers_1.length; _i++) {
                                var answer = answers_1[_i];
                                if (response[answer])
                                    parts.push(tr(answer));
                            }
                        }
                        else {
                            parts.push(response);
                        }
                    }
                    if (writeInTag + question.id in story) {
                        var writeinValue = story[writeInTag + question.id];
                        parts.push(writeinValue);
                    }
                });
                parts.push("");
            });
            participantQuestions.forEach(function (question) {
                var questionName = tr(questionNameForResultsPane(question));
                if (questionName)
                    parts.push(questionName);
                if (question.id in surveyResult.participantData) {
                    var response = surveyResult.participantData[question.id];
                    if (typeof response == "object") {
                        var answers = Object.keys(response);
                        for (var _i = 0, answers_2 = answers; _i < answers_2.length; _i++) {
                            var answer = answers_2[_i];
                            if (response[answer])
                                parts.push(tr(answer));
                        }
                    }
                    else {
                        parts.push(response);
                    }
                }
                if (writeInTag + question.id in surveyResult.participantData) {
                    var writeinValue = surveyResult.participantData[writeInTag + question.id];
                    parts.push(writeinValue);
                }
            });
            var surveyResultPaneHeader = tr(storyForm.surveyResultPaneHeader || exports.defaultFormTexts.surveyResultPaneHeader);
            return [m("div", { "class": "narrafirma-survey-result-summary-header" }, surveyResultPaneHeader),
                m("textarea", { "class": "narrafirma-survey-result-summary" }, parts.join("\n"))];
        }
        function tellAnotherStory() {
            addStory();
            redraw();
        }
        var tagsToMakeReadOnly = {
            "input": true,
            "select": true,
            "textarea": true,
            "button": true
        };
        // Make survey read-only after sent to server
        // Recursive function derived from: http://lhorie.github.io/mithril-blog/when-css-lets-you-down.html
        function makeReadOnly(root, parent) {
            if (!root) {
                return root;
            }
            if (root instanceof Array) {
                for (var i = 0; i < root.length; i++) {
                    makeReadOnly(root[i], parent);
                }
                return;
            }
            if (root.children) {
                makeReadOnly(root.children, root);
            }
            if (typeof root === "object" && root.tag in tagsToMakeReadOnly) {
                if (root.tag === "textarea" || (root.tag === "input" && !root.attrs.type)) {
                    // Ensure text fields still have copy available
                    root.attrs.readOnly = true;
                }
                else {
                    root.attrs.disabled = true;
                }
            }
            return root;
        }
        var view = function () {
            function anotherStoryButton(storyForm) {
                var tellAnotherStoryText = tr(storyForm.tellAnotherStoryText || exports.defaultFormTexts.tellAnotherStoryText);
                var tellAnotherStoryButtonText = tr(storyForm.tellAnotherStoryButtonText || exports.defaultFormTexts.tellAnotherStoryButtonText);
                return m("div", { "class": "narrafirma-survey-tell-another-story-button-panel" }, [
                    tellAnotherStoryText,
                    m("button", { "class": "narrafirma-survey-tell-another-story-button", onclick: tellAnotherStory }, tellAnotherStoryButtonText)
                ]);
            }
            function chooseLanguageHTML() {
                if (!storyForm.defaultLanguage)
                    return "";
                if (!storyForm.languageChoiceQuestion_text)
                    return "";
                if (!storyForm.languageChoiceQuestion_choices)
                    return "";
                var languageChoiceQuestionText = sanitizeHTML.removeHTMLTags(storyForm.languageChoiceQuestion_text);
                var languageNames = [];
                var nonDefaultLanguages = storyForm.languageChoiceQuestion_choices.split("\n").map(function (item) { return item.trim(); });
                languageNames = languageNames.concat([storyForm.defaultLanguage], nonDefaultLanguages);
                var selectOptions = languageNames.map(function (aLanguage) { return m("option", { value: aLanguage, selected: aLanguage === currentLanguage }, aLanguage); });
                var defaultOptions = { name: '', value: '', selected: undefined };
                if (!currentLanguage)
                    defaultOptions.selected = 'selected';
                selectOptions.push(m("option", defaultOptions, tr(storyForm.selectNoChoiceName || exports.defaultFormTexts.selectNoChoiceName)));
                var questionParts = [
                    m("div.narrafirma-language-choice-question-text", languageChoiceQuestionText),
                    m("select", {
                        value: currentLanguage,
                        id: "languageChoiceQuestion",
                        onchange: function (event) {
                            if (event.target.value !== currentLanguage) {
                                currentLanguage = event.target.value;
                                globalRedraw();
                            }
                        }
                    }, selectOptions),
                    m("br")
                ];
                return questionParts;
            }
            var imageHTML = storyForm.image ? "img[src='" + tr(storyForm.image) + "'][class='narrafirma-survey-image']" : "";
            var videoPart = mithrilForVideoInfo(tr(storyForm.video));
            var showSurveyResultPane = false;
            if (submitted === "success") {
                switch (storyForm.showSurveyResultPane) {
                    case "never":
                        showSurveyResultPane = false;
                        break;
                    case "only on survey":
                        showSurveyResultPane = !surveyOptions.dataEntry;
                        break;
                    case "only on data entry":
                        showSurveyResultPane = surveyOptions.dataEntry;
                        break;
                    case "always":
                        showSurveyResultPane = true;
                        break;
                }
            }
            var languageHTML = chooseLanguageHTML();
            var result = m("div", [
                languageHTML,
                m(imageHTML || ""),
                startQuestions.map(function (question, index) {
                    return displayQuestion(null, null, question, storyForm);
                }),
                videoPart,
                m("div.narrafirma-survey-text-after-introductory-video", storyForm.textAfterVideo || ""),
                m("div.narrafirma-survey-stories", stories.map(function (story, index) {
                    return m("div.narrafirma-survey-story-question-set", { key: index }, displayStoryQuestions(story, index));
                })),
                (!storyForm.maxNumStories || storyForm.maxNumStories === "no limit" || stories.length < storyForm.maxNumStories) ? anotherStoryButton(storyForm) : "",
                // A locally unique key needs to be defined so Mithril can track deletions and inserts without rebuilding DOM nodes
                m("div", { key: "participant", "class": "narrafirma-survey-participant" }, participantQuestions.map(function (question, index) {
                    return displayQuestion(null, surveyResult.participantData, question, storyForm);
                })),
                submitButtonOrWaitOrFinal(),
                showSurveyResultPane ? surveyResultPane() : ""
                /*
                m("hr"),
                m("button", {
                    onclick: function() {
                        redraw();
                        console.log("stories", stories);
                        console.log("participantData", surveyResult.participantData);
                    }
                }, "Redraw (for debugging)")
                */
            ]);
            if (submitted === "pending" || submitted === "success") {
                makeReadOnly(result, null);
            }
            return result;
        };
        function redraw(source) {
            if (source === void 0) { source = "gui"; }
            if (surveyDiv) {
                m.render(surveyDiv, view());
            }
            else {
                // When the survey form is used in a Dialog, the code will be calling redraw automatically as a mounted component,
                // so only need to call redraw for an asynchronous server response
                if (source === "network")
                    m.redraw();
            }
        }
        setGlobalRedrawFunction(redraw);
        redraw();
        // Return a function that could be called to produce a survey template, like for a dialog
        return view;
    }
    exports.buildSurveyForm = buildSurveyForm;
});

define('js/questionnaireGeneration',["require", "exports", "./Globals", "./surveyBuilderMithril"], function (require, exports, Globals, surveyBuilderMithril) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // setting up info about fields to look up in get/set methods
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    exports.formFieldsInfo = [
        // Starting out
        { tripleStoreFieldID: "questionForm_image",
            exportImportID: "Image",
            canBeTranslated: true,
            section: "Starting out",
            explanation: "Web link for image to show at top of form" },
        { tripleStoreFieldID: "questionForm_title",
            exportImportID: "Title",
            canBeTranslated: true,
            section: "Starting out",
            explanation: "Title shown at top of page" },
        { tripleStoreFieldID: "questionForm_startText",
            exportImportID: "Start text",
            canBeTranslated: true,
            section: "Starting out",
            explanation: "Introduction to story form" },
        { tripleStoreFieldID: "questionForm_video",
            exportImportID: "Video",
            canBeTranslated: true,
            section: "Starting out",
            explanation: "Web link or iframe embed code for introductory video" },
        { tripleStoreFieldID: "questionForm_textAfterVideo",
            exportImportID: "After-video text",
            canBeTranslated: true,
            section: "Starting out",
            explanation: "Text to show after introductory video" },
        // Choosing a story-eliciting question
        { tripleStoreFieldID: "questionForm_chooseQuestionText",
            exportImportID: "Choose question text",
            canBeTranslated: true,
            default: "Please choose a question to which you would like to respond.",
            section: "Choosing a story-eliciting question",
            explanation: "Instructions for choosing eliciting question" },
        { tripleStoreFieldID: "questionForm_errorMessage_noElicitationQuestionChosen",
            exportImportID: "Error message no elicitation question chosen",
            canBeTranslated: true,
            section: "Choosing a story-eliciting question",
            explanation: "Popup message if participant chose no elicitation question" },
        // Writing and naming a story
        { tripleStoreFieldID: "questionForm_enterStoryText",
            exportImportID: "Enter story text",
            canBeTranslated: true,
            section: "Writing and naming a story",
            explanation: "Instruction to write story in text box" },
        { tripleStoreFieldID: "questionForm_errorMessage_noStoryText",
            exportImportID: "Error message no story text",
            canBeTranslated: true,
            section: "Writing and naming a story",
            explanation: "Popup message if participant wrote no story; # is replaced with number of story on page" },
        { tripleStoreFieldID: "questionForm_nameStoryText",
            exportImportID: "Name story text",
            canBeTranslated: true,
            section: "Writing and naming a story",
            explanation: "Instruction to name story" },
        { tripleStoreFieldID: "questionForm_errorMessage_noStoryName",
            exportImportID: "Error message no story name",
            canBeTranslated: true,
            section: "Writing and naming a story",
            explanation: "Popup message if participant did not name story; # is replaced with number of story on page" },
        // Answering questions about the story
        { tripleStoreFieldID: "questionForm_sliderValuePrompt",
            exportImportID: "Slider value prompt",
            canBeTranslated: true,
            section: "Answering questions about the story",
            explanation: "Popup message when participant clicks slider value" },
        { tripleStoreFieldID: "questionForm_sliderDoesNotApply",
            exportImportID: "Slider does-not-apply label",
            canBeTranslated: true,
            section: "Answering questions about the story",
            explanation: 'Label below slider to indicate "does not apply" answer' },
        { tripleStoreFieldID: "questionForm_selectNoChoiceName",
            exportImportID: "Select no-choice name",
            canBeTranslated: true,
            section: "Answering questions about the story",
            explanation: "What a drop-down list says when no selection has been made" },
        { tripleStoreFieldID: "questionForm_booleanYesNoNames",
            exportImportID: "Boolean yes/no names",
            canBeTranslated: true,
            section: "Answering questions about the story",
            explanation: "The yes and no choices on a boolean question, separated by a forward slash (/)" },
        { tripleStoreFieldID: "questionForm_maxNumAnswersPrompt",
            exportImportID: "Max number of answers prompt",
            canBeTranslated: true,
            section: "Answering questions about the story",
            explanation: "Telling participants how many answers they can choose for a limited-answers question" },
        // Telling another story
        { tripleStoreFieldID: "questionForm_tellAnotherStoryText",
            exportImportID: "Tell another story text",
            canBeTranslated: true,
            section: "Telling another story",
            explanation: "Asking participant if they want to tell another story" },
        { tripleStoreFieldID: "questionForm_tellAnotherStoryButtonText",
            exportImportID: "Tell another story button",
            canBeTranslated: true,
            section: "Telling another story",
            explanation: "Text on tell-another-story button" },
        { tripleStoreFieldID: "questionForm_deleteStoryButtonText",
            exportImportID: "Delete story button",
            canBeTranslated: true,
            section: "Telling another story",
            explanation: "Text on delete-this-story button" },
        { tripleStoreFieldID: "questionForm_deleteStoryDialogPrompt",
            exportImportID: "Delete story prompt",
            canBeTranslated: true,
            section: "Telling another story",
            explanation: "Popup message confirming story deletion" },
        // Answering questions about the participant
        { tripleStoreFieldID: "questionForm_aboutYouText",
            exportImportID: "About you text",
            canBeTranslated: true,
            section: "Answering questions about the participant",
            explanation: "Header for questions about participant" },
        // Finishing the form
        { tripleStoreFieldID: "questionForm_endText",
            exportImportID: "End text",
            canBeTranslated: true,
            section: "Finishing the form",
            explanation: "Conclusion at end of story form" },
        { tripleStoreFieldID: "questionForm_thankYouPopupText",
            exportImportID: "Thank you text",
            canBeTranslated: true,
            section: "Finishing the form",
            explanation: "Popup message thanking participant for submitting story" },
        { tripleStoreFieldID: "questionForm_surveyResultPaneHeader",
            exportImportID: "Survey result header",
            canBeTranslated: true,
            section: "Finishing the form",
            explanation: "Header for copy-paste story texts" },
        { tripleStoreFieldID: "questionForm_submitSurveyButtonText",
            exportImportID: "Submit survey button",
            canBeTranslated: true,
            section: "Finishing the form",
            explanation: "Text on submit-story button" },
        { tripleStoreFieldID: "questionForm_sendingSurveyResultsText",
            exportImportID: "Sending survey text",
            canBeTranslated: true,
            section: "Finishing the form",
            explanation: "Message saying survey is being sent to the server" },
        { tripleStoreFieldID: "questionForm_surveyStoredText",
            exportImportID: "Survey stored message",
            canBeTranslated: true,
            section: "Finishing the form",
            explanation: "Message saying survey has been saved" },
        { tripleStoreFieldID: "questionForm_couldNotSaveSurveyText",
            exportImportID: "Could not save survey text",
            canBeTranslated: true,
            section: "Finishing the form",
            explanation: "Message saying survey could not be saved" },
        { tripleStoreFieldID: "questionForm_resubmitSurveyButtonText",
            exportImportID: "Resubmit survey button",
            canBeTranslated: true,
            section: "Finishing the form",
            explanation: "Text on submit-story button after first attempt at sending survey failed" },
        // not translateable
        { tripleStoreFieldID: "questionForm_maxNumStories", exportImportID: "Max num stories", default: "no limit", canBeTranslated: false },
        { tripleStoreFieldID: "questionForm_showSurveyResultPane", exportImportID: "Show survey result", canBeTranslated: false },
        { tripleStoreFieldID: "questionForm_defaultLanguage", exportImportID: "Default language", canBeTranslated: false },
        { tripleStoreFieldID: "questionForm_languageChoiceQuestion_text", exportImportID: "Language choice question", canBeTranslated: false },
        { tripleStoreFieldID: "questionForm_languageChoiceQuestion_choices", exportImportID: "Additional languages", canBeTranslated: false },
        { tripleStoreFieldID: "questionForm_customCSS", exportImportID: "Custom CSS", canBeTranslated: false },
        { tripleStoreFieldID: "questionForm_customCSSForPrint", exportImportID: "Custom CSS for Printing", canBeTranslated: false }
    ];
    var prefixLength = "questionForm_".length;
    exports.formFieldsInfo.forEach(function (field) { field.objectFieldID = field.tripleStoreFieldID.substr(prefixLength); });
    var displayTypeToValueTypeMap = {
        // used in survey only
        image: "none",
        video: "none",
        // Used in survey and in other parts of the application
        boolean: 'boolean',
        label: "none",
        header: "none",
        checkbox: 'boolean',
        checkboxes: 'dictionary',
        text: 'string',
        textarea: 'string',
        select: "string",
        radiobuttons: "string",
        slider: "number",
        // Used only in other parts of the application
        grid: 'array',
        clusteringDiagram: 'object',
        quizScoreResult: "none",
        button: "none",
        report: "none",
        recommendationTable: "none",
        templateList: "none",
        "function": "none",
        storyBrowser: 'none',
        storyAnnotationBrowser: 'none',
        graphBrowser: 'none',
        annotationGraphBrowser: 'none',
        patternExplorer: 'none',
        observationsList: 'none',
        accumulatedItemsGrid: 'none',
        storiesList: 'none'
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // converting from tripleStore format to object format
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function convertEditorQuestions(editorQuestions, prefixQPA) {
        var adjustedQuestions = [];
        var valueOptions;
        var displayConfiguration;
        var _loop_1 = function (questionIndex) {
            var question = editorQuestions[questionIndex];
            // Including "S_" or "P_" or "A_" prefix for user-supplied question ID to prevent collisions with application fields like storyText and JavaScript functions and __proto__
            var prefixToKeyPrefixMap = { "S_": "storyQuestion_", "P_": "participantQuestion_", "A_": "annotationQuestion_" };
            var keyPrefix = prefixToKeyPrefixMap[prefixQPA];
            var shortName = question[keyPrefix + "shortName"];
            var id = prefixQPA + shortName;
            var questionType = question[keyPrefix + "type"];
            var prompt_1 = question[keyPrefix + "text"];
            var writeInTextBoxLabel = question[keyPrefix + "writeInTextBoxLabel"];
            var options = [];
            var optionsString = question[keyPrefix + "options"];
            if (optionsString) {
                // TODO: Improve option handling so can have standard IDs for options
                var splitOptions = optionsString.split("\n");
                options = splitOptions.filter(function (option) { if (option.trim())
                    return option.trim(); });
            }
            var optionImageLinks = [];
            var optionImageLinksString = question[keyPrefix + "optionImageLinks"];
            if (optionImageLinksString) {
                var splitOptionImageLinks = optionImageLinksString.split("\n");
                optionImageLinks = splitOptionImageLinks.filter(function (link) { if (link.trim())
                    return link.trim(); });
            }
            var optionImagesWidth = question[keyPrefix + "optionImagesWidth"];
            var valueType = displayTypeToValueTypeMap[questionType];
            if (!valueType)
                console.log("ERROR: Could not resolve valueType for ", question);
            // default valueOptions and displayConfiguration to undefined so no object fields will appear set for these if not otherwise set
            valueOptions = undefined;
            if (["checkbox", "select", "radiobuttons", "checkboxes"].indexOf(questionType) >= 0) {
                valueOptions = options;
            }
            // use displayConfiguration for configuration options that are specific to the question type
            displayConfiguration = undefined;
            if (questionType === "slider") {
                if (options.length === 1) {
                    displayConfiguration = options[0];
                }
                else if (options.length > 1) {
                    displayConfiguration = options;
                }
            }
            else if (questionType === "checkbox") {
                displayConfiguration = options[0];
            }
            else if (questionType === "text") {
                displayConfiguration = !isNaN(Number(question[keyPrefix + "textBoxLength"])) ? question[keyPrefix + "textBoxLength"] : 40;
            }
            else if (questionType === "select") {
                displayConfiguration = !isNaN(Number(question[keyPrefix + "listBoxRows"])) ? question[keyPrefix + "listBoxRows"] : "";
            }
            else if (questionType === "checkboxes") {
                displayConfiguration = !isNaN(Number(question[keyPrefix + "maxNumAnswers"])) ? question[keyPrefix + "maxNumAnswers"] : "";
            }
            var import_columnName = question[keyPrefix + "import_columnName"] || question[keyPrefix + "shortName"];
            var import_valueType = question[keyPrefix + "import_valueType"];
            var import_minScaleValue = question[keyPrefix + "import_minScaleValue"];
            var import_maxScaleValue = question[keyPrefix + "import_maxScaleValue"];
            var import_writeInTextsAreInSeparateColumn = question[keyPrefix + "import_writeInTextsAreInSeparateColumn"];
            var importOptions = [];
            var importOptionsString = question[keyPrefix + "import_answerNames"];
            if (importOptionsString && typeof importOptionsString === "string") {
                var splitImportOptions = importOptionsString.split("\n");
                splitImportOptions.filter(function (option) { if (option.trim())
                    importOptions.push(option.trim()); });
            }
            else {
                importOptions = question[keyPrefix + "import_answerNames"];
            }
            adjustedQuestions.push({
                id: id,
                valueType: valueType,
                displayName: shortName,
                displayPrompt: prompt_1,
                displayType: questionType,
                valueOptions: valueOptions,
                optionImageLinks: optionImageLinks,
                optionImagesWidth: optionImagesWidth,
                displayConfiguration: displayConfiguration,
                writeInTextBoxLabel: writeInTextBoxLabel,
                import_columnName: import_columnName,
                import_valueType: import_valueType,
                import_answerNames: importOptions,
                import_minScaleValue: import_minScaleValue,
                import_maxScaleValue: import_maxScaleValue,
                import_writeInTextsAreInSeparateColumn: import_writeInTextsAreInSeparateColumn
            });
        };
        for (var questionIndex = 0; questionIndex < editorQuestions.length; questionIndex++) {
            _loop_1(questionIndex);
        }
        return adjustedQuestions;
    }
    exports.convertEditorQuestions = convertEditorQuestions;
    function convertElicitingQuestions(elicitingQuestions) {
        var result = [];
        for (var i = 0; i < elicitingQuestions.length; i++) {
            result.push({
                text: elicitingQuestions[i].elicitingQuestion_text,
                id: elicitingQuestions[i].elicitingQuestion_shortName,
                "type": elicitingQuestions[i].elicitingQuestion_type,
                importName: elicitingQuestions[i].elicitingQuestion_dataColumnName,
            });
        }
        ensureAtLeastOneElicitingQuestion(result);
        return result;
    }
    function ensureAtLeastOneElicitingQuestion(elicitingQuestions) {
        // TODO: How to prevent this potential problem of no eliciting questions during questionnaire design in GUI?
        if (elicitingQuestions.length === 0) {
            // TODO: Translate
            var defaultElicitingQuestion = "What happened?";
            var defaultElicitingQuestionID = "what happened";
            var message = 'No eliciting questions were defined! Adding "' + defaultElicitingQuestion + '".';
            console.log("PROBLEM", message);
            console.log("Adding eliciting question: ", defaultElicitingQuestion);
            elicitingQuestions.push({
                text: defaultElicitingQuestion,
                id: defaultElicitingQuestionID,
                type: { "what happened": true }
            });
        }
    }
    exports.ensureAtLeastOneElicitingQuestion = ensureAtLeastOneElicitingQuestion;
    function getStoryNameAndTextQuestions() {
        var result = [];
        result.unshift({
            id: "storyName",
            displayName: "Story title",
            displayPrompt: "Please give your story a name",
            displayType: "text",
            displayConfiguration: "20",
            valueOptions: [],
        });
        result.unshift({
            id: "storyText",
            displayName: "Story text",
            displayPrompt: "Please enter your response to the question above in the space below",
            displayType: "textarea",
            valueOptions: [],
        });
        return result;
    }
    exports.getStoryNameAndTextQuestions = getStoryNameAndTextQuestions;
    function getLeadingStoryQuestions(elicitingQuestions) {
        var result = getStoryNameAndTextQuestions();
        // TODO: What about idea of having IDs that go with eliciting questions so store reference to ID not text prompt?
        var elicitingQuestionValues = [];
        for (var elicitingQuestionIndex = 0; elicitingQuestionIndex < elicitingQuestions.length; elicitingQuestionIndex++) {
            var elicitingQuestionSpecification = elicitingQuestions[elicitingQuestionIndex];
            // elicitingQuestionValues.push({value: elicitingQuestionSpecification.id, text: elicitingQuestionSpecification.label});
            elicitingQuestionValues.push(elicitingQuestionSpecification.id || elicitingQuestionSpecification.shortName || elicitingQuestionSpecification.text);
        }
        result.unshift({
            id: "elicitingQuestion",
            displayName: "Eliciting question",
            displayPrompt: "Please choose a question you would like to respond to",
            displayType: "select",
            valueOptions: elicitingQuestionValues,
        });
        return result;
    }
    exports.getLeadingStoryQuestions = getLeadingStoryQuestions;
    function buildShortNamesToQuestionIDsDictionary(questionIDsListName, shortNameField) {
        var project = Globals.project();
        var questionIDsList = project.getListForField(questionIDsListName);
        var result = {};
        questionIDsList.forEach(function (questionID) {
            var shortName = project.tripleStore.queryLatestC(questionID, shortNameField);
            result[shortName] = questionID;
        });
        return result;
    }
    function buildQuestionsFromQuestionChoiceIDs(questionChoiceIDs, shortNameField, shortNamesToQuestionIDsDictionary) {
        var project = Globals.project();
        var result = [];
        questionChoiceIDs.forEach(function (questionChoiceID) {
            // TODO: Fix access here for tripleStore use
            var shortName = project.tripleStore.queryLatestC(questionChoiceID, shortNameField);
            var order = project.tripleStore.queryLatestC(questionChoiceID, "order");
            var questionID = shortNamesToQuestionIDsDictionary[shortName];
            if (questionID) {
                // Retrieve the latest for all the fields of the object (which will include deleted/null fields)
                // TODO: Remove any deleted/null fields
                var question = project.tripleStore.makeObject(questionID, true);
                question.order = order;
                question.id = shortName;
                result.push(question);
            }
            else {
                console.log("Editing error: Missing question definition for ", questionChoiceID);
            }
        });
        result.sort(function (a, b) {
            // in legacy data, the "order" field could have letters in it
            if (!isNaN(Number(a.order)) && !isNaN(Number(b.order))) {
                if (Number(a.order) < Number(b.order))
                    return -1;
                if (Number(a.order) > Number(b.order))
                    return 1;
                return 0;
            }
            else {
                if (a.order.toLowerCase() < b.order.toLowerCase())
                    return -1;
                if (a.order.toLowerCase() > b.order.toLowerCase())
                    return 1;
                return 0;
            }
        });
        return result;
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // handling translation dictionaries
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function buildTranslationDictionariesFromIDs(dictIDs) {
        var project = Globals.project();
        var result = {};
        dictIDs.forEach(function (dictID) {
            var storedDictionary = project.tripleStore.makeObject(dictID, true);
            if (storedDictionary && storedDictionary.defaultText) {
                result[storedDictionary.defaultText] = storedDictionary;
            }
        });
        return result;
    }
    function translateableTextsInStoryForm(storyForm, section) {
        if (section === void 0) { section = undefined; }
        var result = [];
        if (!section || section === "Eliciting questions") {
            storyForm.elicitingQuestions.forEach(function (question) { result.push(question.text); });
        }
        var questionListsToConsider = [];
        if (!section || section === "Story questions") {
            questionListsToConsider.push(storyForm.storyQuestions);
        }
        if (!section || section === "Participant questions") {
            questionListsToConsider.push(storyForm.participantQuestions);
        }
        questionListsToConsider.forEach(function (questionList) {
            questionList.forEach(function (question) {
                result.push(question.displayPrompt);
                if (question.displayType === "slider") {
                    question.displayConfiguration.forEach(function (option) { result.push(option); });
                }
                else if (question.valueOptions) {
                    question.valueOptions.forEach(function (option) { result.push(option); });
                }
                if (question.writeInTextBoxLabel) {
                    result.push(question.writeInTextBoxLabel);
                }
            });
        });
        exports.formFieldsInfo.forEach(function (fieldInfo) {
            if (fieldInfo.canBeTranslated) {
                if (!section || fieldInfo.section === section) {
                    var textToTranslate = storyForm[fieldInfo.objectFieldID];
                    if (!textToTranslate)
                        textToTranslate = surveyBuilderMithril.defaultFormTexts[fieldInfo.objectFieldID];
                    if (textToTranslate)
                        result.push(textToTranslate);
                }
            }
        });
        return result;
    }
    exports.translateableTextsInStoryForm = translateableTextsInStoryForm;
    function explanationForFormFieldOrQuestion(storyForm, text) {
        var result = explanationForFormField(storyForm, text);
        if (!result)
            result = explanationForQuestionText(storyForm, text);
        return result;
    }
    exports.explanationForFormFieldOrQuestion = explanationForFormFieldOrQuestion;
    function explanationForFormField(storyForm, text) {
        for (var i = 0; i < exports.formFieldsInfo.length; i++) {
            var fieldInfo = exports.formFieldsInfo[i];
            if (fieldInfo.canBeTranslated && fieldInfo.explanation) {
                if (storyForm[fieldInfo.objectFieldID] === text || surveyBuilderMithril.defaultFormTexts[fieldInfo.objectFieldID] === text) {
                    return fieldInfo.explanation;
                }
            }
        }
        return null;
    }
    function explanationForQuestionText(storyForm, text) {
        for (var i = 0; i < storyForm.elicitingQuestions.length; i++) {
            var question = storyForm.elicitingQuestions[i];
            if (question.text === text) {
                return "Question: " + question.id; // this is the shortName, not the uuid
            }
        }
        var questionsToConsider = [];
        questionsToConsider = questionsToConsider.concat(storyForm.storyQuestions, storyForm.participantQuestions);
        for (var i = 0; i < questionsToConsider.length; i++) {
            var question = questionsToConsider[i];
            if (question.displayPrompt === text) {
                return "Question: " + question.displayName; // also the shortName
            }
        }
        return null;
    }
    function orphanedTranslationsForStoryForm(storyForm) {
        var textsInForm = translateableTextsInStoryForm(storyForm);
        if (textsInForm.length == 0)
            return [];
        if (!storyForm.translationDictionary)
            return [];
        var textsInTranslationDictionary = Object.keys(storyForm.translationDictionary);
        var orphanedTexts = [];
        textsInTranslationDictionary.forEach(function (text) {
            if (textsInForm.indexOf(text) < 0) {
                orphanedTexts.push(text);
            }
        });
        return orphanedTexts;
    }
    exports.orphanedTranslationsForStoryForm = orphanedTranslationsForStoryForm;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // building the story form 
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // TODO: How to save the fact we have exported this in the project? Make a copy??? Or keep original in document somewhere? Versus what is returned from server for surveys?
    function buildStoryForm(shortName) {
        var project = Globals.project();
        var storyFormID = project.findStoryFormID(shortName);
        if (!storyFormID)
            return null;
        return buildStoryFormUsingTripleStoreID(storyFormID, shortName);
    }
    exports.buildStoryForm = buildStoryForm;
    function buildStoryFormUsingTripleStoreID(storyFormTripleStoreID, shortName) {
        var project = Globals.project();
        var usedIDs = { __createdIDCount: 0 };
        var template = {};
        exports.formFieldsInfo.forEach(function (fieldInfo) {
            template[fieldInfo.tripleStoreFieldID] = fieldInfo.default ? fieldInfo.default : "";
        });
        template.__type = "org.workingwithstories.Questionnaire";
        template.id = storyFormTripleStoreID;
        template.questionForm_shortName = shortName;
        template.questionForm_elicitingQuestions = project.tripleStore.newIdForSet("ElicitingQuestionChoiceSet");
        template.questionForm_storyQuestions = project.tripleStore.newIdForSet("StoryQuestionChoiceSet");
        template.questionForm_participantQuestions = project.tripleStore.newIdForSet("ParticipantQuestionChoiceSet");
        setDefaultImportFieldsForTemplate(template);
        var storyForm = {};
        exports.formFieldsInfo.forEach(function (fieldInfo) {
            if (template[fieldInfo.tripleStoreFieldID]) {
                storyForm[fieldInfo.objectFieldID] = template[fieldInfo.tripleStoreFieldID];
            }
            else if (fieldInfo.default) {
                storyForm[fieldInfo.objectFieldID] = fieldInfo.default;
            }
            else {
                storyForm[fieldInfo.objectFieldID] = "";
            }
        });
        storyForm.id = storyFormTripleStoreID;
        storyForm.shortName = project.tripleStore.queryLatestC(storyFormTripleStoreID, "questionForm_shortName"); // special handling
        exports.formFieldsInfo.forEach(function (fieldInfo) {
            if (fieldInfo.objectFieldID) {
                storyForm[fieldInfo.objectFieldID] = project.tripleStore.queryLatestC(storyFormTripleStoreID, fieldInfo.tripleStoreFieldID);
            }
        });
        getStoredImportFieldsForStoryForm(project, storyFormTripleStoreID, storyForm);
        var translationDictIDs = project.tripleStore.getListForSetIdentifier(project.tripleStore.queryLatestC(storyFormTripleStoreID, "questionForm_translationDictionary"));
        storyForm.translationDictionary = buildTranslationDictionariesFromIDs(translationDictIDs);
        var projectElicitingQuestionShortNamesMappedToIDs = buildShortNamesToQuestionIDsDictionary("project_elicitingQuestionsList", "elicitingQuestion_shortName");
        var formElicitingQuestionChoiceIDs = project.tripleStore.getListForSetIdentifier(project.tripleStore.queryLatestC(storyFormTripleStoreID, "questionForm_elicitingQuestions"));
        var elicitingQuestions = buildQuestionsFromQuestionChoiceIDs(formElicitingQuestionChoiceIDs, "elicitingQuestion", projectElicitingQuestionShortNamesMappedToIDs);
        storyForm.elicitingQuestions = convertElicitingQuestions(elicitingQuestions);
        var projectStoryQuestionShortNamesMappedToIDs = buildShortNamesToQuestionIDsDictionary("project_storyQuestionsList", "storyQuestion_shortName");
        var formStoryQuestionChoiceIDs = project.tripleStore.getListForSetIdentifier(project.tripleStore.queryLatestC(storyFormTripleStoreID, "questionForm_storyQuestions"));
        var storyQuestions = buildQuestionsFromQuestionChoiceIDs(formStoryQuestionChoiceIDs, "storyQuestion", projectStoryQuestionShortNamesMappedToIDs);
        ensureUniqueQuestionIDs(usedIDs, storyQuestions);
        storyForm.storyQuestions = convertEditorQuestions(storyQuestions, "S_");
        var projectParticipantQuestionShortNamesMappedToIDs = buildShortNamesToQuestionIDsDictionary("project_participantQuestionsList", "participantQuestion_shortName");
        var formParticipantQuestionChoiceIDs = project.tripleStore.getListForSetIdentifier(project.tripleStore.queryLatestC(storyFormTripleStoreID, "questionForm_participantQuestions"));
        var participantQuestions = buildQuestionsFromQuestionChoiceIDs(formParticipantQuestionChoiceIDs, "participantQuestion", projectParticipantQuestionShortNamesMappedToIDs);
        ensureUniqueQuestionIDs(usedIDs, participantQuestions);
        storyForm.participantQuestions = convertEditorQuestions(participantQuestions, "P_");
        return storyForm;
    }
    exports.buildStoryFormUsingTripleStoreID = buildStoryFormUsingTripleStoreID;
    function setDefaultImportFieldsForTemplate(template) {
        template.import_minScaleValue = 0;
        template.import_maxScaleValue = 0;
        template.import_multiChoiceYesIndicator = "Yes";
        template.import_multiChoiceYesQASeparator = "";
        template.import_multiChoiceYesQAEnding = "";
        template.import_multiChoiceDelimiter = ";";
        template.import_storyTitleColumnName = "Story title";
        template.import_storyTextColumnName = "Story text";
        template.import_storyCollectionDateColumnName = "Collection date";
        template.import_storyFormLanguageColumnName = "Language";
        template.import_participantIDColumnName = "Participant ID";
        template.import_columnsToIgnore = [];
        template.import_columnsToAppendToStoryText = "";
        template.import_textsToWriteBeforeAppendedColumns = "";
        template.import_minWordsToIncludeStory = "0";
        template.import_stringsToRemoveFromHeaders = "";
        template.import_elicitingQuestionColumnName = "Eliciting question";
        template.import_elicitingQuestionGraphName = "Eliciting question";
    }
    exports.setDefaultImportFieldsForTemplate = setDefaultImportFieldsForTemplate;
    function getStoredImportFieldsForStoryForm(project, id, storyForm) {
        storyForm.import_minScaleValue = project.tripleStore.queryLatestC(id, "questionForm_import_minScaleValue");
        storyForm.import_maxScaleValue = project.tripleStore.queryLatestC(id, "questionForm_import_maxScaleValue");
        storyForm.import_multiChoiceYesQASeparator = project.tripleStore.queryLatestC(id, "questionForm_import_multiChoiceYesQASeparator");
        storyForm.import_multiChoiceYesQAEnding = project.tripleStore.queryLatestC(id, "questionForm_import_multiChoiceYesQAEnding");
        storyForm.import_multiChoiceYesIndicator = project.tripleStore.queryLatestC(id, "questionForm_import_multiChoiceYesIndicator");
        storyForm.import_multiChoiceDelimiter = project.tripleStore.queryLatestC(id, "questionForm_import_multiChoiceDelimiter");
        storyForm.import_storyTitleColumnName = project.tripleStore.queryLatestC(id, "questionForm_import_storyTitleColumnName");
        storyForm.import_storyTextColumnName = project.tripleStore.queryLatestC(id, "questionForm_import_storyTextColumnName");
        storyForm.import_storyCollectionDateColumnName = project.tripleStore.queryLatestC(id, "questionForm_import_storyCollectionDateColumnName");
        storyForm.import_storyFormLanguageColumnName = project.tripleStore.queryLatestC(id, "questionForm_import_storyFormLanguageColumnName");
        storyForm.import_elicitingQuestionColumnName = project.tripleStore.queryLatestC(id, "questionForm_import_elicitingQuestionColumnName");
        storyForm.elicitingQuestionGraphName = project.tripleStore.queryLatestC(id, "import_elicitingQuestionGraphName");
        storyForm.import_minWordsToIncludeStory = project.tripleStore.queryLatestC(id, "questionForm_import_minWordsToIncludeStory");
        storyForm.import_stringsToRemoveFromHeaders = project.tripleStore.queryLatestC(id, "questionForm_import_stringsToRemoveFromHeaders");
        storyForm.import_participantIDColumnName = project.tripleStore.queryLatestC(id, "questionForm_import_participantIDColumnName");
        storyForm.import_columnsToIgnore = project.tripleStore.queryLatestC(id, "questionForm_import_columnsToIgnore");
        storyForm.import_columnsToAppendToStoryText = project.tripleStore.queryLatestC(id, "questionForm_import_columnsToAppendToStoryText");
        storyForm.import_textsToWriteBeforeAppendedColumns = project.tripleStore.queryLatestC(id, "questionForm_import_textsToWriteBeforeAppendedColumns");
    }
    exports.getStoredImportFieldsForStoryForm = getStoredImportFieldsForStoryForm;
    function ensureUniqueQuestionIDs(usedIDs, editorQuestions) {
        // Validate the survey ids to prevent duplicates and missing ones; ideally this should be done in GUI somehow
        for (var index in editorQuestions) {
            var editorQuestion = editorQuestions[index];
            if (!editorQuestion.id) {
                editorQuestion.id = "question " + (++(usedIDs.__createdIDCount));
                console.log("SURVEY DESIGN ERROR: question had missing ID and one was assigned", editorQuestion);
            }
            while (usedIDs[editorQuestion.id]) {
                // ID already exists
                console.log("SURVEY DESIGN ERROR: duplicate ID", editorQuestion.id);
                editorQuestion.id = "question " + (++(usedIDs.__createdIDCount));
                console.log("SURVEY DESIGN ERROR: question had duplicate ID and a new one was assigned", editorQuestion);
            }
            usedIDs[editorQuestion.id] = true;
        }
    }
});

define('js/surveyCollection',["require", "exports", "./panelBuilder/translate", "./questionnaireGeneration"], function (require, exports, translate, questionnaireGeneration) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    var writeInTag = "WriteInEntry_";
    var project;
    function setProject(theProject) {
        project = theProject;
    }
    exports.setProject = setProject;
    function getStoryField(storyID, fieldName, defaultValue) {
        var result = project.tripleStore.queryLatestC(storyID, fieldName);
        if (result === undefined || result === null)
            result = defaultValue;
        return result;
    }
    function getStoryWriteInField(storyID, fieldName, defaultValue) {
        var result = project.tripleStore.queryLatestC(storyID, writeInTag + fieldName);
        if (result === undefined || result === null)
            result = defaultValue;
        return result;
    }
    function setStoryField(storyID, fieldName, value) {
        project.tripleStore.addTriple(storyID, fieldName, value);
        return value;
    }
    // A Story class where data can be overriden
    var Story = (function () {
        function Story(model) {
            this.model = model;
        }
        Story.prototype.storyID = function () {
            return this.model.storyID;
        };
        Story.prototype.isIgnored = function () {
            return getStoryField(this.model.storyID, "ignore", "").trim() !== "";
        };
        Story.prototype.questionnaire = function () {
            return this.model.questionnaire;
        };
        Story.prototype.participantID = function () {
            return this.model.participantID;
        };
        Story.prototype.ignore = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("ignore", newValue);
        };
        Story.prototype.storyText = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("storyText", newValue);
        };
        Story.prototype.storyAnswersDisplay = function () {
            function displayNameAndValue(name, value) {
                var displayText = "";
                displayText += name.substring(2) + ": ";
                if (typeof value === 'object') {
                    var valueKeys = Object.keys(value);
                    var valueTexts = valueKeys.map(function (key) { return value[key] ? key : null; });
                    displayText += valueTexts.join(", ");
                }
                else {
                    displayText += value;
                }
                return displayText;
            }
            var text = "";
            var keys = Object.keys(this.model);
            var i = 0;
            var storyKeys = keys.filter(function (item) { return item.indexOf("S_") >= 0; });
            storyKeys.sort();
            var storyTexts = storyKeys.map(function (item) { return displayNameAndValue(item, this.model[item]); }, this);
            var allStoryTexts = storyTexts.join(". ");
            var participantKeys = keys.filter(function (item) { return item.indexOf("P_") >= 0; });
            participantKeys.sort();
            var participantTexts = participantKeys.map(function (item) { return displayNameAndValue(item, this.model[item]); }, this);
            var allParticipantTexts = participantTexts.join(". ");
            var annotationKeys = keys.filter(function (item) { return item.indexOf("A_") >= 0; });
            annotationKeys.sort();
            var annotationTexts = annotationKeys.map(function (item) { return displayNameAndValue(item, this.model[item]); }, this);
            var allAnnotationTexts = annotationTexts.join(". ");
            return [allStoryTexts, allParticipantTexts, allAnnotationTexts].join(". ") + ".";
        };
        Story.prototype.storyAnswersCount = function () {
            // the model fields include the story text and other non-answer answers
            // but that's okay, we just want a total to show on the dashboard
            if (!this.model)
                return 0;
            var keys = Object.keys(this.model);
            return keys.length;
        };
        Story.prototype.storyName = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("storyName", newValue);
        };
        Story.prototype.elicitingQuestion = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("elicitingQuestion", newValue);
        };
        Story.prototype.numStoriesTold = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("numStoriesTold", newValue);
        };
        Story.prototype.storyLength = function () {
            var storyText = this.fieldValue("storyText");
            if (storyText) {
                return storyText.length;
            }
            else {
                return 0;
            }
        };
        Story.prototype.indexInStoryCollection = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("indexInStoryCollection", newValue);
        };
        Story.prototype.storyCollectionDate = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("collectionDate", newValue);
        };
        Story.prototype.storyLanguage = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("language", newValue);
        };
        // ISO 8601 date format: YYYY-MM-DD
        Story.prototype.storyCollectionYear = function () {
            var collectionDate = this.storyCollectionDate();
            if (collectionDate && collectionDate.length >= 4) {
                return collectionDate.substr(0, 4);
            }
            else {
                return null;
            }
        };
        Story.prototype.storyCollectionQuarter = function () {
            var year = this.storyCollectionYear();
            var month = this.storyCollectionMonth();
            if (!year || !month)
                return null;
            if (["01", "02", "03"].indexOf(month) >= 0) {
                return year + " Q1";
            }
            else if (["04", "05", "06"].indexOf(month) >= 0) {
                return year + " Q2";
            }
            else if (["07", "08", "09"].indexOf(month) >= 0) {
                return year + " Q3";
            }
            else if (["10", "11", "12"].indexOf(month) >= 0) {
                return year + " Q4";
            }
        };
        Story.prototype.storyCollectionYearAndMonth = function () {
            var collectionDate = this.fieldValue("collectionDate");
            if (collectionDate && collectionDate.length >= 4) {
                return collectionDate.substr(0, 7);
            }
            else {
                return null;
            }
        };
        Story.prototype.storyCollectionMonth = function () {
            var collectionDate = this.fieldValue("collectionDate");
            if (collectionDate && collectionDate.length >= 7) {
                return collectionDate.substr(5, 2);
            }
            else {
                return null;
            }
        };
        Story.prototype.storyCollectionDayOfFMonth = function () {
            var collectionDate = this.fieldValue("collectionDate");
            if (collectionDate && collectionDate.length >= 10) {
                return collectionDate.substr(8, 2);
            }
            else {
                return null;
            }
        };
        Story.prototype.storyCollectionIdentifier = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("storyCollectionIdentifier", newValue);
        };
        Story.prototype.fieldValue = function (fieldName, newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue === undefined) {
                var defaultValue = (this.model[fieldName] !== undefined && this.model[fieldName] !== null) ? this.model[fieldName] : "";
                return getStoryField(this.model.storyID, fieldName, defaultValue);
            }
            else {
                return setStoryField(this.model.storyID, fieldName, newValue);
            }
        };
        Story.prototype.fieldValueWriteIn = function (fieldName) {
            var defaultValue = this.model[writeInTag + fieldName];
            if (defaultValue === undefined || defaultValue === null)
                defaultValue = "";
            return getStoryWriteInField(this.model.storyID, fieldName, defaultValue);
        };
        return Story;
    }());
    exports.Story = Story;
    function getStoriesForStoryCollection(storyCollectionIdentifier, includeIgnored) {
        if (includeIgnored === void 0) { includeIgnored = false; }
        var result = [];
        var surveyMessages = project.pointrelClient.filterMessages(function (message) {
            var match = (message._topicIdentifier === "surveyResults" &&
                message.messageType === "surveyResult" &&
                message.change.projectIdentifier === project.projectIdentifier &&
                message.change.storyCollectionIdentifier === storyCollectionIdentifier);
            return match;
        });
        var numStoriesAddedForCollection = 0;
        surveyMessages.forEach(function (message) {
            // Now add stories in survey to results, with extra participant information
            try {
                var surveyResult = message.change.surveyResult;
                var stories = surveyResult.stories;
                for (var storyIndex in stories) {
                    // calculate derived count of number of stories told in each survey session (to be shown in graphs)
                    stories[storyIndex].numStoriesTold = "" + stories.length;
                    stories[storyIndex].storyLength = "" + stories[storyIndex].length;
                    // only set collection date info if it was not previously saved
                    // if the story was imported from a CSV file, the collection date read from the file
                    // was saved in the "collectionDate" field, and the "_topicTimestamp" of the message is the import timestamp
                    if (!stories[storyIndex].collectionDate) {
                        if (message._topicTimestamp && message._topicTimestamp.length >= 10) {
                            // ISO 8601 date format: YYYY-MM-DD
                            stories[storyIndex].collectionDate = message._topicTimestamp.substr(0, 10);
                        }
                    }
                    stories[storyIndex].language = surveyResult.language;
                    // Make a copy of the story so as not to modify original in message
                    var story = JSON.parse(JSON.stringify(stories[storyIndex]));
                    // Add participant info for story
                    var participantData = surveyResult.participantData;
                    for (var key in participantData) {
                        if (key !== "__type") {
                            story[key] = participantData[key];
                        }
                    }
                    // Add some fields for displaying information
                    // note: we must check both field names (questionnaire and storyForm)
                    // because I stupidly changed "questionnaire" to "storyForm" 
                    // without realizing I was messing up references in the data;
                    // I put it back later, but either name could be in legacy data
                    if (surveyResult.questionnaire) {
                        story.questionnaire = surveyResult.questionnaire;
                    }
                    else if (surveyResult.storyForm) {
                        story.questionnaire = surveyResult.storyForm;
                    }
                    else {
                        console.log("ERROR: story has no story form reference.");
                    }
                    story.indexInStoryCollection = ++numStoriesAddedForCollection;
                    story.storyCollectionIdentifier = storyCollectionIdentifier;
                    var wrappedStory = new Story(story);
                    if (includeIgnored || !wrappedStory.isIgnored()) {
                        result.push(wrappedStory);
                    }
                }
            }
            catch (e) {
                console.log("Problem processing survey result", message, e);
            }
        });
        return result;
    }
    exports.getStoriesForStoryCollection = getStoriesForStoryCollection;
    function getQuestionnaireForStoryCollection(storyCollectionName, alertIfProblem) {
        if (alertIfProblem === void 0) { alertIfProblem = false; }
        var storyCollectionID = project.findStoryCollectionID(storyCollectionName);
        if (!storyCollectionID) {
            // TODO: translate
            if (alertIfProblem)
                alert("The selected story collection could not be found.");
            return null;
        }
        var questionnaireName = project.tripleStore.queryLatestC(storyCollectionID, "storyCollection_questionnaireIdentifier");
        if (!questionnaireName) {
            // TODO: translate
            if (alertIfProblem)
                alert("The story collection has no selection for a questionnaire.");
            return null;
        }
        var questionnaire = project.tripleStore.queryLatestC(storyCollectionID, "questionnaire");
        if (!questionnaire) {
            // TODO: translate
            if (alertIfProblem)
                alert("The questionnaire selected in the story collection could not be found.");
            return null;
        }
        return questionnaire;
    }
    exports.getQuestionnaireForStoryCollection = getQuestionnaireForStoryCollection;
    function urlForSurvey(storyCollectionID) {
        var href = window.location.href;
        var baseURL = href.substring(0, href.lastIndexOf("/"));
        // TODO: Duplicated project prefix; should refactor to have it in one place
        var projectName = project.journalIdentifier.substring("NarraFirmaProject-".length);
        var shortName = project.tripleStore.queryLatestC(storyCollectionID, "storyCollection_shortName");
        var url = baseURL + "/survey.html#project=" + projectName + "&survey=" + shortName;
        var cleanedUrl = encodeURI(url);
        var result = m("a[id=narrafirma-survey-url]", { href: cleanedUrl, title: cleanedUrl, target: "_blank" }, url);
        return result;
    }
    exports.urlForSurvey = urlForSurvey;
    function urlForSurveyAsString(storyCollectionID) {
        var href = window.location.href;
        var baseURL = href.substring(0, href.lastIndexOf("/"));
        // TODO: Duplicated project prefix; should refactor to have it in one place
        var projectName = project.journalIdentifier.substring("NarraFirmaProject-".length);
        var shortName = project.tripleStore.queryLatestC(storyCollectionID, "storyCollection_shortName");
        var url = baseURL + "/survey.html#project=" + projectName + "&survey=" + shortName;
        var cleanedUrl = encodeURI(url);
        return cleanedUrl;
    }
    exports.urlForSurveyAsString = urlForSurveyAsString;
    function urlForStoryCollectionReview(storyCollectionID, pageName) {
        var href = window.location.href;
        var baseURL = href.substring(0, href.lastIndexOf("/"));
        // TODO: Duplicated project prefix; should refactor to have it in one place
        var projectName = project.journalIdentifier.substring("NarraFirmaProject-".length);
        var shortName = project.tripleStore.queryLatestC(storyCollectionID, "storyCollection_shortName");
        var url = baseURL + "/narrafirma.html#project=" + projectName + "&page=" + pageName + "&storyCollection=" + shortName;
        var cleanedUrl = encodeURI(url);
        return cleanedUrl;
    }
    exports.urlForStoryCollectionReview = urlForStoryCollectionReview;
    function toggleWebActivationOfSurvey(model, fieldSpecification, value) {
        // TODO: Fix this for mover to using triples for projectModel
        var grid = fieldSpecification.grid;
        var selectedItem = grid.getSelectedItem();
        console.log("toggleWebActivationOfSurvey selectedItem", selectedItem, model, fieldSpecification);
        var shortName = project.tripleStore.queryLatestC(selectedItem, "storyCollection_shortName");
        var activeOnWeb = project.tripleStore.queryLatestC(selectedItem, "storyCollection_activeOnWeb");
        activeOnWeb = !activeOnWeb;
        if (activeOnWeb) {
            // urlForSurvey(shortName)
            project.tripleStore.addTriple(selectedItem, "storyCollection_activeOnWeb", true);
        }
        else {
            project.tripleStore.addTriple(selectedItem, "storyCollection_activeOnWeb", false);
        }
        // TODO: Potential window of vulnerability here because not making both changes (to item and survey questionnaires) as a single transaction
        var questionnaires = {};
        for (var key in project.activeQuestionnaires) {
            questionnaires[key] = project.activeQuestionnaires[key];
        }
        var questionnaire = project.tripleStore.queryLatestC(selectedItem, "questionnaire");
        if (!questionnaire) {
            var questionnaireName = project.tripleStore.queryLatestC(selectedItem, "storyCollection_questionnaireIdentifier");
            console.log("Could not find questionnnaire for", questionnaireName);
            return;
        }
        if (activeOnWeb) {
            questionnaires[shortName] = questionnaire;
        }
        else {
            delete questionnaires[shortName];
        }
        // Now publish the new or removed questionnaire so surveys can pick up the change...
        updateActiveQuestionnaires(questionnaires, "sendMessage", activeOnWeb);
    }
    exports.toggleWebActivationOfSurvey = toggleWebActivationOfSurvey;
    function updateActiveQuestionnaires(questionnaires, sendMessage, activeOnWeb) {
        project.activeQuestionnaires = questionnaires;
        if (!sendMessage)
            return;
        // TODO: Should not have GUI actions in here like alert; either do as Toast or publish on topic that can be hooked up to alert or Toast
        project.pointrelClient.createAndSendChangeMessage("questionnaires", "questionnairesMessage", questionnaires, null, function (error, result) {
            if (error) {
                // TODO: Translate
                var errorMessage = "Problem activating web form";
                if (!activeOnWeb)
                    errorMessage = "Problem deactivating web form";
                alert(errorMessage);
                return;
            }
            // TODO: Translate
            var message = "The web form has been activated.";
            if (!activeOnWeb)
                message = "The web form has been deactivated.";
            alert(message);
        });
    }
    exports.updateActiveQuestionnaires = updateActiveQuestionnaires;
    function storyCollectionStop() {
        // TODO: translate
        // TODO: probably should not have GUI action in here; need to rethink?
        if (!isStoryCollectingEnabled()) {
            alert("Story collection via the web is already not currently enabled.");
            return;
        }
        if (!confirm("Deactivate all story collection via the web?"))
            return;
        var storyCollections = project.getListForField("project_storyCollections");
        for (var i = 0; i < storyCollections.length; i++) {
            var storyCollectionIdentifier = storyCollections[i];
            if (project.tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_activeOnWeb")) {
                project.tripleStore.addTriple(storyCollectionIdentifier, "storyCollection_activeOnWeb", false);
            }
        }
        updateActiveQuestionnaires({}, "sendMessage", false);
        console.log("Deactivated all web questionnaires");
    }
    exports.storyCollectionStop = storyCollectionStop;
    function isStoryCollectingEnabled() {
        for (var key in project.activeQuestionnaires) {
            return true;
        }
        return false;
    }
    exports.isStoryCollectingEnabled = isStoryCollectingEnabled;
    function collectQuestionsForQuestionnaire(questionnaire) {
        if (!questionnaire)
            return [];
        var leadingStoryQuestions = questionnaireGeneration.getLeadingStoryQuestions(questionnaire.elicitingQuestions);
        var questions = [].concat(leadingStoryQuestions, questionnaire.storyQuestions);
        questions.push({
            id: "participantData_header",
            displayName: "Participant Data",
            displayPrompt: "---- participant data below ----",
            displayType: "header",
            valueOptions: []
        });
        // TODO: add more participant and survey info, like timestamps and participant ID
        // Participant data has elsewhere been copied into story, so these questions can access it directly
        questions = questions.concat(questionnaire.participantQuestions);
        return questions;
    }
    exports.collectQuestionsForQuestionnaire = collectQuestionsForQuestionnaire;
    // Types of questions that have data associated with them for filters and graphs
    var filterableQuestionTypes = ["select", "slider", "boolean", "text", "checkbox", "checkboxes", "radiobuttons"];
    // function updateFilterPaneForCurrentQuestions(questions) {
    function optionsForAllQuestions(questions, excludeTextQuestionsFlag) {
        if (excludeTextQuestionsFlag === void 0) { excludeTextQuestionsFlag = null; }
        var questionOptions = [];
        questions.forEach(function (question) {
            if (filterableQuestionTypes.indexOf(question.displayType) !== -1) {
                if (!excludeTextQuestionsFlag || question.displayType !== "text") {
                    var defaultText = question.displayName;
                    if (!defaultText)
                        defaultText = question.displayPrompt;
                    questionOptions.push({ label: translate(question.id + "::shortName", defaultText), value: question.id });
                }
            }
        });
        // Sort options by their name
        questionOptions.sort(function (a, b) {
            if (a.label.toLowerCase() < b.label.toLowerCase())
                return -1;
            if (a.label.toLowerCase() > b.label.toLowerCase())
                return 1;
            return 0;
        });
        return questionOptions;
    }
    exports.optionsForAllQuestions = optionsForAllQuestions;
});

define('js/surveyStorage',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeSurveyResultMessage(pointrelClient, projectIdentifier, storyCollectionName, completedSurvey) {
        var surveyResultWrapper = {
            projectIdentifier: projectIdentifier,
            // TODO: Mismatch of stored string's intent and the field name
            storyCollectionIdentifier: storyCollectionName,
            surveyResult: completedSurvey
        };
        var message = pointrelClient.createChangeMessage("surveyResults", "surveyResult", surveyResultWrapper, null);
        return message;
    }
    exports.makeSurveyResultMessage = makeSurveyResultMessage;
    function storeSurveyResult(pointrelClient, projectIdentifier, storyCollectionName, completedSurvey, wizardPane) {
        var message = makeSurveyResultMessage(pointrelClient, projectIdentifier, storyCollectionName, completedSurvey);
        console.log("storeSurveyResult", message);
        var thankYouPopupText = "Your contribution has been added to the story collection. Thank you.";
        if (completedSurvey && completedSurvey.questionnaire && completedSurvey.questionnaire.thankYouPopupText) {
            thankYouPopupText = completedSurvey.questionnaire.thankYouPopupText;
        }
        pointrelClient.sendMessage(message, function (error, result) {
            if (error) {
                console.log("Problem saving survey result", error);
                if (wizardPane && wizardPane.failed) {
                    wizardPane.failed();
                }
                else {
                    // TODO: Translate
                    alert("Problem saving survey result; check the console for details.\nPlease try to submit the survey result later.");
                }
                return;
            }
            console.log("Survey result stored");
            if (wizardPane) {
                wizardPane.forward();
            }
            else {
                // TODO: Translate
                alert(thankYouPopupText);
            }
        });
    }
    exports.storeSurveyResult = storeSurveyResult;
});

/**
 * humane.js
 * Humanized Messages for Notifications
 * @author Marc Harter (@wavded)
 * @example
 *   humane.log('hello world');
 * @license MIT
 * See more usage examples at: http://wavded.github.com/humane-js/
 */

;!function (name, context, definition) {
   if (typeof module !== 'undefined') module.exports = definition(name, context)
   else if (typeof define === 'function' && typeof define.amd  === 'object') define('humane',definition)
   else context[name] = definition(name, context)
}('humane', this, function (name, context) {
   var win = window
   var doc = document

   var ENV = {
      on: function (el, type, cb) {
         'addEventListener' in win ? el.addEventListener(type,cb,false) : el.attachEvent('on'+type,cb)
      },
      off: function (el, type, cb) {
         'removeEventListener' in win ? el.removeEventListener(type,cb,false) : el.detachEvent('on'+type,cb)
      },
      bind: function (fn, ctx) {
         return function () { fn.apply(ctx,arguments) }
      },
      isArray: Array.isArray || function (obj) { return Object.prototype.toString.call(obj) === '[object Array]' },
      config: function (preferred, fallback) {
         return preferred != null ? preferred : fallback
      },
      transSupport: false,
      useFilter: /msie [678]/i.test(navigator.userAgent), // sniff, sniff
      _checkTransition: function () {
         var el = doc.createElement('div')
         var vendors = { webkit: 'webkit', Moz: '', O: 'o', ms: 'MS' }

         for (var vendor in vendors)
            if (vendor + 'Transition' in el.style) {
               this.vendorPrefix = vendors[vendor]
               this.transSupport = true
            }
      }
   }
   ENV._checkTransition()

   var Humane = function (o) {
      o || (o = {})
      this.queue = []
      this.baseCls = o.baseCls || 'humane'
      this.addnCls = o.addnCls || ''
      this.timeout = 'timeout' in o ? o.timeout : 2500
      this.waitForMove = o.waitForMove || false
      this.clickToClose = o.clickToClose || false
      this.timeoutAfterMove = o.timeoutAfterMove || false
      this.container = o.container

      try { this._setupEl() } // attempt to setup elements
      catch (e) {
        ENV.on(win,'load',ENV.bind(this._setupEl, this)) // dom wasn't ready, wait till ready
      }
   }

   Humane.prototype = {
      constructor: Humane,
      _setupEl: function () {
         var el = doc.createElement('div')
         el.style.display = 'none'
         if (!this.container){
           if(doc.body) this.container = doc.body;
           else throw 'document.body is null'
         }
         this.container.appendChild(el)
         this.el = el
         this.removeEvent = ENV.bind(function(){
            var timeoutAfterMove = ENV.config(this.currentMsg.timeoutAfterMove,this.timeoutAfterMove)
            if (!timeoutAfterMove){
               this.remove()
            } else {
               setTimeout(ENV.bind(this.remove,this),timeoutAfterMove)
            }
         },this)

         this.transEvent = ENV.bind(this._afterAnimation,this)
         this._run()
      },
      _afterTimeout: function () {
         if (!ENV.config(this.currentMsg.waitForMove,this.waitForMove)) this.remove()

         else if (!this.removeEventsSet) {
            ENV.on(doc.body,'mousemove',this.removeEvent)
            ENV.on(doc.body,'click',this.removeEvent)
            ENV.on(doc.body,'keypress',this.removeEvent)
            ENV.on(doc.body,'touchstart',this.removeEvent)
            this.removeEventsSet = true
         }
      },
      _run: function () {
         if (this._animating || !this.queue.length || !this.el) return

         this._animating = true
         if (this.currentTimer) {
            clearTimeout(this.currentTimer)
            this.currentTimer = null
         }

         var msg = this.queue.shift()
         var clickToClose = ENV.config(msg.clickToClose,this.clickToClose)

         if (clickToClose) {
            ENV.on(this.el,'click',this.removeEvent)
            ENV.on(this.el,'touchstart',this.removeEvent)
         }

         var timeout = ENV.config(msg.timeout,this.timeout)

         if (timeout > 0)
            this.currentTimer = setTimeout(ENV.bind(this._afterTimeout,this), timeout)

         if (ENV.isArray(msg.html)) msg.html = '<ul><li>'+msg.html.join('<li>')+'</ul>'

         this.el.innerHTML = msg.html
         this.currentMsg = msg
         this.el.className = this.baseCls
         if (ENV.transSupport) {
            this.el.style.display = 'block'
            setTimeout(ENV.bind(this._showMsg,this),50)
         } else {
            this._showMsg()
         }

      },
      _setOpacity: function (opacity) {
         if (ENV.useFilter){
            try{
               this.el.filters.item('DXImageTransform.Microsoft.Alpha').Opacity = opacity*100
            } catch(err){}
         } else {
            this.el.style.opacity = String(opacity)
         }
      },
      _showMsg: function () {
         var addnCls = ENV.config(this.currentMsg.addnCls,this.addnCls)
         if (ENV.transSupport) {
            this.el.className = this.baseCls+' '+addnCls+' '+this.baseCls+'-animate'
         }
         else {
            var opacity = 0
            this.el.className = this.baseCls+' '+addnCls+' '+this.baseCls+'-js-animate'
            this._setOpacity(0) // reset value so hover states work
            this.el.style.display = 'block'

            var self = this
            var interval = setInterval(function(){
               if (opacity < 1) {
                  opacity += 0.1
                  if (opacity > 1) opacity = 1
                  self._setOpacity(opacity)
               }
               else clearInterval(interval)
            }, 30)
         }
      },
      _hideMsg: function () {
         var addnCls = ENV.config(this.currentMsg.addnCls,this.addnCls)
         if (ENV.transSupport) {
            this.el.className = this.baseCls+' '+addnCls
            ENV.on(this.el,ENV.vendorPrefix ? ENV.vendorPrefix+'TransitionEnd' : 'transitionend',this.transEvent)
         }
         else {
            var opacity = 1
            var self = this
            var interval = setInterval(function(){
               if(opacity > 0) {
                  opacity -= 0.1
                  if (opacity < 0) opacity = 0
                  self._setOpacity(opacity);
               }
               else {
                  self.el.className = self.baseCls+' '+addnCls
                  clearInterval(interval)
                  self._afterAnimation()
               }
            }, 30)
         }
      },
      _afterAnimation: function () {
         if (ENV.transSupport) ENV.off(this.el,ENV.vendorPrefix ? ENV.vendorPrefix+'TransitionEnd' : 'transitionend',this.transEvent)

         if (this.currentMsg.cb) this.currentMsg.cb()
         this.el.style.display = 'none'

         this._animating = false
         this._run()
      },
      remove: function (e) {
         var cb = typeof e == 'function' ? e : null

         ENV.off(doc.body,'mousemove',this.removeEvent)
         ENV.off(doc.body,'click',this.removeEvent)
         ENV.off(doc.body,'keypress',this.removeEvent)
         ENV.off(doc.body,'touchstart',this.removeEvent)
         ENV.off(this.el,'click',this.removeEvent)
         ENV.off(this.el,'touchstart',this.removeEvent)
         this.removeEventsSet = false

         if (cb && this.currentMsg) this.currentMsg.cb = cb
         if (this._animating) this._hideMsg()
         else if (cb) cb()
      },
      log: function (html, o, cb, defaults) {
         var msg = {}
         if (defaults)
           for (var opt in defaults)
               msg[opt] = defaults[opt]

         if (typeof o == 'function') cb = o
         else if (o)
            for (var opt in o) msg[opt] = o[opt]

         msg.html = html
         if (cb) msg.cb = cb
         this.queue.push(msg)
         this._run()
         return this
      },
      spawn: function (defaults) {
         var self = this
         return function (html, o, cb) {
            self.log.call(self,html,o,cb,defaults)
            return self
         }
      },
      create: function (o) { return new Humane(o) }
   }
   return new Humane()
});

define('js/panelBuilder/toaster',["require", "exports", "humane"], function (require, exports, humane) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    // For a "toaster" that can give status or progress updates
    var toasterWidget = null;
    // This should only be called once in your application, at the beginning
    function createToasterWidget(container) {
        // No longer needed to do anything
    }
    exports.createToasterWidget = createToasterWidget;
    function toast(message, messageType, duration_ms) {
        if (messageType === void 0) { messageType = "message"; }
        if (duration_ms === void 0) { duration_ms = 5000; }
        // TODO: Translate message if needed
        humane.log(message, { timeout: duration_ms, clickToClose: true });
    }
    exports.toast = toast;
});

define('js/panelBuilder/dialogSupport',["require", "exports", "./translate", "mithril", "./toaster"], function (require, exports, translate, m, toaster) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    // Only supports one dialog at a time -- no nesting!
    // Use an standard alert or confirm for one more level of nesting if needed.
    // TODO: Using a global here to avoid parameterizing mounted components until the following Mithril issue is resolved or clarified:
    // https://github.com/lhorie/mithril.js/issues/638
    // If this is null, no dialog is drawn. If this is a valid configuration, dialog will be displayed.
    var globalDialogConfiguration = null;
    // Leaving one dialog mounted all the time to try to get around with re-creation of grids when dialog opens; maybe Mithril bug?
    function initialize() {
        m.mount(document.getElementById("dialogDiv"), MithrilDialog);
    }
    exports.initialize = initialize;
    // TODO: Translate: Change to taking a translate ID
    // TODO: Buttons don't show up if window too narrow for dialog
    function confirm(message, okCallback) {
        var confirmed = window.confirm(message);
        if (confirmed)
            okCallback();
    }
    exports.confirm = confirm;
    function addButtonThatLaunchesDialog(fieldSpecification, dialogConfiguration) {
        var parts = [m("span", { "class": "button-text" }, translate(fieldSpecification.id, fieldSpecification.displayPrompt))];
        if (fieldSpecification.displayIconClass) {
            var icon = m("span", { "class": "buttonWithTextImage " + fieldSpecification.displayIconClass });
            if (fieldSpecification.displayIconPosition === "right") {
                parts.push(icon);
            }
            else {
                parts.unshift(icon);
            }
        }
        var button = m("button", {
            "class": "narrafirma-dialog-launching-button",
            onclick: function () {
                openDialog(dialogConfiguration);
            }
        }, parts);
        if (fieldSpecification.displayPreventBreak)
            return button;
        return [button, m("br")];
    }
    exports.addButtonThatLaunchesDialog = addButtonThatLaunchesDialog;
    function hideDialogMethod() {
        globalDialogConfiguration = null;
    }
    var MithrilDialog = (function () {
        function MithrilDialog() {
        }
        MithrilDialog.controller = function () {
            return new MithrilDialog();
        };
        MithrilDialog.view = function (controller) {
            var dialogContent = [];
            if (globalDialogConfiguration) {
                try {
                    dialogContent = controller.calculateView(globalDialogConfiguration);
                }
                catch (e) {
                    console.log("Problem creating dialog", e);
                    alert("Problem creating dialog");
                    hideDialogMethod();
                    // dialogContent = m("div", "Problem creating dialog");
                }
            }
            return m("div.dialogContentWrapper", dialogContent);
        };
        MithrilDialog.prototype.calculateView = function (args) {
            var dialogConfiguration = args;
            var internalView;
            try {
                internalView = dialogConfiguration.dialogConstructionFunction(dialogConfiguration, hideDialogMethod);
            }
            catch (e) {
                console.log("Problem creating view", args, e);
                internalView = m("div", "Problem creating view");
            }
            var parts = [
                m("b", translate(dialogConfiguration.dialogTitle)),
                m("div.modal-internal", internalView)
            ];
            var bottomPanelButtons = [];
            if (dialogConfiguration.dialogCopyButtonLabel) {
                bottomPanelButtons.push(m("button", {
                    onclick: function () {
                        var textAreas = document.getElementsByClassName("textEditorInDialog");
                        if (textAreas.length) {
                            var value = textAreas[0].value;
                            window.navigator['clipboard'].writeText(value);
                            toaster.toast("Copied to clipboard", "message", 800);
                        }
                    },
                    "class": "narrafirma-dialog-copy-button"
                }, translate(args.dialogCopyButtonLabel)));
            }
            if (!dialogConfiguration.dialogOKButtonHidden) {
                bottomPanelButtons.push(m("button", { onclick: function () {
                        if (dialogConfiguration.dialogOKCallback) {
                            dialogConfiguration.dialogOKCallback(dialogConfiguration, hideDialogMethod);
                        }
                        else {
                            hideDialogMethod();
                        }
                    }, "class": "narrafirma-dialog-ok-button" }, translate(args.dialogOKButtonLabel || "OK")));
            }
            if (dialogConfiguration.dialogCancelButtonLabel) {
                bottomPanelButtons.push(m("button", { onclick: function () {
                        hideDialogMethod();
                    }, "class": "narrafirma-dialog-cancel-button" }, translate(args.dialogCancelButtonLabel)));
            }
            parts.push(m("div.modal-button-panel", bottomPanelButtons));
            return m("div.overlay", m("div.modal-content", { "class": dialogConfiguration.dialogClass }, parts));
        };
        return MithrilDialog;
    }());
    function openDialog(dialogConfiguration) {
        if (!dialogConfiguration.key)
            dialogConfiguration.key = "standardDialog";
        globalDialogConfiguration = dialogConfiguration;
    }
    exports.openDialog = openDialog;
    // Caller needs to call the hideDialogMethod returned as the second arg of dialogOKCallback to close the dialog
    function openTextEditorDialog(text, dialogTitle, dialogOKButtonLabel, dialogCopyButtonLabel, dialogOKCallback, showCancelButton, readOnly) {
        if (showCancelButton === void 0) { showCancelButton = true; }
        if (readOnly === void 0) { readOnly = false; }
        if (!dialogTitle)
            dialogTitle = "Editor";
        if (!dialogOKButtonLabel)
            dialogOKButtonLabel = "OK";
        var model = { text: text };
        var dialogConfiguration = {
            dialogModel: model,
            dialogTitle: dialogTitle,
            dialogClass: undefined,
            dialogReadOnly: readOnly,
            dialogCopyButtonLabel: dialogCopyButtonLabel,
            dialogConstructionFunction: build_textEditorDialogContent,
            dialogOKButtonLabel: dialogOKButtonLabel,
            dialogOKCallback: function (dialogConfiguration, hideDialogMethod) { dialogOKCallback(model.text, hideDialogMethod); },
            dialogCancelButtonLabel: showCancelButton ? "Cancel" : ""
        };
        openDialog(dialogConfiguration);
    }
    exports.openTextEditorDialog = openTextEditorDialog;
    function build_textEditorDialogContent(dialogConfiguration, hideDialogMethod) {
        return m("div", [
            m("textarea", {
                key: "standardTextEditorTextarea",
                class: "textEditorInDialog",
                onchange: function (event) { dialogConfiguration.dialogModel.text = event.target.value; },
                value: dialogConfiguration.dialogModel.text,
                disabled: dialogConfiguration.dialogReadOnly
            })
        ]);
    }
    // Caller needs to call the hideDialogMethod returned as the second arg of dialogOKCallback to close the dialog
    function openProgressDialog(progressText, dialogTitle, cancelButtonLabel, dialogCancelCallback) {
        if (!dialogTitle)
            dialogTitle = "Progress";
        if (!cancelButtonLabel)
            cancelButtonLabel = "Cancel";
        var model = {
            progressText: progressText,
            hideDialogMethod: hideDialogMethod,
            redraw: m.redraw,
            cancelled: false,
            failed: false
        };
        var dialogConfiguration = {
            dialogModel: model,
            dialogTitle: dialogTitle,
            dialogClass: undefined,
            dialogConstructionFunction: build_progressDialogContent,
            // Use OK button isntead of Cancel because it has a callback and represents the action button
            dialogOKButtonLabel: cancelButtonLabel,
            dialogOKCallback: function (dialogConfiguration, hideDialogMethod) { dialogCancelCallback(dialogConfiguration, hideDialogMethod); }
        };
        openDialog(dialogConfiguration);
        return model;
    }
    exports.openProgressDialog = openProgressDialog;
    function build_progressDialogContent(dialogConfiguration, hideDialogMethod) {
        return m("div", dialogConfiguration.dialogModel.progressText);
    }
    function openFinishedDialog(finishedText, dialogTitle, okButtonLabel, cancelButtonLabel, dialogOKCallback) {
        if (!dialogTitle)
            dialogTitle = "Finished";
        if (!okButtonLabel)
            okButtonLabel = "OK";
        if (!cancelButtonLabel)
            cancelButtonLabel = "Cancel";
        var model = {
            finishedText: finishedText,
            hideDialogMethod: hideDialogMethod,
            redraw: m.redraw,
            cancelled: false,
            failed: false
        };
        var dialogConfiguration = {
            dialogModel: model,
            dialogTitle: dialogTitle,
            dialogClass: undefined,
            dialogConstructionFunction: build_finishedDialogContent,
            // Use OK button instead of Cancel because it has a callback and represents the action button
            dialogOKButtonLabel: okButtonLabel,
            dialogOKCallback: function (dialogConfiguration, hideDialogMethod) { dialogOKCallback(dialogConfiguration, hideDialogMethod); },
            dialogCancelButtonLabel: cancelButtonLabel
        };
        openDialog(dialogConfiguration);
        return model;
    }
    exports.openFinishedDialog = openFinishedDialog;
    function build_finishedDialogContent(dialogConfiguration, hideDialogMethod) {
        return m("div", dialogConfiguration.dialogModel.finishedText);
    }
    // columns are currently ignored
    // choices should be a list of objects with a name field, like: {name: "test", other: "???}
    function openListChoiceDialog(initialChoice, choices, columns, dialogTitle, dialogOKButtonLabel, isNewAllowed, dialogOKCallback) {
        if (!dialogTitle)
            dialogTitle = "Choices";
        if (!dialogOKButtonLabel)
            dialogOKButtonLabel = "Choose";
        var dialogConfiguration = {
            key: "standardListChooser",
            initialChoice: initialChoice,
            choices: choices,
            columns: columns,
            dialogTitle: dialogTitle,
            dialogOKButtonLabel: dialogOKButtonLabel,
            dialogOKCallback: dialogOKCallback,
            dialogConstructionFunction: build_listChooserDialogContent,
            dialogOKButtonHidden: true,
            isNewAllowed: isNewAllowed
        };
        openDialog(dialogConfiguration);
    }
    exports.openListChoiceDialog = openListChoiceDialog;
    function build_listChooserDialogContent(dialogConfiguration, hideDialogMethod) {
        function selectionMade(args, choice) {
            hideDialogMethod();
            args.dialogOKCallback(choice);
        }
        function makeNewListItem(args, choice) {
            // TODO: Translate
            var name = prompt("New project name?");
            if (!name)
                return;
            hideDialogMethod();
            args.dialogOKCallback({ id: name, name: name, isNew: true });
        }
        // style: "min-height: 400px; min-width: 600px; max-height: 800px; max-width: 800px; overflow: auto"
        return [
            dialogConfiguration.dialogOKButtonLabel,
            m("br"),
            dialogConfiguration.choices.sort(function (a, b) { return a.name.localeCompare(b.name); }).map(function (choice) {
                return [
                    m("button", { onclick: selectionMade.bind(null, dialogConfiguration, choice) }, choice.name), m("br")
                ];
            }),
            m("br"),
            dialogConfiguration.isNewAllowed ?
                m("button", { onclick: makeNewListItem.bind(null, dialogConfiguration) }, "[Make new project]")
                :
                    m("div")
        ];
    }
});

define('js/applicationWidgets/ClusteringDiagram',["require", "exports", "d3", "../pointrel20150417/generateRandomUuid", "../panelBuilder/dialogSupport", "mithril", "../Globals"], function (require, exports, d3, generateRandomUuid, dialogSupport, m, Globals) {
    "use strict";
    "use strict";
    // TODO: Make a systemic communications fix to PointrelClient so can stop using Math.round to ensure x and y are integers to avoid JSON conversion errors and sha256 error in WordPress plugin due to PHP and numeric precision (2015-10-08)
    var defaultSurfaceWidthInPixels = 800;
    var defaultSurfaceHeightInPixels = 500;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // support functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // TODO: Unfortunate mix of canvas into an SVG app
    // Only straightforward way (without Dojo gfx) to get the text width, given the page may be hidden while making this, which causes text width to return 0 for SVG
    // Could not get other approaches of adding measuring div to dom to work, perhaps because top level body CSS styling
    // From: http://stackoverflow.com/questions/118241/calculate-text-width-with-javascript
    var measuringCanvas;
    function getTextWidth(text, textStyle) {
        // re-use canvas object for better performance
        var canvas = measuringCanvas || (measuringCanvas = document.createElement("canvas"));
        var context = canvas.getContext("2d");
        context.font = "normal normal " + textStyle.weight + " " + textStyle.size + " " + textStyle.family;
        var metrics = context.measureText(text);
        var result = metrics.width;
        return result;
    }
    function myWrap(text, itemText, textStyle, textColor, maxWidth) {
        var lineHeight_em = 1.1;
        var words = itemText.split(/\s+/);
        var lines = [];
        var line = "";
        forEach(words, function (index, word) {
            if (lines.length >= 5) {
                line = "...";
                return;
            }
            if (line === "") {
                line = word;
            }
            else if (getTextWidth(line + " " + word, textStyle) < maxWidth) {
                line += " " + word;
            }
            else {
                lines.push(line);
                line = word;
            }
        });
        if (line !== "")
            lines.push(line);
        var lineNumber = (Math.round(-lines.length / 2 + 0.5));
        forEach(lines, function (index, line) {
            var tspan = text.append("tspan")
                .attr("x", 0)
                .attr("y", 0)
                .attr("dy", (lineNumber++) * lineHeight_em + "em")
                .text(line)
                .style("fill", textColor);
        });
    }
    // Caution: "this" may be undefined for functions called by this unless "bind" or "hitch" is used
    function forEach(theArray, theFunction) {
        if (!theArray) {
            console.log("theArray is invalid", theArray);
        }
        for (var index = 0, length_1 = theArray.length; index < length_1; ++index) {
            theFunction(index, theArray[index], theArray);
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // clustering diagram
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    var ClusteringDiagram = (function () {
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // constructor
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        function ClusteringDiagram(configuration, storageFunction, autosave) {
            this.model = null;
            this.project = Globals.project();
            this.mainButtons = [];
            this.autosave = false;
            this.lastSelectedItem = null;
            this.divForResizing = null;
            this._mainSurface = null;
            this.mainSurface = null;
            this.itemToDisplayObjectMap = {};
            this.d3DivForResizing = null;
            this.doThingsSelectID = generateRandomUuid("doThingsSelect_");
            this.background = null;
            this.showStrengthColors = true;
            this.selectionRect = null;
            this.selectionRectUUID = generateRandomUuid("selectionRect_");
            this.parentChildLinesGroup = null;
            this.parentChildLinesUUID = generateRandomUuid("parentChildLines_");
            this.selectedItems = [];
            this.rubberBanding = false;
            this.shiftKeyIsBeingHeldDownWhileRubberBanding = false;
            this.rubberBandingStartX = 0;
            this.rubberBandingStartY = 0;
            this.showEntryDialog = false;
            this.itemBeingEdited = null;
            this.itemBeingEditedCopy = null;
            this.isEditedItemNew = false;
            this.showSurfaceSizeDialog = false;
            this.surfaceWidthBeingEdited = 0;
            this.surfaceHeightBeingEdited = 0;
            this.showReorderDialog = false;
            this.configuration = configuration;
            this.useContext = (this.configuration === "interpretations" || this.configuration === "observations") ? "catalysis" : "planning";
            this.storageFunction = storageFunction;
            this.autosave = autosave;
            this.model = storageFunction();
            if (!this.model) {
                this.model = ClusteringDiagram.newDiagramModel();
            }
            this.setupOptionsAndButtons();
            this.setupMainSurface();
        }
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // static functions - These functions are static so other code can create and store diagram contents directly as source
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ClusteringDiagram.newDiagramModel = function () {
            return {
                surfaceWidthInPixels: defaultSurfaceWidthInPixels,
                surfaceHeightInPixels: defaultSurfaceHeightInPixels,
                items: [],
                changesCount: 0
            };
        };
        ClusteringDiagram.newItem = function (itemType, name, notes, x, y) {
            if (itemType === void 0) { itemType = "item"; }
            if (name === void 0) { name = ""; }
            if (notes === void 0) { notes = ""; }
            if (x === void 0) { x = ClusteringDiagram.initialDisplacement; }
            if (y === void 0) { y = ClusteringDiagram.initialDisplacement; }
            var item = {
                uuid: generateRandomUuid("ClusteringDiagramItem"),
                "type": itemType,
                name: name,
                notes: notes,
                x: Math.round(x),
                y: Math.round(y)
            };
            return item;
        };
        ClusteringDiagram.bumpXYOfItem = function (item) {
            ClusteringDiagram.bumpedItemCount++;
            item.x = Math.round(item.x + (ClusteringDiagram.bumpedItemCount * ClusteringDiagram.bumpXShiftPerItem) % ClusteringDiagram.bumpXRange);
            item.y = Math.round(item.y + (ClusteringDiagram.bumpedItemCount / 10 * ClusteringDiagram.bumpYShiftPerItem) % ClusteringDiagram.bumpYRange);
        };
        ClusteringDiagram.addNewItemToDiagram = function (diagram, itemType, name, notes) {
            if (notes === void 0) { notes = ""; }
            var item = ClusteringDiagram.newItem(itemType, name, notes);
            ClusteringDiagram.bumpXYOfItem(item);
            diagram.items.push(item);
            diagram.changesCount++;
            return item;
        };
        ClusteringDiagram.controller = function (args) {
            return new ClusteringDiagram(args.configuration, args.storageFunction, args.autosave);
        };
        ClusteringDiagram.view = function (controller, args) {
            return controller.calculateView(args);
        };
        ClusteringDiagram.calculateClusteringForDiagram = function (clusteringDiagram) {
            var result = [];
            if (!clusteringDiagram)
                return result;
            var clusters = clusteringDiagram.items.filter(function (item) { return item.type === "cluster"; });
            var items = clusteringDiagram.items.filter(function (item) { return item.type === "item"; });
            items.forEach(function (item) {
                item.clusterDistance = Number.MAX_VALUE;
                item.cluster = null;
                clusters.forEach(function (cluster) {
                    var dx = item.x - cluster.x;
                    var dy = item.y - cluster.y;
                    var distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < item.clusterDistance) {
                        item.clusterDistance = distance;
                        item.cluster = cluster;
                    }
                });
            });
            clusters.forEach(function (cluster) {
                cluster.items = [];
                items.forEach(function (item) {
                    if (item.cluster === cluster)
                        cluster.items.push(item);
                });
            });
            return [clusters, items];
        };
        ClusteringDiagram.setItemColorBasedOnStrength = function (item, strength) {
            switch (strength) {
                case "3 (strong)":
                    item.bodyColor = ClusteringDiagram.itemColor_strong;
                    break;
                case "2 (medium)":
                    item.bodyColor = ClusteringDiagram.itemColor_medium;
                    break;
                case "1 (weak)":
                    item.bodyColor = ClusteringDiagram.itemColor_weak;
                    break;
                default:
                    item.bodyColor = ClusteringDiagram.itemColor_unassigned;
            }
        };
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // starting up
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ClusteringDiagram.prototype.configSurface = function (element, isInitialized, context) {
            if (!isInitialized) {
                element.appendChild(this.divForResizing);
            }
        };
        ClusteringDiagram.prototype.setupMainSurface = function () {
            var _this = this;
            var divForResizing = document.createElement("div");
            this.divForResizing = divForResizing;
            var divUUID = generateRandomUuid("ResizeableCanvasHolder");
            divForResizing.setAttribute("id", divUUID);
            //divForResizing.setAttribute("style", "width: " + this.diagram.surfaceWidthInPixels + "px; height: " + this.diagram.surfaceHeightInPixels + "px; border: solid 1px; position: relative");
            //divForResizing.setAttribute("style", "resize: auto; border: solid 1px");
            var width = this.model.surfaceWidthInPixels;
            var height = this.model.surfaceHeightInPixels;
            this.d3DivForResizing = d3.select(divForResizing);
            this._mainSurface = this.d3DivForResizing.append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('class', 'clustering');
            this.background = this._mainSurface.append("rect")
                .attr('width', "100%")
                .attr('height', "100%")
                .attr('class', 'clusteringDiagramBackground')
                .style('fill', 'white')
                .style('stroke-width', '3')
                .style('stroke', '#a7a5a5')
                .on("mousedown", function () {
                _this.shiftKeyIsBeingHeldDownWhileRubberBanding = d3.event.shiftKey;
            });
            var drag = d3.behavior.drag();
            var self = this;
            drag.on("dragstart", function () {
                var position = d3.mouse(this);
                self.rubberBanding = true;
                self.rubberBandingStartX = position[0];
                self.rubberBandingStartY = position[1];
                d3.select("." + self.selectionRectUUID)
                    .attr('rx', 6) // this makes a rounded rectangle
                    .attr('ry', 6)
                    .transition()
                    .duration(1)
                    .style('stroke', "black")
                    .style('fill', 'none')
                    .style('stroke-width', 2);
            });
            drag.on("drag", function () {
                if (self.rubberBanding) {
                    var position = d3.mouse(this);
                    d3.select("." + self.selectionRectUUID)
                        .transition()
                        .duration(1)
                        .attr('rx', 6)
                        .attr('ry', 6)
                        .attr('transform', 'translate (' + Math.min(self.rubberBandingStartX, position[0]) + ", " + Math.min(self.rubberBandingStartY, position[1]) + ")")
                        .attr('width', Math.abs(position[0] - self.rubberBandingStartX))
                        .attr('height', Math.abs(position[1] - self.rubberBandingStartY))
                        .style('stroke', "black")
                        .style('fill', 'none')
                        .style('stroke-width', 2);
                }
            });
            drag.on("dragend", function () {
                var position = d3.mouse(this);
                self.selectItemsInRectangle(self.rubberBandingStartX, self.rubberBandingStartY, position[0], position[1], self.shiftKeyIsBeingHeldDownWhileRubberBanding);
                self.rubberBanding = false;
                self.shiftKeyIsBeingHeldDownWhileRubberBanding = false;
                d3.select("." + self.selectionRectUUID)
                    .style('stroke', "none")
                    .attr('transform', 'translate (0, 0)')
                    .attr('width', 0)
                    .attr('height', 0);
            });
            this.background.call(drag);
            this.mainSurface = this._mainSurface.append('g').attr('class', 'mainSurface');
            this.recreateDisplayObjectsForAllItems();
        };
        ClusteringDiagram.prototype.setupOptionsAndButtons = function () {
            var thingsYouCanDo;
            if (this.useContext === "planning") {
                thingsYouCanDo = [
                    "Create new answer",
                    "Create new cluster name",
                    "Edit selected answer or cluster name",
                    "Delete selected answer or cluster name",
                    "Resize clustering space",
                    "Edit answers and clusters in JSON format"
                ];
            }
            else if (this.useContext === "catalysis") {
                thingsYouCanDo = [
                    "Create new cluster name",
                    "Edit selected cluster name",
                    "Delete selected cluster name",
                    "Show/hide selected item/cluster in report",
                    "Change cluster print order",
                    "Resize clustering space",
                    "Toggle observation strength colors"
                ];
            }
            var selectOptions = [];
            thingsYouCanDo.forEach(function (thing, index) { selectOptions.push(m("option", { value: thing, selected: undefined }, thing)); });
            this.mainButtons.push(m("select.narrafirma-clustering-diagram-do-things-select", { id: this.doThingsSelectID }, selectOptions));
            var self = this; // must copy "this" because "this" inside an event handler is the DOM element
            this.mainButtons.push(m("button", { onclick: function () { self.doThing(self.doThingsSelectID); } }, m("span", { class: "buttonWithTextImage doItButtonImage" }), "Do it"));
            if (!this.autosave) {
                this.mainButtons.push(m("button.narrafirma-clustering-diagram-save-changes", { onclick: function () { self.saveChanges(); } }, "Save changes"));
            }
        };
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // data handling
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ClusteringDiagram.prototype.newItem = function (itemType, name, notes) {
            if (itemType === void 0) { itemType = "item"; }
            if (name === void 0) { name = ""; }
            if (notes === void 0) { notes = ""; }
            var newItem = ClusteringDiagram.newItem(itemType, name, notes);
            ClusteringDiagram.bumpXYOfItem(newItem);
            return newItem;
        };
        ClusteringDiagram.prototype.saveChanges = function () {
            this.storageFunction(this.model);
        };
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // drawing
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ClusteringDiagram.prototype.calculateView = function (args) {
            // Make sure the model is up to date
            // this seems wasteful but there is no other way to be sure you have the latest data
            this.updateDiagram(this.storageFunction());
            var entryDialog = [];
            if (this.showEntryDialog) {
                entryDialog.push(this.buildEntryDialog());
            }
            var surfaceSizeDialog = [];
            if (this.showSurfaceSizeDialog) {
                surfaceSizeDialog.push(this.buildSurfaceSizeDialog());
            }
            var reorderDialog = [];
            if (this.showReorderDialog) {
                reorderDialog.push(this.buildReorderDialog());
            }
            this.model.items.forEach(function (item) {
                var displayObject = this.itemToDisplayObjectMap[item.uuid];
                if (displayObject) {
                    var borderWidth = (this.selectedItems.indexOf(item) >= 0) ? displayObject.borderWidth * 5 : displayObject.borderWidth;
                    displayObject.circle.style("stroke-width", borderWidth);
                }
            }, this);
            return m("div", [
                m("div.narrafirma-clustering-surface", { config: this.configSurface.bind(this) }),
                this.mainButtons,
                entryDialog,
                surfaceSizeDialog,
                reorderDialog
            ]);
        };
        ClusteringDiagram.prototype.addDisplayObjectForItem = function (surface, item) {
            var _this = this;
            var bodyColor = item.bodyColor;
            if (!bodyColor || !this.showStrengthColors) {
                if (item.type === "cluster") {
                    bodyColor = ClusteringDiagram.defaultClusterBodyColor;
                }
                else {
                    bodyColor = ClusteringDiagram.defaultItemBodyColor;
                }
            }
            if (item.hidden) {
                bodyColor = "white";
            }
            var textColor = item.textColor;
            if (!textColor)
                textColor = ClusteringDiagram.defaultTextColor;
            var borderColor = item.borderColor;
            if (!borderColor)
                borderColor = ClusteringDiagram.defaultBorderColor;
            var borderWidth = item.borderWidth;
            if (!borderWidth)
                borderWidth = ClusteringDiagram.defaultBorderWidth;
            var radius = item.radius;
            if (!radius)
                radius = ClusteringDiagram.defaultRadius;
            var textStyle = item.textStyle;
            if (!textStyle)
                textStyle = ClusteringDiagram.defaultTextStyle;
            if (item.type === "cluster") {
                textStyle.weight = "bold";
            }
            else {
                textStyle.weight = "normal";
            }
            var group;
            group = surface.append('g')
                .attr('transform', 'translate(' + item.x + ',' + item.y + ')')
                .attr('class', 'item');
            // TODO: Does this work with SVG elements? Are they really D3 selections? Or maybe could also map data to element with D3?
            group.item = item;
            if (item.type === "cluster") {
                var clusterCircle = group.append("circle")
                    .attr("r", radius)
                    .attr("cx", 0)
                    .attr("cy", 0)
                    .style("cursor", "pointer")
                    .style("fill", bodyColor)
                    .style("opacity", 0.8)
                    .style("stroke", borderColor)
                    .style("stroke-width", borderWidth);
                group.circle = clusterCircle;
            }
            else {
                var itemCircle = group.append("circle")
                    .attr("r", radius)
                    .attr("cx", 0)
                    .attr("cy", 0)
                    .style("cursor", "pointer")
                    .style("fill", bodyColor)
                    .style("opacity", 0.8)
                    .style("stroke", borderColor)
                    .style("stroke-width", borderWidth);
                group.circle = itemCircle;
            }
            group.borderColor = borderColor;
            group.borderWidth = borderWidth;
            var textToShow = item.name;
            if (item.order)
                textToShow = item.order + ". " + item.name;
            if (!textToShow)
                textToShow = item.notes.split(" ").slice(0, 10).join(" ") + " ...";
            this.addText(group, textToShow, radius * 1.5, textStyle, textColor);
            var hoverText = item.name;
            if (item.hidden)
                hoverText += ' (hidden)';
            if (item.notes)
                hoverText += " -- " + item.notes;
            if (item.notesExtra)
                hoverText += "\n---\nObservation: " + item.notesExtra;
            if (item.strength)
                hoverText += " [Strength: " + item.strength + "]";
            group.append("title").text(hoverText);
            group.on("mousedown", function () {
                _this.selectItem(item, d3.event.shiftKey);
            });
            var self = this;
            var drag = d3.behavior.drag();
            var moved = false;
            function drawParentChildLines(item) {
                var parentOrChildren = [];
                if (item.type === "item") {
                    var closestCluster = self.closestClusterToItem(item);
                    if (closestCluster)
                        parentOrChildren.push(closestCluster);
                }
                else {
                    var closestItems = self.itemsClosestToCluster(item);
                    if (closestItems.length)
                        parentOrChildren = parentOrChildren.concat(closestItems);
                }
                self.parentChildLinesGroup.selectAll("*").remove();
                parentOrChildren.forEach(function (parentOrChild) {
                    self.parentChildLinesGroup.append('line')
                        .style("stroke", "black")
                        .style("stroke-width", 1)
                        .style("stroke-dasharray", 4)
                        .style("opacity", 1.0)
                        .attr("x1", item.x)
                        .attr("y1", item.y)
                        .attr("x2", parentOrChild.x)
                        .attr("y2", parentOrChild.y);
                });
            }
            drag.on("dragstart", function () {
                if (!item) {
                    self.rubberBanding = true;
                    self.rubberBandingStartX = d3.event.x;
                    self.rubberBandingStartY = d3.event.y;
                }
                drawParentChildLines(item);
                moved = false;
            });
            drag.on("drag", function () {
                // TODO: Casting to any as workaround to silence TypeScript error for maybe incomplete d3 typing file
                //item.x = Math.round(item.x + (<any>d3.event).dx);
                //item.y = Math.round(item.y + (<any>d3.event).dy);
                //group.attr('transform', 'translate(' + item.x + ',' + item.y + ')');
                self.selectedItems.forEach(function (item) {
                    item.x = Math.min(self.model.surfaceWidthInPixels, Math.max(0, Math.round(item.x + d3.event.dx)));
                    item.y = Math.min(self.model.surfaceHeightInPixels, Math.max(0, Math.round(item.y + d3.event.dy)));
                    var displayObject = self.itemToDisplayObjectMap[item.uuid];
                    if (displayObject)
                        displayObject.attr('transform', 'translate(' + item.x + ',' + item.y + ')');
                    drawParentChildLines(item);
                });
                moved = true;
            });
            drag.on("dragend", function () {
                self.parentChildLinesGroup.selectAll("*").remove();
                if (moved && item)
                    self.incrementChangesCount();
            });
            group.call(drag);
            group.on("dblclick", function () {
                if (_this.useContext === "planning") {
                    self.openEntryDialog(item, true);
                }
                else if (_this.useContext === "catalysis") {
                    if (item.type === "cluster")
                        self.openEntryDialog(item, true);
                }
                m.redraw();
            });
            this.itemToDisplayObjectMap[item.uuid] = group;
            return group;
        };
        ClusteringDiagram.prototype.addText = function (group, itemText, maxWidth, textStyle, textColor) {
            if (itemText === undefined)
                itemText = "[missing text]";
            var text = group.append("text")
                .style("cursor", "pointer")
                .style("font-family", textStyle.family)
                .style("font-size", textStyle.size)
                .style("font-weight", textStyle.weight)
                .style("text-anchor", "middle");
            myWrap(text, itemText, textStyle, textColor, maxWidth);
        };
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // selecting and deselecting items 
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ClusteringDiagram.prototype.selectItem = function (item, shift) {
            if (shift === void 0) { shift = false; }
            if (shift) {
                if (item) {
                    this.lastSelectedItem = item;
                    var itemIndex = this.selectedItems.indexOf(item);
                    if (itemIndex < 0) {
                        this.selectedItems.push(item);
                    }
                    else {
                        this.selectedItems.splice(itemIndex, 1);
                    }
                }
                else {
                    this.lastSelectedItem = item;
                    this.selectedItems = [];
                }
            }
            else {
                if (item) {
                    if (this.selectedItems.length <= 1) {
                        this.lastSelectedItem = item;
                        this.selectedItems = [];
                        this.selectedItems.push(item);
                    }
                }
                else {
                    this.lastSelectedItem = item;
                    this.selectedItems = [];
                }
            }
            // Queue redrawing as this was selected via D3 not Mithril
            m.redraw();
        };
        ClusteringDiagram.prototype.clearSelection = function () {
            this.selectItem(null);
        };
        ClusteringDiagram.prototype.selectItemsInRectangle = function (x1, y1, x2, y2, shift) {
            if (!shift)
                this.selectedItems = [];
            this.model.items.forEach(function (item) {
                if (item.x >= Math.min(x1, x2) && item.x < Math.max(x1, x2) && item.y >= Math.min(y1, y2) && item.y < Math.max(y1, y2)) {
                    if (this.selectedItems.indexOf(item) < 0) {
                        this.selectedItems.push(item);
                    }
                }
            }, this);
            m.redraw();
        };
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // updating the diagram for changes
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ClusteringDiagram.prototype.incrementChangesCount = function () {
            this.model.changesCount++;
            if (this.autosave) {
                this.saveChanges();
            }
        };
        ClusteringDiagram.prototype.acceptChangesForItemBeingEdited = function () {
            this.showEntryDialog = false;
            this.itemBeingEdited.name = this.itemBeingEditedCopy.name;
            // Ensure the item has a name
            // TODO: This allows duplicate names if items have been deleted
            if (!this.itemBeingEdited.name) {
                this.itemBeingEdited.name = "Untitled " + this.itemBeingEdited.type + " #" + (this.model.items.length + 1);
            }
            this.itemBeingEdited.notes = this.itemBeingEditedCopy.notes;
            this.itemBeingEdited.order = this.itemBeingEditedCopy.order;
            if (this.isEditedItemNew) {
                this.model.items.push(this.itemBeingEdited);
                this.addDisplayObjectForItem(this.mainSurface, this.itemBeingEdited);
            }
            else {
                this.updateDisplayForChangedItem(this.itemBeingEdited, "update");
            }
            this.incrementChangesCount();
            this.selectItem(this.itemBeingEdited);
        };
        ClusteringDiagram.prototype.acceptChangesToSurfaceSize = function () {
            this.showSurfaceSizeDialog = false;
            if (this.surfaceWidthBeingEdited !== this.model.surfaceWidthInPixels || this.surfaceHeightBeingEdited !== this.model.surfaceHeightInPixels) {
                this.model.surfaceWidthInPixels = this.surfaceWidthBeingEdited;
                this.model.surfaceHeightInPixels = this.surfaceHeightBeingEdited;
                this.incrementChangesCount(); // need to do this to save new surface size to the model
                this.updateSizeOfSurfaceFromModel();
            }
        };
        // typeOfChange should be either "delete" or "update"
        ClusteringDiagram.prototype.updateDisplayForChangedItem = function (item, typeOfChange) {
            if (item === null) {
                console.log("updateDisplayForChangedItem item is null", typeOfChange);
                return;
            }
            var displayObject = this.itemToDisplayObjectMap[item.uuid];
            if (typeOfChange === "delete") {
                delete this.itemToDisplayObjectMap[item.uuid];
                displayObject.remove();
                return;
            }
            displayObject.remove();
            var newDisplayObject = this.addDisplayObjectForItem(this.mainSurface, item);
            this.itemToDisplayObjectMap[item.uuid] = newDisplayObject;
        };
        ClusteringDiagram.prototype.updateDiagram = function (newDiagram) {
            if (!newDiagram)
                return;
            if (this.model.changesCount === newDiagram.changesCount) {
                // Optimize out reflections of our changes back to us if the diagrams are the same
                // Extra cautious to compare JSON; otherwise probably could just return
                if (JSON.stringify(this.model) === JSON.stringify(newDiagram)) {
                    // console.log("updateDiagram: new diagram seems identical to the old; not updating");
                    return;
                }
            } // else {
            // console.log("updateDiagram: changes counts do not match", this.diagram.changesCount, newDiagram.changesCount);
            // }
            this.model = newDiagram;
            this.recreateDisplayObjectsForAllItems();
            this.clearSelection();
            this.updateSizeOfSurfaceFromModel();
        };
        ClusteringDiagram.prototype.recreateDisplayObjectsForAllItems = function () {
            this.itemToDisplayObjectMap = {};
            this.mainSurface.selectAll("*").remove();
            this.selectionRect = this.mainSurface.append('rect').attr('class', this.selectionRectUUID);
            this.parentChildLinesGroup = this.mainSurface.append('g').attr('class', this.parentChildLinesUUID);
            this.model.items.forEach(function (item) { this.addDisplayObjectForItem(this.mainSurface, item); }, this);
        };
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // things you can do
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ClusteringDiagram.prototype.doThing = function (selectID) {
            var select = document.getElementById(selectID);
            if (!select) {
                var message = 'Error: Cannot find drop-down list box with id "' + selectID + '" on HTML page. Please report this error.';
                alert(message);
                console.error(message);
                return;
            }
            var choice = select.value;
            switch (choice) {
                case "Create new answer":// planning
                    this.createNewItem();
                    break;
                case "Create new cluster name":// either
                    this.createNewClusterName();
                    break;
                case "Edit selected answer or cluster name":// planning
                    this.editSelectedItemOrCluster();
                    break;
                case "Edit selected cluster name":// catalysis
                    this.editSelectedCluster();
                    break;
                case "Delete selected answer or cluster name":// planning
                    this.deleteSelectedItemOrCluster();
                    break;
                case "Delete selected cluster name":// catalysis
                    this.deleteSelectedCluster();
                    break;
                case "Show/hide selected item/cluster in report":// catalysis
                    this.showOrHideItemOrClusterInReport();
                    break;
                case "Change cluster print order":// catalysis
                    this.openReorderDialog();
                    break;
                case "Resize clustering space":// either
                    this.openSurfaceSizeDialog();
                    break;
                case "Toggle observation strength colors":// catalysis
                    this.toggleStrengthColors();
                    break;
                case "Edit answers and clusters in JSON format":// planning
                    this.openSourceDialog(JSON.stringify(this.model, null, 2));
                    break;
                default:
                    alert("Please choose an action from the list before you click the button.");
                    break;
            }
        };
        ClusteringDiagram.prototype.createNewItem = function () {
            var aNewItem = this.newItem("item");
            this.openEntryDialog(aNewItem, false);
        };
        ClusteringDiagram.prototype.createNewClusterName = function () {
            var aNewClusterName = this.newItem("cluster");
            this.openEntryDialog(aNewClusterName, false);
        };
        ClusteringDiagram.prototype.editSelectedItemOrCluster = function () {
            if (this.lastSelectedItem) {
                this.openEntryDialog(this.lastSelectedItem, true);
            }
            else {
                alert("Please select an answer or cluster name to edit.");
            }
        };
        ClusteringDiagram.prototype.editSelectedCluster = function () {
            if (this.lastSelectedItem && this.lastSelectedItem.type === "cluster") {
                this.openEntryDialog(this.lastSelectedItem, true);
            }
            else {
                alert("Please select a cluster name to edit.");
            }
        };
        ClusteringDiagram.prototype.deleteSelectedItemOrCluster = function () {
            var _this = this;
            if (!this.lastSelectedItem) {
                alert("Please select an answer or cluster name to delete.");
                return;
            }
            var itemOrCluster = this.lastSelectedItem.type === "cluster" ? "cluster" : "item";
            dialogSupport.confirm("Are you sure you want to delete the " + itemOrCluster + " called '" + this.lastSelectedItem.name + "'?", function () {
                _this.updateDisplayForChangedItem(_this.lastSelectedItem, "delete");
                var itemIndex = _this.model.items.indexOf(_this.lastSelectedItem);
                if (itemIndex >= 0) {
                    _this.model.items.splice(itemIndex, 1);
                }
                _this.clearSelection();
                _this.incrementChangesCount();
            });
        };
        ClusteringDiagram.prototype.deleteSelectedCluster = function () {
            var _this = this;
            if (!this.lastSelectedItem || this.lastSelectedItem.type != "cluster") {
                alert("Please select a cluster name to delete.");
                return;
            }
            dialogSupport.confirm("Are you sure you want to delete the cluster name '" + this.lastSelectedItem.name + "'?", function () {
                _this.updateDisplayForChangedItem(_this.lastSelectedItem, "delete");
                var itemIndex = _this.model.items.indexOf(_this.lastSelectedItem);
                if (itemIndex >= 0) {
                    _this.model.items.splice(itemIndex, 1);
                }
                _this.clearSelection();
                _this.incrementChangesCount();
            });
        };
        ClusteringDiagram.prototype.showOrHideItemOrClusterInReport = function () {
            var _this = this;
            if (this.selectedItems.length > 0) {
                this.selectedItems.forEach(function (item) {
                    if (item.hidden === undefined)
                        item.hidden = false;
                    item.hidden = !item.hidden;
                    _this.updateDisplayForChangedItem(item, "update");
                    if (item.type === "cluster") {
                        var itemsClosestToThisCluster = _this.itemsClosestToCluster(item);
                        itemsClosestToThisCluster.forEach(function (clusteredItem) {
                            clusteredItem.hidden = item.hidden;
                            _this.updateDisplayForChangedItem(clusteredItem, "update");
                        });
                    }
                    _this.incrementChangesCount();
                });
            }
            else {
                alert("Please select at least one item or cluster to show or hide.");
            }
        };
        ClusteringDiagram.prototype.itemsClosestToCluster = function (clusterToCheck) {
            var _this = this;
            var clusters = this.model.items.filter(function (item) { return item.type === "cluster"; });
            var items = this.model.items.filter(function (item) { return item.type === "item"; });
            var result = [];
            items.forEach(function (item) {
                var closestCluster = _this.closestClusterToItem(item);
                if (closestCluster.name === clusterToCheck.name)
                    result.push(item);
            });
            return result;
        };
        ClusteringDiagram.prototype.closestClusterToItem = function (item) {
            var clusters = this.model.items.filter(function (item) { return item.type === "cluster"; });
            var smallestDistanceToACluster = Number.MAX_VALUE;
            var closestCluster = null;
            for (var i = 0; i < clusters.length; i++) {
                var cluster = clusters[i];
                var dx = item.x - cluster.x;
                var dy = item.y - cluster.y;
                var distanceToThisCluster = Math.sqrt(dx * dx + dy * dy);
                if (distanceToThisCluster < smallestDistanceToACluster) {
                    smallestDistanceToACluster = distanceToThisCluster;
                    closestCluster = cluster;
                }
            }
            return closestCluster;
        };
        ClusteringDiagram.prototype.toggleStrengthColors = function () {
            this.showStrengthColors = !this.showStrengthColors;
            this.recreateDisplayObjectsForAllItems();
        };
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // pop-up dialogs
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ClusteringDiagram.prototype.openSurfaceSizeDialog = function () {
            this.surfaceWidthBeingEdited = this.model.surfaceWidthInPixels;
            this.surfaceHeightBeingEdited = this.model.surfaceHeightInPixels;
            this.showSurfaceSizeDialog = true;
        };
        ClusteringDiagram.prototype.buildSurfaceSizeDialog = function () {
            var _this = this;
            var selectOptionsRaw = ["400", "450", "500", "550", "600", "650", "700", "750", "800", "850", "900", "950", "1000", "1050", "1100", "1150", "1200", "1250", "1300", "1350", "1400", "1450", "1500", "1550", "1600", "1650", "1700", "1750", "1800", "1850", "1900", "1950", "2000"];
            var widthOptions = selectOptionsRaw.map(function (option, index) {
                return m("option", { value: option, selected: parseInt(option) === _this.model.surfaceWidthInPixels }, option);
            });
            var heightOptions = selectOptionsRaw.map(function (option, index) {
                return m("option", { value: option, selected: parseInt(option) === _this.model.surfaceHeightInPixels }, option);
            });
            return m("div.overlay", m("div.modal-content", { "style": "width: 30%" }, [
                "Choose a new width and height for the clustering surface.",
                m("br"),
                m("br"),
                m('label', { for: "sizeDialog_width", style: "margin-right: 0.5em" }, "Width:"),
                m("select", {
                    id: "sizeDialog_width",
                    // the reason to do this is because this redraw method is called WHILE the user is holding down the OK button
                    // during which time these two numbers do not agree, so the old value was flickering into view
                    value: this.showSurfaceSizeDialog ? this.surfaceWidthBeingEdited : this.model.surfaceWidthInPixels,
                    onchange: function (event) {
                        var newWidth = parseInt(event.target.value.trim(), 10);
                        if (newWidth)
                            _this.surfaceWidthBeingEdited = newWidth;
                    },
                }, widthOptions),
                m('br'),
                m('br'),
                m('label', { for: "sizeDialog_height", style: "margin-right: 0.5em" }, "Height:"),
                m("select", {
                    id: "sizeDialog_height",
                    value: this.showSurfaceSizeDialog ? this.surfaceHeightBeingEdited : this.model.surfaceHeightInPixels,
                    onchange: function (event) {
                        var newHeight = parseInt(event.target.value.trim(), 10);
                        if (newHeight)
                            _this.surfaceHeightBeingEdited = newHeight;
                    }
                }, heightOptions),
                m("br"),
                m("br"),
                m("button", { onclick: function () { _this.showSurfaceSizeDialog = false; } }, "Cancel"),
                m("button", { onclick: function () { _this.acceptChangesToSurfaceSize(); } }, "OK")
            ]));
        };
        ClusteringDiagram.prototype.openReorderDialog = function () {
            this.showReorderDialog = true;
        };
        ClusteringDiagram.prototype.buildReorderDialog = function () {
            if (!this.model)
                return m("div");
            var clusters = this.model.items.filter(function (item) { return item.type === "cluster"; });
            var atLeastOneClusterHasNoOrderValueSet = false;
            clusters.sort(function (a, b) {
                if (a.order && b.order) {
                    return (a.order > b.order) ? 1 : -1;
                }
                else {
                    atLeastOneClusterHasNoOrderValueSet = true;
                    return (a > b) ? 1 : -1; // alphabetical
                }
            });
            if (atLeastOneClusterHasNoOrderValueSet) {
                clusters.forEach(function (cluster, index) { cluster.order = index + 1; });
            }
            var selectOptions = clusters.map(function (cluster) { return m("option", { value: cluster.name }, cluster.name); });
            var self = this;
            return m("div.overlay", m("div.modal-content", { "style": "width: 30%" }, [
                "Click the up and down arrows to reorder clusters.",
                m("br"),
                m("br"),
                m("select", { size: 10, id: "orderDialogSelect" }, selectOptions),
                m('br'),
                m("button", { onclick: function () { self.moveSelectedClusterUp(); } }, "↑"),
                m("button", { onclick: function () { self.moveSelectedClusterDown(); } }, "↓"),
                m("button", { onclick: function () { self.closeReorderDialog(); } }, "Close")
            ]));
        };
        ClusteringDiagram.prototype.moveSelectedClusterUp = function () {
            var element = document.getElementById("orderDialogSelect");
            if (!element || element.selectedIndex < 0 || element.selectedIndex - 1 < 0)
                return;
            var selectedOption = element.options[element.selectedIndex];
            var selectedCluster = this.clusterForName(selectedOption.value);
            var optionAboveSelectedOption = element.options[element.selectedIndex - 1];
            var clusterAboveSelectedCluster = this.clusterForName(optionAboveSelectedOption.value);
            var oldSelectedClusterOrder = selectedCluster.order;
            selectedCluster.order = clusterAboveSelectedCluster.order;
            clusterAboveSelectedCluster.order = oldSelectedClusterOrder;
            if (element.selectedIndex > 0)
                element.selectedIndex--;
            this.incrementChangesCount();
            this.recreateDisplayObjectsForAllItems();
        };
        ClusteringDiagram.prototype.moveSelectedClusterDown = function () {
            var element = document.getElementById("orderDialogSelect");
            if (!element || element.selectedIndex < 0 || element.selectedIndex + 1 > element.options.length - 1)
                return;
            var selectedOption = element.options[element.selectedIndex];
            var selectedCluster = this.clusterForName(selectedOption.value);
            var optionBelowSelectedOption = element.options[element.selectedIndex + 1];
            var clusterBelowSelectedCluster = this.clusterForName(optionBelowSelectedOption.value);
            var oldSelectedClusterOrder = selectedCluster.order;
            selectedCluster.order = clusterBelowSelectedCluster.order;
            clusterBelowSelectedCluster.order = oldSelectedClusterOrder;
            if (element.selectedIndex < element.options.length - 1)
                element.selectedIndex++;
            this.incrementChangesCount();
            this.recreateDisplayObjectsForAllItems();
        };
        ClusteringDiagram.prototype.clusterForName = function (name) {
            var matchingClusterNames = this.model.items.filter(function (item) { return item.type === "cluster" && item.name === name; });
            return (matchingClusterNames.length > 0) ? matchingClusterNames[0] : null;
        };
        ClusteringDiagram.prototype.closeReorderDialog = function () {
            this.showReorderDialog = false;
            this.recreateDisplayObjectsForAllItems();
        };
        ClusteringDiagram.prototype.openEntryDialog = function (item, isExistingItem) {
            this.itemBeingEdited = item;
            this.itemBeingEditedCopy = JSON.parse(JSON.stringify(item));
            this.isEditedItemNew = !isExistingItem;
            this.showEntryDialog = true;
        };
        ClusteringDiagram.prototype.buildEntryDialog = function () {
            var _this = this;
            var result = [];
            var createOrEdit = (this.isEditedItemNew) ? "New" : "Edit";
            result.push(createOrEdit + " " + this.itemBeingEditedCopy.type);
            result.push(m("br"));
            result.push(m("br"));
            result.push(m('label', { for: "itemDialog_name", style: "margin-right: 0.5em" }, "Name"));
            result.push(m('input[type=text]', {
                id: "itemDialog_name",
                // note: don't have to use config option here because itemBeingEditedCopy is a local copy of the data
                value: this.itemBeingEditedCopy.name || "",
                onchange: function (event) { _this.itemBeingEditedCopy.name = event.target.value; }
            }));
            result.push(m('br'));
            result.push(m('br'));
            result.push(m('label', { "for": "itemDialog_notes" }, "Notes:"));
            result.push(m("br"));
            result.push(m('textarea[class=narrafirma-textbox]', {
                id: "itemDialog_notes",
                value: this.itemBeingEditedCopy.notes || "",
                onchange: function (event) { _this.itemBeingEditedCopy.notes = event.target.value; }
            }));
            result.push(m("br"));
            result.push(m("br"));
            result.push(m("button", { onclick: function () { _this.showEntryDialog = false; } }, "Cancel"));
            result.push(m("button", { onclick: function () { _this.acceptChangesForItemBeingEdited(); } }, "OK"));
            return m("div.overlay", m("div.modal-content", { "style": "width: 40%" }, result));
        };
        ClusteringDiagram.prototype.updateSourceClicked = function (text, hideDialogMethod) {
            var newDiagram;
            try {
                newDiagram = JSON.parse(text);
            }
            catch (e) {
                alert("Problem parsing source\n" + e);
                return;
            }
            hideDialogMethod();
            this.updateDiagram(newDiagram);
            this.incrementChangesCount();
        };
        ClusteringDiagram.prototype.openSourceDialog = function (text) {
            dialogSupport.openTextEditorDialog(text, "#clusterDiagramSource_titleID|Clustering Diagram", "#clusterDiagramSource_okButtonID|OK", "Copy to Clipboard", this.updateSourceClicked.bind(this));
        };
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // resizing 
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ClusteringDiagram.prototype.updateSizeOfSurfaceFromResizeHandle = function () {
            var newWidth = this.divForResizing.clientWidth;
            var newHeight = this.divForResizing.clientHeight;
            this._mainSurface.attr("width", newWidth).attr("height", newHeight);
            this.background.attr('width', newWidth).attr('height', newHeight);
            this.model.surfaceWidthInPixels = newWidth;
            this.model.surfaceHeightInPixels = newHeight;
            this.incrementChangesCount();
        };
        ClusteringDiagram.prototype.updateSizeOfSurfaceFromModel = function () {
            var newWidth = this.model.surfaceWidthInPixels;
            var newHeight = this.model.surfaceHeightInPixels;
            this.divForResizing.setAttribute("style", "width: " + this.model.surfaceWidthInPixels + "px; height: " + this.model.surfaceHeightInPixels + "px; border: solid 1px; position: relative");
            this._mainSurface.attr("width", newWidth).attr("height", newHeight);
            this.background.attr('width', newWidth).attr('height', newHeight);
        };
        ClusteringDiagram.defaultItemBodyColor = "#bcbcbc";
        ClusteringDiagram.defaultClusterBodyColor = "#84c8ff";
        ClusteringDiagram.defaultBorderColor = "black";
        ClusteringDiagram.defaultBorderWidth = 1;
        ClusteringDiagram.defaultTextStyle = { family: "Arial", size: "9pt", weight: "normal" };
        ClusteringDiagram.defaultTextColor = "black";
        ClusteringDiagram.defaultRadius = 44;
        ClusteringDiagram.bumpedItemCount = 0;
        ClusteringDiagram.bumpXShiftPerItem = 50;
        ClusteringDiagram.bumpYShiftPerItem = 50;
        ClusteringDiagram.initialDisplacement = 100;
        ClusteringDiagram.bumpXRange = 400;
        ClusteringDiagram.bumpYRange = 400;
        ClusteringDiagram.itemColor_strong = "#ff9138";
        ClusteringDiagram.itemColor_medium = "#ffbb84";
        ClusteringDiagram.itemColor_weak = "#ffe5d1";
        ClusteringDiagram.itemColor_unassigned = "#bcbcbc";
        return ClusteringDiagram;
    }()); // end of the ClusteringDiagram class
    return ClusteringDiagram;
});

// jStat 1.4.3 from: https://github.com/jstat/jstat
/* Copyright (c) 2013 jStat

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

define('jstat',[],function() {
    
this.j$ = this.jStat = (function(Math, undefined) {

// For quick reference.
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

// Calculate correction for IEEE error
// TODO: This calculation can be improved.
function calcRdx(n, m) {
  var val = n > m ? n : m;
  return Math.pow(10,
                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));
}


var isArray = Array.isArray || function isArray(arg) {
  return toString.call(arg) === '[object Array]';
};


function isFunction(arg) {
  return toString.call(arg) === '[object Function]';
}


function isNumber(arg) {
  return typeof arg === 'number' && arg === arg;
}


// Converts the jStat matrix to vector.
function toVector(arr) {
  return concat.apply([], arr);
}


// The one and only jStat constructor.
function jStat() {
  return new jStat._init(arguments);
}


// TODO: Remove after all references in src files have been removed.
jStat.fn = jStat.prototype;


// By separating the initializer from the constructor it's easier to handle
// always returning a new instance whether "new" was used or not.
jStat._init = function _init(args) {
  var i;

  // If first argument is an array, must be vector or matrix.
  if (isArray(args[0])) {
    // Check if matrix.
    if (isArray(args[0][0])) {
      // See if a mapping function was also passed.
      if (isFunction(args[1]))
        args[0] = jStat.map(args[0], args[1]);
      // Iterate over each is faster than this.push.apply(this, args[0].
      for (i = 0; i < args[0].length; i++)
        this[i] = args[0][i];
      this.length = args[0].length;

    // Otherwise must be a vector.
    } else {
      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];
      this.length = 1;
    }

  // If first argument is number, assume creation of sequence.
  } else if (isNumber(args[0])) {
    this[0] = jStat.seq.apply(null, args);
    this.length = 1;

  // Handle case when jStat object is passed to jStat.
  } else if (args[0] instanceof jStat) {
    // Duplicate the object and pass it back.
    return jStat(args[0].toArray());

  // Unexpected argument value, return empty jStat object.
  // TODO: This is strange behavior. Shouldn't this throw or some such to let
  // the user know they had bad arguments?
  } else {
    this[0] = [];
    this.length = 1;
  }

  return this;
};
jStat._init.prototype = jStat.prototype;
jStat._init.constructor = jStat;


// Utility functions.
// TODO: for internal use only?
jStat.utils = {
  calcRdx: calcRdx,
  isArray: isArray,
  isFunction: isFunction,
  isNumber: isNumber,
  toVector: toVector
};


// Easily extend the jStat object.
// TODO: is this seriously necessary?
jStat.extend = function extend(obj) {
  var i, j;

  if (arguments.length === 1) {
    for (j in obj)
      jStat[j] = obj[j];
    return this;
  }

  for (i = 1; i < arguments.length; i++) {
    for (j in arguments[i])
      obj[j] = arguments[i][j];
  }

  return obj;
};


// Returns the number of rows in the matrix.
jStat.rows = function rows(arr) {
  return arr.length || 1;
};


// Returns the number of columns in the matrix.
jStat.cols = function cols(arr) {
  return arr[0].length || 1;
};


// Returns the dimensions of the object { rows: i, cols: j }
jStat.dimensions = function dimensions(arr) {
  return {
    rows: jStat.rows(arr),
    cols: jStat.cols(arr)
  };
};


// Returns a specified row as a vector
jStat.row = function row(arr, index) {
  return arr[index];
};


// Returns the specified column as a vector
jStat.col = function cols(arr, index) {
  var column = new Array(arr.length);
  for (var i = 0; i < arr.length; i++)
    column[i] = [arr[i][index]];
  return column;
};


// Returns the diagonal of the matrix
jStat.diag = function diag(arr) {
  var nrow = jStat.rows(arr);
  var res = new Array(nrow);
  for (var row = 0; row < nrow; row++)
    res[row] = [arr[row][row]];
  return res;
};


// Returns the anti-diagonal of the matrix
jStat.antidiag = function antidiag(arr) {
  var nrow = jStat.rows(arr) - 1;
  var res = new Array(nrow);
  for (var i = 0; nrow >= 0; nrow--, i++)
    res[i] = [arr[i][nrow]];
  return res;
};

// Transpose a matrix or array.
jStat.transpose = function transpose(arr) {
  var obj = [];
  var objArr, rows, cols, j, i;

  // Make sure arr is in matrix format.
  if (!isArray(arr[0]))
    arr = [arr];

  rows = arr.length;
  cols = arr[0].length;

  for (i = 0; i < cols; i++) {
    objArr = new Array(rows);
    for (j = 0; j < rows; j++)
      objArr[j] = arr[j][i];
    obj.push(objArr);
  }

  // If obj is vector, return only single array.
  return obj.length === 1 ? obj[0] : obj;
};


// Map a function to an array or array of arrays.
// "toAlter" is an internal variable.
jStat.map = function map(arr, func, toAlter) {
  var row, nrow, ncol, res, col;

  if (!isArray(arr[0]))
    arr = [arr];

  nrow = arr.length;
  ncol = arr[0].length;
  res = toAlter ? arr : new Array(nrow);

  for (row = 0; row < nrow; row++) {
    // if the row doesn't exist, create it
    if (!res[row])
      res[row] = new Array(ncol);
    for (col = 0; col < ncol; col++)
      res[row][col] = func(arr[row][col], row, col);
  }

  return res.length === 1 ? res[0] : res;
};


// Cumulatively combine the elements of an array or array of arrays using a function.
jStat.cumreduce = function cumreduce(arr, func, toAlter) {
  var row, nrow, ncol, res, col;

  if (!isArray(arr[0]))
    arr = [arr];

  nrow = arr.length;
  ncol = arr[0].length;
  res = toAlter ? arr : new Array(nrow);

  for (row = 0; row < nrow; row++) {
    // if the row doesn't exist, create it
    if (!res[row])
      res[row] = new Array(ncol);
    if (ncol > 0)
      res[row][0] = arr[row][0];
    for (col = 1; col < ncol; col++)
      res[row][col] = func(res[row][col-1], arr[row][col]);
  }
  return res.length === 1 ? res[0] : res;
};


// Destructively alter an array.
jStat.alter = function alter(arr, func) {
  return jStat.map(arr, func, true);
};


// Generate a rows x cols matrix according to the supplied function.
jStat.create = function  create(rows, cols, func) {
  var res = new Array(rows);
  var i, j;

  if (isFunction(cols)) {
    func = cols;
    cols = rows;
  }

  for (i = 0; i < rows; i++) {
    res[i] = new Array(cols);
    for (j = 0; j < cols; j++)
      res[i][j] = func(i, j);
  }

  return res;
};


function retZero() { return 0; }


// Generate a rows x cols matrix of zeros.
jStat.zeros = function zeros(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retZero);
};


function retOne() { return 1; }


// Generate a rows x cols matrix of ones.
jStat.ones = function ones(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retOne);
};


// Generate a rows x cols matrix of uniformly random numbers.
jStat.rand = function rand(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, Math.random);
};


function retIdent(i, j) { return i === j ? 1 : 0; }


// Generate an identity matrix of size row x cols.
jStat.identity = function identity(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retIdent);
};


// Tests whether a matrix is symmetric
jStat.symmetric = function symmetric(arr) {
  var issymmetric = true;
  var size = arr.length;
  var row, col;

  if (arr.length !== arr[0].length)
    return false;

  for (row = 0; row < size; row++) {
    for (col = 0; col < size; col++)
      if (arr[col][row] !== arr[row][col])
        return false;
  }

  return true;
};


// Set all values to zero.
jStat.clear = function clear(arr) {
  return jStat.alter(arr, retZero);
};


// Generate sequence.
jStat.seq = function seq(min, max, length, func) {
  if (!isFunction(func))
    func = false;

  var arr = [];
  var hival = calcRdx(min, max);
  var step = (max * hival - min * hival) / ((length - 1) * hival);
  var current = min;
  var cnt;

  // Current is assigned using a technique to compensate for IEEE error.
  // TODO: Needs better implementation.
  for (cnt = 0;
       current <= max;
       cnt++, current = (min * hival + step * hival * cnt) / hival) {
    arr.push((func ? func(current, cnt) : current));
  }

  return arr;
};


// TODO: Go over this entire implementation. Seems a tragic waste of resources
// doing all this work. Instead, and while ugly, use new Function() to generate
// a custom function for each static method.

// Quick reference.
var jProto = jStat.prototype;

// Default length.
jProto.length = 0;

// For internal use only.
// TODO: Check if they're actually used, and if they are then rename them
// to _*
jProto.push = Array.prototype.push;
jProto.sort = Array.prototype.sort;
jProto.splice = Array.prototype.splice;
jProto.slice = Array.prototype.slice;


// Return a clean array.
jProto.toArray = function toArray() {
  return this.length > 1 ? slice.call(this) : slice.call(this)[0];
};


// Map a function to a matrix or vector.
jProto.map = function map(func, toAlter) {
  return jStat(jStat.map(this, func, toAlter));
};


// Cumulatively combine the elements of a matrix or vector using a function.
jProto.cumreduce = function cumreduce(func, toAlter) {
  return jStat(jStat.cumreduce(this, func, toAlter));
};


// Destructively alter an array.
jProto.alter = function alter(func) {
  jStat.alter(this, func);
  return this;
};


// Extend prototype with methods that have no argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(func) {
      var self = this,
      results;
      // Check for callback.
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self));
        });
        return this;
      }
      results = jStat[passfunc](this);
      return isArray(results) ? jStat(results) : results;
    };
  })(funcs[i]);
})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));


// Extend prototype with methods that have one argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(index, func) {
      var self = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self, index));
        });
        return this;
      }
      return jStat(jStat[passfunc](this, index));
    };
  })(funcs[i]);
})('row col'.split(' '));


// Extend prototype with simple shortcut methods.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = new Function(
        'return jStat(jStat.' + passfunc + '.apply(null, arguments));');
  })(funcs[i]);
})('create zeros ones rand identity'.split(' '));


// Exposing jStat.
return jStat;

}(Math));
(function(jStat, Math) {

var isFunction = jStat.utils.isFunction;

// Ascending functions for sort
function ascNum(a, b) { return a - b; }

function clip(arg, min, max) {
  return Math.max(min, Math.min(arg, max));
}


// sum of an array
jStat.sum = function sum(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i];
  return sum;
};


// sum squared
jStat.sumsqrd = function sumsqrd(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i] * arr[i];
  return sum;
};


// sum of squared errors of prediction (SSE)
jStat.sumsqerr = function sumsqerr(arr) {
  var mean = jStat.mean(arr);
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0) {
    tmp = arr[i] - mean;
    sum += tmp * tmp;
  }
  return sum;
};

// sum of an array in each row
jStat.sumrow = function sumrow(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i];
  return sum;
};

// product of an array
jStat.product = function product(arr) {
  var prod = 1;
  var i = arr.length;
  while (--i >= 0)
    prod *= arr[i];
  return prod;
};


// minimum value of an array
jStat.min = function min(arr) {
  var low = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] < low)
      low = arr[i];
  return low;
};


// maximum value of an array
jStat.max = function max(arr) {
  var high = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] > high)
      high = arr[i];
  return high;
};


// mean value of an array
jStat.mean = function mean(arr) {
  return jStat.sum(arr) / arr.length;
};


// mean squared error (MSE)
jStat.meansqerr = function meansqerr(arr) {
  return jStat.sumsqerr(arr) / arr.length;
};


// geometric mean of an array
jStat.geomean = function geomean(arr) {
  return Math.pow(jStat.product(arr), 1 / arr.length);
};


// median of an array
jStat.median = function median(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  // check if array is even or odd, then return the appropriate
  return !(arrlen & 1)
    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2
    : _arr[(arrlen / 2) | 0 ];
};


// cumulative sum of an array
jStat.cumsum = function cumsum(arr) {
  return jStat.cumreduce(arr, function (a, b) { return a + b; });
};


// cumulative product of an array
jStat.cumprod = function cumprod(arr) {
  return jStat.cumreduce(arr, function (a, b) { return a * b; });
};


// successive differences of a sequence
jStat.diff = function diff(arr) {
  var diffs = [];
  var arrLen = arr.length;
  var i;
  for (i = 1; i < arrLen; i++)
    diffs.push(arr[i] - arr[i - 1]);
  return diffs;
};


// mode of an array
// if there are multiple modes of an array, return all of them
// is this the appropriate way of handling it?
jStat.mode = function mode(arr) {
  var arrLen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  var count = 1;
  var maxCount = 0;
  var numMaxCount = 0;
  var mode_arr = [];
  var i;

  for (i = 0; i < arrLen; i++) {
    if (_arr[i] === _arr[i + 1]) {
      count++;
    } else {
      if (count > maxCount) {
        mode_arr = [_arr[i]];
        maxCount = count;
        numMaxCount = 0;
      }
      // are there multiple max counts
      else if (count === maxCount) {
        mode_arr.push(_arr[i]);
        numMaxCount++;
      }
      // resetting count for new value in array
      count = 1;
    }
  }

  return numMaxCount === 0 ? mode_arr[0] : mode_arr;
};


// range of an array
jStat.range = function range(arr) {
  return jStat.max(arr) - jStat.min(arr);
};

// variance of an array
// flag = true indicates sample instead of population
jStat.variance = function variance(arr, flag) {
  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
};


// standard deviation of an array
// flag = true indicates sample instead of population
jStat.stdev = function stdev(arr, flag) {
  return Math.sqrt(jStat.variance(arr, flag));
};


// mean deviation (mean absolute deviation) of an array
jStat.meandev = function meandev(arr) {
  var devSum = 0;
  var mean = jStat.mean(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - mean);
  return devSum / arr.length;
};


// median deviation (median absolute deviation) of an array
jStat.meddev = function meddev(arr) {
  var devSum = 0;
  var median = jStat.median(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - median);
  return devSum / arr.length;
};


// coefficient of variation
jStat.coeffvar = function coeffvar(arr) {
  return jStat.stdev(arr) / jStat.mean(arr);
};


// quartiles of an array
jStat.quartiles = function quartiles(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  return [
    _arr[ Math.round((arrlen) / 4) - 1 ],
    _arr[ Math.round((arrlen) / 2) - 1 ],
    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]
  ];
};


// Arbitary quantiles of an array. Direct port of the scipy.stats
// implementation by Pierre GF Gerard-Marchant.
jStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
  var sortedArray = arr.slice().sort(ascNum);
  var quantileVals = [quantilesArray.length];
  var n = arr.length;
  var i, p, m, aleph, k, gamma;

  if (typeof alphap === 'undefined')
    alphap = 3 / 8;
  if (typeof betap === 'undefined')
    betap = 3 / 8;

  for (i = 0; i < quantilesArray.length; i++) {
    p = quantilesArray[i];
    m = alphap + p * (1 - alphap - betap);
    aleph = n * p + m;
    k = Math.floor(clip(aleph, 1, n - 1));
    gamma = clip(aleph - k, 0, 1);
    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];
  }

  return quantileVals;
};

// Returns the k-th percentile of values in a range, where k is in the
// range 0..1, exclusive.
jStat.percentile = function percentile(arr, k) {
  var _arr = arr.slice().sort(ascNum);
  var realIndex = k * (_arr.length - 1);
  var index = parseInt(realIndex);
  var frac = realIndex - index;

  if (index + 1 < _arr.length) {
    return _arr[index] * (1 - frac) + _arr[index + 1] * frac;
  } else {
    return _arr[index];
  }
}


// The percentile rank of score in a given array. Returns the percentage
// of all values in the input array that are less than (kind='strict') or
// less or equal than (kind='weak') score. Default is weak.
jStat.percentileOfScore = function percentileOfScore(arr, score, kind) {
  var counter = 0;
  var len = arr.length;
  var strict = false;
  var value, i;

  if (kind === 'strict')
    strict = true;

  for (i = 0; i < len; i++) {
    value = arr[i];
    if ((strict && value < score) ||
        (!strict && value <= score)) {
      counter++;
    }
  }

  return counter / len;
};


// Histogram (bin count) data
jStat.histogram = function histogram(arr, bins) {
  var first = jStat.min(arr);
  var binCnt = bins || 4;
  var binWidth = (jStat.max(arr) - first) / binCnt;
  var len = arr.length;
  var bins = [];
  var i;

  for (i = 0; i < binCnt; i++)
    bins[i] = 0;
  for (i = 0; i < len; i++)
    bins[Math.min(Math.floor(((arr[i] - first) / binWidth)), binCnt - 1)] += 1;

  return bins;
};


// covariance of two arrays
jStat.covariance = function covariance(arr1, arr2) {
  var u = jStat.mean(arr1);
  var v = jStat.mean(arr2);
  var arr1Len = arr1.length;
  var sq_dev = new Array(arr1Len);
  var i;

  for (i = 0; i < arr1Len; i++)
    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);

  return jStat.sum(sq_dev) / (arr1Len - 1);
};


// (pearson's) population correlation coefficient, rho
jStat.corrcoeff = function corrcoeff(arr1, arr2) {
  return jStat.covariance(arr1, arr2) /
      jStat.stdev(arr1, 1) /
      jStat.stdev(arr2, 1);
};

// pdfernhout added from jstat pull request: https://github.com/jstat/jstat/pull/163/files
// (spearman's) rank correlation coefficient, sp
jStat.spearmancoeff = function spearmancoeff(arr1, arr2) {
  sortfunction = function(a,b) { return a[1]-b[1]};
  var npoints = arr1.length;
  if (arr1.length != arr2.length)
    return 0.0;
  if (npoints == 0)
    return 0.0;
  var arr1cp = new Array(npoints);
  var arr2cp = new Array(npoints);
  var arr1rank = new Array(npoints);
  var arr2rank = new Array(npoints);
  var arr1cps;
  var arr2cps;
  var dsqr = 0;
  var i;
  for (i = 0; i < npoints; i++){
    arr1cp[i] = [i,arr1[i]];
    arr2cp[i] = [i,arr2[i]];
  }
  var arr1cps = arr1cp.sort(sortfunction);
  var arr2cps = arr2cp.sort(sortfunction);
  for (i = 0; i < npoints; i++){
    arr1rank[arr1cps[i][0]] = i;
    arr2rank[arr2cps[i][0]] = i;
  }
  dsqr = 0;
  for (i = 0; i < npoints; i++){
    dsqr  += (arr1rank[i] - arr2rank[i])*(arr1rank[i] - arr2rank[i]);
  }

  return 1 - dsqr*6.0/(npoints*(npoints*npoints-1))
};

// statistical standardized moments (general form of skew/kurt)
jStat.stanMoment = function stanMoment(arr, n) {
  var mu = jStat.mean(arr);
  var sigma = jStat.stdev(arr);
  var len = arr.length;
  var skewSum = 0;

  for (i = 0; i < len; i++)
    skewSum += Math.pow((arr[i] - mu) / sigma, n);

  return skewSum / arr.length;
};

// (pearson's) moment coefficient of skewness
jStat.skewness = function skewness(arr) {
  return jStat.stanMoment(arr, 3);
};

// (pearson's) (excess) kurtosis
jStat.kurtosis = function kurtosis(arr) {
  return jStat.stanMoment(arr, 4) - 3;
};


var jProto = jStat.prototype;


// Extend jProto with method for calculating cumulative sums and products.
// This differs from the similar extension below as cumsum and cumprod should
// not be run again in the case fullbool === true.
// If a matrix is passed, automatically assume operation should be done on the
// columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    // If a matrix is passed, automatically assume operation should be done on
    // the columns.
    jProto[passfunc] = function(fullbool, func) {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      // Assignment reassignation depending on how parameters were passed in.
      if (isFunction(fullbool)) {
        func = fullbool;
        fullbool = false;
      }
      // Check if a callback was passed with the function.
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
        });
        return this;
      }
      // Check if matrix and run calculations.
      if (this.length > 1) {
        tmpthis = fullbool === true ? this : this.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = jStat[passfunc](tmpthis[i]);
        return arr;
      }
      // Pass fullbool if only vector, not a matrix. for variance and stdev.
      return jStat[passfunc](this[0], fullbool);
    };
  })(funcs[i]);
})(('cumsum cumprod').split(' '));


// Extend jProto with methods which don't require arguments and work on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    // If a matrix is passed, automatically assume operation should be done on
    // the columns.
    jProto[passfunc] = function(fullbool, func) {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      // Assignment reassignation depending on how parameters were passed in.
      if (isFunction(fullbool)) {
        func = fullbool;
        fullbool = false;
      }
      // Check if a callback was passed with the function.
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
        });
        return this;
      }
      // Check if matrix and run calculations.
      if (this.length > 1) {
        if (passfunc !== 'sumrow')
          tmpthis = fullbool === true ? this : this.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = jStat[passfunc](tmpthis[i]);
        return fullbool === true
            ? jStat[passfunc](jStat.utils.toVector(arr))
            : arr;
      }
      // Pass fullbool if only vector, not a matrix. for variance and stdev.
      return jStat[passfunc](this[0], fullbool);
    };
  })(funcs[i]);
})(('sum sumsqrd sumsqerr sumrow product min max mean meansqerr geomean ' +
    'median diff mode range variance stdev meandev meddev coeffvar quartiles ' +
    'histogram skewness kurtosis').split(' '));


// Extend jProto with functions that take arguments. Operations on matrices are
// done on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function() {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      var args = Array.prototype.slice.call(arguments);

      // If the last argument is a function, we assume it's a callback; we
      // strip the callback out and call the function again.
      if (isFunction(args[args.length - 1])) {
        var callbackFunction = args[args.length - 1];
        var argsToPass = args.slice(0, args.length - 1);

        setTimeout(function() {
          callbackFunction.call(tmpthis,
                                jProto[passfunc].apply(tmpthis, argsToPass));
        });
        return this;

      // Otherwise we curry the function args and call normally.
      } else {
        var callbackFunction = undefined;
        var curriedFunction = function curriedFunction(vector) {
          return jStat[passfunc].apply(tmpthis, [vector].concat(args));
        }
      }

      // If this is a matrix, run column-by-column.
      if (this.length > 1) {
        tmpthis = tmpthis.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = curriedFunction(tmpthis[i]);
        return arr;
      }

      // Otherwise run on the vector.
      return curriedFunction(this[0]);
    };
  })(funcs[i]);
})('quantiles percentileOfScore'.split(' '));

}(this.jStat, Math));
// Special functions //
(function(jStat, Math) {

// Log-gamma function
jStat.gammaln = function gammaln(x) {
  var j = 0;
  var cof = [
    76.18009172947146, -86.50532032941677, 24.01409824083091,
    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5
  ];
  var ser = 1.000000000190015;
  var xx, y, tmp;
  tmp = (y = xx = x) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j < 6; j++)
    ser += cof[j] / ++y;
  return Math.log(2.5066282746310005 * ser / xx) - tmp;
};


// gamma of x
jStat.gammafn = function gammafn(x) {
  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,
           629.3311553128184, 866.9662027904133, -31451.272968848367,
           -36144.413418691176, 66456.14382024054
  ];
  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,
           -3107.771671572311, 22538.118420980151, 4755.8462775278811,
           -134659.9598649693, -115132.2596755535];
  var fact = false;
  var n = 0;
  var xden = 0;
  var xnum = 0;
  var y = x;
  var i, z, yi, res, sum, ysq;
  if (y <= 0) {
    res = y % 1 + 3.6e-16;
    if (res) {
      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);
      y = 1 - y;
    } else {
      return Infinity;
    }
  }
  yi = y;
  if (y < 1) {
    z = y++;
  } else {
    z = (y -= n = (y | 0) - 1) - 1;
  }
  for (i = 0; i < 8; ++i) {
    xnum = (xnum + p[i]) * z;
    xden = xden * z + q[i];
  }
  res = xnum / xden + 1;
  if (yi < y) {
    res /= yi;
  } else if (yi > y) {
    for (i = 0; i < n; ++i) {
      res *= y;
      y++;
    }
  }
  if (fact) {
    res = fact / res;
  }
  return res;
};


// lower incomplete gamma function, which is usually typeset with a
// lower-case greek gamma as the function symbol
jStat.gammap = function gammap(a, x) {
  return jStat.lowRegGamma(a, x) * jStat.gammafn(a);
};


// The lower regularized incomplete gamma function, usually written P(a,x)
jStat.lowRegGamma = function lowRegGamma(a, x) {
  var aln = jStat.gammaln(a);
  var ap = a;
  var sum = 1 / a;
  var del = sum;
  var b = x + 1 - a;
  var c = 1 / 1.0e-30;
  var d = 1 / b;
  var h = d;
  var i = 1;
  // calculate maximum number of itterations required for a
  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);
  var an, endval;

  if (x < 0 || a <= 0) {
    return NaN;
  } else if (x < a + 1) {
    for (; i <= ITMAX; i++) {
      sum += del *= x / ++ap;
    }
    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));
  }

  for (; i <= ITMAX; i++) {
    an = -i * (i - a);
    b += 2;
    d = an * d + b;
    c = b + an / c;
    d = 1 / d;
    h *= d * c;
  }

  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));
};

// natural log factorial of n
jStat.factorialln = function factorialln(n) {
  return n < 0 ? NaN : jStat.gammaln(n + 1);
};

// factorial of n
jStat.factorial = function factorial(n) {
  return n < 0 ? NaN : jStat.gammafn(n + 1);
};

// combinations of n, m
jStat.combination = function combination(n, m) {
  // make sure n or m don't exceed the upper limit of usable values
  return (n > 170 || m > 170)
      ? Math.exp(jStat.combinationln(n, m))
      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);
};


jStat.combinationln = function combinationln(n, m){
  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);
};


// permutations of n, m
jStat.permutation = function permutation(n, m) {
  return jStat.factorial(n) / jStat.factorial(n - m);
};


// beta function
jStat.betafn = function betafn(x, y) {
  // ensure arguments are positive
  if (x <= 0 || y <= 0)
    return undefined;
  // make sure x + y doesn't exceed the upper limit of usable values
  return (x + y > 170)
      ? Math.exp(jStat.betaln(x, y))
      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);
};


// natural logarithm of beta function
jStat.betaln = function betaln(x, y) {
  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);
};


// Evaluates the continued fraction for incomplete beta function by modified
// Lentz's method.
jStat.betacf = function betacf(x, a, b) {
  var fpmin = 1e-30;
  var m = 1;
  var qab = a + b;
  var qap = a + 1;
  var qam = a - 1;
  var c = 1;
  var d = 1 - qab * x / qap;
  var m2, aa, del, h;

  // These q's will be used in factors that occur in the coefficients
  if (Math.abs(d) < fpmin)
    d = fpmin;
  d = 1 / d;
  h = d;

  for (; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    // One step (the even one) of the recurrence
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7)
      break;
  }

  return h;
};


// Returns the inverse of the lower regularized inomplete gamma function
jStat.gammapinv = function gammapinv(p, a) {
  var j = 0;
  var a1 = a - 1;
  var EPS = 1e-8;
  var gln = jStat.gammaln(a);
  var x, err, t, u, pp, lna1, afac;

  if (p >= 1)
    return Math.max(100, a + 100 * Math.sqrt(a));
  if (p <= 0)
    return 0;
  if (a > 1) {
    lna1 = Math.log(a1);
    afac = Math.exp(a1 * (lna1 - 1) - gln);
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    x = Math.max(1e-3,
                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));
  } else {
    t = 1 - a * (0.253 + a * 0.12);
    if (p < t)
      x = Math.pow(p / t, 1 / a);
    else
      x = 1 - Math.log(1 - (p - t) / (1 - t));
  }

  for(; j < 12; j++) {
    if (x <= 0)
      return 0;
    err = jStat.lowRegGamma(a, x) - p;
    if (a > 1)
      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));
    else
      t = Math.exp(-x + a1 * Math.log(x) - gln);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (Math.abs(t) < EPS * x)
      break;
  }

  return x;
};


// Returns the error function erf(x)
jStat.erf = function erf(x) {
  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,
             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,
             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,
             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,
             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,
             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,
             -6.886027e-12, 8.94487e-13, 3.13092e-13,
             -1.12708e-13, 3.81e-16, 7.106e-15,
             -1.523e-15, -9.4e-17, 1.21e-16,
             -2.8e-17];
  var j = cof.length - 1;
  var isneg = false;
  var d = 0;
  var dd = 0;
  var t, ty, tmp, res;

  if (x < 0) {
    x = -x;
    isneg = true;
  }

  t = 2 / (2 + x);
  ty = 4 * t - 2;

  for(; j > 0; j--) {
    tmp = d;
    d = ty * d - dd + cof[j];
    dd = tmp;
  }

  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
  return isneg ? res - 1 : 1 - res;
};


// Returns the complmentary error function erfc(x)
jStat.erfc = function erfc(x) {
  return 1 - jStat.erf(x);
};


// Returns the inverse of the complementary error function
jStat.erfcinv = function erfcinv(p) {
  var j = 0;
  var x, err, t, pp;
  if (p >= 2)
    return -100;
  if (p <= 0)
    return 100;
  pp = (p < 1) ? p : 2 - p;
  t = Math.sqrt(-2 * Math.log(pp / 2));
  x = -0.70711 * ((2.30753 + t * 0.27061) /
                  (1 + t * (0.99229 + t * 0.04481)) - t);
  for (; j < 2; j++) {
    err = jStat.erfc(x) - pp;
    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);
  }
  return (p < 1) ? x : -x;
};


// Returns the inverse of the incomplete beta function
jStat.ibetainv = function ibetainv(p, a, b) {
  var EPS = 1e-8;
  var a1 = a - 1;
  var b1 = b - 1;
  var j = 0;
  var lna, lnb, pp, t, u, err, x, al, h, w, afac;
  if (p <= 0)
    return 0;
  if (p >= 1)
    return 1;
  if (a >= 1 && b >= 1) {
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    al = (x * x - 3) / 6;
    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));
    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *
        (al + 5 / 6 - 2 / (3 * h));
    x = a / (a + b * Math.exp(2 * w));
  } else {
    lna = Math.log(a / (a + b));
    lnb = Math.log(b / (a + b));
    t = Math.exp(a * lna) / a;
    u = Math.exp(b * lnb) / b;
    w = t + u;
    if (p < t / w)
      x = Math.pow(a * w * p, 1 / a);
    else
      x = 1 - Math.pow(b * w * (1 - p), 1 / b);
  }
  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);
  for(; j < 10; j++) {
    if (x === 0 || x === 1)
      return x;
    err = jStat.ibeta(x, a, b) - p;
    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (x >= 1)
      x = 0.5 * (x + t + 1);
    if (Math.abs(t) < EPS * x && j > 0)
      break;
  }
  return x;
};


// Returns the incomplete beta function I_x(a,b)
jStat.ibeta = function ibeta(x, a, b) {
  // Factors in front of the continued fraction.
  var bt = (x === 0 || x === 1) ?  0 :
    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -
             jStat.gammaln(b) + a * Math.log(x) + b *
             Math.log(1 - x));
  if (x < 0 || x > 1)
    return false;
  if (x < (a + 1) / (a + b + 2))
    // Use continued fraction directly.
    return bt * jStat.betacf(x, a, b) / a;
  // else use continued fraction after making the symmetry transformation.
  return 1 - bt * jStat.betacf(1 - x, b, a) / b;
};


// Returns a normal deviate (mu=0, sigma=1).
// If n and m are specified it returns a object of normal deviates.
jStat.randn = function randn(n, m) {
  var u, v, x, y, q, mat;
  if (!m)
    m = n;
  if (n)
    return jStat.create(n, m, function() { return jStat.randn(); });
  do {
    u = Math.random();
    v = 1.7156 * (Math.random() - 0.5);
    x = u - 0.449871;
    y = Math.abs(v) + 0.386595;
    q = x * x + y * (0.19600 * y - 0.25472 * x);
  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));
  return v / u;
};


// Returns a gamma deviate by the method of Marsaglia and Tsang.
jStat.randg = function randg(shape, n, m) {
  var oalph = shape;
  var a1, a2, u, v, x, mat;
  if (!m)
    m = n;
  if (!shape)
    shape = 1;
  if (n) {
    mat = jStat.zeros(n,m);
    mat.alter(function() { return jStat.randg(shape); });
    return mat;
  }
  if (shape < 1)
    shape += 1;
  a1 = shape - 1 / 3;
  a2 = 1 / Math.sqrt(9 * a1);
  do {
    do {
      x = jStat.randn();
      v = 1 + a2 * x;
    } while(v <= 0);
    v = v * v * v;
    u = Math.random();
  } while(u > 1 - 0.331 * Math.pow(x, 4) &&
          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));
  // alpha > 1
  if (shape == oalph)
    return a1 * v;
  // alpha < 1
  do {
    u = Math.random();
  } while(u === 0);
  return Math.pow(u, 1 / oalph) * a1 * v;
};


// making use of static methods on the instance
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(
          jStat.map(this, function(value) { return jStat[passfunc](value); }));
    }
  })(funcs[i]);
})('gammaln gammafn factorial factorialln'.split(' '));


(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(jStat[passfunc].apply(null, arguments));
    };
  })(funcs[i]);
})('randn'.split(' '));

}(this.jStat, Math));
(function(jStat, Math) {

// generate all distribution instance methods
(function(list) {
  for (var i = 0; i < list.length; i++) (function(func) {
    // distribution instance method
    jStat[func] = function(a, b, c) {
      if (!(this instanceof arguments.callee))
        return new arguments.callee(a, b, c);
      this._a = a;
      this._b = b;
      this._c = c;
      return this;
    };
    // distribution method to be used on a jStat instance
    jStat.fn[func] = function(a, b, c) {
      var newthis = jStat[func](a, b, c);
      newthis.data = this;
      return newthis;
    };
    // sample instance method
    jStat[func].prototype.sample = function(arr) {
      var a = this._a;
      var b = this._b;
      var c = this._c;
      if (arr)
        return jStat.alter(arr, function() {
          return jStat[func].sample(a, b, c);
        });
      else
        return jStat[func].sample(a, b, c);
    };
    // generate the pdf, cdf and inv instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function(x) {
          var a = this._a;
          var b = this._b;
          var c = this._c;
          if (!x && x !== 0)
            x = this.data;
          if (typeof x !== 'number') {
            return jStat.fn.map.call(x, function(x) {
              return jStat[func][fnfunc](x, a, b, c);
            });
          }
          return jStat[func][fnfunc](x, a, b, c);
        };
      })(vals[i]);
    })('pdf cdf inv'.split(' '));
    // generate the mean, median, mode and variance instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function() {
          return jStat[func][fnfunc](this._a, this._b, this._c);
        };
      })(vals[i]);
    })('mean median mode variance'.split(' '));
  })(list[i]);
})((
  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +
  'lognormal noncentralt normal pareto studentt weibull uniform  binomial ' +
  'negbin hypgeom poisson triangular'
).split(' '));



// extend beta function with static methods
jStat.extend(jStat.beta, {
  pdf: function pdf(x, alpha, beta) {
    // PDF is zero outside the support
    if (x > 1 || x < 0)
      return 0;
    // PDF is one for the uniform case
    if (alpha == 1 && beta == 1)
      return 1;

    if (alpha < 512 || beta < 512) {
      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /
          jStat.betafn(alpha, beta);
    } else {
      return Math.exp((alpha - 1) * Math.log(x) +
                      (beta - 1) * Math.log(1 - x) -
                      jStat.betaln(alpha, beta));
    }
  },

  cdf: function cdf(x, alpha, beta) {
    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);
  },

  inv: function inv(x, alpha, beta) {
    return jStat.ibetainv(x, alpha, beta);
  },

  mean: function mean(alpha, beta) {
    return alpha / (alpha + beta);
  },

  median: function median(alpha, beta) {
    return jStat.ibetainv(0.5, alpha, beta);
  },

  mode: function mode(alpha, beta) {
    return (alpha - 1 ) / ( alpha + beta - 2);
  },

  // return a random sample
  sample: function sample(alpha, beta) {
    var u = jStat.randg(alpha);
    return u / (u + jStat.randg(beta));
  },

  variance: function variance(alpha, beta) {
    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
  }
});

// extend F function with static methods
jStat.extend(jStat.centralF, {
  // This implementation of the pdf function avoids float overflow
  // See the way that R calculates this value:
  // https://svn.r-project.org/R/trunk/src/nmath/df.c
  pdf: function pdf(x, df1, df2) {
    var p, q, f;

    if (x < 0)
      return 0;

    if (df1 <= 2) {
      if (x === 0 && df1 < 2) {
        return Infinity;
      }
      if (x === 0 && df1 === 2) {
        return 1;
      }
      return Math.sqrt((Math.pow(df1 * x, df1) * Math.pow(df2, df2)) /
                       (Math.pow(df1 * x + df2, df1 + df2))) /
                       (x * jStat.betafn(df1/2, df2/2));
    }

    p = (df1 * x) / (df2 + x * df1);
    q = df2 / (df2 + x * df1);
    f = df1 * q / 2.0;
    return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);
  },

  cdf: function cdf(x, df1, df2) {
    if (x < 0)
      return 0;
    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);
  },

  inv: function inv(x, df1, df2) {
    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));
  },

  mean: function mean(df1, df2) {
    return (df2 > 2) ? df2 / (df2 - 2) : undefined;
  },

  mode: function mode(df1, df2) {
    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;
  },

  // return a random sample
  sample: function sample(df1, df2) {
    var x1 = jStat.randg(df1 / 2) * 2;
    var x2 = jStat.randg(df2 / 2) * 2;
    return (x1 / df1) / (x2 / df2);
  },

  variance: function variance(df1, df2) {
    if (df2 <= 4)
      return undefined;
    return 2 * df2 * df2 * (df1 + df2 - 2) /
        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
  }
});


// extend cauchy function with static methods
jStat.extend(jStat.cauchy, {
  pdf: function pdf(x, local, scale) {
    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;
  },

  cdf: function cdf(x, local, scale) {
    return Math.atan((x - local) / scale) / Math.PI + 0.5;
  },

  inv: function(p, local, scale) {
    return local + scale * Math.tan(Math.PI * (p - 0.5));
  },

  median: function median(local, scale) {
    return local;
  },

  mode: function mode(local, scale) {
    return local;
  },

  sample: function sample(local, scale) {
    return jStat.randn() *
        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;
  }
});



// extend chisquare function with static methods
jStat.extend(jStat.chisquare, {
  pdf: function pdf(x, dof) {
    if (x < 0)
      return 0;
    return (x === 0 && dof === 2) ? 0.5 :
        Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *
                 Math.log(2) - jStat.gammaln(dof / 2));
  },

  cdf: function cdf(x, dof) {
    if (x < 0)
      return 0;
    return jStat.lowRegGamma(dof / 2, x / 2);
  },

  inv: function(p, dof) {
    return 2 * jStat.gammapinv(p, 0.5 * dof);
  },

  mean : function(dof) {
    return dof;
  },

  // TODO: this is an approximation (is there a better way?)
  median: function median(dof) {
    return dof * Math.pow(1 - (2 / (9 * dof)), 3);
  },

  mode: function mode(dof) {
    return (dof - 2 > 0) ? dof - 2 : 0;
  },

  sample: function sample(dof) {
    return jStat.randg(dof / 2) * 2;
  },

  variance: function variance(dof) {
    return 2 * dof;
  }
});



// extend exponential function with static methods
jStat.extend(jStat.exponential, {
  pdf: function pdf(x, rate) {
    return x < 0 ? 0 : rate * Math.exp(-rate * x);
  },

  cdf: function cdf(x, rate) {
    return x < 0 ? 0 : 1 - Math.exp(-rate * x);
  },

  inv: function(p, rate) {
    return -Math.log(1 - p) / rate;
  },

  mean : function(rate) {
    return 1 / rate;
  },

  median: function (rate) {
    return (1 / rate) * Math.log(2);
  },

  mode: function mode(rate) {
    return 0;
  },

  sample: function sample(rate) {
    return -1 / rate * Math.log(Math.random());
  },

  variance : function(rate) {
    return Math.pow(rate, -2);
  }
});



// extend gamma function with static methods
jStat.extend(jStat.gamma, {
  pdf: function pdf(x, shape, scale) {
    if (x < 0)
      return 0;
    return (x === 0 && shape === 1) ? 1 / scale :
            Math.exp((shape - 1) * Math.log(x) - x / scale -
                    jStat.gammaln(shape) - shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    if (x < 0)
      return 0;
    return jStat.lowRegGamma(shape, x / scale);
  },

  inv: function(p, shape, scale) {
    return jStat.gammapinv(p, shape) * scale;
  },

  mean : function(shape, scale) {
    return shape * scale;
  },

  mode: function mode(shape, scale) {
    if(shape > 1) return (shape - 1) * scale;
    return undefined;
  },

  sample: function sample(shape, scale) {
    return jStat.randg(shape) * scale;
  },

  variance: function variance(shape, scale) {
    return shape * scale * scale;
  }
});

// extend inverse gamma function with static methods
jStat.extend(jStat.invgamma, {
  pdf: function pdf(x, shape, scale) {
    if (x <= 0)
      return 0;
    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -
                    jStat.gammaln(shape) + shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    if (x <= 0)
      return 0;
    return 1 - jStat.lowRegGamma(shape, scale / x);
  },

  inv: function(p, shape, scale) {
    return scale / jStat.gammapinv(1 - p, shape);
  },

  mean : function(shape, scale) {
    return (shape > 1) ? scale / (shape - 1) : undefined;
  },

  mode: function mode(shape, scale) {
    return scale / (shape + 1);
  },

  sample: function sample(shape, scale) {
    return scale / jStat.randg(shape);
  },

  variance: function variance(shape, scale) {
    if (shape <= 2)
      return undefined;
    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
  }
});


// extend kumaraswamy function with static methods
jStat.extend(jStat.kumaraswamy, {
  pdf: function pdf(x, alpha, beta) {
    if (x === 0 && alpha === 1)
      return beta;
    else if (x === 1 && beta === 1)
      return alpha;
    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *
                    Math.log(x) + (beta - 1) *
                    Math.log(1 - Math.pow(x, alpha)));
  },

  cdf: function cdf(x, alpha, beta) {
    if (x < 0)
      return 0;
    else if (x > 1)
      return 1;
    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));
  },

  inv: function inv(p, alpha, beta) {
    return Math.pow(1 - Math.pow(1 - p, 1 / beta), 1 / alpha);
  },

  mean : function(alpha, beta) {
    return (beta * jStat.gammafn(1 + 1 / alpha) *
            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));
  },

  median: function median(alpha, beta) {
    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);
  },

  mode: function mode(alpha, beta) {
    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
      return undefined;
    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
  },

  variance: function variance(alpha, beta) {
    throw new Error('variance not yet implemented');
    // TODO: complete this
  }
});



// extend lognormal function with static methods
jStat.extend(jStat.lognormal, {
  pdf: function pdf(x, mu, sigma) {
    if (x <= 0)
      return 0;
    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -
                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /
                    (2 * sigma * sigma));
  },

  cdf: function cdf(x, mu, sigma) {
    if (x < 0)
      return 0;
    return 0.5 +
        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));
  },

  inv: function(p, mu, sigma) {
    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);
  },

  mean: function mean(mu, sigma) {
    return Math.exp(mu + sigma * sigma / 2);
  },

  median: function median(mu, sigma) {
    return Math.exp(mu);
  },

  mode: function mode(mu, sigma) {
    return Math.exp(mu - sigma * sigma);
  },

  sample: function sample(mu, sigma) {
    return Math.exp(jStat.randn() * sigma + mu);
  },

  variance: function variance(mu, sigma) {
    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);
  }
});



// extend noncentralt function with static methods
jStat.extend(jStat.noncentralt, {
  pdf: function pdf(x, dof, ncp) {
    var tol = 1e-14;
    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t
      return jStat.studentt.pdf(x, dof)

    if (Math.abs(x) < tol) {  // different formula for x == 0
      return Math.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 -
                      0.5 * Math.log(Math.PI * dof) - jStat.gammaln(dof / 2));
    }

    // formula for x != 0
    return dof / x *
        (jStat.noncentralt.cdf(x * Math.sqrt(1 + 2 / dof), dof+2, ncp) -
         jStat.noncentralt.cdf(x, dof, ncp));
  },

  cdf: function cdf(x, dof, ncp) {
    var tol = 1e-14;
    var min_iterations = 200;

    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t
      return jStat.studentt.cdf(x, dof);

    // turn negative x into positive and flip result afterwards
    var flip = false;
    if (x < 0) {
      flip = true;
      ncp = -ncp;
    }

    var prob = jStat.normal.cdf(-ncp, 0, 1);
    var value = tol + 1;
    // use value at last two steps to determine convergence
    var lastvalue = value;
    var y = x * x / (x * x + dof);
    var j = 0;
    var p = Math.exp(-ncp * ncp / 2);
    var q = Math.exp(-ncp * ncp / 2 - 0.5 * Math.log(2) -
                     jStat.gammaln(3 / 2)) * ncp;
    while (j < min_iterations || lastvalue > tol || value > tol) {
      lastvalue = value;
      if (j > 0) {
        p *= (ncp * ncp) / (2 * j);
        q *= (ncp * ncp) / (2 * (j + 1 / 2));
      }
      value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) +
          q * jStat.beta.cdf(y, j+1, dof/2);
      prob += 0.5 * value;
      j++;
    }

    return flip ? (1 - prob) : prob;
  }
});


// extend normal function with static methods
jStat.extend(jStat.normal, {
  pdf: function pdf(x, mean, std) {
    return Math.exp(-0.5 * Math.log(2 * Math.PI) -
                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));
  },

  cdf: function cdf(x, mean, std) {
    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));
  },

  inv: function(p, mean, std) {
    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;
  },

  mean : function(mean, std) {
    return mean;
  },

  median: function median(mean, std) {
    return mean;
  },

  mode: function (mean, std) {
    return mean;
  },

  sample: function sample(mean, std) {
    return jStat.randn() * std + mean;
  },

  variance : function(mean, std) {
    return std * std;
  }
});



// extend pareto function with static methods
jStat.extend(jStat.pareto, {
  pdf: function pdf(x, scale, shape) {
    if (x < scale)
      return 0;
    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);
  },

  cdf: function cdf(x, scale, shape) {
    if (x < scale)
      return 0;
    return 1 - Math.pow(scale / x, shape);
  },

  inv: function inv(p, scale, shape) {
    return scale / Math.pow(1 - p, 1 / shape);
  },

  mean: function mean(scale, shape) {
    if (shape <= 1)
      return undefined;
    return (shape * Math.pow(scale, shape)) / (shape - 1);
  },

  median: function median(scale, shape) {
    return scale * (shape * Math.SQRT2);
  },

  mode: function mode(scale, shape) {
    return scale;
  },

  variance : function(scale, shape) {
    if (shape <= 2)
      return undefined;
    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));
  }
});



// extend studentt function with static methods
jStat.extend(jStat.studentt, {
  pdf: function pdf(x, dof) {
    dof = dof > 1e100 ? 1e100 : dof;
    return (1/(Math.sqrt(dof) * jStat.betafn(0.5, dof/2))) *
        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));
  },

  cdf: function cdf(x, dof) {
    var dof2 = dof / 2;
    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /
                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);
  },

  inv: function(p, dof) {
    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
    x = Math.sqrt(dof * (1 - x) / x);
    return (p > 0.5) ? x : -x;
  },

  mean: function mean(dof) {
    return (dof > 1) ? 0 : undefined;
  },

  median: function median(dof) {
    return 0;
  },

  mode: function mode(dof) {
    return 0;
  },

  sample: function sample(dof) {
    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));
  },

  variance: function variance(dof) {
    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;
  }
});



// extend weibull function with static methods
jStat.extend(jStat.weibull, {
  pdf: function pdf(x, scale, shape) {
    if (x < 0)
      return 0;
    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *
        Math.exp(-(Math.pow((x / scale), shape)));
  },

  cdf: function cdf(x, scale, shape) {
    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));
  },

  inv: function(p, scale, shape) {
    return scale * Math.pow(-Math.log(1 - p), 1 / shape);
  },

  mean : function(scale, shape) {
    return scale * jStat.gammafn(1 + 1 / shape);
  },

  median: function median(scale, shape) {
    return scale * Math.pow(Math.log(2), 1 / shape);
  },

  mode: function mode(scale, shape) {
    if (shape <= 1)
      return undefined;
    return scale * Math.pow((shape - 1) / shape, 1 / shape);
  },

  sample: function sample(scale, shape) {
    return scale * Math.pow(-Math.log(Math.random()), 1 / shape);
  },

  variance: function variance(scale, shape) {
    return scale * scale * jStat.gammafn(1 + 2 / shape) -
        Math.pow(this.mean(scale, shape), 2);
  }
});



// extend uniform function with static methods
jStat.extend(jStat.uniform, {
  pdf: function pdf(x, a, b) {
    return (x < a || x > b) ? 0 : 1 / (b - a);
  },

  cdf: function cdf(x, a, b) {
    if (x < a)
      return 0;
    else if (x < b)
      return (x - a) / (b - a);
    return 1;
  },

  inv: function(p, a, b) {
    return a + (p * (b - a));
  },

  mean: function mean(a, b) {
    return 0.5 * (a + b);
  },

  median: function median(a, b) {
    return jStat.mean(a, b);
  },

  mode: function mode(a, b) {
    throw new Error('mode is not yet implemented');
  },

  sample: function sample(a, b) {
    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * Math.random() - 1);
  },

  variance: function variance(a, b) {
    return Math.pow(b - a, 2) / 12;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.binomial, {
  pdf: function pdf(k, n, p) {
    return (p === 0 || p === 1) ?
      ((n * p) === k ? 1 : 0) :
      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
  },

  cdf: function cdf(x, n, p) {
    var binomarr = [],
    k = 0;
    if (x < 0) {
      return 0;
    }
    if (x < n) {
      for (; k <= x; k++) {
        binomarr[ k ] = jStat.binomial.pdf(k, n, p);
      }
      return jStat.sum(binomarr);
    }
    return 1;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.negbin, {
  pdf: function pdf(k, r, p) {
    return k !== k | 0
      ? false
      : k < 0
        ? 0
        : jStat.combination(k + r - 1, r - 1) * Math.pow(1 - p, k) * Math.pow(p, r);
  },

  cdf: function cdf(x, r, p) {
    var sum = 0,
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sum += jStat.negbin.pdf(k, r, p);
    }
    return sum;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.hypgeom, {
  pdf: function pdf(k, N, m, n) {
    // Hypergeometric PDF.

    // A simplification of the CDF algorithm below.

    // k = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(k !== k | 0) {
      return false;
    } else if(k < 0 || k < m - (N - n)) {
      // It's impossible to have this few successes drawn.
      return 0;
    } else if(k > n || k > m) {
      // It's impossible to have this many successes drawn.
      return 0;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return jStat.hypgeom.pdf(n - k, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return jStat.hypgeom.pdf(m - k, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.pdf(k, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate product to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < k; i++) {
        // For every possible number of successes up to that observed...

        while(scaledPDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          scaledPDF *= 1 - (m / (N - samplesDone));

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledPDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledPDF));
    }
  },

  cdf: function cdf(x, N, m, n) {
    // Hypergeometric CDF.

    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,
    // and comes from his hypergeometric test calculator at
    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.

    // x = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(x < 0 || x < m - (N - n)) {
      // It's impossible to have this few successes drawn or fewer.
      return 0;
    } else if(x >= n || x >= m) {
      // We will always have this many successes or fewer.
      return 1;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.cdf(x, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate sum to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // Holds the intermediate, scaled total CDF.
      var scaledCDF = 1;

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < x; i++) {
        // For every possible number of successes up to that observed...

        while(scaledCDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          var factor = 1 - (m / (N - samplesDone));

          scaledPDF *= factor;
          scaledCDF *= factor;

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));

        // Add to the CDF answer.
        scaledCDF += scaledPDF;
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledCDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledCDF));
    }
  }
});



// extend uniform function with static methods
jStat.extend(jStat.poisson, {
  pdf: function pdf(k, l) {
    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);
  },

  cdf: function cdf(x, l) {
    var sumarr = [],
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sumarr.push(jStat.poisson.pdf(k, l));
    }
    return jStat.sum(sumarr);
  },

  mean : function(l) {
    return l;
  },

  variance : function(l) {
    return l;
  },

  sample: function sample(l) {
    var p = 1, k = 0, L = Math.exp(-l);
    do {
      k++;
      p *= Math.random();
    } while (p > L);
    return k - 1;
  }
});

// extend triangular function with static methods
jStat.extend(jStat.triangular, {
  pdf: function pdf(x, a, b, c) {
    if (b <= a || c < a || c > b) {
      return NaN;
    } else {
      if (x < a || x > b) {
        return 0;
      } else if (x < c) {
          return (2 * (x - a)) / ((b - a) * (c - a));
      } else if (x === c) {
          return (2 / (b - a));
      } else { // x > c
          return (2 * (b - x)) / ((b - a) * (b - c));
      }
    }
  },

  cdf: function cdf(x, a, b, c) {
    if (b <= a || c < a || c > b)
      return NaN;
    if (x <= a)
      return 0;
    else if (x >= b)
      return 1;
    if (x <= c)
      return Math.pow(x - a, 2) / ((b - a) * (c - a));
    else // x > c
      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));
  },

  inv: function inv(p, a, b, c) {
    if (b <= a || c < a || c > b) {
      return NaN;
    } else {
      if (p <= ((c - a) / (b - a))) {
        return a + (b - a) * Math.sqrt(p * ((c - a) / (b - a)));
      } else { // p > ((c - a) / (b - a))
        return a + (b - a) * (1 - Math.sqrt((1 - p) * (1 - ((c - a) / (b - a)))));
      }
    }
  },

  mean: function mean(a, b, c) {
    return (a + b + c) / 3;
  },

  median: function median(a, b, c) {
    if (c <= (a + b) / 2) {
      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);
    } else if (c > (a + b) / 2) {
      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);
    }
  },

  mode: function mode(a, b, c) {
    return c;
  },

  sample: function sample(a, b, c) {
    var u = Math.random();
    if (u < ((c - a) / (b - a)))
      return a + Math.sqrt(u * (b - a) * (c - a))
    return b - Math.sqrt((1 - u) * (b - a) * (b - c));
  },

  variance: function variance(a, b, c) {
    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
  }
});

}(this.jStat, Math));
/* Provides functions for the solution of linear system of equations, integration, extrapolation,
 * interpolation, eigenvalue problems, differential equations and PCA analysis. */

(function(jStat, Math) {

var push = Array.prototype.push;
var isArray = jStat.utils.isArray;

jStat.extend({

  // add a vector/matrix to a vector/matrix or scalar
  add: function add(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value + arg[row][col];
      });
    }
    return jStat.map(arr, function(value) { return value + arg; });
  },

  // subtract a vector or scalar from the vector
  subtract: function subtract(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value - arg[row][col] || 0;
      });
    }
    return jStat.map(arr, function(value) { return value - arg; });
  },

  // matrix division
  divide: function divide(arr, arg) {
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.multiply(arr, jStat.inv(arg));
    }
    return jStat.map(arr, function(value) { return value / arg; });
  },

  // matrix multiplication
  multiply: function multiply(arr, arg) {
    var row, col, nrescols, sum,
    nrow = arr.length,
    ncol = arr[0].length,
    res = jStat.zeros(nrow, nrescols = (isArray(arg)) ? arg[0].length : ncol),
    rescols = 0;
    if (isArray(arg)) {
      for (; rescols < nrescols; rescols++) {
        for (row = 0; row < nrow; row++) {
          sum = 0;
          for (col = 0; col < ncol; col++)
          sum += arr[row][col] * arg[col][rescols];
          res[row][rescols] = sum;
        }
      }
      return (nrow === 1 && rescols === 1) ? res[0][0] : res;
    }
    return jStat.map(arr, function(value) { return value * arg; });
  },

  // Returns the dot product of two matricies
  dot: function dot(arr, arg) {
    if (!isArray(arr[0])) arr = [ arr ];
    if (!isArray(arg[0])) arg = [ arg ];
    // convert column to row vector
    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,
    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,
    res = [],
    row = 0,
    nrow = left.length,
    ncol = left[0].length,
    sum, col;
    for (; row < nrow; row++) {
      res[row] = [];
      sum = 0;
      for (col = 0; col < ncol; col++)
      sum += left[row][col] * right[row][col];
      res[row] = sum;
    }
    return (res.length === 1) ? res[0] : res;
  },

  // raise every element by a scalar
  pow: function pow(arr, arg) {
    return jStat.map(arr, function(value) { return Math.pow(value, arg); });
  },

  // exponentiate every element
  exp: function exp(arr) {
    return jStat.map(arr, function(value) { return Math.exp(value); });
  },

  // generate the natural log of every element
  log: function exp(arr) {
    return jStat.map(arr, function(value) { return Math.log(value); });
  },

  // generate the absolute values of the vector
  abs: function abs(arr) {
    return jStat.map(arr, function(value) { return Math.abs(value); });
  },

  // computes the p-norm of the vector
  // In the case that a matrix is passed, uses the first row as the vector
  norm: function norm(arr, p) {
    var nnorm = 0,
    i = 0;
    // check the p-value of the norm, and set for most common case
    if (isNaN(p)) p = 2;
    // check if multi-dimensional array, and make vector correction
    if (isArray(arr[0])) arr = arr[0];
    // vector norm
    for (; i < arr.length; i++) {
      nnorm += Math.pow(Math.abs(arr[i]), p);
    }
    return Math.pow(nnorm, 1 / p);
  },

  // computes the angle between two vectors in rads
  // In case a matrix is passed, this uses the first row as the vector
  angle: function angle(arr, arg) {
    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));
  },

  // augment one matrix by another
  // Note: this function returns a matrix, not a jStat object
  aug: function aug(a, b) {
    var newarr = a.slice(),
    i = 0;
    for (; i < newarr.length; i++) {
      push.apply(newarr[i], b[i]);
    }
    return newarr;
  },

  // The inv() function calculates the inverse of a matrix
  // Create the inverse by augmenting the matrix by the identity matrix of the
  // appropriate size, and then use G-J elimination on the augmented matrix.
  inv: function inv(a) {
    var rows = a.length;
    var cols = a[0].length;
    var b = jStat.identity(rows, cols);
    var c = jStat.gauss_jordan(a, b);
    var result = [];
    var i = 0;
    var j;

    //We need to copy the inverse portion to a new matrix to rid G-J artifacts
    for (; i < rows; i++) {
      result[i] = [];
      for (j = cols; j < c[0].length; j++)
        result[i][j - cols] = c[i][j];
    }
    return result;
  },

  // calculate the determinant of a matrix
  det: function det(a) {
    var alen = a.length,
    alend = alen * 2,
    vals = new Array(alend),
    rowshift = alen - 1,
    colshift = alend - 1,
    mrow = rowshift - alen + 1,
    mcol = colshift,
    i = 0,
    result = 0,
    j;
    // check for special 2x2 case
    if (alen === 2) {
      return a[0][0] * a[1][1] - a[0][1] * a[1][0];
    }
    for (; i < alend; i++) {
      vals[i] = 1;
    }
    for (i = 0; i < alen; i++) {
      for (j = 0; j < alen; j++) {
        vals[(mrow < 0) ? mrow + alen : mrow ] *= a[i][j];
        vals[(mcol < alen) ? mcol + alen : mcol ] *= a[i][j];
        mrow++;
        mcol--;
      }
      mrow = --rowshift - alen + 1;
      mcol = --colshift;
    }
    for (i = 0; i < alen; i++) {
      result += vals[i];
    }
    for (; i < alend; i++) {
      result -= vals[i];
    }
    return result;
  },

  gauss_elimination: function gauss_elimination(a, b) {
    var i = 0,
    j = 0,
    n = a.length,
    m = a[0].length,
    factor = 1,
    sum = 0,
    x = [],
    maug, pivot, temp, k;
    a = jStat.aug(a, b);
    maug = a[0].length;
    for(i = 0; i < n; i++) {
      pivot = a[i][i];
      j = i;
      for (k = i + 1; k < m; k++) {
        if (pivot < Math.abs(a[k][i])) {
          pivot = a[k][i];
          j = k;
        }
      }
      if (j != i) {
        for(k = 0; k < maug; k++) {
          temp = a[i][k];
          a[i][k] = a[j][k];
          a[j][k] = temp;
        }
      }
      for (j = i + 1; j < n; j++) {
        factor = a[j][i] / a[i][i];
        for(k = i; k < maug; k++) {
          a[j][k] = a[j][k] - factor * a[i][k];
        }
      }
    }
    for (i = n - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j<= n - 1; j++) {
        sum = sum + x[j] * a[i][j];
      }
      x[i] =(a[i][maug - 1] - sum) / a[i][i];
    }
    return x;
  },

  gauss_jordan: function gauss_jordan(a, b) {
    var m = jStat.aug(a, b),
    h = m.length,
    w = m[0].length;
    // find max pivot
    for (var y = 0; y < h; y++) {
      var maxrow = y;
      for (var y2 = y+1; y2 < h; y2++) {
        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
          maxrow = y2;
      }
      var tmp = m[y];
      m[y] = m[maxrow];
      m[maxrow] = tmp
      for (var y2 = y+1; y2 < h; y2++) {
        c = m[y2][y] / m[y][y];
        for (var x = y; x < w; x++) {
          m[y2][x] -= m[y][x] * c;
        }
      }
    }
    // backsubstitute
    for (var y = h-1; y >= 0; y--) {
      c = m[y][y];
      for (var y2 = 0; y2 < y; y2++) {
        for (var x = w-1; x > y-1; x--) {
          m[y2][x] -= m[y][x] * m[y2][y] / c;
        }
      }
      m[y][y] /= c;
      for (var x = h; x < w; x++) {
        m[y][x] /= c;
      }
    }
    return m;
  },

  lu: function lu(a, b) {
    throw new Error('lu not yet implemented');
  },

  cholesky: function cholesky(a, b) {
    throw new Error('cholesky not yet implemented');
  },

  gauss_jacobi: function gauss_jacobi(a, b, x, r) {
    var i = 0;
    var j = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);
    c = jStat.multiply(jStat.inv(d), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  gauss_seidel: function gauss_seidel(a, b, x, r) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);
    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i = i + 1;
    }
    return xk;
  },

  SOR: function SOR(a, b, x, r, w) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),
                       jStat.subtract(jStat.multiply(d, 1 - w),
                                      jStat.multiply(u, w)));
    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,
        jStat.multiply(l, w))), b), w);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  householder: function householder(a) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var alpha, r, k, j, factor;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
      alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, jStat.multiply(a, p));
    }
    return a;
  },

  // TODO: not working properly.
  QR: function QR(a, b) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var x = [];
    var j, alpha, r, k, factor, sum;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
        alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++)
        w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, a);
      b = jStat.multiply(p, b);
    }
    for (i = m - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j <= n - 1; j++)
      sum = x[j] * a[i][j];
      x[i] = b[i][0] / a[i][i];
    }
    return x;
  },

  jacobi: function jacobi(a) {
    var condition = 1;
    var count = 0;
    var n = a.length;
    var e = jStat.identity(n, n);
    var ev = [];
    var b, i, j, p, q, maxim, theta, s;
    // condition === 1 only if tolerance is not reached
    while (condition === 1) {
      count++;
      maxim = a[0][1];
      p = 0;
      q = 1;
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          if (i != j) {
            if (maxim < Math.abs(a[i][j])) {
              maxim = Math.abs(a[i][j]);
              p = i;
              q = j;
            }
          }
        }
      }
      if (a[p][p] === a[q][q])
        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;
      else
        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;
      s = jStat.identity(n, n);
      s[p][p] = Math.cos(theta);
      s[p][q] = -Math.sin(theta);
      s[q][p] = Math.sin(theta);
      s[q][q] = Math.cos(theta);
      // eigen vector matrix
      e = jStat.multiply(e, s);
      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);
      a = b;
      condition = 0;
      for (i = 1; i < n; i++) {
        for (j = 1; j < n; j++) {
          if (i != j && Math.abs(a[i][j]) > 0.001) {
            condition = 1;
          }
        }
      }
    }
    for (i = 0; i < n; i++) ev.push(a[i][i]);
    //returns both the eigenvalue and eigenmatrix
    return [e, ev];
  },

  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {
    var k1, k2, u_j1, k3, k4;
    if (order === 2) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h, u_j + k1);
        u_j1 = u_j + (k1 + k2) / 2;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    if (order === 4) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h / 2, u_j + k1 / 2);
        k3 = h * f(t_j + h / 2, u_j + k2 / 2);
        k4 = h * f(t_j +h, u_j + k3);
        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    return u_j;
  },

  romberg: function romberg(f, a, b, order) {
    var i = 0;
    var h = (b - a) / 2;
    var x = [];
    var h1 = [];
    var g = [];
    var m, a1, j, k, I, d;
    while (i < order / 2) {
      I = f(a);
      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;
      m = x.length;
      for (j = 1; j < m - 1; j++) {
        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);
      }
      I = (h / 3) * (I + f(b));
      g[i] = I;
      h /= 2;
      i++;
    }
    a1 = g.length;
    m = 1;
    while (a1 !== 1) {
      for (j = 0; j < a1 - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a1 = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  richardson: function richardson(X, f, x, h) {
    function pos(X, x) {
      var i = 0;
      var n = X.length;
      var p;
      for (; i < n; i++)
        if (X[i] === x) p = i;
      return p;
    }
    var n = X.length,
    h_min = Math.abs(x - X[pos(X, x) + 1]),
    i = 0,
    g = [],
    h1 = [],
    y1, y2, m, a, j;
    while (h >= h_min) {
      y1 = pos(X, x + h);
      y2 = pos(X, x);
      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);
      h /= 2;
      i++;
    }
    a = g.length;
    m = 1;
    while (a != 1) {
      for (j = 0; j < a - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  simpson: function simpson(f, a, b, n) {
    var h = (b - a) / n;
    var I = f(a);
    var x = [];
    var j = a;
    var k = 0;
    var i = 1;
    var m;
    for (; j <= b; j = j + h, k++)
      x[k] = j;
    m = x.length;
    for (; i < m - 1; i++) {
      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);
    }
    return (h / 3) * (I + f(b));
  },

  hermite: function hermite(X, F, dF, value) {
    var n = X.length;
    var p = 0;
    var i = 0;
    var l = [];
    var dl = [];
    var A = [];
    var B = [];
    var j;
    for (; i < n; i++) {
      l[i] = 1;
      for (j = 0; j < n; j++) {
        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);
      }
      dl[i] = 0;
      for (j = 0; j < n; j++) {
        if (i != j) dl[i] += 1 / (X [i] - X[j]);
      }
      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);
      B[i] = (value - X[i]) * (l[i] * l[i]);
      p += (A[i] * F[i] + B[i] * dF[i]);
    }
    return p;
  },

  lagrange: function lagrange(X, F, value) {
    var p = 0;
    var i = 0;
    var j, l;
    var n = X.length;
    for (; i < n; i++) {
      l = F[i];
      for (j = 0; j < n; j++) {
        // calculating the lagrange polynomial L_i
        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);
      }
      // adding the lagrange polynomials found above
      p += l;
    }
    return p;
  },

  cubic_spline: function cubic_spline(X, F, value) {
    var n = X.length;
    var i = 0, j;
    var A = [];
    var B = [];
    var alpha = [];
    var c = [];
    var h = [];
    var b = [];
    var d = [];
    for (; i < n - 1; i++)
      h[i] = X[i + 1] - X[i];
    alpha[0] = 0;
    for (i = 1; i < n - 1; i++) {
      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -
          (3 / h[i-1]) * (F[i] - F[i-1]);
    }
    for (i = 1; i < n - 1; i++) {
      A[i] = [];
      B[i] = [];
      A[i][i-1] = h[i-1];
      A[i][i] = 2 * (h[i - 1] + h[i]);
      A[i][i+1] = h[i];
      B[i][0] = alpha[i];
    }
    c = jStat.multiply(jStat.inv(A), B);
    for (j = 0; j < n - 1; j++) {
      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;
      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);
    }
    for (j = 0; j < n; j++) {
      if (X[j] > value) break;
    }
    j -= 1;
    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *
        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];
  },

  gauss_quadrature: function gauss_quadrature() {
    throw new Error('gauss_quadrature not yet implemented');
  },

  PCA: function PCA(X) {
    var m = X.length;
    var n = X[0].length;
    var flag = false;
    var i = 0;
    var j, temp1;
    var u = [];
    var D = [];
    var result = [];
    var temp2 = [];
    var Y = [];
    var Bt = [];
    var B = [];
    var C = [];
    var V = [];
    var Vt = [];
    for (i = 0; i < m; i++) {
      u[i] = jStat.sum(X[i]) / n;
    }
    for (i = 0; i < n; i++) {
      B[i] = [];
      for(j = 0; j < m; j++) {
        B[i][j] = X[j][i] - u[j];
      }
    }
    B = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      C[i] = [];
      for (j = 0; j < m; j++) {
        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);
      }
    }
    result = jStat.jacobi(C);
    V = result[0];
    D = result[1];
    Vt = jStat.transpose(V);
    for (i = 0; i < D.length; i++) {
      for (j = i; j < D.length; j++) {
        if(D[i] < D[j])  {
          temp1 = D[i];
          D[i] = D[j];
          D[j] = temp1;
          temp2 = Vt[i];
          Vt[i] = Vt[j];
          Vt[j] = temp2;
        }
      }
    }
    Bt = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      Y[i] = [];
      for (j = 0; j < Bt.length; j++) {
        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);
      }
    }
    return [X, D, Vt, Y];
  }
});

// extend jStat.fn with methods that require one argument
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function(arg, func) {
      var tmpthis = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));
        }, 15);
        return this;
      }
      if (typeof jStat[passfunc](this, arg) === 'number')
        return jStat[passfunc](this, arg);
      else
        return jStat(jStat[passfunc](this, arg));
    };
  }(funcs[i]));
}('add divide multiply subtract dot pow exp log abs norm angle'.split(' ')));

}(this.jStat, Math));
(function(jStat, Math) {

var slice = [].slice;
var isNumber = jStat.utils.isNumber;
var isArray = jStat.utils.isArray;

// flag==true denotes use of sample standard deviation
// Z Statistics
jStat.extend({
  // 2 different parameter lists:
  // (value, mean, sd)
  // (value, array, flag)
  zscore: function zscore() {
    var args = slice.call(arguments);
    if (isNumber(args[1])) {
      return (args[0] - args[1]) / args[2];
    }
    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);
  },

  // 3 different paramter lists:
  // (value, mean, sd, sides)
  // (zscore, sides)
  // (value, array, sides, flag)
  ztest: function ztest() {
    var args = slice.call(arguments);
    var z;
    if (isArray(args[1])) {
      // (value, array, sides, flag)
      z = jStat.zscore(args[0],args[1],args[3]);
      return (args[2] === 1) ?
        (jStat.normal.cdf(-Math.abs(z), 0, 1)) :
        (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);
    } else {
      if (args.length > 2) {
        // (value, mean, sd, sides)
        z = jStat.zscore(args[0],args[1],args[2]);
        return (args[3] === 1) ?
          (jStat.normal.cdf(-Math.abs(z),0,1)) :
          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);
      } else {
        // (zscore, sides)
        z = args[0];
        return (args[1] === 1) ?
          (jStat.normal.cdf(-Math.abs(z),0,1)) :
          (jStat.normal.cdf(-Math.abs(z),0,1)*2);
      }
    }
  }
});

jStat.extend(jStat.fn, {
  zscore: function zscore(value, flag) {
    return (value - this.mean()) / this.stdev(flag);
  },

  ztest: function ztest(value, sides, flag) {
    var zscore = Math.abs(this.zscore(value, flag));
    return (sides === 1) ?
      (jStat.normal.cdf(-zscore, 0, 1)) :
      (jStat.normal.cdf(-zscore, 0, 1) * 2);
  }
});

// T Statistics
jStat.extend({
  // 2 parameter lists
  // (value, mean, sd, n)
  // (value, array)
  tscore: function tscore() {
    var args = slice.call(arguments);
    return (args.length === 4) ?
      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :
      ((args[0] - jStat.mean(args[1])) /
       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));
  },

  // 3 different paramter lists:
  // (value, mean, sd, n, sides)
  // (tscore, n, sides)
  // (value, array, sides)
  ttest: function ttest() {
    var args = slice.call(arguments);
    var tscore;
    if (args.length === 5) {
      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));
      return (args[4] === 1) ?
        (jStat.studentt.cdf(-tscore, args[3]-1)) :
        (jStat.studentt.cdf(-tscore, args[3]-1)*2);
    }
    if (isNumber(args[1])) {
      tscore = Math.abs(args[0])
      return (args[2] == 1) ?
        (jStat.studentt.cdf(-tscore, args[1]-1)) :
        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);
    }
    tscore = Math.abs(jStat.tscore(args[0], args[1]))
    return (args[2] == 1) ?
      (jStat.studentt.cdf(-tscore, args[1].length-1)) :
      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);
  }
});

jStat.extend(jStat.fn, {
  tscore: function tscore(value) {
    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));
  },

  ttest: function ttest(value, sides) {
    return (sides === 1) ?
      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :
      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);
  }
});

// F Statistics
jStat.extend({
  // Paramter list is as follows:
  // (array1, array2, array3, ...)
  // or it is an array of arrays
  // array of arrays conversion
  anovafscore: function anovafscore() {
    var args = slice.call(arguments),
    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;
    if (args.length === 1) {
      tmpargs = new Array(args[0].length);
      for (i = 0; i < args[0].length; i++) {
        tmpargs[i] = args[0][i];
      }
      args = tmpargs;
    }
    // 2 sample case
    if (args.length === 2) {
      return jStat.variance(args[0]) / jStat.variance(args[1]);
    }
    // Builds sample array
    sample = new Array();
    for (i = 0; i < args.length; i++) {
      sample = sample.concat(args[i]);
    }
    sampMean = jStat.mean(sample);
    // Computes the explained variance
    expVar = 0;
    for (i = 0; i < args.length; i++) {
      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);
    }
    expVar /= (args.length - 1);
    // Computes unexplained variance
    unexpVar = 0;
    for (i = 0; i < args.length; i++) {
      sampSampMean = jStat.mean(args[i]);
      for (j = 0; j < args[i].length; j++) {
        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);
      }
    }
    unexpVar /= (sample.length - args.length);
    return expVar / unexpVar;
  },

  // 2 different paramter setups
  // (array1, array2, array3, ...)
  // (anovafscore, df1, df2)
  anovaftest: function anovaftest() {
    var args = slice.call(arguments),
    df1, df2, n, i;
    if (isNumber(args[0])) {
      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);
    }
    anovafscore = jStat.anovafscore(args);
    df1 = args.length - 1;
    n = 0;
    for (i = 0; i < args.length; i++) {
      n = n + args[i].length;
    }
    df2 = n - df1 - 1;
    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);
  },

  ftest: function ftest(fscore, df1, df2) {
    return 1 - jStat.centralF.cdf(fscore, df1, df2);
  }
});

jStat.extend(jStat.fn, {
  anovafscore: function anovafscore() {
    return jStat.anovafscore(this.toArray());
  },

  anovaftes: function anovaftes() {
    var n = 0;
    var i;
    for (i = 0; i < this.length; i++) {
      n = n + this[i].length;
    }
    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);
  }
});

// Error Bounds
jStat.extend({
  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  normalci: function normalci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  tci: function tci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *
                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  significant: function significant(pvalue, alpha) {
    return pvalue < alpha;
  }
});

jStat.extend(jStat.fn, {
  normalci: function normalci(value, alpha) {
    return jStat.normalci(value, alpha, this.toArray());
  },

  tci: function tci(value, alpha) {
    return jStat.tci(value, alpha, this.toArray());
  }
});

// internal method for calculating the z-score for a difference of proportions test
function differenceOfProportions(p1, n1, p2, n2) {
  if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {
    throw new Error("Proportions should be greater than 0 and less than 1")
  }
  var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);
  var se = Math.sqrt(pooled * (1 - pooled) * ((1/n1) + (1/n2)));
  return (p1 - p2) / se;
}

// Difference of Proportions
jStat.extend(jStat.fn, {
  oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {
    var z = differenceOfProportions(p1, n1, p2, n2);
    return jStat.ztest(z, 1);
  },

  twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {
    var z = differenceOfProportions(p1, n1, p2, n2);
    return jStat.ztest(z, 2);
  }
});

}(this.jStat, Math));

return this.jStat;

});
define('js/statistics/chiSquare',["require", "exports", "jstat"], function (require, exports, jStat) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    // Derived from: https://en.wikipedia.org/wiki/Pearson's_chi-squared_test
    function chiSquare(observed, expected, degreesOfFreedom) {
        if (degreesOfFreedom === void 0) { degreesOfFreedom = undefined; }
        if (observed.length !== expected.length) {
            throw new Error("chiSquare: observed.length !== expected.length");
        }
        if (!degreesOfFreedom)
            degreesOfFreedom = observed.length - 1;
        if (degreesOfFreedom >= observed.length) {
            throw new Error("chiSquare: degreesOfFreedom is too large for length: " + degreesOfFreedom + " " + observed.length);
        }
        var x2 = 0;
        var observedTotal = 0;
        var expectedTotal = 0;
        for (var i = 0; i < observed.length; i++) {
            x2 += Math.pow(observed[i] - expected[i], 2) / expected[i];
            observedTotal += observed[i];
            expectedTotal += expected[i];
        }
        if (observedTotal !== Math.round(expectedTotal)) {
            console.log("Error chiSquare observedTotal", observedTotal, "expectedTotal", expectedTotal, "observed", observed, "expected", expected);
            throw new Error("chiSquare: observedTotal !== expectedTotal");
        }
        // const p = 1 - jStat.lowRegGamma(degreesOfFreedom / 2, x2 / 2) / jStat.gammafn(degreesOfFreedom / 2);
        var p = 1 - jStat.chisquare.cdf(x2, degreesOfFreedom);
        var result = { x2: x2, p: p, k: degreesOfFreedom, n: observed.length };
        return result;
    }
    exports.chiSquare = chiSquare;
    // Data from Apache Commons Math ChiSquareTestTest.java
    function test() {
        var observed = [10, 9, 11];
        var expected = [10, 10, 10];
        // expected x2 = 0.2
        // expected p = 0.904837418036
        console.log("chiSquare", chiSquare(observed, expected));
        // was { x2: 0.2, p: 0.9048374180359595 }
        // The original test data seems buggy!!! Missing 90 somewhere in expected
        var observed1 = [500, 623, 72, 70, 31];
        var expected1 = [485, 541, 82, 61, 37];
        // Expected x2 = 9.023307936427388
        // Expected p = 0.06051952647453607
        // was // { x2: 16.413107036160778, p: 0.002512095663000702 }
        // Data from Wikipedia
        var observed2 = [5, 8, 9, 8, 10, 20];
        var expected2 = [10, 10, 10, 10, 10, 10];
        // Expect x2 = 13.4
        // Expected p = ???
        console.log("chiSquare", chiSquare(observed2, expected2));
        // Was  { x2: 13.4, p: 0.019905220334774376 }
    }
});
// test(); 

define('js/statistics/statisticsCommon',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function repeatCounts(array) {
        var values = {};
        for (var i = 0; i < array.length; i++) {
            var value = array[i];
            if (values[value] !== undefined) {
                values[value] += 1;
            }
            else {
                values[value] = 1;
            }
        }
        var result = [];
        for (var index in values) {
            var count = values[index];
            if (count > 1)
                result.push(count);
        }
        return result;
    }
    exports.repeatCounts = repeatCounts;
    function rankdata(a) {
        /*
        Ranks the data in a, dealing with ties appropriately.
    
        Equal values are assigned a rank that is the average of the ranks that
        would have been otherwise assigned to all of the values within that set.
        Ranks begin at 1, not 0.
    
        Example
        -------
        In [15]: stats.rankdata([0, 2, 2, 3])
        Out[15]: array([ 1. ,  2.5,  2.5,  4. ])
    
        Parameters
        ----------
        a : array
    
        Returns
        -------
        An array of length equal to the size of a, containing rank scores.
       
        */
        var n = a.length;
        var i;
        var j;
        var sortedArray = [];
        for (var i_1 = 0; i_1 < n; i_1++) {
            sortedArray.push({ originalPosition: i_1, value: a[i_1] });
        }
        sortedArray.sort(function (a, b) { return a.value - b.value; });
        var newarray = newFilledArray(n);
        var sumranks = 0;
        var dupcount = 0;
        for (var i_2 = 0; i_2 < n; i_2++) {
            sumranks += i_2;
            dupcount += 1;
            if (i_2 === n - 1 || sortedArray[i_2].value !== sortedArray[i_2 + 1].value) {
                var averank = sumranks / dupcount + 1;
                for (j = i_2 - dupcount + 1; j < i_2 + 1; j++) {
                    newarray[sortedArray[j].originalPosition] = averank;
                }
                sumranks = 0;
                dupcount = 0;
            }
        }
        return newarray;
    }
    exports.rankdata = rankdata;
    function rankdata_test() {
        var result = rankdata([0, 2, 2, 3]);
        console.log("rankdata self-test", result);
        // Should be: [ 1, 2.5, 2.5, 4 ]
    }
    // rankdata_test();
    function newFilledArray(length, val) {
        if (val === void 0) { val = 0; }
        var array = [];
        for (var i = 0; i < length; i++) {
            array[i] = val;
        }
        return array;
    }
    exports.newFilledArray = newFilledArray;
});

define('js/statistics/mannWhitneyU',["require", "exports", "jstat", "./statisticsCommon"], function (require, exports, jStat, statisticsCommon) {
    "use strict";
    "use strict";
    // Calculates Mann-Whitney U test
    // Derived from older SciPy: http://web.mit.edu/6.863/spring2011/packages/scipy_src/scipy/stats/stats.py
    // Calculates a Mann-Whitney U statistic on the provided scores and returns the result.
    // Use only when the n in each condition is < 20 and you have 2 independent samples of ranks.
    // REMEMBER: Mann-Whitney U is significant if the u-obtained is LESS THAN or equal to the critical value of U.
    // Returns: u-statistic, one-tailed p-value (i.e., p(z(U)))
    function mannWhitneyU(x, y) {
        var n1 = x.length;
        var n2 = y.length;
        var allValues = x.concat(y);
        var ranked = statisticsCommon.rankdata(allValues);
        // get the x-ranks
        var rankx = ranked.slice(0, n1);
        // the rest are y-ranks
        var ranky = ranked.slice(n1);
        // calc U for x
        var u1 = n1 * n2 + (n1 * (n1 + 1)) / 2.0 - jStat.sum(rankx);
        // remainder is U for y
        var u2 = n1 * n2 - u1;
        var bigu = Math.max(u1, u2);
        var smallu = Math.min(u1, u2);
        // correction factor for tied scores
        // was: const T = Math.sqrt(tiecorrect(ranked));
        // Note: in the scipy commit of Mar 26, 2009 (https://github.com/scipy/scipy/commit/e40b50ef1600c25d1a31005a71b9c148271aa8e5)
        // the sqrt was removed. The commit says "correct tiecorrection" but does not say WHY the correction was made.
        // In this mailing list post (https://mail.python.org/pipermail/scipy-user/2009-February/019766.html), it says:
        // ------------------------------------------------------------------------
        // I think there is a mistake in the tie handling of stats.mannwhitneyu
        // In the calculation of the standard error the sqrt is taken twice.
        // 
        //     T = np.sqrt(tiecorrect(ranked))  # correction factor for tied scores
        //     if T == 0:
        //         raise ValueError, 'All numbers are identical in amannwhitneyu'
        //     sd = np.sqrt(T*n1*n2*(n1+n2+1)/12.0)
        // 
        // I don't have the formulas for the tie correction, but from looking at the tie correction
        // in Sturlas version of ranksums, it seems that the first sqrt shouldn't be there.
        // ------------------------------------------------------------------------
        // The post is signed by "Josef," which is the same name as the person who made the commit (probably Josef Perktold).
        // The correction does seem to fit the calculations on the Wikipedia page:
        // https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test#Normal_approximation_and_tie_correction
        var T = tiecorrect(ranked);
        if (T === 0) {
            throw new Error("Mann-Whitney U test: All numbers are identical.");
        }
        var sd = Math.sqrt(T * n1 * n2 * (n1 + n2 + 1) / 12.0);
        // Note: scipy has a "use_continuity" argument for the continuity correction of 0.5 in the calculation of z
        // I think that because NF often deals with small sample sizes, 
        // and because it has pseudo-continuous data (scale markings are integers, and they are not measurements),
        // it is best to apply the correction in all cases rather than ask the user what they want to do for each test.
        // However, let us keep the option (set to a constant) in case we want to offer it to users later.
        var use_continuity = true;
        var z;
        if (use_continuity) {
            // normal approximation for prob calc with continuity correction
            z = Math.abs((bigu - 0.5 - n1 * n2 / 2.0) / sd);
        }
        else {
            // normal approximation for prob calc without continuity correction
            z = Math.abs((bigu - n1 * n2 / 2.0) / sd);
        }
        var p = 1.0 - jStat.normal.cdf(z, 0, 1);
        return { p: p, u: smallu, n1: n1, n2: n2 };
    }
    function tiecorrect(rankvals) {
        /*
        Tie-corrector for ties in Mann Whitney U and Kruskal Wallis H tests.
        See Siegel, S. (1956) Nonparametric Statistics for the Behavioral
        Sciences.  New York: McGraw-Hill.  Code adapted from |Stat rankind.c
        code.
    
        Returns: T correction factor for U or H
        */
        var sorted = rankvals.slice().sort(function (a, b) {
            return a - b;
        });
        var n = sorted.length;
        var T = 0.0;
        var i = 0;
        while (i < n - 1) {
            if (sorted[i] === sorted[i + 1]) {
                var nties = 1;
                while ((i < n - 1) && (sorted[i] === sorted[i + 1])) {
                    nties = nties + 1;
                    i = i + 1;
                }
                T = T + nties * nties * nties - nties;
            }
            i = i + 1;
        }
        T = T / (n * n * n - n);
        return 1.0 - T;
    }
    function test() {
        console.log("mannWhitneyU self diagnostic");
        var result1 = mannWhitneyU([1, 2, 3], [1, 2, 4]);
        console.log("result1", result1);
        // Result { u: 4, p: 0.5 }
        // Values from: http://www.stat.purdue.edu/~tqin/system101/method/method_wilcoxon_rank_sum_sas.htm
        var result2 = mannWhitneyU([17, 20, 170, 315, 22, 190, 64], [22, 29, 13, 16, 15, 18, 15, 6]);
        console.log("result2", result2);
        // Result { u: 6.5, p: 0.007453528422421307 }
        // Values from: http://geographyfieldwork.com/Mann%20Whitney.htm
        var result3 = mannWhitneyU([7, 3, 6, 2, 4, 3, 5, 5], [3, 5, 6, 4, 6, 5, 7, 5]);
        console.log("result3", result3);
        // result3 { u: 23, p: 0.18060905238025948 }
        // Useful for comparing, but off a bit for p: http://www.socscistatistics.com/tests/mannwhitney/default2.aspx
    }
    return mannWhitneyU;
});

define('js/calculateStatistics',["require", "exports", "jstat", "./statistics/chiSquare", "./statistics/mannWhitneyU"], function (require, exports, jStat, chiSquare, mannWhitneyU) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    exports.IGNOREANSWERCODE = "*IGNORE*";
    function isValidNumber(value) {
        return value !== "" && !isNaN(value);
    }
    function getChoiceValueForQuestionAndStory(question, story, unansweredText, includeNAValues, lumpingCommands) {
        if (!question)
            return null;
        if (question.id === "storyLength")
            return getStoryLengthValueForStory(story, question, unansweredText, includeNAValues, lumpingCommands);
        if (question.id === "collectionDate")
            return getCollectionDateValueForStory(story, question, unansweredText, includeNAValues, lumpingCommands);
        if (question.id === "language")
            return getLanguageForStory(story, question, unansweredText, includeNAValues, lumpingCommands);
        var value = story.fieldValue(question.id);
        if (value === undefined || value === null || value === "") {
            if (includeNAValues) {
                if (question.displayType === "checkboxes") {
                    var result = {};
                    result[unansweredText] = true;
                    return result;
                }
                else {
                    return unansweredText;
                }
            }
            else {
                return null;
            }
        }
        if (question.displayType === "checkbox") {
            if (value) {
                return "true";
            }
            else {
                return "false";
            }
        }
        else if (question.displayType === "boolean") {
            if (value) {
                return "yes";
            }
            else {
                return "no";
            }
        }
        else if (["radiobuttons", "checkboxes", "select"].indexOf(question.displayType) >= 0) {
            if (lumpingCommands.hasOwnProperty(question.displayName)) {
                if (question.displayType === "checkboxes") {
                    // do not want to change the actual values, because they are in the story
                    // so make a copy of the dictionary, change that, and return it
                    var answersToReport = {};
                    var valueKeys = Object.keys(value);
                    for (var i = 0; i < valueKeys.length; i++) {
                        // the answers entered into the lumping command are trimmed during parsing
                        // in v1.6.1, validation was added to require users to trim answers in lists for choice questions
                        // trimming this copied data should not be necessary in projects created in that version and afterward
                        // but legacy data could still have extra whitespace characters that make it incompatible with the display lumping system
                        // so we will trim it as we read it
                        var trimmedKey = valueKeys[i].trim();
                        answersToReport[trimmedKey] = value[valueKeys[i]];
                    }
                    var answersToLumpTogether = Object.keys(lumpingCommands[question.displayName]);
                    for (var i = 0; i < answersToLumpTogether.length; i++) {
                        // answersToLumpTogether (and substituteAnswer) do not need to be trimmed, because they are trimmed during parsing of the lumping command
                        var thisAnswer = answersToLumpTogether[i];
                        if (answersToReport.hasOwnProperty(thisAnswer) && answersToReport[thisAnswer]) {
                            var substituteAnswer = lumpingCommands[question.displayName][thisAnswer];
                            delete answersToReport[thisAnswer];
                            if (substituteAnswer !== exports.IGNOREANSWERCODE) {
                                answersToReport[substituteAnswer] = true;
                            }
                        }
                    }
                    return answersToReport;
                }
                else {
                    // the same value trimming has to take place here (again for legacy data)
                    var trimmedValue = value.trim();
                    if (lumpingCommands[question.displayName].hasOwnProperty(trimmedValue)) {
                        var substituteAnswer = lumpingCommands[question.displayName][trimmedValue];
                        if (substituteAnswer !== exports.IGNOREANSWERCODE) {
                            return substituteAnswer;
                        }
                        else {
                            return unansweredText;
                        }
                    }
                }
            }
        }
        return value;
    }
    exports.getChoiceValueForQuestionAndStory = getChoiceValueForQuestionAndStory;
    function getScaleValueForQuestionAndStory(question, story, unansweredText) {
        if (question.displayType !== "slider")
            return undefined;
        var value = story.fieldValue(question.id);
        if (value === undefined || value === null || value === "")
            return unansweredText;
        if (typeof value === "string")
            value = parseInt(value);
        return value;
    }
    exports.getScaleValueForQuestionAndStory = getScaleValueForQuestionAndStory;
    function getStoryLengthValueForStory(story, question, unansweredText, includeNAValues, lumpingCommands) {
        var value = story.storyLength();
        if (value == 0) {
            if (includeNAValues) {
                return unansweredText;
            }
            else {
                return null;
            }
        }
        else {
            var result = null;
            for (var i = 0; i < question.valueOptions.length; i++) {
                var optionAsInt = parseInt(question.valueOptions[i]);
                if (value <= optionAsInt) {
                    result = question.valueOptions[i];
                    break;
                }
            }
            if (!result) {
                result = question.valueOptions[question.valueOptions.length - 1];
            }
            if (lumpingCommands.hasOwnProperty(question.displayName)) {
                if (lumpingCommands[question.displayName].hasOwnProperty(result)) {
                    result = lumpingCommands[question.displayName][result];
                }
            }
            return result;
        }
    }
    function getCollectionDateValueForStory(story, question, unansweredText, includeNAValues, lumpingCommands) {
        var value = null;
        var dateUnit = question.displayConfiguration;
        if (dateUnit === "years") {
            value = story.storyCollectionYear();
        }
        else if (dateUnit === "quarters") {
            value = story.storyCollectionQuarter();
        }
        else if (dateUnit === "months") {
            value = story.storyCollectionYearAndMonth();
        }
        else if (dateUnit === "days") {
            value = story.storyCollectionDate();
        }
        if (!value) {
            if (includeNAValues) {
                return unansweredText;
            }
            else {
                return null;
            }
        }
        if (lumpingCommands.hasOwnProperty(question.displayName)) {
            if (lumpingCommands[question.displayName].hasOwnProperty(value))
                value = lumpingCommands[question.displayName][value];
        }
        return value;
    }
    function getLanguageForStory(story, question, unansweredText, includeNAValues, lumpingCommands) {
        var value = story.storyLanguage();
        if (!value) {
            if (includeNAValues) {
                return unansweredText;
            }
            else {
                return null;
            }
        }
        if (lumpingCommands.hasOwnProperty(question.displayName)) {
            if (lumpingCommands[question.displayName].hasOwnProperty(value))
                value = lumpingCommands[question.displayName][value];
        }
        return value;
    }
    function collectValuesForOneScale(stories, fieldName, conversionFunction) {
        if (conversionFunction === void 0) { conversionFunction = null; }
        var result = [];
        for (var i = 0; i < stories.length; i++) {
            var value = stories[i].fieldValue(fieldName);
            if (value === null || value === undefined || value === "")
                continue;
            if (conversionFunction)
                value = conversionFunction(value);
            result.push(value);
        }
        return result;
    }
    exports.collectValuesForOneScale = collectValuesForOneScale;
    function choiceValueMatchesQuestionOption(value, question, option) {
        if (value === null)
            return false;
        if (question.displayType === "checkboxes") {
            if (!value[option])
                return false;
        }
        else {
            if (value !== option)
                return false;
        }
        return true;
    }
    exports.choiceValueMatchesQuestionOption = choiceValueMatchesQuestionOption;
    function collectValuesForTwoScalesAndMaybeOneChoiceOption(stories, xFieldName, yFieldName, choiceQuestion, option, unansweredText, includeNAValues, lumpingCommands) {
        var xResult = [];
        var yResult = [];
        var unansweredCount = 0;
        for (var i = 0; i < stories.length; i++) {
            var xValue = stories[i].fieldValue(xFieldName);
            var yValue = stories[i].fieldValue(yFieldName);
            if (choiceQuestion) {
                var choiceValue = getChoiceValueForQuestionAndStory(choiceQuestion, stories[i], unansweredText, includeNAValues, lumpingCommands);
                if (choiceValueMatchesQuestionOption(choiceValue, choiceQuestion, option)) {
                    if (!isValidNumber(xValue) || !isValidNumber(yValue)) {
                        unansweredCount += 1;
                    }
                    else {
                        xResult.push(xValue);
                        yResult.push(yValue);
                    }
                }
            }
            else {
                xResult.push(xValue);
                yResult.push(yValue);
            }
        }
        return { x: xResult, y: yResult, unansweredCount: unansweredCount };
    }
    function collectValuesForOneScaleAndOneOrTwoChoices(stories, unansweredText, includeNAValues, lumpingCommands, scaleQuestion, choiceQuestion, secondChoiceQuestion) {
        if (secondChoiceQuestion === void 0) { secondChoiceQuestion = null; }
        function addValue(arrayHolder, fieldName, value, secondFieldName) {
            if (secondFieldName === void 0) { secondFieldName = null; }
            var key = fieldName;
            if (secondFieldName)
                key += ", " + secondFieldName;
            var values = arrayHolder[key];
            if (!values)
                values = [];
            values.push(value);
            arrayHolder[key] = values;
        }
        var values = {};
        for (var i = 0; i < stories.length; i++) {
            var story = stories[i];
            var scaleValue = stories[i].fieldValue(scaleQuestion.id);
            if (scaleValue === null || scaleValue === undefined || scaleValue === "")
                continue;
            var choiceValue = getChoiceValueForQuestionAndStory(choiceQuestion, story, unansweredText, includeNAValues, lumpingCommands);
            if (choiceValue === null || Object.keys(choiceValue).length === 0)
                continue;
            var secondChoiceValue = null;
            if (secondChoiceQuestion) {
                secondChoiceValue = getChoiceValueForQuestionAndStory(secondChoiceQuestion, story, unansweredText, includeNAValues, lumpingCommands);
                if (secondChoiceValue === null)
                    continue;
            }
            addValue(values, choiceValue, scaleValue, secondChoiceValue);
        }
        return values;
    }
    exports.collectValuesForOneScaleAndOneOrTwoChoices = collectValuesForOneScaleAndOneOrTwoChoices;
    function valueTag(field1, field2) {
        if (field1 === null || field1 === undefined || field1 === "")
            field1 = "{N/A}";
        if (field2 === null || field2 === undefined || field2 === "")
            field2 = "{N/A}";
        var result = JSON.stringify([field1, field2]);
        return result;
    }
    function collectValuesForTwoChoices(stories, field1, field2, unansweredText, includeNAValues, lumpingCommands) {
        function increment(countHolder, fieldName) {
            var count = countHolder[fieldName];
            if (!count)
                count = 0;
            count++;
            countHolder[fieldName] = count;
        }
        var counts = {};
        var field1Options = {};
        var field2Options = {};
        var total = 0;
        for (var i = 0; i < stories.length; i++) {
            // in this case the value cannot be an object, because stats are not run when either question is checkboxes 
            var value1 = getChoiceValueForQuestionAndStory(field1, stories[i], unansweredText, includeNAValues, lumpingCommands);
            var value2 = getChoiceValueForQuestionAndStory(field2, stories[i], unansweredText, includeNAValues, lumpingCommands);
            increment(counts, valueTag(value1, value2));
            increment(field1Options, "" + value1);
            increment(field2Options, "" + value2);
            total++;
        }
        var result = { counts: counts, field1Options: field1Options, field2Options: field2Options, total: total };
        return result;
    }
    function calculateStatisticsForPattern(pattern, stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands, progressUpdater, patternNumber, numPatterns, howOftenToUpdateProgressMessage) {
        var graphType = pattern.graphType;
        var statistics = null;
        if (graphType === "bar") {
            statistics = { statsSummary: "None", statsDetailed: [] };
        }
        else if (graphType === "table") {
            statistics = calculateStatisticsForTable(pattern.questions[0], pattern.questions[1], stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands);
        }
        else if (graphType === "contingency-histogram") {
            statistics = calculateStatisticsForMiniHistograms(pattern.questions[2], pattern.questions[0], pattern.questions[1], stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands);
        }
        else if (graphType === "histogram") {
            statistics = calculateStatisticsForHistogram(pattern.questions[0], stories, minimumStoryCountRequiredForTest, unansweredText);
        }
        else if (graphType === "multiple histogram") {
            statistics = calculateStatisticsForMultipleHistogram(pattern.questions[0], pattern.questions[1], stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands);
        }
        else if (graphType === "scatter") {
            statistics = calculateStatisticsForScatterPlot(pattern.questions[0], pattern.questions[1], null, null, stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands);
        }
        else if (graphType === "multiple scatter") {
            statistics = calculateStatisticsForMultipleScatterPlot(pattern.questions[0], pattern.questions[1], pattern.questions[2], stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands);
        }
        else if (graphType == "data integrity") {
            statistics = { statsSummary: "None", statsDetailed: [] };
        }
        else if (graphType == "texts") {
            statistics = { statsSummary: "None", statsDetailed: [] };
        }
        else if (graphType == "write-in texts") {
            statistics = { statsSummary: "None", statsDetailed: [] };
        }
        else if (graphType == "correlation map") {
            statistics = { statsSummary: "None", statsDetailed: [] };
        }
        else {
            console.log("ERROR: Unexpected graphType: " + graphType);
            throw new Error("ERROR: Not suported graphType: " + graphType);
        }
        if (statistics) {
            pattern.statsSummary = statistics.statsSummary;
            pattern.statsDetailed = statistics.statsDetailed.map(function (stat) { return stat + ": " + statistics[stat]; });
            pattern.allStatResults = statistics.allResults || null;
        }
        else {
            pattern.statsSummary = "ERROR";
        }
        if (progressUpdater && (patternNumber % howOftenToUpdateProgressMessage == 0)) {
            progressUpdater.progressMessage = "Calculating statistics for pattern " + patternNumber + " of " + numPatterns + "...";
            progressUpdater.redraw();
        }
    }
    exports.calculateStatisticsForPattern = calculateStatisticsForPattern;
    function calculateStatisticsForBarGraphValues(values) {
        return { statsSummary: "None", statsDetailed: [] };
    }
    exports.calculateStatisticsForBarGraphValues = calculateStatisticsForBarGraphValues;
    function calculateStatisticsForHistogram(ratioQuestion, stories, minimumStoryCountRequiredForTest, unansweredText) {
        var values = collectValuesForOneScale(stories, ratioQuestion.id, parseFloat);
        return calculateStatisticsForHistogramValues(values, -1, unansweredText); // unanswered count not needed for this use
    }
    exports.calculateStatisticsForHistogram = calculateStatisticsForHistogram;
    function calculateStatisticsForHistogramValues(values, unansweredCount, unansweredText) {
        var n = values.length;
        var result;
        if (n <= 0) {
            result = { statsSummary: "None", statsDetailed: ["n"], n: n };
        }
        else {
            var mean = jStat.mean(values);
            var median = jStat.median(values);
            var mode = jStat.mode(values);
            var sd = jStat.stdev(values, true);
            var skewness = jStat.skewness(values);
            var kurtosis = jStat.kurtosis(values);
            result = { statsSummary: "None", statsDetailed: ["mean", "median", "mode", "sd", "skewness", "kurtosis", "n"], mean: mean, median: median, mode: mode, sd: sd, skewness: skewness, kurtosis: kurtosis, n: n };
            if (unansweredCount >= 0) {
                result["statsDetailed"].push(unansweredText);
                result[unansweredText] = unansweredCount;
            }
        }
        return result;
    }
    exports.calculateStatisticsForHistogramValues = calculateStatisticsForHistogramValues;
    function calculateStatisticsForMiniHistograms(scaleQuestion, firstChoiceQuestion, secondChoiceQuestion, stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands) {
        // Can't calculate a statistic if one or both are mutiple answer checkboxes
        if (firstChoiceQuestion.displayType === "checkboxes" || secondChoiceQuestion.displayType === "checkboxes") {
            return { statsSummary: "None (choices not mutually exclusive)", statsDetailed: [] };
        }
        var values = collectValuesForOneScaleAndOneOrTwoChoices(stories, unansweredText, includeNAValues, lumpingCommands, scaleQuestion, firstChoiceQuestion, secondChoiceQuestion);
        var options = Object.keys(values);
        // For every pair, compute test, and take best p score
        var pLowest = Number.MAX_VALUE;
        var uLowest = NaN;
        var n = 0;
        var allNs = [];
        var allResults = {};
        for (var i = 0; i < options.length; i++) {
            var x = values[options[i]];
            allNs.push(x.length);
            if (x.length < minimumStoryCountRequiredForTest)
                continue;
            n += x.length;
            if (options.length === 1) {
                return { statsSummary: "None (too few options to compare)", statsDetailed: ["n"], n: n };
            }
            for (var j = i + 1; j < options.length; j++) {
                var y = values[options[j]];
                if (y.length < minimumStoryCountRequiredForTest)
                    continue;
                var statResult = void 0;
                try {
                    statResult = mannWhitneyU(x, y);
                }
                catch (err) {
                    console.log('Error in Mann-Whitney U test for questions [' + scaleQuestion.displayName + ", "
                        + firstChoiceQuestion.displayName + ", " + secondChoiceQuestion.displayName + "]: " + err);
                    return { statsSummary: "None (error)", statsDetailed: [] };
                }
                allResults[options[i] + " x " + options[j]] = { p: statResult.p, U: statResult.u, n1: statResult.n1, n2: statResult.n2 };
                if (statResult.p <= pLowest) {
                    pLowest = statResult.p;
                    uLowest = statResult.u;
                }
            }
        }
        if (pLowest === Number.MAX_VALUE) {
            return { statsSummary: "None (at least one count in [" + allNs.join(", ") + "] below threshold)", statsDetailed: ["n"], n: n };
        }
        var significance = "";
        if (pLowest < 0.001) {
            significance = " p<0.001" + " U=" + uLowest + " n=" + n;
        }
        else {
            significance = " p=" + pLowest.toFixed(3) + " U=" + uLowest + " n=" + n;
        }
        return { statsSummary: significance, statsDetailed: ["p", "U", "n"], p: pLowest, U: uLowest, n: n, allResults: allResults };
    }
    exports.calculateStatisticsForMiniHistograms = calculateStatisticsForMiniHistograms;
    function calculateStatisticsForMultipleHistogram(scaleQuestion, choiceQuestion, stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands) {
        // Can't calculate a statistic if one or both are mutiple answer checkboxes
        if (choiceQuestion.displayType === "checkboxes") {
            return { statsSummary: "None (choices not mutually exclusive)", statsDetailed: [] };
        }
        var values = collectValuesForOneScaleAndOneOrTwoChoices(stories, unansweredText, includeNAValues, lumpingCommands, scaleQuestion, choiceQuestion);
        var options = Object.keys(values);
        // For every pair, compute test, and take best p score
        var pLowest = Number.MAX_VALUE;
        var uLowest = NaN;
        var n = 0;
        var allNs = [];
        var allResults = {};
        for (var i = 0; i < options.length; i++) {
            var x = values[options[i]];
            allNs.push(x.length);
            if (x.length < minimumStoryCountRequiredForTest)
                continue;
            n += x.length;
            if (options.length === 1) {
                return { statsSummary: "None (too few options to compare)", statsDetailed: ["n"], n: n };
            }
            for (var j = i + 1; j < options.length; j++) {
                var y = values[options[j]];
                if (y.length < minimumStoryCountRequiredForTest)
                    continue;
                var statResult = void 0;
                try {
                    statResult = mannWhitneyU(x, y);
                }
                catch (err) {
                    console.log('Error in Mann-Whitney U test for questions [' + scaleQuestion.displayName + ", " + choiceQuestion.displayName + "]: " + err);
                    return { statsSummary: "None (error)", statsDetailed: [] };
                }
                allResults[options[i] + " x " + options[j]] = { p: statResult.p, U: statResult.u, n1: statResult.n1, n2: statResult.n2 };
                if (statResult.p <= pLowest) {
                    pLowest = statResult.p;
                    uLowest = statResult.u;
                }
            }
        }
        if (pLowest === Number.MAX_VALUE) {
            return { statsSummary: "None (at least one count in [" + allNs.join(", ") + "] below threshold)", statsDetailed: ["n"], n: n };
        }
        var significance = "";
        if (pLowest < 0.001) {
            significance = " p<0.001" + " U=" + uLowest + " n=" + n;
        }
        else {
            significance = " p=" + pLowest.toFixed(3) + " U=" + uLowest + " n=" + n;
        }
        return { statsSummary: significance, statsDetailed: ["p", "U", "n"], p: pLowest, U: uLowest, n: n, allResults: allResults };
    }
    exports.calculateStatisticsForMultipleHistogram = calculateStatisticsForMultipleHistogram;
    function calculateStatisticsForScatterPlot(ratioQuestion1, ratioQuestion2, choiceQuestion, option, stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands) {
        // TODO: both continuous -- look for correlation with Pearson's R (if normal distribution) or Spearman's R / Kendall's Tau (if not normal distribution)"
        var data = collectValuesForTwoScalesAndMaybeOneChoiceOption(stories, ratioQuestion1.id, ratioQuestion2.id, choiceQuestion, option, unansweredText, includeNAValues, lumpingCommands);
        if (data.x.length < minimumStoryCountRequiredForTest) {
            return { statsSummary: "None (count of " + data.x.length + " below threshold)", statsDetailed: ["n", unansweredText], n: data.x.length, "No answer": data.unansweredCount };
        }
        // TODO: Add a flag somewhere to use Kendall's Tau instead of Pearson/Spearman's R
        // const statResult = kendallsTau(data.x, data.y);
        // TODO: Use Pearson's R instead of Spearman if normally distributed
        var r = jStat.spearmancoeff(data.x, data.y);
        // https://en.wikipedia.org/wiki/Spearman's_rank_correlation_coefficient#Determining_significance
        var n = data.x.length;
        var p;
        var t;
        if (r >= 1) {
            // Perfectly correlated; handle separately to avoid divide by zero error otherwise
            p = 0;
        }
        else {
            t = r * Math.sqrt((n - 2.0) / (1.0 - r * r));
            p = jStat.ttest(t, n, 2);
        }
        var significance = "";
        if (p < 0.001) {
            significance = " p<0.001" + " rho=" + r.toFixed(3) + " n=" + n;
        }
        else {
            significance = " p=" + p.toFixed(3) + " rho=" + r.toFixed(3) + " n=" + n;
        }
        //  + " tt=" + statResult.test.toFixed(3) + " tz=" + statResult.z.toFixed(3) + " tp=" + statResult.prob.toFixed(3) ;
        return { statsSummary: significance, statsDetailed: ["p", "rho", "n", "No answer"], p: p, rho: r, n: n, "No answer": data.unansweredCount };
    }
    exports.calculateStatisticsForScatterPlot = calculateStatisticsForScatterPlot;
    function calculateStatisticsForMultipleScatterPlot(ratioQuestion1, ratioQuestion2, choiceQuestion, stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands) {
        var options = [];
        var allResults = {};
        var index;
        if (choiceQuestion.displayType !== "checkbox" && choiceQuestion.displayType !== "checkboxes") {
            if (includeNAValues)
                options.push(unansweredText);
        }
        if (choiceQuestion.displayType === "boolean" || choiceQuestion.displayType === "checkbox") {
            options.push("false");
            options.push("true");
        }
        else if (choiceQuestion.valueOptions) {
            for (index in choiceQuestion.valueOptions) {
                options.push(choiceQuestion.valueOptions[index]);
            }
        }
        var minSignificanceOptionStats = { statsSummary: "None", statsDetailed: [], allResults: {} };
        var minSignificance = 1000;
        var maxSignificance = 0;
        for (index in options) {
            var option = options[index];
            var optionStats = calculateStatisticsForScatterPlot(ratioQuestion1, ratioQuestion2, choiceQuestion, option, stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands);
            if (optionStats.p) {
                if (optionStats.p > maxSignificance) {
                    maxSignificance = optionStats.p;
                }
                if (optionStats.p < minSignificance) {
                    minSignificance = optionStats.p;
                    minSignificanceOptionStats = optionStats;
                }
            }
            allResults[option] = optionStats;
        }
        var difference = maxSignificance - minSignificance;
        var differenceText = "";
        if (difference == -1000) {
            differenceText = "(none)";
        }
        else {
            differenceText = "" + difference.toFixed(3);
        }
        minSignificanceOptionStats.statsSummary = "p range: " + differenceText + ", p lowest: [" + minSignificanceOptionStats.statsSummary.trim() + "]";
        minSignificanceOptionStats.allResults = allResults;
        return minSignificanceOptionStats;
    }
    exports.calculateStatisticsForMultipleScatterPlot = calculateStatisticsForMultipleScatterPlot;
    function calculateStatisticsForTable(nominalQuestion1, nominalQuestion2, stories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands) {
        // both not continuous -- look for a 'correspondence' between counts using Chi-squared test
        // Can't calculate a statistic if one or both are mutiple answer checkboxes
        if (nominalQuestion1.displayType === "checkboxes" || nominalQuestion2.displayType === "checkboxes") {
            return { statsSummary: "None (choices not mutually exclusive)", statsDetailed: [] };
        }
        var counts = collectValuesForTwoChoices(stories, nominalQuestion1, nominalQuestion2, unansweredText, includeNAValues, lumpingCommands);
        var observed = [];
        var expected = [];
        // Only calculate observed and expected considering the fields which pass threshold and are actually used
        var field1OptionsUsed = {};
        var field2OptionsUsed = {};
        var field1Option;
        var field2Option;
        var field1Total;
        var field2Total;
        var observedValue;
        for (field1Option in counts.field1Options) {
            field1Total = counts.field1Options[field1Option];
            if (field1Total < minimumStoryCountRequiredForTest)
                continue;
            field1OptionsUsed[field1Option] = 0;
        }
        for (field2Option in counts.field2Options) {
            field2Total = counts.field2Options[field2Option];
            if (field2Total < minimumStoryCountRequiredForTest)
                continue;
            field2OptionsUsed[field2Option] = 0;
        }
        var usedTotal = 0;
        for (field1Option in field1OptionsUsed) {
            field1Total = 0;
            for (field2Option in field2OptionsUsed) {
                observedValue = counts.counts[valueTag(field1Option, field2Option)] || 0;
                field1Total += observedValue;
                usedTotal += observedValue;
            }
            field1OptionsUsed[field1Option] = field1Total;
        }
        for (field2Option in field2OptionsUsed) {
            field2Total = 0;
            for (field1Option in field1OptionsUsed) {
                observedValue = counts.counts[valueTag(field1Option, field2Option)] || 0;
                field2Total += observedValue;
            }
            field2OptionsUsed[field2Option] = field2Total;
        }
        for (field1Option in field1OptionsUsed) {
            field1Total = field1OptionsUsed[field1Option];
            for (field2Option in field2OptionsUsed) {
                field2Total = field2OptionsUsed[field2Option];
                observedValue = counts.counts[valueTag(field1Option, field2Option)] || 0;
                observed.push(observedValue);
                var expectedValue = 0;
                if (usedTotal) {
                    expectedValue = field1Total * field2Total / usedTotal;
                }
                expected.push(expectedValue);
            }
        }
        var n1 = Object.keys(field1OptionsUsed).length;
        var n2 = Object.keys(field2OptionsUsed).length;
        if (n1 <= 1 || n2 <= 1) {
            return { statsSummary: "None (count below threshold)", statsDetailed: [] };
        }
        var degreesOfFreedom = (n1 - 1) * (n2 - 1);
        // Conditions needed for test according to: https://en.wikipedia.org/wiki/Pearson's_chi-squared_test
        var tooLowCount = 0;
        var zeroInCell = false;
        for (var i = 0; i < expected.length; i++) {
            if (expected[i] < 5)
                tooLowCount++;
            if (expected[i] === 0)
                zeroInCell = true;
        }
        if (zeroInCell) {
            return { statsSummary: "None (zero in expected cell)", statsDetailed: [] };
        }
        if (n1 <= 2 && n2 <= 2 && tooLowCount > 0) {
            return { statsSummary: "None (2X2 with expected cell < 5)", statsDetailed: [] };
        }
        if (tooLowCount / observed.length > 0.2) {
            return { statsSummary: "None (less than 80% of expected cells >= 5)", statsDetailed: [] };
        }
        var statResult;
        try {
            statResult = chiSquare.chiSquare(observed, expected, degreesOfFreedom);
        }
        catch (err) {
            var errorMessage = 'Error in chi-squared test for questions [' + nominalQuestion1.displayName + ", " + nominalQuestion2.displayName + "]: " + err + ". See console for details.";
            console.log(errorMessage, n1, n2, statResult, observed, expected);
            // toaster.toast(errorMessage);
            return { statsSummary: "None (error)", statsDetailed: [] };
        }
        if (statResult.n !== n1 * n2) {
            var errorMessage = 'Error in chi-squared test for questions [' + nominalQuestion1.displayName + ", " + nominalQuestion2.displayName + "]: Unexpected n1 * n2. See console for details.";
            console.log(errorMessage, n1, n2, statResult, observed, expected);
            // toaster.toast(errorMessage);
            return { statsSummary: "None (error)", statsDetailed: [] };
            //throw new Error("unexpected n1 * n2");
        }
        if (statResult.n === degreesOfFreedom) {
            var errorMessage = 'Error in chi-squared test for questions [' + nominalQuestion1.displayName + ", " + nominalQuestion2.displayName + "]: Unexpected n. See console for details.";
            console.log(errorMessage, n1, n2, statResult, observed, expected);
            // toaster.toast(errorMessage);
            return { statsSummary: "None (error)", statsDetailed: [] };
            //throw new Error("unexpected statResult.n");
        }
        var significance = "";
        if (statResult.p < 0.001) {
            significance = " p<0.001" + " x2=" + statResult.x2.toFixed(3) + " k=" + statResult.k + " n=" + statResult.n;
        }
        else {
            significance = " p=" + statResult.p.toFixed(3) + " x2=" + statResult.x2.toFixed(3) + " k=" + statResult.k + " n=" + statResult.n;
        }
        return { statsSummary: significance, statsDetailed: ["p", "x2", "k", "n"], p: statResult.p, x2: statResult.x2, k: statResult.k, n: statResult.n };
    }
    exports.calculateStatisticsForTable = calculateStatisticsForTable;
});

/**
 * @license
 * lodash 3.3.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash compat -o ./lodash.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.3.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      REARG_FLAG = 128,
      ARY_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 0,
      LAZY_MAP_FLAG = 1,
      LAZY_WHILE_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /**
   * Used to match ES template delimiters.
   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components)
   * for more details.
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect named functions. */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to detect hexadecimal string values. */
  var reHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /**
   * Used to match `RegExp` special characters.
   * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
   * for more details.
   */
  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to detect functions containing a `this` reference. */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '{2,}(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to detect and test for whitespace. */
  var whitespace = (
    // Basic whitespace characters.
    ' \t\x0b\f\xa0\ufeff' +

    // Line terminators.
    '\n\r\u2028\u2029' +

    // Unicode category "Zs" space separators.
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',
    'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    'window', 'WinRTError'
  ];

  /** Used to fix the JScript `[[DontEnum]]` bug. */
  var shadowProps = [
    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
    'toLocaleString', 'toString', 'valueOf'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used as an internal `_.debounce` options object by `_.throttle`. */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it is the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = (objectTypes[typeof window] && window !== (this && this.window)) ? window : this;

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare to `other`.
   * @param {*} other The value to compare to `value`.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsReflexive = value === value,
          othIsReflexive = other === other;

      if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
        return 1;
      }
      if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = (fromIndex || 0) - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * The base implementation of `_.sortBy` and `_.sortByAll` which uses `comparer`
   * to define the sort order of `array` and replaces criteria objects with their
   * corresponding values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * Converts `value` to a string if it is not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.max` and `_.min` as the default callback for string values.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the code unit of the first character of the string.
   */
  function charAtCallback(string) {
    return string.charCodeAt(0);
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByAll` to compare multiple properties of each element
   * in a collection and stable sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultipleAscending(object, other) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        return result;
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   * If `fromRight` is provided elements of `array` are iterated from right to left.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} [fromIndex] The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */
  var isHostObject = (function() {
    try {
      Object({ 'toString': 0 } + '');
    } catch(e) {
      return function() { return false; };
    }
    return function(value) {
      // IE < 9 presents many host objects as `Object` objects that can coerce
      // to strings despite having improperly defined `toString` methods.
      return typeof value.toString != 'function' && typeof (value + '') == 'string';
    };
  }());

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return (value && typeof value == 'object') || false;
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'add': function(a, b) { return a + b; } });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'sub': function(a, b) { return a - b; } });
   *
   * _.isFunction(_.add);
   * // => true
   * _.isFunction(_.sub);
   * // => false
   *
   * lodash.isFunction(lodash.add);
   * // => false
   * lodash.isFunction(lodash.sub);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        errorProto = Error.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to detect DOM support. */
    var document = (document = context.window) && document.document;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to the length of n-tuples for `_.unzip`. */
    var getLength = baseProperty('length');

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the `toStringTag` of values.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * for more details.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = context._;

    /** Used to detect if a method is native. */
    var reNative = RegExp('^' +
      escapeRegExp(objToString)
      .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
        bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
        ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        push = arrayProto.push,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = isNative(Set = context.Set) && Set,
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
        WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;

    /** Used to clone array buffers. */
    var Float64Array = (function() {
      // Safari 5 errors when using an array buffer to initialize a typed array
      // where the array buffer's `byteLength` is not a multiple of the typed
      // array's `BYTES_PER_ELEMENT`.
      try {
        var func = isNative(func = context.Float64Array) && func,
            result = new func(new ArrayBuffer(10), 0, 1) && func;
      } catch(e) {}
      return result;
    }());

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsFinite = context.isFinite,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = isNative(nativeNow = Date.now) && nativeNow,
        nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
        MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /** Used as the size, in bytes, of each `Float64Array` element. */
    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

    /**
     * Used as the maximum length of an array-like value.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
     * for more details.
     */
    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup a type array constructors by `toStringTag`. */
    var ctorByTag = {};
    ctorByTag[float32Tag] = context.Float32Array;
    ctorByTag[float64Tag] = context.Float64Array;
    ctorByTag[int8Tag] = context.Int8Array;
    ctorByTag[int16Tag] = context.Int16Array;
    ctorByTag[int32Tag] = context.Int32Array;
    ctorByTag[uint8Tag] = context.Uint8Array;
    ctorByTag[uint8ClampedTag] = context.Uint8ClampedArray;
    ctorByTag[uint16Tag] = context.Uint16Array;
    ctorByTag[uint32Tag] = context.Uint32Array;

    /** Used to avoid iterating over non-enumerable properties in IE < 9. */
    var nonEnumProps = {};
    nonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
    nonEnumProps[boolTag] = nonEnumProps[stringTag] = { 'constructor': true, 'toString': true, 'valueOf': true };
    nonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = { 'constructor': true, 'toString': true };
    nonEnumProps[objectTag] = { 'constructor': true };

    arrayEach(shadowProps, function(key) {
      for (var tag in nonEnumProps) {
        if (hasOwnProperty.call(nonEnumProps, tag)) {
          var props = nonEnumProps[tag];
          props[key] = hasOwnProperty.call(props, key);
        }
      }
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that return a boolean or single value will
     * automatically end the chain returning the unwrapped value. Explicit chaining
     * may be enabled using `_.chain`. The execution of chained methods is lazy,
     * that is, execution is deferred until `_#value` is implicitly or explicitly
     * called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization that merges iteratees to avoid creating intermediate
     * arrays and reduce the number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
     * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
     * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
     * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
     * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
     * `keysIn`, `map`, `mapValues`, `matches`, `matchesProperty`, `memoize`, `merge`,
     * `mixin`, `negate`, `noop`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,
     * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `splice`, `spread`,
     * `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`,
     * `thru`, `times`, `toArray`, `toPlainObject`, `transform`, `union`, `uniq`,
     * `unshift`, `unzip`, `values`, `valuesIn`, `where`, `without`, `wrap`, `xor`,
     * `zip`, and `zipObject`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
     * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
     * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,
     * `identity`, `includes`, `indexOf`, `isArguments`, `isArray`, `isBoolean`,
     * `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`, `isFinite`,
     * `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
     * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,
     * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,
     * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,
     * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,
     * `startCase`, `startsWith`, `template`, `trim`, `trimLeft`, `trimRight`,
     * `trunc`, `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, n) {
     *   return sum + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    (function(x) {
      var Ctor = function() { this.x = 1; },
          object = { '0': 1, 'length': 1 },
          props = [];

      Ctor.prototype = { 'valueOf': 1, 'y': 1 };
      for (var key in new Ctor) { props.push(key); }

      /**
       * Detect if the `toStringTag` of `arguments` objects is resolvable
       * (all but Firefox < 4, IE < 9).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.argsTag = objToString.call(arguments) == argsTag;

      /**
       * Detect if `name` or `message` properties of `Error.prototype` are
       * enumerable by default (IE < 9, Safari < 5.1).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||
        propertyIsEnumerable.call(errorProto, 'name');

      /**
       * Detect if `prototype` properties are enumerable by default.
       *
       * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
       * (if the prototype or a property on the prototype has been set)
       * incorrectly set the `[[Enumerable]]` value of a function's `prototype`
       * property to `true`.
       *
       * @memberOf _.support
       * @type boolean
       */
      support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');

      /**
       * Detect if functions can be decompiled by `Function#toString`
       * (all but Firefox OS certified apps, older Opera mobile browsers, and
       * the PlayStation 3; forced `false` for Windows 8 apps).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

      /**
       * Detect if `Function#name` is supported (all but IE).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcNames = typeof Function.name == 'string';

      /**
       * Detect if the `toStringTag` of DOM nodes is resolvable (all but IE < 9).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.nodeTag = objToString.call(document) != objectTag;

      /**
       * Detect if string indexes are non-enumerable
       * (IE < 9, RingoJS, Rhino, Narwhal).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.nonEnumStrings = !propertyIsEnumerable.call('x', 0);

      /**
       * Detect if properties shadowing those on `Object.prototype` are
       * non-enumerable.
       *
       * In IE < 9 an object's own properties, shadowing non-enumerable ones,
       * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.nonEnumShadows = !/valueOf/.test(props);

      /**
       * Detect if own properties are iterated after inherited properties (IE < 9).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.ownLast = props[0] != 'x';

      /**
       * Detect if `Array#shift` and `Array#splice` augment array-like objects
       * correctly.
       *
       * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array `shift()`
       * and `splice()` functions that fail to remove the last element, `value[0]`,
       * of array-like objects even though the `length` property is set to `0`.
       * The `shift()` method is buggy in compatibility modes of IE 8, while `splice()`
       * is buggy regardless of mode in IE < 9.
       *
       * @memberOf _.support
       * @type boolean
       */
      support.spliceObjects = (splice.call(object, 0, 1), !object[0]);

      /**
       * Detect lack of support for accessing string characters by index.
       *
       * IE < 8 can't access characters by index. IE 8 can only access characters
       * by index on string literals, not string objects.
       *
       * @memberOf _.support
       * @type boolean
       */
      support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';

      /**
       * Detect if the DOM is supported.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.dom = document.createDocumentFragment().nodeType === 11;
      } catch(e) {
        support.dom = false;
      }

      /**
       * Detect if `arguments` object indexes are non-enumerable.
       *
       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
       * checks for indexes that exceed their function's formal parameters with
       * associated values of `0`.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
      } catch(e) {
        support.nonEnumArgs = true;
      }
    }(0, 0));

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = null;
      this.__dir__ = 1;
      this.__dropCount__ = 0;
      this.__filtered__ = false;
      this.__iteratees__ = null;
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = null;
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var actions = this.__actions__,
          iteratees = this.__iteratees__,
          views = this.__views__,
          result = new LazyWrapper(this.__wrapped__);

      result.__actions__ = actions ? arrayCopy(actions) : null;
      result.__dir__ = this.__dir__;
      result.__dropCount__ = this.__dropCount__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = views ? arrayCopy(views) : null;
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value();
      if (!isArray(array)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var dir = this.__dir__,
          isRight = dir < 0,
          view = getView(0, array.length, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          dropCount = this.__dropCount__,
          takeCount = nativeMin(length, this.__takeCount__),
          index = isRight ? end : start - 1,
          iteratees = this.__iteratees__,
          iterLength = iteratees ? iteratees.length : 0,
          resIndex = 0,
          result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              computed = iteratee(value, index, array),
              type = data.type;

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        if (dropCount) {
          dropCount--;
        } else {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Adds `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * A specialized version of `_.max` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     */
    function arrayMax(array) {
      var index = -1,
          length = array.length,
          result = NEGATIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value > result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.min` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     */
    function arrayMin(array) {
      var index = -1,
          length = array.length,
          result = POSITIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value < result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return typeof objectValue == 'undefined' ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This method is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize assigning values.
     * @returns {Object} Returns the destination object.
     */
    function baseAssign(object, source, customizer) {
      var props = keys(source);
      if (!customizer) {
        return baseCopy(source, object, props);
      }
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? result !== value : value === value) ||
            (typeof value == 'undefined' && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.at` without support for strings and individual
     * key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} [props] The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          length = collection.length,
          isArr = isLength(length),
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          key = parseFloat(key);
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = collection[key];
        }
      }
      return result;
    }

    /**
     * Copies the properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Array} props The property names to copy.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, object, props) {
      if (!props) {
        props = object;
        object = {};
      }
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.bindAll` without support for individual
     * method name arguments.
     *
     * @private
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {string[]} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     */
    function baseBindAll(object, methodNames) {
      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return (typeof thisArg != 'undefined' && isBindable(func))
          ? bindCallback(func, thisArg, argCount)
          : func;
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return typeof thisArg == 'undefined'
        ? baseProperty(func + '')
        : baseMatchesProperty(func + '', thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (typeof result != 'undefined') {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseCopy(value, result, keys(value));
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function Object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          Object.prototype = prototype;
          var result = new Object;
          Object.prototype = null;
        }
        return result || context.Object();
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The `arguments` object to slice and provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args, fromIndex) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, baseSlice(args, fromIndex)); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= 200) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    function baseEach(collection, iteratee) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        return baseForOwn(collection, iteratee);
      }
      var index = -1,
          iterable = toObject(collection);

      while (++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    }

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    function baseEachRight(collection, iteratee) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        return baseForOwnRight(collection, iteratee);
      }
      var iterable = toObject(collection);
      while (length--) {
        if (iteratee(iterable[length], length, iterable) === false) {
          break;
        }
      }
      return collection;
    }

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end >>> 0;
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            value = baseFlatten(value, isDeep, isStrict);
          }
          var valIndex = -1,
              valLength = value.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[++resIndex] = value[valIndex];
          }
        } else if (!isStrict) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iterator functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    function baseFor(object, iteratee, keysFunc) {
      var index = -1,
          iterable = toObject(object),
          props = keysFunc(object),
          length = props.length;

      while (++index < length) {
        var key = props[index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    function baseForRight(object, iteratee, keysFunc) {
      var iterable = toObject(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[length];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invoke` which requires additional arguments
     * to be provided as an array of arguments rather than individually.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {Array} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     */
    function baseInvoke(collection, methodName, args) {
      var index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? methodName : (value != null && value[methodName]);
        result[++index] = func ? func.apply(value, args) : undefined;
      });
      return result;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
      // Exit early for identical values.
      if (value === other) {
        // Treat `+0` vs. `-0` as not equal.
        return value !== 0 || (1 / value == 1 / other);
      }
      var valType = typeof value,
          othType = typeof other;

      // Exit early for unlike primitive values.
      if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
          value == null || other == null) {
        // Return `false` unless both values are `NaN`.
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag && !isHostObject(object),
          othIsObj = othTag == objectTag && !isHostObject(other),
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (valWrapped || othWrapped) {
        return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The source property names to match.
     * @param {Array} values The source values to match.
     * @param {Array} strictCompareFlags Strict comparison flags for source values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      var index = -1,
          noCustomizer = !customizer;

      while (++index < length) {
        if ((noCustomizer && strictCompareFlags[index])
              ? values[index] !== object[props[index]]
              : !hasOwnProperty.call(object, props[index])
            ) {
          return false;
        }
      }
      index = -1;
      while (++index < length) {
        var key = props[index];
        if (noCustomizer && strictCompareFlags[index]) {
          var result = hasOwnProperty.call(object, key);
        } else {
          var objValue = object[key],
              srcValue = values[index];

          result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (typeof result == 'undefined') {
            result = baseIsEqual(srcValue, objValue, customizer, true);
          }
        }
        if (!result) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var result = [];
      baseEach(collection, function(value, key, collection) {
        result.push(iteratee(value, key, collection));
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var props = keys(source),
          length = props.length;

      if (length == 1) {
        var key = props[0],
            value = source[key];

        if (isStrictComparable(value)) {
          return function(object) {
            return object != null && object[key] === value && hasOwnProperty.call(object, key);
          };
        }
      }
      var values = Array(length),
          strictCompareFlags = Array(length);

      while (length--) {
        value = source[props[length]];
        values[length] = value;
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return function(object) {
        return baseIsMatch(object, props, values, strictCompareFlags);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not coerce `key`
     * to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} value The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(key, value) {
      if (isStrictComparable(value)) {
        return function(object) {
          return object != null && object[key] === value;
        };
      }
      return function(object) {
        return object != null && baseIsEqual(value, object[key], null, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns the destination object.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
      (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        var value = object[key],
            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
            isCommon = typeof result == 'undefined';

        if (isCommon) {
          result = srcValue;
        }
        if ((isSrcArr || typeof result != 'undefined') &&
            (isCommon || (result === result ? result !== value : value === value))) {
          object[key] = result;
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = typeof result == 'undefined';

      if (isCommon) {
        result = srcValue;
        if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (value ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? result !== value : value === value) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` which does not coerce `key` to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     */
    function basePullAt(array, indexes) {
      var length = indexes.length,
          result = baseAt(array, indexes);

      indexes.sort(baseCompareAscending);
      while (length--) {
        var index = parseFloat(indexes[length]);
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands or `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end - start) >>> 0;
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= 200,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * returned by `keysFunc`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved unwrapped value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var args = [result],
            action = actions[index];

        push.apply(args, action.args);
        result = action.func.apply(action.thisArg, args);
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest, instead
     *  of the lowest, index at which a value should be inserted into `array`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (retHighest ? (computed <= value) : (computed < value)) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest, instead
     *  of the lowest, index at which a value should be inserted into `array`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsUndef = typeof value == 'undefined';

      while (low < high) {
        var mid = floor((low + high) / 2),
            computed = iteratee(array[mid]),
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || typeof computed != 'undefined');
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (typeof thisArg == 'undefined') {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      return bufferSlice.call(buffer, 0);
    }
    if (!bufferSlice) {
      // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
      bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
        var byteLength = buffer.byteLength,
            floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
            offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
            result = new ArrayBuffer(byteLength);

        if (floatLength) {
          var view = new Float64Array(result, 0, floatLength);
          view.set(new Float64Array(buffer, 0, floatLength));
        }
        if (byteLength != offset) {
          view = new Uint8Array(result, offset);
          view.set(new Uint8Array(buffer, offset));
        }
        return result;
      };
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(argsLength + leftLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var pad = argsIndex;
      while (++rightIndex < rightLength) {
        result[pad + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[pad + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an accumulator
     * object composed from the results of running each element in the collection
     * through an iteratee.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that assigns properties of source object(s) to a given
     * destination object.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return function() {
        var length = arguments.length,
            object = arguments[0];

        if (length < 2 || object == null) {
          return object;
        }
        if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
          length = 2;
        }
        // Juggle arguments.
        if (length > 3 && typeof arguments[length - 2] == 'function') {
          var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
        } else if (length > 2 && typeof arguments[length - 1] == 'function') {
          customizer = arguments[--length];
        }
        var index = 0;
        while (++index < length) {
          var source = arguments[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
      return new SetCache(values);
    };

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, arguments);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that gets the extremum value of a collection.
     *
     * @private
     * @param {Function} arrayFunc The function to get the extremum value from an array.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,
     *  extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(arrayFunc, isMin) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = null;
        }
        var func = getCallback(),
            noIteratee = iteratee == null;

        if (!(func === baseCallback && noIteratee)) {
          noIteratee = false;
          iteratee = func(iteratee, thisArg, 3);
        }
        if (noIteratee) {
          var isArr = isArray(collection);
          if (!isArr && isString(collection)) {
            iteratee = charAtCallback;
          } else {
            return arrayFunc(isArr ? collection : toIterable(collection));
          }
        }
        return extremumBy(collection, iteratee, isMin);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG;

      var Ctor = !isBindKey && createCtorWrapper(func),
          key = func;

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : null,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : null,
                newHoldersRight = isCurry ? null : argsHolders,
                newPartials = isCurry ? args : null,
                newPartialsRight = isCurry ? null : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this;
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        return (this instanceof wrapper ? (Ctor || createCtorWrapper(func)) : func).apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the pad required for `string` based on the given padding length.
     * The `chars` string may be truncated if the number of padding characters
     * exceeds the padding length.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPad(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(argsLength + leftLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = null;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = null;
      }
      var data = !isBindKey && getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data && data !== true) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length,
          result = true;

      if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
        return false;
      }
      // Deep compare the contents, ignoring non-numeric properties.
      while (result && ++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        result = undefined;
        if (customizer) {
          result = isWhere
            ? customizer(othValue, arrValue, index)
            : customizer(arrValue, othValue, index);
        }
        if (typeof result == 'undefined') {
          // Recursively compare arrays (susceptible to call stack limits).
          if (isWhere) {
            var othIndex = othLength;
            while (othIndex--) {
              othValue = other[othIndex];
              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
              if (result) {
                break;
              }
            }
          } else {
            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
          }
        }
      }
      return !!result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} value The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            // But, treat `-0` vs. `+0` as not equal.
            : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isWhere) {
        return false;
      }
      var hasCtor,
          index = -1;

      while (++index < objLength) {
        var key = objProps[index],
            result = hasOwnProperty.call(other, key);

        if (result) {
          var objValue = object[key],
              othValue = other[key];

          result = undefined;
          if (customizer) {
            result = isWhere
              ? customizer(othValue, objValue, key)
              : customizer(objValue, othValue, key);
          }
          if (typeof result == 'undefined') {
            // Recursively compare objects (susceptible to call stack limits).
            result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
          }
        }
        if (!result) {
          return false;
        }
        hasCtor || (hasCtor = key == 'constructor');
      }
      if (!hasCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments; (value, index, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the
     *  maximum, extremum value.
     * @returns {*} Returns the extremum value.
     */
    function extremumBy(collection, iteratee, isMin) {
      var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
          computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = iteratee(value, index, collection);
        if ((isMin ? current < computed : current > computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} [transforms] The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms ? transforms.length : 0;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          // Safari 5 mobile incorrectly has `Object` as the constructor of typed arrays.
          if (Ctor instanceof Ctor) {
            Ctor = ctorByTag[tag];
          }
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Checks if `func` is eligible for `this` binding.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
     */
    function isBindable(func) {
      var support = lodash.support,
          result = !(support.funcNames ? func.name : support.funcDecomp);

      if (!result) {
        var source = fnToString.call(func);
        if (!support.funcNames) {
          result = !reFuncName.test(source);
        }
        if (!result) {
          // Check if `func` references the `this` keyword and store the result.
          result = reThis.test(source) || isNative(func);
          baseSetData(func, result);
        }
      }
      return result;
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = +value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number') {
        var length = object.length,
            prereq = isLength(length) && isIndex(index, length);
      } else {
        prereq = type == 'string' && index in object;
      }
      if (prereq) {
        var other = object[index];
        return value === value ? value === other : other !== other;
      }
      return false;
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on ES `ToLength`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
     * for more details.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask;

      var arityFlags = ARY_FLAG | REARG_FLAG,
          bindFlags = BIND_FLAG | BIND_KEY_FLAG,
          comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;

      var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
          isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
          argPos = (isRearg ? data : source)[7],
          ary = (isAry ? data : source)[8];

      var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&
        !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);

      var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&
        (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties specified
     * by the `props` array.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `_.isPlainObject` which checks if `value`
     * is an object created by the `Object` constructor or has a `[[Prototype]]`
     * of `null`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var Ctor,
          support = lodash.support;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value)) ||
          (!hasOwnProperty.call(value, 'constructor') &&
            (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor))) ||
          (!support.argsTag && isArguments(value))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      if (support.ownLast) {
        baseForIn(value, function(subValue, key, object) {
          result = hasOwnProperty.call(object, key);
          return false;
        });
        return result !== false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length,
          support = lodash.support;

      var allowIndexes = length && isLength(length) &&
        (isArray(object) || (support.nonEnumStrings && isString(object)) ||
          (support.nonEnumArgs && isArguments(object)));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isLength(value.length)) {
        return values(value);
      }
      if (lodash.support.unindexedChars && isString(value)) {
        return value.split('');
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      if (lodash.support.unindexedChars && isString(value)) {
        var index = -1,
            length = value.length,
            result = Object(value);

        while (++index < length) {
          result[index] = value.charAt(index);
        }
        return result;
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(+size || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(ceil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    function difference() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var value = arguments[index];
        if (isArray(value) || isArguments(value)) {
          break;
        }
      }
      return baseDifference(value, baseFlatten(arguments, false, true, ++index));
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': pebbles, 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      predicate = getCallback(predicate, thisArg, 3);
      while (length-- && predicate(array[length], length, array)) {}
      return baseSlice(array, 0, length + 1);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var index = -1;
      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length && predicate(array[index], index, array)) {}
      return baseSlice(array, index);
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for, instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      predicate = getCallback(predicate, thisArg, 3);
      while (length--) {
        if (predicate(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]];
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4];
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4];
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,
     * it is used as the offset from the end of `array`. If `array` is sorted
     * providing `true` for `fromIndex` performs a faster binary search.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      } else if (fromIndex) {
        var index = binaryIndex(array, value),
            other = array[index];

        return (value === value ? value === other : other !== other) ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values in all provided arrays using `SameValueZero`
     * for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = [],
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf;

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push((isCommon && value.length >= 120) ? createCache(argsIndex && value) : null);
        }
      }
      argsLength = args.length;
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [],
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {
          argsIndex = argsLength;
          while (--argsIndex) {
            var cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        return (value === value ? value === other : other !== other) ? index : -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using `SameValueZero` for equality
     * comparisons.
     *
     * **Notes:**
     *  - Unlike `_.without`, this method mutates `array`.
     *  - `SameValueZero` comparisons are like strict equality comparisons, e.g. `===`,
     *    except that `NaN` matches `NaN`. See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     *    for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var array = arguments[0];
      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = arguments.length;

      while (++index < length) {
        var fromIndex = 0,
            value = arguments[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    function pullAt(array) {
      return basePullAt(array || [], baseFlatten(arguments, false, false, 1));
    }

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This function is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    function sortedIndex(array, value, iteratee, thisArg) {
      var func = getCallback(iteratee);
      return (func === baseCallback && iteratee == null)
        ? binaryIndex(array, value)
        : binaryIndexBy(array, value, func(iteratee, thisArg, 1));
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    function sortedLastIndex(array, value, iteratee, thisArg) {
      var func = getCallback(iteratee);
      return (func === baseCallback && iteratee == null)
        ? binaryIndex(array, value, true)
        : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      predicate = getCallback(predicate, thisArg, 3);
      while (length-- && predicate(array[length], length, array)) {}
      return baseSlice(array, length + 1);
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var index = -1;
      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length && predicate(array[index], index, array)) {}
      return baseSlice(array, 0, index);
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, false, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using `SameValueZero`
     * for equality comparisons. Providing `true` for `isSorted` performs a faster
     * search algorithm for sorted arrays. If an iteratee function is provided it
     * is invoked for each value in the array to generate the criterion by which
     * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1]);
     * // => [1, 2]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
        isSorted = false;
      }
      var func = getCallback();
      if (!(func === baseCallback && iteratee == null)) {
        iteratee = func(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-`_.zip`
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      var index = -1,
          length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
          result = Array(length);

      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * Creates an array excluding all provided values using `SameValueZero` for
     * equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    function without(array) {
      return baseDifference(array, baseSlice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Symmetric_difference) for
     * more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseDifference(result, array).concat(baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var length = arguments.length,
          array = Array(length);

      while (length--) {
        array[length] = arguments[length];
      }
      return unzip(array);
    }

    /**
     * Creates an object composed from arrays of property names and values. Provide
     * either a single two dimensional array, e.g. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of property names and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _([1, 2, 3])
     *  .last()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => [3]
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapper = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapper = wrapper.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapper.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapper = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapper = wrapper.plant(other);
     *
     * otherWrapper.value();
     * // => [9, 16]
     *
     * wrapper.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        if (this.__actions__.length) {
          value = new LazyWrapper(this);
        }
        return new LodashWrapper(value.reverse(), this.__chain__);
      }
      return this.thru(function(value) {
        return value.reverse();
      });
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var length = collection ? collection.length : 0;
      if (isLength(length)) {
        collection = toIterable(collection);
      }
      return baseAt(collection, baseFlatten(arguments, false, false, 1));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    function find(collection, predicate, thisArg) {
      if (isArray(collection)) {
        var index = findIndex(collection, predicate, thisArg);
        return index > -1 ? collection[index] : undefined;
      }
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(collection, predicate, baseEach);
    }

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(collection, predicate, baseEachRight);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Iterator functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    function forEach(collection, iteratee, thisArg) {
      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
        ? arrayEach(collection, iteratee)
        : baseEach(collection, bindCallback(iteratee, thisArg, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).join(',');
     * // => logs each value from right to left and returns the array
     */
    function forEachRight(collection, iteratee, thisArg) {
      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
        ? arrayEachRight(collection, iteratee)
        : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using `SameValueZero` for equality
     * comparisons. If `fromIndex` is negative, it is used as the offset from
     * the end of `collection`.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (!length) {
        return false;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      } else {
        fromIndex = 0;
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
        : (getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in `collection`,
     * returning an array of the results of each invoked method. Any additional
     * arguments are provided to each invoked method. If `methodName` is a function
     * it is invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      return baseInvoke(collection, methodName, baseSlice(arguments, 2));
    }

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as interatees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
     * `dropRight`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`, `slice`,
     * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`, `trimRight`,
     * `trunc`, `random`, `range`, `sample`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     *  create a `_.property` or `_.matches` style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 };
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 };
     */
    var max = createExtremum(arrayMax);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 };
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 };
     */
    var min = createExtremum(arrayMin, true);

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1, 3], [2]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the value of `key` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} key The key of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, key) {
      return map(collection, baseProperty(key));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg`and invoked with four arguments;
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as interatees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `merge`, and `sortAllBy`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator, thisArg) {
      var func = isArray(collection) ? arrayReduce : baseReduce;
      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator, thisArg) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce;
      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See [Wikipedia](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      collection = toIterable(collection);

      var index = -1,
          length = collection.length,
          result = Array(length);

      while (++index < length) {
        var rand = baseRandom(0, index);
        if (index != rand) {
          result[index] = result[rand];
        }
        result[rand] = collection[index];
      }
      return result;
    }

    /**
     * Gets the size of `collection` by returning `collection.length` for
     * array-like values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity] The function
     *  invoked per iteration. If a property name or an object is provided it is
     *  used to create a `_.property` or `_.matches` style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = isLength(length) ? Array(length) : [];

      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = null;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      baseEach(collection, function(value, key, collection) {
        result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it sorts by property names
     * instead of an iteratee function.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(string|string[])} props The property names to sort by,
     *  specified as individual property names or arrays of property names.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 26 },
     *   { 'user': 'fred',   'age': 30 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortByAll(collection) {
      var args = arguments;
      if (args.length > 3 && isIterateeCall(args[1], args[2], args[3])) {
        args = [collection, args[1]];
      }
      var index = -1,
          length = collection ? collection.length : 0,
          props = baseFlatten(args, false, false, 1),
          result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value) {
        var length = props.length,
            criteria = Array(length);

        while (length--) {
          criteria[length] = value == null ? undefined : value[props[length]];
        }
        result[++index] = { 'criteria': criteria, 'index': index, 'value': value };
      });
      return baseSortBy(result, compareMultipleAscending);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = null;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, null, null, null, null, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        } else {
          func = null;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the `length`
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    function bind(func, thisArg) {
      var bitmask = BIND_FLAG;
      if (arguments.length > 2) {
        var partials = baseSlice(arguments, 2),
            holders = replaceHolders(partials, bind.placeholder);

        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the `length` property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    function bindAll(object) {
      return baseBindAll(object,
        arguments.length > 1
          ? baseFlatten(arguments, false, false, 1)
          : functions(object)
      );
    }

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (arguments.length > 2) {
        var partials = baseSlice(arguments, 2),
            holders = replaceHolders(partials, bindKey.placeholder);

        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    }

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      if (guard && isIterateeCall(func, arity, guard)) {
        arity = null;
      }
      var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      if (guard && isIterateeCall(func, arity, guard)) {
        arity = null;
      }
      var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a function that delays invoking `func` until after `wait` milliseconds
     * have elapsed since the last time it was invoked. The created function comes
     * with a `cancel` method to cancel delayed invocations. Provide an options
     * object to indicate that `func` should be invoked on the leading and/or
     * trailing edge of the `wait` timeout. Subsequent calls to the debounced
     * function return the result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      return baseDelay(func, 1, arguments, 1);
    }

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      return baseDelay(func, wait, arguments, 2);
    }

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function add(x, y) {
     *   return x + y;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(add, square);
     * addSquare(1, 2);
     * // => 9
     */
    function flow() {
      var funcs = arguments,
          length = funcs.length;

      if (!length) {
        return function() { return arguments[0]; };
      }
      if (!arrayEvery(funcs, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var index = 0,
            result = funcs[index].apply(this, arguments);

        while (++index < length) {
          result = funcs[index].call(this, result);
        }
        return result;
      };
    }

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function add(x, y) {
     *   return x + y;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, add);
     * addSquare(1, 2);
     * // => 9
     */
    function flowRight() {
      var funcs = arguments,
          fromIndex = funcs.length - 1;

      if (fromIndex < 0) {
        return function() { return arguments[0]; };
      }
      if (!arrayEvery(funcs, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var index = fromIndex,
            result = funcs[index].apply(this, arguments);

        while (index--) {
          result = funcs[index].call(this, result);
        }
        return result;
      };
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the ES `Map` method interface
     * of `get`, `has`, and `set`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : arguments[0];

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, arguments);
        cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(func, 2);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    function partial(func) {
      var partials = baseSlice(arguments, 1),
          holders = replaceHolders(partials, partial.placeholder);

      return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
    }

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    function partialRight(func) {
      var partials = baseSlice(arguments, 1),
          holders = replaceHolders(partials, partialRight.placeholder);

      return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);
    }

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    function rearg(func) {
      var indexes = baseFlatten(arguments, false, false, 1);
      return createWrapper(func, REARG_FLAG, null, null, null, indexes);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and the array of arguments provided to the created
     * function much like [Function#apply](http://es5.github.io/#x15.3.4.3).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {*} Returns the new function.
     * @example
     *
     * var spread = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * spread(['Fred', 'hello']);
     * // => 'Fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a function that only invokes `func` at most once per every `wait`
     * milliseconds. The created function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the throttled function return the result of the last
     * `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = +wait;
      debounceOptions.trailing = trailing;
      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the structured clone algorithm.
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, isDeep, customizer);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the structured clone algorithm.
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, true, customizer);
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      var length = isObjectLike(value) ? value.length : undefined;
      return (isLength(length) && objToString.call(value) == argsTag) || false;
    }
    // Fallback for environments without a `toStringTag` for `arguments` objects.
    if (!support.argsTag) {
      isArguments = function(value) {
        var length = isObjectLike(value) ? value.length : undefined;
        return (isLength(length) && hasOwnProperty.call(value, 'callee') &&
          !propertyIsEnumerable.call(value, 'callee')) || false;
      };
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return (isObjectLike(value) && objToString.call(value) == dateTag) || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return (value && value.nodeType === 1 && isObjectLike(value) &&
        (lodash.support.nodeTag ? objToString.call(value).indexOf('Element') > -1 : isHostObject(value))) || false;
    }
    // Fallback for environments without DOM support.
    if (!support.dom) {
      isElement = function(value) {
        return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;
      };
    }

    /**
     * Checks if a value is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      var length = value.length;
      if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments; (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
        return value === other;
      }
      var result = customizer ? customizer(value, other) : undefined;
      return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on ES `Number.isFinite`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    var isFinite = nativeNumIsFinite || function(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    };

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return objToString.call(value) == funcTag;
    };

    /**
     * Checks if `value` is the language type of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return type == 'function' || (value && type == 'object') || false;
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments; (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      var props = keys(source),
          length = props.length;

      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && length == 1) {
        var key = props[0],
            value = source[key];

        if (isStrictComparable(value)) {
          return object != null && value === object[key] && hasOwnProperty.call(object, key);
        }
      }
      var values = Array(length),
          strictCompareFlags = Array(length);

      while (length--) {
        value = values[length] = source[props[length]];
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return baseIsMatch(object, props, values, strictCompareFlags, customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as native `isNaN` which returns `true`
     * for `undefined` and other non-numeric values. See the [ES5 spec](https://es5.github.io/#x15.1.2.4)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (objToString.call(value) == funcTag) {
        return reNative.test(fnToString.call(value));
      }
      return (isObjectLike(value) &&
        (isHostObject(value) ? reNative : reHostCtor).test(value)) || false;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && objToString.call(value) == objectTag) || (!lodash.support.argsTag && isArguments(value))) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return (isObject(value) && objToString.call(value) == regexpTag) || false;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? value.length : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return (lodash.support.unindexedChars && isString(value))
        ? value.split('')
        : arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments;
     * (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return typeof value == 'undefined' ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(baseAssign);

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = null;
      }
      return properties ? baseCopy(properties, result, keys(properties)) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property are ignored.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    function defaults(object) {
      if (object == null) {
        return object;
      }
      var args = arrayCopy(arguments);
      args.push(assignDefaults);
      return assign.apply(undefined, args);
    }

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element `predicate` returns truthy for, instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(object, predicate, baseForOwn, true);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(object, predicate, baseForOwnRight, true);
    }

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments; (value, key, object). Iterator functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    function forIn(object, iteratee, thisArg) {
      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
        iteratee = bindCallback(iteratee, thisArg, 3);
      }
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    function forInRight(object, iteratee, thisArg) {
      iteratee = bindCallback(iteratee, thisArg, 3);
      return baseForRight(object, iteratee, keysIn);
    }

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments; (value, key, object). Iterator functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    function forOwn(object, iteratee, thisArg) {
      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
        iteratee = bindCallback(iteratee, thisArg, 3);
      }
      return baseForOwn(object, iteratee);
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    function forOwnRight(object, iteratee, thisArg) {
      iteratee = bindCallback(iteratee, thisArg, 3);
      return baseForRight(object, iteratee, keys);
    }

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Checks if `key` exists as a direct property of `object` instead of an
     * inherited property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {string} key The key to check.
     * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 3 };
     *
     * _.has(object, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = null;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (object) {
        var Ctor = object.constructor,
            length = object.length;
      }
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
         (typeof object == 'function' ? lodash.support.enumPrototypes : (length && isLength(length)))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length,
          support = lodash.support;

      length = (length && isLength(length) &&
        (isArray(object) || (support.nonEnumStrings && isString(object)) ||
          (support.nonEnumArgs && isArguments(object))) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          proto = (isFunction(Ctor) && Ctor.prototype) || objectProto,
          isProto = proto === object,
          result = Array(length),
          skipIndexes = length > 0,
          skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),
          skipProto = support.enumPrototypes && isFunction(object);

      while (++index < length) {
        result[index] = (index + '');
      }
      // lodash skips the `constructor` property when it infers it is iterating
      // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`
      // attribute of an existing property and the `constructor` property of a
      // prototype defaults to non-enumerable.
      for (var key in object) {
        if (!(skipProto && key == 'prototype') &&
            !(skipErrorProps && (key == 'message' || key == 'name')) &&
            !(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      if (support.nonEnumShadows && object !== objectProto) {
        var tag = object === stringProto ? stringTag : object === errorProto ? errorTag : objToString.call(object),
            nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];

        if (tag == objectTag) {
          proto = objectProto;
        }
        length = shadowProps.length;
        while (length--) {
          key = shadowProps[length];
          var nonEnum = nonEnums[key];
          if (!(isProto && nonEnum) &&
              (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {
            result.push(key);
          }
        }
      }
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee, thisArg) {
      var result = {};
      iteratee = getCallback(iteratee, thisArg, 3);

      baseForOwn(object, function(value, key, object) {
        result[key] = iteratee(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments; (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If `predicate` is provided it is invoked for each property
     * of `object` omitting the properties `predicate` returns truthy for. The
     * predicate is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    function omit(object, predicate, thisArg) {
      if (object == null) {
        return {};
      }
      if (typeof predicate != 'function') {
        var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      predicate = bindCallback(predicate, thisArg, 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    }

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    function pick(object, predicate, thisArg) {
      if (object == null) {
        return {};
      }
      return typeof predicate == 'function'
        ? pickByCallback(object, bindCallback(predicate, thisArg, 3))
        : pickByArray(object, baseFlatten(arguments, false, false, 1));
    }

    /**
     * Resolves the value of property `key` on `object`. If the value of `key` is
     * a function it is invoked with the `this` binding of `object` and its result
     * is returned, else the property value is returned. If the property value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to resolve.
     * @param {*} [defaultValue] The value returned if the property value
     *  resolves to `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'user': 'fred', 'age': _.constant(40) };
     *
     * _.result(object, 'user');
     * // => 'fred'
     *
     * _.result(object, 'age');
     * // => 40
     *
     * _.result(object, 'status', 'busy');
     * // => 'busy'
     *
     * _.result(object, 'status', _.constant('busy'));
     * // => 'busy'
     */
    function result(object, key, defaultValue) {
      var value = object == null ? undefined : object[key];
      if (typeof value == 'undefined') {
        value = defaultValue;
      }
      return isFunction(value) ? value.call(object) : value;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments; (accumulator, value, key, object). Iterator functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it defaults to `start` with `start` becoming `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (typeof end === 'undefined') {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= start && value < end;
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = null;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to camel case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/CamelCase) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting latin-1 supplementary letters to basic latin letters.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter);
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = (typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length)) - target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and '`', in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't require escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),
     * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of
     * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
     *
     * When working with HTML you should always quote attribute values to reduce
     * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
     * "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, '\\$&')
        : string;
    }

    /**
     * Converts `string` to kebab case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles) for
     * more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it is shorter then the given
     * padding length. The `chars` string may be truncated if the number of padding
     * characters can't be evenly divided by the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = floor(mid),
          rightLength = ceil(mid);

      chars = createPad('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it is shorter then the given padding
     * length. The `chars` string may be truncated if the number of padding
     * characters exceeds the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    function padLeft(string, length, chars) {
      string = baseToString(string);
      return string && (createPad(string, length, chars) + string);
    }

    /**
     * Pads `string` on the right side if it is shorter then the given padding
     * length. The `chars` string may be truncated if the number of padding
     * characters exceeds the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    function padRight(string, length, chars) {
      string = baseToString(string);
      return string && (string + createPad(string, length, chars));
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the ES5 implementation of `parseInt`.
     * See the [ES5 spec](https://es5.github.io/#E) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard && isIterateeCall(string, radix, guard)) {
        radix = 0;
      }
      return nativeParseInt(string, radix);
    }
    // Fallback for environments with pre-ES5 implementations.
    if (nativeParseInt(whitespace + '08') != 8) {
      parseInt = function(string, radix, guard) {
        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
        // Chrome fails to trim leading <BOM> whitespace characters.
        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        string = trim(string);
        return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
      };
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = floor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to snake case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Snake_case) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to start case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes sourceURLs for easier debugging.
     * See the [HTML5 Rocks article on sourcemaps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for more details.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = null;
      }
      string = baseToString(string);
      options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar]
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it is longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * //=> 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = null;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? +options.length || 0 : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = null;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    function attempt() {
      var length = arguments.length,
          func = arguments[0];

      try {
        var args = Array(length ? length - 1 : 0);
        while (--length > 0) {
          args[length - 1] = arguments[length];
        }
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = null;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function which performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function which compares the property value of `key` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} key The key of the property to get.
     * @param {*} value The value to compare.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred', 'age': 40 }
     */
    function matchesProperty(key, value) {
      return baseMatchesProperty(key + '', baseClone(value, true));
    }

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=this] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * // use `_.runInContext` to avoid potential conflicts (esp. in Node.js)
     * var _ = require('lodash').runInContext();
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj && keys(source),
            methodNames = props && props.length && baseFunctions(source, props);

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__);
                (result.__actions__ = arrayCopy(this.__actions__)).push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              var args = [this.value()];
              push.apply(args, arguments);
              return func.apply(object, args);
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function which returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function which returns the property value of `key` on a given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'barney' }
     * ];
     *
     * var getName = _.property('user');
     *
     * _.map(users, getName);
     * // => ['fred', barney']
     *
     * _.pluck(_.sortBy(users, getName), 'user');
     * // => ['barney', 'fred']
     */
    function property(key) {
      return baseProperty(key + '');
    }

    /**
     * The inverse of `_.property`; this method creates a function which returns
     * the property value of a given key on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to inspect.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'a': 3, 'b': 1, 'c': 2 };
     *
     * _.map(['a', 'c'], _.propertyOf(object));
     * // => [3, 2]
     *
     * _.sortBy(['a', 'b', 'c'], _.propertyOf(object));
     * // => ['b', 'c', 'a']
     */
    function propertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it
     * defaults to `start` with `start` becoming `0`. If `start` is less than
     * `end` a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = null;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(ceil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = +n;

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var isFilter = index == LAZY_FILTER_FLAG || index == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone(),
            iteratees = result.__iteratees__ || (result.__iteratees__ = []);

        result.__filtered__ = result.__filtered__ || isFilter;
        iteratees.push({ 'iteratee': getCallback(iteratee, thisArg, 3), 'type': index });
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      var countName = '__' + methodName + 'Count__',
          whileName = methodName + 'While';

      LazyWrapper.prototype[methodName] = function(n) {
        n = n == null ? 1 : nativeMax(floor(n) || 0, 0);

        var result = this.clone();
        if (result.__filtered__) {
          var value = result[countName];
          result[countName] = index ? nativeMin(value, n) : (value + n);
        } else {
          var views = result.__views__ || (result.__views__ = []);
          views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };

      LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
        return this.reverse()[whileName](predicate, thisArg).reverse();
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : baseProperty;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.dropWhile = function(predicate, thisArg) {
      var done,
          lastIndex,
          isRight = this.__dir__ < 0;

      predicate = getCallback(predicate, thisArg, 3);
      return this.filter(function(value, index, array) {
        done = done && (isRight ? index < lastIndex : index > lastIndex);
        lastIndex = index;
        return done || (done = !predicate(value, index, array));
      });
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return this.filter(function(value, index, array) {
        return !predicate(value, index, array);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);
      var result = start < 0 ? this.takeRight(-start) : this.drop(start);

      if (typeof end != 'undefined') {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.toArray = function() {
      return this.drop(0);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName],
          retUnwrapped = /^(?:first|last)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = arguments,
            chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          return onlyLazy
            ? func.call(value)
            : lodashFunc.call(lodash, this.value());
        }
        var interceptor = function(value) {
          var otherArgs = [value];
          push.apply(otherArgs, args);
          return lodashFunc.apply(lodash, otherArgs);
        };
        if (isLazy || isArray(value)) {
          var wrapper = onlyLazy ? value : new LazyWrapper(this),
              result = func.apply(wrapper, args);

          if (!retUnwrapped && (isHybrid || result.__actions__)) {
            var actions = result.__actions__ || (result.__actions__ = []);
            actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });
          }
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array.prototype` functions to `lodash.prototype`.
    arrayEach(['concat', 'join', 'pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var arrayFunc = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          fixObjects = !support.spliceObjects && /^(?:pop|shift|splice)$/.test(methodName),
          retUnwrapped = /^(?:join|pop|shift)$/.test(methodName);

      // Avoid array-like object bugs with `Array#shift` and `Array#splice` in
      // IE < 9, Firefox < 10, Narwhal, and RingoJS.
      var func = !fixObjects ? arrayFunc : function() {
        var result = arrayFunc.apply(this, arguments);
        if (this.length === 0) {
          delete this[0];
        }
        return result;
      };

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define('lodash',[],function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Narwhal or Rhino -require.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

define('js/applicationWidgets/charting',["require", "exports", "jstat", "d3", "mithril", "../calculateStatistics", "lodash", "../Globals"], function (require, exports, jStat, d3, m, calculateStatistics, _, Globals) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    var maxRangeLabelLength = 26;
    var defaultStatsTexts = {
        "count": "Count",
        "frequency": "Frequency",
        "unanswered": "No answer",
        "stats": "Statistics",
        "none": "None",
        "p": "p",
        "n": "n",
        "n1": "n1",
        "n2": "n2",
        "mean": "mean",
        "median": "median",
        "mode": "mode",
        "sd": "standard deviation",
        "skewness": "skewness",
        "kurtosis": "kurtosis",
        "x2": "chi squared (x2)",
        "k": "degrees of freedom (k)",
        "U": "Mann-Whitney U",
        "rho": "Spearman's rho",
        "subgraph": "Sub-graph",
        "U table": "Mann-Whitney U test results for multiple histograms, sorted by significance value (p)",
    };
    //------------------------------------------------------------------------------------------------------------------------------------------
    // support functions 
    //------------------------------------------------------------------------------------------------------------------------------------------
    function limitLabelLength(label, maximumCharacters) {
        if (!maximumCharacters)
            return label;
        if (typeof label !== "string")
            return label;
        if (label.length <= maximumCharacters)
            return label;
        return label.substring(0, maximumCharacters - 3) + "...";
    }
    // TODO: Put elipsis starting between words so no words are cut off
    function limitStoryTextLength(text) {
        return limitLabelLength(text, 500);
    }
    function displayTextForAnswer(answer) {
        if (!answer && answer !== 0)
            return "";
        var hasCheckboxes = _.isObject(answer);
        if (!hasCheckboxes)
            return answer;
        var result = "";
        for (var key in answer) {
            if (answer[key]) {
                if (result)
                    result += ", ";
                result += key;
            }
        }
        return result;
    }
    // escapeHtml is from: http://shebang.brandonmintern.com/foolproof-html-escaping-in-javascript/
    function escapeHtml(str) {
        var div = document.createElement('div');
        div.appendChild(document.createTextNode(str));
        return div.innerHTML;
    }
    ;
    //------------------------------------------------------------------------------------------------------------------------------------------
    // lookup functions 
    //------------------------------------------------------------------------------------------------------------------------------------------
    function customStatLabel(key, graphHolder) {
        if (graphHolder.customStatsTextReplacements) {
            return graphHolder.customStatsTextReplacements[defaultStatsTexts[key]] || defaultStatsTexts[key];
        }
        else {
            return defaultStatsTexts[key];
        }
    }
    exports.customStatLabel = customStatLabel;
    function showNAValues(graphHolder) {
        if (graphHolder.patternDisplayConfiguration == undefined)
            return true;
        return !graphHolder.patternDisplayConfiguration.hideNoAnswerValues;
    }
    function getLumpingCommands(graphHolder) {
        if (graphHolder.patternDisplayConfiguration == undefined)
            return graphHolder.lumpingCommands;
        if (graphHolder.patternDisplayConfiguration.useLumpingCommands)
            return graphHolder.lumpingCommands;
        return {};
    }
    function nameForQuestion(question) {
        if (typeof question === "string")
            return escapeHtml(question);
        if (question.displayName)
            return escapeHtml(question.displayName);
        if (question.displayPrompt)
            return escapeHtml(question.displayPrompt);
        return escapeHtml(question.id);
    }
    function boundedSliderValueForQuestionAnswer(question, answer, unansweredText) {
        if (question.displayType !== "slider")
            return undefined;
        if (answer === undefined || answer === unansweredText)
            return undefined;
        if (isNaN(answer))
            return undefined;
        if (answer > 100)
            return 100;
        if (answer < 0)
            return 0;
        return answer;
    }
    function plotItemForScatterPlot(xAxisQuestion, yAxisQuestion, xValue, yValue, story, unansweredText) {
        var x = boundedSliderValueForQuestionAnswer(xAxisQuestion, xValue, unansweredText);
        var y = boundedSliderValueForQuestionAnswer(yAxisQuestion, yValue, unansweredText);
        return { x: x, y: y, story: story };
    }
    //------------------------------------------------------------------------------------------------------------------------------------------
    // functions for counting numbers of answers 
    //------------------------------------------------------------------------------------------------------------------------------------------
    function addToCountOfStoriesForChoiceCombination(map, key) {
        var oldCount = map[key];
        if (!oldCount)
            oldCount = 0;
        map[key] = oldCount + 1;
    }
    function saveCountOfStoriesForChoiceCombination(map, key, value) {
        var values = map[key];
        if (!values)
            values = [];
        values.push(value);
        map[key] = values;
    }
    function createEmptyDataStructureForAnswerCountsUsingDictionary(structure, question, unansweredText, showNoAnswerValues, lumpingCommands) {
        if (showNoAnswerValues === void 0) { showNoAnswerValues = true; }
        var type = question.displayType;
        if (type === "boolean") {
            structure["yes"] = 0;
            structure["no"] = 0;
        }
        else if (type === "checkbox") {
            structure["true"] = 0;
            structure["false"] = 0;
        }
        else if (question.valueOptions) {
            for (var i = 0; i < question.valueOptions.length; i++) {
                // the answers entered into the lumping command are trimmed during parsing
                // in v1.6.1, validation was added to require users to trim answers in lists for choice questions
                // trimming this copied data should not be necessary in projects created in that version and afterward
                // but legacy data could still have extra whitespace characters that make it incompatible with the display lumping system
                var value = String(question.valueOptions[i]).trim();
                if (lumpingCommands.hasOwnProperty(question.displayName)) {
                    if (lumpingCommands[question.displayName].hasOwnProperty(value))
                        value = lumpingCommands[question.displayName][value];
                }
                if (value !== calculateStatistics.IGNOREANSWERCODE) {
                    if (!(value in structure)) {
                        structure[value] = 0;
                    }
                }
            }
        }
        if (type !== "checkbox" && showNoAnswerValues)
            structure[unansweredText] = 0;
    }
    function createEmptyDataStructureForAnswerCountsUsingArray(structure, question, unansweredText, showNoAnswerValues, lumpingCommands) {
        if (showNoAnswerValues === void 0) { showNoAnswerValues = true; }
        var type = question.displayType;
        if (type === "boolean") {
            structure.push("yes");
            structure.push("no");
        }
        else if (type === "checkbox") {
            structure.push("true");
            structure.push("false");
        }
        else if (question.valueOptions) {
            for (var i = 0; i < question.valueOptions.length; i++) {
                var value = String(question.valueOptions[i]).trim(); // see above comment about trimming
                if (lumpingCommands.hasOwnProperty(question.displayName)) {
                    if (lumpingCommands[question.displayName].hasOwnProperty(value))
                        value = lumpingCommands[question.displayName][value];
                }
                if (value !== calculateStatistics.IGNOREANSWERCODE) {
                    if (structure.indexOf(value) < 0) {
                        structure.push(value);
                    }
                }
            }
        }
        if (type !== "checkbox" && showNoAnswerValues)
            structure.push(unansweredText);
    }
    //------------------------------------------------------------------------------------------------------------------------------------------
    // d3 support functions - setting up panes and panels
    //------------------------------------------------------------------------------------------------------------------------------------------
    function createGraphResultsPane(theClass) {
        var pane = document.createElement("div");
        pane.className = theClass;
        return pane;
    }
    exports.createGraphResultsPane = createGraphResultsPane;
    function initializedGraphHolder(allStories, options) {
        var graphHolder = {
            graphResultsPane: createGraphResultsPane("narrafirma-graph-results-pane chartEnclosure"),
            chartPanes: [],
            allStories: allStories,
            currentGraph: null,
            currentSelectionExtentPercentages: null,
            excludeStoryTooltips: true,
            minimumStoryCountRequiredForTest: options.minimumStoryCountRequiredForTest,
            minimumStoryCountRequiredForGraph: options.minimumStoryCountRequiredForGraph,
            numHistogramBins: options.numHistogramBins,
            numScatterDotOpacityLevels: options.numScatterDotOpacityLevels,
            scatterDotSize: options.scatterDotSize,
            correlationMapShape: options.correlationMapShape,
            correlationMapIncludeScaleEndLabels: options.correlationMapIncludeScaleEndLabels,
            correlationMapCircleDiameter: options.correlationMapCircleDiameter,
            correlationLineChoice: options.correlationLineChoice,
            customLabelLengthLimit: options.customLabelLengthLimit,
            hideNumbersOnContingencyGraphs: options.hideNumbersOnContingencyGraphs,
            outputGraphFormat: options.outputGraphFormat,
            outputFontModifierPercent: options.outputFontModifierPercent,
            showStatsPanelsInReport: options.showStatsPanelsInReport,
            customStatsTextReplacements: options.customStatsTextReplacements,
            customGraphWidth: options.customGraphWidth,
            customGraphHeight: options.customGraphHeight,
            patternDisplayConfiguration: { hideNoAnswerValues: false, useLumpingCommands: true },
            adjustedCSS: options.adjustedCSS,
            graphTypesToCreate: {},
            lumpingCommands: {}
        };
        return graphHolder;
    }
    exports.initializedGraphHolder = initializedGraphHolder;
    var defaultLargeGraphWidth = 800;
    function makeChartFramework(chartPane, chartType, size, margin, customGraphWidth, customGraphHeight) {
        var largeGraphWidth = customGraphWidth || defaultLargeGraphWidth;
        var largeGraphHeight = customGraphHeight || Math.round(largeGraphWidth * 0.75);
        var fullWidth = 0;
        var fullHeight = 0;
        if (size == "large") {
            fullWidth = largeGraphWidth;
            fullHeight = largeGraphHeight;
        }
        else if (size === "tall") {
            fullWidth = largeGraphWidth;
            fullHeight = largeGraphWidth;
        }
        else if (size == "small") {
            fullWidth = largeGraphWidth / 3;
            fullHeight = largeGraphHeight / 3;
        }
        else if (size == "medium") {
            fullWidth = largeGraphWidth / 2;
            fullHeight = largeGraphHeight / 2;
        }
        else if (size == "medium-large") {
            fullWidth = 2 * largeGraphWidth / 3;
            fullHeight = 2 * largeGraphHeight / 3;
        }
        else if (size == "thumbnail") {
            fullWidth = 101;
            fullHeight = 101;
        }
        else {
            throw new Error("Unexpected chart size: " + size);
        }
        var width = fullWidth - margin.left - margin.right;
        var height = fullHeight - margin.top - margin.bottom;
        var chart = d3.select(chartPane).append('svg')
            .attr('width', width + margin.right + margin.left)
            .attr('height', height + margin.top + margin.bottom)
            .attr('class', 'chart ' + chartType);
        var chartBackground = chart.append("rect")
            .attr('width', fullWidth)
            .attr('height', fullHeight)
            .attr('class', 'chartBackground')
            .attr('style', 'fill: none;');
        var chartBody = chart.append('g')
            .attr('width', width)
            .attr('height', height)
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            .attr('class', 'chartBody');
        var chartBodyBackground = chartBody.append("rect")
            .attr('width', width)
            .attr('height', height)
            .attr('class', 'chartBodyBackground')
            .attr('style', 'fill: none;');
        return {
            fullWidth: fullWidth,
            fullHeight: fullHeight,
            margin: margin,
            width: width,
            height: height,
            chart: chart,
            chartType: chartType,
            chartBackground: chartBackground,
            chartBody: chartBody,
            chartBodyBackground: chartBodyBackground,
            xScale: undefined,
            yScale: undefined,
            xQuestion: undefined,
            yQuestion: undefined,
            brush: undefined,
            brushend: undefined,
            subgraphQuestion: undefined,
            subgraphChoice: undefined
        };
    }
    function newChartPane(graphHolder, styleClass) {
        var chartPane = document.createElement("div");
        chartPane.className = styleClass;
        graphHolder.chartPanes.push(chartPane);
        graphHolder.graphResultsPane.appendChild(chartPane);
        return chartPane;
    }
    function addTitlePanelForChart(chartPane, chartTitle) {
        var titlePane = document.createElement("h5");
        titlePane.className = "narrafirma-graph-title";
        titlePane.innerHTML = chartTitle;
        chartPane.appendChild(titlePane);
    }
    function addNoGraphsWarningForChart(chartPane) {
        chartPane.innerHTML += '<p style="margin-left: 0.5em">There are no graphs for this selection in which the number of stories is greater than the minimum required to draw a graph.</p>';
    }
    function addStatisticsPanelForChart(chartPane, graphHolder, statistics, chartTitle, chartSize, hide) {
        if (hide === void 0) { hide = false; }
        var text_stats = customStatLabel("stats", graphHolder);
        var text_none = customStatLabel("none", graphHolder);
        var text_mann_whitney = customStatLabel("U table", graphHolder);
        var text_subgraph = customStatLabel("subgraph", graphHolder);
        var statsPane = document.createElement("h6");
        var html = "";
        var text = "";
        if (hide)
            statsPane.style.cssText = "display:none";
        if (statistics.statsSummary.substring("None") === 0 || statistics.statsDetailed.length !== 0) {
            if (statistics.statsDetailed.length === 0) {
                html += text_stats + ": " + text_none;
                text += text_stats + ": " + text_none;
            }
            if (statistics.allResults) {
                html += '<span class="narrafirma-mann-whitney-title">' + text_mann_whitney + " " + '<br>' + chartTitle + '</span><br>\n';
                text += "\n\n" + text_mann_whitney + ": " + chartTitle + "\n\n";
            }
            else {
                if (chartSize === "small") {
                    text += "\n\n" + text_subgraph + ": " + chartTitle + "\n";
                }
            }
            var htmlDelimiter = void 0;
            var textDelimiter = void 0;
            if (chartPane.classList.contains("smallChartStyle")) {
                htmlDelimiter = "<br>\n";
                textDelimiter = "\n";
            }
            else {
                htmlDelimiter = "; ";
                textDelimiter = "; ";
            }
            for (var i = 0; i < statistics.statsDetailed.length; i++) {
                html += htmlForLabelAndValue(statistics.statsDetailed[i], statistics, graphHolder);
                text += htmlForLabelAndValue(statistics.statsDetailed[i], statistics, graphHolder, false);
                if (i < statistics.statsDetailed.length - 1) {
                    html += htmlDelimiter;
                    text += textDelimiter;
                }
            }
            if (statistics.allResults) {
                html += "<br>\n";
                html += '<table class="narrafirma-mw-all-results">\n';
                text += "\n\n";
                var sortedResultKeys = Object.keys(statistics.allResults).sort(function (a, b) { return statistics.allResults[a].p - statistics.allResults[b].p; });
                for (var resultKeyIndex in sortedResultKeys) {
                    var resultKey = sortedResultKeys[resultKeyIndex];
                    var result = statistics.allResults[resultKey];
                    html += '<tr><td class="narrafirma-mw-nested-title">' + escapeHtml(resultKey) + '</td><td class="narrafirma-mw-nested-stats">';
                    text += resultKey + " - ";
                    var first = true;
                    for (var key in result) {
                        if (!first) {
                            html += "; ";
                            text += "; ";
                        }
                        else {
                            first = false;
                        }
                        html += htmlForLabelAndValue(key, result, graphHolder);
                        text += htmlForLabelAndValue(key, result, graphHolder, false);
                    }
                    html += "</td></tr>\n";
                    text += "\n";
                }
                html += "</table>\n";
                text += "\n";
            }
            if (chartSize === "small") {
                statsPane.className = "narrafirma-statistics-panel-small narrafirma-statistics-panel";
            }
            else if (chartSize === "large") {
                statsPane.className = "narrafirma-statistics-panel";
            }
            else {
                console.log("addStatisticsPanelForChart: No chart size specified");
                alert("ERROR: No chart size specified for addStatisticsPanelForChart");
            }
        }
        statsPane.innerHTML = html;
        chartPane.appendChild(statsPane);
        return text;
    }
    // addXAxis(chart, xScale, {labelLengthLimit: 64, isSmallFormat: false, drawLongAxisLines: false, rotateAxisLabels: false});
    function addXAxis(chart, xScale, options) {
        if (!options)
            options = {};
        if (!options.labelLengthLimit)
            options.labelLengthLimit = 64;
        if (!options.textAnchor)
            options.textAnchor = "middle";
        var axisClassName = 'x-axis'
            + (options.graphType ? " " + options.graphType : "")
            + (options.isSmallFormat ? " small" : "")
            + (options.rotateAxisLabels ? " rotated" : "")
            + (options.textAnchor ? " " + options.textAnchor : "");
        var xAxis = d3.svg.axis()
            .scale(xScale)
            .tickPadding(6)
            .orient('bottom');
        if (options.isSmallFormat)
            xAxis.tickValues(xScale.domain());
        if (options.drawLongAxisLines)
            xAxis.tickSize(-(chart.height));
        if (!options.rotateAxisLabels) {
            var labels = chart.chartBody.append('g')
                .attr('transform', 'translate(0,' + chart.height + ')')
                .attr('class', axisClassName)
                .call(xAxis).selectAll("text");
            if (options.labelLengthLimit) {
                labels.text(function (label, i) {
                    var result = label;
                    result = limitLabelLength(result, options.labelLengthLimit);
                    if (options.namesAndTotals && options.namesAndTotals[label]) {
                        result = result + " (" + options.namesAndTotals[label] + ")";
                    }
                    return result;
                });
            }
            labels.append("svg:title").text(function (label, i) {
                return label;
            });
        }
        else {
            if (options.labelLengthLimit) {
                xAxis.tickFormat(function (label) {
                    var result = label;
                    result = limitLabelLength(result, options.labelLengthLimit);
                    if (options.namesAndTotals && options.namesAndTotals[label]) {
                        result = result + " (" + options.namesAndTotals[label] + ")";
                    }
                    return result;
                });
            }
            // TODO: These do not have hovers
            chart.chartBody.append('g')
                .attr('transform', 'translate(0,' + chart.height + ')')
                .attr('class', axisClassName)
                .call(xAxis).selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-0.8em")
                .attr("dy", "0.15em")
                .attr("transform", function (d) {
                return "rotate(-65)";
            });
        }
        return xAxis;
    }
    // This function is similar to the one for the x axis, except for transform, tickFormat, CSS classes, and not needing rotate
    // yAxis = addYAxis(chart, yScale, {labelLengthLimit: 64, isSmallFormat: false, drawLongAxisLines: false});
    function addYAxis(chart, yScale, options) {
        if (!options)
            options = {};
        if (!options.labelLengthLimit)
            options.labelLengthLimit = 64;
        if (!options.textAnchor)
            options.textAnchor = "middle";
        var axisClassName = 'y-axis ' + (options.graphType || "") + (options.isSmallFormat ? "-small" : "");
        var yAxis = d3.svg.axis()
            .scale(yScale)
            .tickPadding(6)
            .orient('left');
        if (options.labelLengthLimit) {
            yAxis.tickFormat(function (label) {
                var result = label;
                result = limitLabelLength(result, options.labelLengthLimit);
                if (options.namesAndTotals && options.namesAndTotals[label]) {
                    result = result + " (" + options.namesAndTotals[label] + ")";
                }
                return result;
            });
        }
        else {
            // This seems to be needed to ensure small numbers for labels don't get ".0" appended to them
            yAxis.tickFormat(d3.format("d"));
        }
        if (options.isSmallFormat)
            yAxis.tickValues(yScale.domain());
        if (options.drawLongAxisLines)
            yAxis.tickSize(-(chart.width));
        var labels = chart.chartBody.append('g')
            .attr('class', axisClassName)
            .call(yAxis).selectAll("text");
        if (options.labelLengthLimit) {
            labels.text(function (label, i) {
                var result = label;
                result = limitLabelLength(result, options.labelLengthLimit);
                if (options.namesAndTotals && options.namesAndTotals[label]) {
                    result = result + " (" + options.namesAndTotals[label] + ")";
                }
                return result;
            });
        }
        labels.append("svg:title").text(function (label, i) {
            return label;
        });
        return yAxis;
    }
    function addXAxisLabel(chart, label, options) {
        if (!options)
            options = {};
        if (!options.labelLengthLimit)
            options.labelLengthLimit = 64;
        if (!options.textAnchor)
            options.textAnchor = "middle";
        var shortenedLabel = limitLabelLength(label, options.labelLengthLimit);
        var xPosition;
        var yPosition;
        var className;
        if (options.placeAxisNamesInUpperRight) {
            options.textAnchor = "end";
            xPosition = chart.fullWidth - chart.margin.right;
            yPosition = chart.margin.top - 6;
            className = 'x-axis-label ' + (options.graphType || "") + (options.isSmallFormat ? " small" : "") + " upper-corner";
        }
        else {
            yPosition = chart.fullHeight - 16;
            if (options.textAnchor === "middle") {
                xPosition = chart.margin.left + chart.width / 2;
            }
            else if (options.textAnchor === "start") {
                xPosition = chart.margin.left;
                yPosition -= 25;
            }
            else if (options.textAnchor === "end") {
                xPosition = chart.margin.left + chart.width;
                yPosition -= 25;
            }
            className = 'x-axis-label ' + (options.graphType || "") + (options.isSmallFormat ? " small" : "") + (options.textAnchor ? " " + options.textAnchor : "");
        }
        var shortenedLabelSVG = chart.chart.append("text")
            .attr("class", className)
            .attr("text-anchor", options.textAnchor)
            .attr("x", xPosition)
            .attr("y", yPosition)
            .text(shortenedLabel);
        if (label.length > options.labelLengthLimit) {
            shortenedLabelSVG.append("svg:title")
                .text(label);
        }
    }
    function addYAxisLabel(chart, label, options) {
        if (!options)
            options = {};
        if (!options.labelLengthLimit)
            options.labelLengthLimit = 64;
        if (!options.textAnchor)
            options.textAnchor = "middle";
        var shortenedLabel = limitLabelLength(label, options.labelLengthLimit);
        var xPosition;
        var yPosition;
        var className;
        var rotateAngle;
        // Y and X are flipped because of the rotate
        if (options.placeAxisNamesInUpperRight) {
            options.textAnchor = "start";
            yPosition = -(chart.fullWidth - chart.margin.right + 8); // negative because of rotation
            xPosition = chart.margin.top;
            rotateAngle = 90;
            className = 'y-axis-label ' + (options.graphType || "") + (options.isSmallFormat ? " small" : "") + " upper-corner";
        }
        else {
            yPosition = 16;
            if (options.textAnchor === "middle") {
                xPosition = -(chart.margin.top + chart.height / 2);
            }
            else if (options.textAnchor === "start") {
                xPosition = -(chart.margin.top + chart.height);
                yPosition += 25;
            }
            else if (options.textAnchor === "end") {
                xPosition = -chart.margin.top;
                yPosition += 25;
            }
            rotateAngle = -90;
            className = 'y-axis-label ' + (options.graphType || "") + (options.isSmallFormat ? " small" : "") + (options.textAnchor ? " " + options.textAnchor : "");
        }
        var shortenedLabelSVG = chart.chart.append("text")
            .attr("class", className)
            .attr("text-anchor", options.textAnchor)
            .attr("y", yPosition)
            .attr("x", xPosition)
            .attr("transform", "rotate(" + rotateAngle + ")")
            .text(shortenedLabel);
        if (label.length > options.labelLengthLimit) {
            shortenedLabelSVG.append("svg:title")
                .text(label);
        }
    }
    function htmlForLabelAndValue(key, object, graphHolder, html) {
        if (html === void 0) { html = true; }
        var value = object[key];
        if (value === undefined) {
            console.log("htmlForLabelAndValue: value is undefined");
        }
        var unansweredText = customStatLabel("unanswered", graphHolder);
        if (key === "mode") {
            if (typeof value === "object") {
                var truncatedValues = [];
                for (var i = 0; i < value.length; i++) {
                    truncatedValues.push(value[i].toFixed(0)); // these have to be slider values, which are integers
                }
                value = truncatedValues.join(", ");
            }
            else {
                value = value.toFixed(0);
            }
        }
        else if (["n", "n1", "n2", "k", unansweredText].indexOf(key) >= 0) {
            value = value.toFixed(0);
        }
        else if (key === "p") {
            if (value < 0.0001) {
                value = "<0.0001";
            }
            else {
                if (isNaN(value)) {
                    value = "NaN";
                }
                else {
                    value = value.toFixed(4);
                }
            }
        }
        else {
            if (isNaN(value)) {
                value = "NaN";
            }
            else {
                value = value.toFixed(4);
            }
        }
        var keyToReport = customStatLabel(key, graphHolder) || key;
        if (html) {
            return '<span class="statistics-name">' + keyToReport + '</span>: <span class="statistics-value">' + value + "</span>";
        }
        else {
            return keyToReport + ": " + value;
        }
    }
    //------------------------------------------------------------------------------------------------------------------------------------------
    // d3 support functions - selecting items in graphs
    //------------------------------------------------------------------------------------------------------------------------------------------
    // Support starting a drag when mouse is over a node
    function supportStartingDragOverStoryDisplayItemOrCluster(chartBody, storyDisplayItems) {
        storyDisplayItems.on('mousedown', function () {
            var brushElements = chartBody.select(".brush").node();
            // TODO: Casting Event to any because TypeScript somehow thinks it does not take an argument
            var newClickEvent = new Event('mousedown');
            newClickEvent.pageX = d3.event.pageX;
            newClickEvent.clientX = d3.event.clientX;
            newClickEvent.pageY = d3.event.pageY;
            newClickEvent.clientY = d3.event.clientY;
            brushElements.dispatchEvent(newClickEvent);
        });
    }
    function createBrush(chartBody, xScale, yScale, brushendCallback) {
        // If yScale is null, constrain brush to just work across the x range of the chart
        var brush = d3.svg.brush()
            .x(xScale)
            .on("brushend", brushendCallback);
        if (yScale)
            brush.y(yScale);
        var brushGroup = chartBody.append("g")
            .attr("class", "brush")
            .call(brush);
        if (!yScale) {
            brushGroup.selectAll("rect")
                .attr("y", 0)
                .attr("height", chartBody.attr("height"));
        }
        return { brush: brush, brushGroup: brushGroup };
    }
    // The complementary decodeCurlyBraces function is in PatternExplorer.js
    function encodeCurlyBraces(optionText) {
        return optionText.replace("{", "&#123;").replace("}", "&#125;");
    }
    function setCurrentChartSelection(chart, graphHolder, extent) {
        // Chart types and scaling
        // Bar: X Ordinal, Y in screen coordinates
        // Table: X Ordinal, Y Ordinal - X and Y need to be scaled
        // Histogram: X Linear, Y in screen coordinates - X are already scaled to 100
        // Scatter: X Linear, Y Linear - X and Y are already scaled to 100
        var x1;
        var x2;
        var y1;
        var y2;
        var selection;
        var width = chart.width;
        var height = chart.height;
        if (chart.chartType === "histogram" || chart.chartType === "scatterPlot") {
            width = 100;
            height = 100;
        }
        if (_.isArray(extent[0])) {
            x1 = Math.round(100 * extent[0][0] / width);
            x2 = Math.round(100 * extent[1][0] / width);
            y1 = Math.round(100 * extent[0][1] / height);
            y2 = Math.round(100 * extent[1][1] / height);
            selection = {
                xAxis: encodeCurlyBraces(nameForQuestion(chart.xQuestion)),
                x1: x1,
                x2: x2,
                yAxis: encodeCurlyBraces(nameForQuestion(chart.yQuestion)),
                y1: y1,
                y2: y2
            };
        }
        else {
            x1 = Math.round(100 * extent[0] / width);
            x2 = Math.round(100 * extent[1] / width);
            selection = {
                xAxis: encodeCurlyBraces(nameForQuestion(chart.xQuestion)),
                x1: x1,
                x2: x2
            };
        }
        selection.selectionCategories = []; // going to be set in isPlotItemSelected
        graphHolder.currentSelectionExtentPercentages = selection;
        if (_.isArray(graphHolder.currentGraph)) {
            selection.subgraphQuestion = encodeCurlyBraces(nameForQuestion(chart.subgraphQuestion));
            selection.subgraphChoice = encodeCurlyBraces(chart.subgraphChoice);
        }
    }
    function updateListOfSelectedStories(chart, storyDisplayItemsOrClusters, graphHolder, storiesSelectedCallback, selectionTestFunction) {
        var extent = chart.brush.brush.extent();
        setCurrentChartSelection(chart, graphHolder, extent);
        var selectedStories = [];
        storyDisplayItemsOrClusters.classed("selected", function (plotItem) {
            var selected = selectionTestFunction(extent, plotItem);
            var story;
            if (selected) {
                if (plotItem.stories) {
                    for (var i = 0; i < plotItem.stories.length; i++) {
                        story = plotItem.stories[i];
                        if (selectedStories.indexOf(story) === -1)
                            selectedStories.push(story);
                    }
                }
                else {
                    story = plotItem.story;
                    if (!story)
                        throw new Error("Expected story in plotItem");
                    if (selectedStories.indexOf(story) === -1)
                        selectedStories.push(story);
                }
            }
            return selected;
        });
        if (storiesSelectedCallback) {
            storiesSelectedCallback(selectedStories);
            // TODO: Maybe could call sm.startComputation/m.endComputation around this instead?
            // Since this event is generated by d3, need to redraw afterwards 
            m.redraw();
        }
    }
    function restoreChartSelection(chart, selection) {
        var extent;
        if (chart.chartType === "histogram") {
            extent = [selection.x1, selection.x2];
        }
        else if (chart.chartType === "scatterPlot") {
            extent = [[selection.x1, selection.y1], [selection.x2, selection.y2]];
        }
        else if (chart.chartType === "barChart") {
            extent = [selection.x1 * chart.width / 100, selection.x2 * chart.width / 100];
        }
        else if (chart.chartType === "contingencyChart") {
            extent = [[selection.x1 * chart.width / 100, selection.y1 * chart.height / 100], [selection.x2 * chart.width / 100, selection.y2 * chart.height / 100]];
        }
        else {
            return false;
        }
        chart.brush.brush.extent(extent);
        chart.brush.brush(chart.brush.brushGroup);
        chart.brushend();
        return true;
    }
    exports.restoreChartSelection = restoreChartSelection;
    //------------------------------------------------------------------------------------------------------------------------------------------
    // *bar chart*
    //------------------------------------------------------------------------------------------------------------------------------------------
    function d3BarChartForQuestion(graphHolder, question, storiesSelectedCallback, hideStatsPanel) {
        if (hideStatsPanel === void 0) { hideStatsPanel = false; }
        var allPlotItems = [];
        var xLabels = [];
        var key;
        var showNAs = showNAValues(graphHolder);
        var lumpingCommands = getLumpingCommands(graphHolder);
        var unansweredText = customStatLabel("unanswered", graphHolder);
        graphHolder.dataForCSVExport = {};
        var results = {};
        createEmptyDataStructureForAnswerCountsUsingDictionary(results, question, unansweredText, showNAs, lumpingCommands);
        createEmptyDataStructureForAnswerCountsUsingArray(xLabels, question, unansweredText, showNAs, lumpingCommands);
        // change 0 to [] for preloaded results
        for (key in results)
            results[key] = [];
        var stories = graphHolder.allStories;
        for (var storyIndex in stories) {
            var story = stories[storyIndex];
            var xValue = calculateStatistics.getChoiceValueForQuestionAndStory(question, story, unansweredText, showNAs, lumpingCommands);
            if (xValue !== null) {
                var xHasCheckboxes = _.isObject(xValue);
                if (!xHasCheckboxes) {
                    saveCountOfStoriesForChoiceCombination(results, xValue, { story: story, value: xValue });
                }
                else if (Object.keys(xValue).length === 0) {
                    if (showNAs)
                        saveCountOfStoriesForChoiceCombination(results, unansweredText, { story: story, value: unansweredText });
                }
                else {
                    for (var xIndex in xValue) {
                        if (xValue[xIndex])
                            saveCountOfStoriesForChoiceCombination(results, xIndex, { story: story, value: xIndex });
                    }
                }
            }
        }
        for (key in results) {
            xLabels.push(key);
            allPlotItems.push({ name: key, stories: results[key], value: results[key].length });
            graphHolder.dataForCSVExport[key] = results[key].length;
        }
        var chartTitle = "" + nameForQuestion(question);
        var xAxisLabel = nameForQuestion(question);
        return d3BarChartForValues(graphHolder, allPlotItems, xLabels, chartTitle, xAxisLabel, question, storiesSelectedCallback, hideStatsPanel);
    }
    exports.d3BarChartForQuestion = d3BarChartForQuestion;
    function d3BarChartToShowUnansweredChoiceQuestions(graphHolder, questions, dataIntegrityType) {
        var allPlotItems = [];
        var xLabels = [];
        var stories = graphHolder.allStories;
        var results = {};
        graphHolder.dataForCSVExport = {};
        function questionWasNotAnswered(question, value) {
            if (question.displayType === "checkbox" && !value)
                return false; // if they answered no on a checkbox they answered the question
            if (value === undefined || value === null || value === "")
                return true;
            if (typeof value === "object") {
                for (var arrayIndex in value) {
                    if (value[arrayIndex] == true) {
                        return false;
                    }
                    return true;
                }
            }
            return false;
        }
        for (var questionIndex in questions) {
            var question = questions[questionIndex];
            var storiesWithoutAnswersForThisQuestion = [];
            for (var storyIndex in stories) {
                var story = stories[storyIndex];
                var value = story.fieldValue(question.id);
                if (questionWasNotAnswered(question, value)) {
                    storiesWithoutAnswersForThisQuestion.push({ story: story });
                }
            }
            xLabels.push(question.displayName);
            allPlotItems.push({ name: question.displayName, stories: storiesWithoutAnswersForThisQuestion, value: storiesWithoutAnswersForThisQuestion.length });
            graphHolder.dataForCSVExport[question.displayName] = storiesWithoutAnswersForThisQuestion.length;
        }
        return d3BarChartForValues(graphHolder, allPlotItems, xLabels, dataIntegrityType, dataIntegrityType, null, null);
    }
    exports.d3BarChartToShowUnansweredChoiceQuestions = d3BarChartToShowUnansweredChoiceQuestions;
    function d3BarChartForValues(graphHolder, plotItems, xLabels, chartTitle, xAxisLabel, question, storiesSelectedCallback, hideStatsPanel) {
        if (hideStatsPanel === void 0) { hideStatsPanel = false; }
        var labelLengthLimit = parseInt(graphHolder.customLabelLengthLimit);
        var longestLabelText = "";
        for (var label in xLabels) {
            if (xLabels[label].length > longestLabelText.length) {
                longestLabelText = xLabels[label];
            }
        }
        var longestLabelTextLength = longestLabelText.length;
        if (longestLabelTextLength > labelLengthLimit) {
            longestLabelTextLength = labelLengthLimit + 3;
        }
        // Build chart
        // TODO: Improve the way labels are drawn or ellipsed based on chart size and font size and number of bars
        var chartPane = newChartPane(graphHolder, "singleChartStyleWithoutChildren");
        addTitlePanelForChart(chartPane, chartTitle);
        var maxItemsPerBar = d3.max(plotItems, function (plotItem) { return plotItem.value; });
        var letterSize = 8; // it would be better to get this from the DOM - but it would decrease performance...
        var margin = {
            top: 20,
            right: 15,
            bottom: 30 + longestLabelTextLength * letterSize + (graphHolder.customGraphPadding || 0),
            left: 70
        };
        if (maxItemsPerBar >= 100)
            margin.left += letterSize;
        if (maxItemsPerBar >= 1000)
            margin.left += letterSize;
        var chart = makeChartFramework(chartPane, "barChart", "large", margin, graphHolder.customGraphWidth, graphHolder.customGraphHeight);
        var chartBody = chart.chartBody;
        var statistics = calculateStatistics.calculateStatisticsForBarGraphValues(function (plotItem) { return plotItem.value; });
        graphHolder.statisticalInfo += addStatisticsPanelForChart(chartPane, graphHolder, statistics, chartTitle, "large", hideStatsPanel);
        // draw the x axis
        var xScale = d3.scale.ordinal()
            .domain(xLabels)
            .rangeRoundBands([0, chart.width], 0.1);
        chart.xScale = xScale;
        chart.xQuestion = question;
        var xAxis = addXAxis(chart, xScale, { labelLengthLimit: labelLengthLimit, rotateAxisLabels: true, graphType: "barChart" });
        // cfk hiding x axis label on bar chart - too far away if texts are long and redundant so not necessary
        // addXAxisLabel(chart, xAxisLabel, {graphType: "barChart"});
        // draw the y axis
        var yScale = d3.scale.linear()
            .domain([0, maxItemsPerBar])
            .range([chart.height, 0]);
        chart.yScale = yScale;
        // Extra version of scale for calculating heights without subtracting as in height - yScale(value)
        var yHeightScale = d3.scale.linear()
            .domain([0, maxItemsPerBar])
            .range([0, chart.height]);
        var yAxis = addYAxis(chart, yScale, { graphType: "barChart" });
        var countLabel = customStatLabel("count", graphHolder);
        addYAxisLabel(chart, countLabel, { graphType: "barChart" });
        // Append brush before data to ensure titles are drown
        if (storiesSelectedCallback)
            chart.brush = createBrush(chartBody, xScale, null, brushend);
        var bars = chartBody.selectAll(".barChart-bar")
            .data(plotItems)
            .enter().append("g")
            .attr("class", "barChart-bar")
            .attr('transform', function (plotItem) { return 'translate(' + xScale(plotItem.name) + ',' + yScale(0) + ')'; });
        var barBackground = bars.append("rect")
            .attr("x", function (plotItem) { return 0; })
            .attr("y", function (plotItem) { return yHeightScale(-plotItem.value); })
            .attr("height", function (plotItem) { return yHeightScale(plotItem.value); })
            .attr("width", xScale.rangeBand());
        var barLabels = chartBody.selectAll(".barChart-label")
            .data(plotItems)
            .enter().append("text")
            .text(function (plotItem) { if (plotItem.value > 0) {
            return "" + plotItem.value;
        }
        else {
            return "";
        } ; })
            .attr("class", "barChart-label")
            .attr("x", function (plotItem) { return xScale(plotItem.name) + xScale.rangeBand() / 2; })
            .attr("y", function (plotItem) { return chart.height - yHeightScale(plotItem.value) - 12; })
            .attr("dx", -3) // padding-right
            .attr("dy", ".35em") // vertical-align: middle
            .attr("text-anchor", "middle"); // text-align: middle
        // Overlay stories on each bar...
        var storyDisplayItems = bars.selectAll(".barChart-story")
            .data(function (plotItem) { return plotItem.stories; })
            .enter().append("rect")
            .attr('class', function (d, i) { return "barChart-story " + ((i % 2 === 0) ? "even" : "odd"); })
            .attr("x", function (plotItem) { return 0; })
            .attr("y", function (plotItem, i) { return yHeightScale(-i - 1); })
            .attr("height", function (plotItem) { return yHeightScale(1); })
            .attr("width", xScale.rangeBand());
        // Add tooltips
        if (!graphHolder.excludeStoryTooltips) {
            storyDisplayItems.append("svg:title")
                .text(function (storyItem) {
                var story = storyItem.story;
                var questionText = "";
                if (question) {
                    if (question.id === "storyLength") {
                        questionText = xAxisLabel + ": " + story.storyLength();
                    }
                    else if (question.id === "collectionDate") {
                        questionText = xAxisLabel + ": " + story.storyCollectionDate();
                    }
                    else if (question.id === "language") {
                        questionText = xAxisLabel + ": " + story.storyLanguage();
                    }
                    else {
                        questionText = xAxisLabel + ": " + displayTextForAnswer(story.fieldValue(question.id));
                    }
                }
                var tooltipText = "Title: " + story.storyName() +
                    "\nIndex: " + story.indexInStoryCollection() +
                    "\n" + questionText +
                    "\nText: " + limitStoryTextLength(story.storyText());
                return tooltipText;
            });
        }
        if (storiesSelectedCallback)
            supportStartingDragOverStoryDisplayItemOrCluster(chartBody, storyDisplayItems);
        function isPlotItemSelected(extent, plotItem) {
            var midPoint = xScale(plotItem.value) + xScale.rangeBand() / 2;
            var selected = extent[0] <= midPoint && midPoint <= extent[1];
            if (selected) {
                var itemName = plotItem.value;
                if (graphHolder.currentSelectionExtentPercentages.selectionCategories.indexOf(itemName) < 0) {
                    graphHolder.currentSelectionExtentPercentages.selectionCategories.push(itemName);
                }
            }
            return selected;
        }
        function brushend() {
            updateListOfSelectedStories(chart, storyDisplayItems, graphHolder, storiesSelectedCallback, isPlotItemSelected);
        }
        if (storiesSelectedCallback) {
            chart.brushend = brushend;
        }
        return chart;
    }
    exports.d3BarChartForValues = d3BarChartForValues;
    //------------------------------------------------------------------------------------------------------------------------------------------
    // *histogram* 
    //------------------------------------------------------------------------------------------------------------------------------------------
    // Histogram reference for d3: http://bl.ocks.org/mbostock/3048450
    function d3HistogramChartForQuestion(graphHolder, scaleQuestion, choiceQuestion, choice, storiesSelectedCallback, hideStatsPanel) {
        if (hideStatsPanel === void 0) { hideStatsPanel = false; }
        // note that choiceQuestion and choice may be undefined if this is just a simple histogram for all values
        var unanswered = [];
        var values = [];
        var matchingStories = [];
        var unansweredText = customStatLabel("unanswered", graphHolder);
        var showNAs = showNAValues(graphHolder);
        var lumpingCommands = getLumpingCommands(graphHolder);
        if (choiceQuestion) {
            graphHolder.dataForCSVExport[choice] = [];
        }
        else {
            graphHolder.dataForCSVExport = {};
            graphHolder.dataForCSVExport[scaleQuestion.displayName] = [];
        }
        var stories = graphHolder.allStories;
        for (var storyIndex in stories) {
            var story = stories[storyIndex];
            var scaleValue = calculateStatistics.getScaleValueForQuestionAndStory(scaleQuestion, story, unansweredText);
            if (choiceQuestion) {
                var choiceValue = calculateStatistics.getChoiceValueForQuestionAndStory(choiceQuestion, story, unansweredText, showNAs, lumpingCommands);
                if (!calculateStatistics.choiceValueMatchesQuestionOption(choiceValue, choiceQuestion, choice))
                    continue;
            }
            var newPlotItem = { story: story, value: scaleValue };
            if (scaleValue === unansweredText) {
                unanswered.push(newPlotItem);
            }
            else {
                values.push(newPlotItem);
                matchingStories.push(story);
            }
        }
        if (matchingStories.length < graphHolder.minimumStoryCountRequiredForGraph) {
            return null;
        }
        var chartTitle = "" + nameForQuestion(scaleQuestion);
        if (choiceQuestion)
            chartTitle = "" + choice;
        var style = "singleChartStyleWithoutChildren";
        var chartSize = "large";
        if (choiceQuestion) {
            style = "smallChartStyle";
            chartSize = "small";
        }
        var xAxisLabel = "";
        var xAxisStart = "";
        var xAxisEnd = "";
        if (choiceQuestion) {
            xAxisLabel = choice;
        }
        else {
            xAxisLabel = nameForQuestion(scaleQuestion);
            if (scaleQuestion.displayType === "slider") {
                if (scaleQuestion.displayConfiguration) {
                    xAxisStart = scaleQuestion.displayConfiguration[0];
                    xAxisEnd = scaleQuestion.displayConfiguration[1];
                }
            }
        }
        return d3HistogramChartForValues(graphHolder, values, choiceQuestion, choice, unanswered.length, matchingStories, style, chartSize, chartTitle, xAxisLabel, xAxisStart, xAxisEnd, storiesSelectedCallback, hideStatsPanel);
    }
    exports.d3HistogramChartForQuestion = d3HistogramChartForQuestion;
    function d3HistogramChartForDataIntegrity(graphHolder, scaleQuestions, dataIntegrityType) {
        var unanswered = [];
        var values = [];
        var stories = graphHolder.allStories;
        var unansweredCount = -1;
        var unansweredText = customStatLabel("unanswered", graphHolder);
        graphHolder.dataForCSVExport = {};
        graphHolder.dataForCSVExport[dataIntegrityType] = [];
        if (dataIntegrityType == "All scale values") {
            for (var storyIndex in stories) {
                var story = stories[storyIndex];
                for (var questionIndex in scaleQuestions) {
                    var aScaleQuestion = scaleQuestions[questionIndex];
                    var xValue = calculateStatistics.getScaleValueForQuestionAndStory(aScaleQuestion, story, unansweredText);
                    var newPlotItem = { story: story, value: xValue, questionName: nameForQuestion(aScaleQuestion) };
                    if (xValue === unansweredText) {
                        unanswered.push(newPlotItem);
                    }
                    else {
                        values.push(newPlotItem);
                    }
                }
            }
            unansweredCount = unanswered.length;
        }
        else {
            var storiesByParticipant = {};
            for (var storyIndex in stories) {
                var story = stories[storyIndex];
                if (storiesByParticipant[story.participantID()]) {
                    storiesByParticipant[story.participantID()].push(story);
                }
                else {
                    storiesByParticipant[story.participantID()] = [story];
                }
            }
            for (var participantID in storiesByParticipant) {
                var valuesForParticipant = [];
                for (var storyIndex in storiesByParticipant[participantID]) {
                    var story = storiesByParticipant[participantID][storyIndex];
                    for (var questionIndex in scaleQuestions) {
                        var aScaleQuestion = scaleQuestions[questionIndex];
                        var xValue = calculateStatistics.getScaleValueForQuestionAndStory(aScaleQuestion, story, unansweredText);
                        if (!(xValue === unansweredText)) {
                            valuesForParticipant.push(parseFloat(xValue));
                        }
                    }
                }
                var aPlotItem = null;
                if (dataIntegrityType == "Participant means") {
                    if (valuesForParticipant.length > 0) {
                        var mean = jStat.mean(valuesForParticipant);
                        aPlotItem = { story: null, value: mean };
                    }
                }
                else if (dataIntegrityType == "Participant standard deviations") {
                    if (valuesForParticipant.length > 1) {
                        var sd = jStat.stdev(valuesForParticipant, true);
                        aPlotItem = { story: null, value: sd };
                    }
                }
                if (aPlotItem)
                    values.push(aPlotItem);
            }
            unansweredCount = -1; // don't show; meaningless
        }
        return d3HistogramChartForValues(graphHolder, values, null, null, unansweredCount, [], "singleChartStyleWithoutChildren", "large", dataIntegrityType, dataIntegrityType, "", "", null);
    }
    exports.d3HistogramChartForDataIntegrity = d3HistogramChartForDataIntegrity;
    function d3HistogramChartForValues(graphHolder, plotItems, choiceQuestion, choice, unansweredCount, matchingStories, style, chartSize, chartTitle, xAxisLabel, xAxisStart, xAxisEnd, storiesSelectedCallback, hideStatsPanel) {
        if (hideStatsPanel === void 0) { hideStatsPanel = false; }
        var margin = { top: 20, right: 15, bottom: 60, left: 70 };
        if (plotItems.length > 1000)
            margin.left += 20;
        var isSmallFormat = style == "smallChartStyle";
        if (isSmallFormat) {
            margin.left = 35;
        }
        else {
            margin.bottom += 30;
        }
        var chartPane = newChartPane(graphHolder, style);
        if (!isSmallFormat)
            addTitlePanelForChart(chartPane, chartTitle);
        var chart = makeChartFramework(chartPane, "histogram", chartSize, margin, graphHolder.customGraphWidth, graphHolder.customGraphHeight);
        var chartBody = chart.chartBody;
        var values = plotItems.map(function (item) { return parseFloat(item.value); });
        var unansweredText = customStatLabel("unanswered", graphHolder);
        var statistics = calculateStatistics.calculateStatisticsForHistogramValues(values, unansweredCount, unansweredText);
        graphHolder.statisticalInfo += addStatisticsPanelForChart(chartPane, graphHolder, statistics, chartTitle, isSmallFormat ? "small" : "large", hideStatsPanel);
        var mean = statistics.mean;
        var standardDeviation = statistics.sd;
        // Draw the x axis
        var xScale = d3.scale.linear()
            .domain([0, 100])
            .range([0, chart.width]);
        chart.xScale = xScale;
        chart.xQuestion = xAxisLabel;
        var xAxis = addXAxis(chart, xScale, { isSmallFormat: isSmallFormat, graphType: "histogram" });
        var cutoff = 64;
        if (isSmallFormat) {
            cutoff = 32;
        }
        else {
            cutoff = 64;
        }
        addXAxisLabel(chart, xAxisLabel, { labelLengthLimit: cutoff, isSmallFormat: isSmallFormat, graphType: "histogram" });
        if (xAxisStart) {
            addXAxisLabel(chart, xAxisStart, { labelLengthLimit: maxRangeLabelLength, isSmallFormat: isSmallFormat, textAnchor: "start", graphType: "histogram" });
            addXAxisLabel(chart, xAxisEnd, { labelLengthLimit: maxRangeLabelLength, isSmallFormat: isSmallFormat, textAnchor: "end", graphType: "histogram" });
        }
        // draw the y axis
        // Generate a histogram using numHistogramBins uniformly-spaced bins.
        // TODO: Casting to any to get around D3 typing limitation where it expects number not an object
        var data = d3.layout.histogram().bins(xScale.ticks(graphHolder.numHistogramBins)).value(function (d) { return d.value; })(plotItems);
        var delimiter = Globals.clientState().csvDelimiter();
        data.forEach(function (bin) {
            var csvText = [bin.x, bin.x + bin.dx - ((bin.x == 95) ? 0 : 1), bin.length].join(delimiter);
            if (choiceQuestion) {
                graphHolder.dataForCSVExport[choice].push(csvText);
            }
            else {
                graphHolder.dataForCSVExport[chartTitle].push(csvText);
            }
        });
        // Set the bin for each plotItem
        data.forEach(function (bin) {
            bin.forEach(function (plotItem) {
                plotItem.xBinStart = bin.x;
            });
        });
        // TODO: May want to consider unanswered here if decide to plot it to the side
        var maxValue = d3.max(data, function (d) { return d.y; });
        var yScale = d3.scale.linear()
            .domain([0, maxValue])
            .range([chart.height, 0]);
        chart.yScale = yScale;
        chart.subgraphQuestion = choiceQuestion;
        chart.subgraphChoice = choice;
        // Extra version of scale for calculating heights without subtracting as in height - yScale(value)
        var yHeightScale = d3.scale.linear()
            .domain([0, maxValue])
            .range([0, chart.height]);
        var yAxis = addYAxis(chart, yScale, { isSmallFormat: isSmallFormat, graphType: "histogram" });
        if (!isSmallFormat) {
            var frequencyLabel = customStatLabel("frequency", graphHolder);
            addYAxisLabel(chart, frequencyLabel, { isSmallFormat: isSmallFormat, graphType: "histogram" });
        }
        if (isSmallFormat) {
            chartBody.selectAll('.axis').style({ 'stroke-width': '1px', 'fill': 'gray' });
        }
        // Append brush before data to ensure titles are drown
        if (storiesSelectedCallback)
            chart.brush = createBrush(chartBody, xScale, null, brushend);
        var bars = chartBody.selectAll(".histogram-bar")
            .data(data)
            .enter().append("g")
            .attr("class", "histogram-bar")
            .attr("transform", function (d) { return "translate(" + xScale(d.x) + "," + yScale(0) + ")"; });
        var barLabelClass = "histogram-barLabel";
        if (isSmallFormat) {
            barLabelClass = "histogram-barLabelSmall";
        }
        var barLabels = chartBody.selectAll("." + barLabelClass)
            .data(data)
            .enter().append("text")
            .text(function (d) { if (d.y > 0) {
            return "" + d.y;
        }
        else {
            return "";
        } ; })
            .attr("class", barLabelClass)
            .attr("x", function (d) { return xScale(d.x) + xScale(d.dx) / 2; })
            .attr("y", function (d) { return chart.height - yHeightScale(d.y) - 12; })
            .attr("dx", -3) // padding-right
            .attr("dy", ".35em") // vertical-align: middle
            .attr("text-anchor", "middle"); // text-align: middle
        // Overlay stories on each bar...
        var storyDisplayItems = bars.selectAll(".histogram-story")
            .data(function (plotItem) { return plotItem; })
            .enter().append("rect")
            .attr('class', function (d, i) { return "histogram-story " + ((i % 2 === 0) ? "even" : "odd"); })
            .attr("x", function (plotItem) { return 0; })
            .attr("y", function (plotItem, i) { return yHeightScale(-i - 1); })
            .attr("height", function (plotItem) { return yHeightScale(1); })
            .attr("width", xScale(data[0].dx) - 1);
        // Add tooltips
        if (!graphHolder.excludeStoryTooltips) {
            storyDisplayItems.append("svg:title")
                .text(function (plotItem) {
                var story = plotItem.story;
                var questionName = xAxisLabel;
                if (plotItem["questionName"]) {
                    questionName = plotItem["questionName"];
                }
                var tooltipText = "Title: " + story.storyName() +
                    "\nIndex: " + story.indexInStoryCollection() +
                    "\n" + questionName + ": " + plotItem.value +
                    "\nText: " + limitStoryTextLength(story.storyText());
                return tooltipText;
            });
        }
        if (storiesSelectedCallback)
            supportStartingDragOverStoryDisplayItemOrCluster(chartBody, storyDisplayItems);
        if (!isNaN(mean)) {
            // Draw mean
            chartBody.append("line")
                .attr('class', "histogram-mean")
                .attr("x1", xScale(mean))
                .attr("y1", yHeightScale(0))
                .attr("x2", xScale(mean))
                .attr("y2", yHeightScale(maxValue));
            if (!isNaN(standardDeviation)) {
                // Draw standard deviation
                var sdLow = mean - standardDeviation;
                if (sdLow >= 0) {
                    chartBody.append("line")
                        .attr('class', "histogram-standard-deviation-low")
                        .attr("x1", xScale(sdLow))
                        .attr("y1", yHeightScale(0))
                        .attr("x2", xScale(sdLow))
                        .attr("y2", yHeightScale(maxValue));
                }
                var sdHigh = mean + standardDeviation;
                if (sdHigh <= 100) {
                    chartBody.append("line")
                        .attr('class', "histogram-standard-deviation-high")
                        .attr("x1", xScale(sdHigh))
                        .attr("y1", yHeightScale(0))
                        .attr("x2", xScale(sdHigh))
                        .attr("y2", yHeightScale(maxValue));
                }
            }
        }
        function isPlotItemSelected(extent, plotItem) {
            // We don't want to compute a midPoint based on plotItem.value which can be anywhere in the bin; we want to use the stored bin.x.
            var midPoint = plotItem.xBinStart + data[0].dx / 2;
            var selected = extent[0] <= midPoint && midPoint <= extent[1];
            if (selected) {
                var xBinStop = plotItem.xBinStart + data[0].dx;
                var itemName = plotItem.xBinStart + "-" + xBinStop;
                if (graphHolder.currentSelectionExtentPercentages.selectionCategories.indexOf(itemName) < 0) {
                    graphHolder.currentSelectionExtentPercentages.selectionCategories.push(itemName);
                }
            }
            return selected;
        }
        function brushend(doNotUpdateStoryList) {
            // Clear selections in other graphs
            if (_.isArray(graphHolder.currentGraph) && !doNotUpdateStoryList) {
                graphHolder.currentGraph.forEach(function (otherGraph) {
                    if (otherGraph !== chart) {
                        otherGraph.brush.brush.clear();
                        otherGraph.brush.brush(otherGraph.brush.brushGroup);
                        otherGraph.brushend("doNotUpdateStoryList");
                    }
                });
            }
            var callback = storiesSelectedCallback;
            if (doNotUpdateStoryList)
                callback = null;
            updateListOfSelectedStories(chart, storyDisplayItems, graphHolder, callback, isPlotItemSelected);
        }
        if (storiesSelectedCallback) {
            chart.brushend = brushend;
        }
        // TODO: Put up title
        return chart;
    }
    exports.d3HistogramChartForValues = d3HistogramChartForValues;
    // TODO: Need to update this to pass instance for self into histograms so they can clear the selections in other histograms
    // TODO: Also need to track the most recent histogram with an actual selection so can save and restore that from patterns browser
    function multipleHistograms(graphHolder, choiceQuestion, scaleQuestion, storiesSelectedCallback, hideStatsPanel) {
        if (hideStatsPanel === void 0) { hideStatsPanel = false; }
        var unansweredText = customStatLabel("unanswered", graphHolder);
        var lumpingCommands = getLumpingCommands(graphHolder);
        var options = [];
        createEmptyDataStructureForAnswerCountsUsingArray(options, choiceQuestion, unansweredText, showNAValues(graphHolder), lumpingCommands);
        graphHolder.dataForCSVExport = {};
        // TODO: Could push extra options based on actual data choices (in case question changed at some point
        var chartPane = newChartPane(graphHolder, "singleChartStyleWithChildren");
        var optionsText = "";
        if (scaleQuestion.displayConfiguration && scaleQuestion.displayConfiguration.length > 1) {
            optionsText = " (" + scaleQuestion.displayConfiguration[0] + " - " + scaleQuestion.displayConfiguration[1] + ")";
        }
        var chartTitle = "" + nameForQuestion(scaleQuestion) + optionsText + " x " + nameForQuestion(choiceQuestion);
        addTitlePanelForChart(chartPane, chartTitle);
        var subCharts = [];
        for (var index in options) {
            var option = options[index];
            // TODO: Maybe need to pass which chart to the storiesSelectedCallback
            var subchart = d3HistogramChartForQuestion(graphHolder, scaleQuestion, choiceQuestion, option, storiesSelectedCallback, hideStatsPanel);
            if (subchart)
                subCharts.push(subchart);
        }
        if (subCharts.length === 0)
            addNoGraphsWarningForChart(chartPane);
        // End the float
        var clearFloat = document.createElement("br");
        clearFloat.style.clear = "left";
        graphHolder.graphResultsPane.appendChild(clearFloat);
        // Add these statistics at the bottom after all other graphs
        var statistics = calculateStatistics.calculateStatisticsForMultipleHistogram(scaleQuestion, choiceQuestion, graphHolder.allStories, graphHolder.minimumStoryCountRequiredForTest, unansweredText, showNAValues(graphHolder), lumpingCommands);
        graphHolder.statisticalInfo += addStatisticsPanelForChart(graphHolder.graphResultsPane, graphHolder, statistics, chartTitle, "large", hideStatsPanel);
        return subCharts;
    }
    exports.multipleHistograms = multipleHistograms;
    //------------------------------------------------------------------------------------------------------------------------------------------
    // *scatterplot* 
    //------------------------------------------------------------------------------------------------------------------------------------------
    // Reference for initial scatter chart: http://bl.ocks.org/bunkat/2595950
    // Reference for brushing: http://bl.ocks.org/mbostock/4560481
    // Reference for brush and tooltip: http://wrobstory.github.io/2013/11/D3-brush-and-tooltip.html
    function d3ScatterPlot(graphHolder, xAxisQuestion, yAxisQuestion, choiceQuestion, option, storiesSelectedCallback, hideStatsPanel) {
        // Collect data
        if (hideStatsPanel === void 0) { hideStatsPanel = false; }
        var allPlotItems = [];
        var storiesAtXYPoints = {};
        var stories = graphHolder.allStories;
        var unansweredText = customStatLabel("unanswered", graphHolder);
        var showNAs = showNAValues(graphHolder);
        var lumpingCommands = getLumpingCommands(graphHolder);
        var delimiter = Globals.clientState().csvDelimiter();
        if (choiceQuestion) {
            graphHolder.dataForCSVExport[option] = [];
        }
        else {
            graphHolder.dataForCSVExport = {};
            graphHolder.dataForCSVExport[xAxisQuestion.displayName + delimiter + yAxisQuestion.displayName] = [];
        }
        for (var index in stories) {
            var story = stories[index];
            var xValue = calculateStatistics.getScaleValueForQuestionAndStory(xAxisQuestion, story, unansweredText);
            var yValue = calculateStatistics.getScaleValueForQuestionAndStory(yAxisQuestion, story, unansweredText);
            if (xValue === unansweredText || yValue === unansweredText)
                continue;
            if (choiceQuestion) {
                var choiceValue = calculateStatistics.getChoiceValueForQuestionAndStory(choiceQuestion, story, unansweredText, showNAs, lumpingCommands);
                if (!calculateStatistics.choiceValueMatchesQuestionOption(choiceValue, choiceQuestion, option))
                    continue;
            }
            var newPlotItem = plotItemForScatterPlot(xAxisQuestion, yAxisQuestion, xValue, yValue, story, unansweredText);
            allPlotItems.push(newPlotItem);
            if (choiceQuestion) {
                graphHolder.dataForCSVExport[option].push([xValue + delimiter + yValue]);
            }
            else {
                graphHolder.dataForCSVExport[xAxisQuestion.displayName + delimiter + yAxisQuestion.displayName].push(xValue + delimiter + yValue);
            }
            var key = xValue + "|" + yValue;
            if (!(key in storiesAtXYPoints))
                storiesAtXYPoints[key] = [];
            storiesAtXYPoints[key].push(story);
        }
        if (allPlotItems.length < graphHolder.minimumStoryCountRequiredForGraph) {
            return null;
        }
        var isSmallFormat = !!choiceQuestion;
        var style = "singleChartStyleWithoutChildren";
        var chartSize = "large";
        if (isSmallFormat) {
            style = "mediumChartStyle";
            chartSize = "medium";
        }
        var chartPane = newChartPane(graphHolder, style);
        var largeGraphWidth = graphHolder.customGraphWidth || defaultLargeGraphWidth;
        var margin = { top: 20, right: 15 + largeGraphWidth / 4, bottom: 90, left: 90 };
        if (isSmallFormat) {
            margin.right = 20;
        }
        var chartTitle = "" + nameForQuestion(xAxisQuestion) + " x " + nameForQuestion(yAxisQuestion);
        if (!isSmallFormat)
            addTitlePanelForChart(chartPane, chartTitle);
        var chart = makeChartFramework(chartPane, "scatterPlot", chartSize, margin, graphHolder.customGraphWidth, graphHolder.customGraphHeight);
        var chartBody = chart.chartBody;
        chart.subgraphQuestion = choiceQuestion;
        chart.subgraphChoice = option;
        var statistics = calculateStatistics.calculateStatisticsForScatterPlot(xAxisQuestion, yAxisQuestion, choiceQuestion, option, stories, graphHolder.minimumStoryCountRequiredForTest, unansweredText, showNAs, lumpingCommands);
        graphHolder.statisticalInfo += addStatisticsPanelForChart(chartPane, graphHolder, statistics, chartTitle, isSmallFormat ? "small" : "large", hideStatsPanel);
        // draw the x axis
        var xScale = d3.scale.linear()
            .domain([0, 100])
            .range([0, chart.width]);
        chart.xScale = xScale;
        chart.xQuestion = xAxisQuestion;
        var xAxis = addXAxis(chart, xScale, { isSmallFormat: isSmallFormat, graphType: "scatterplot" });
        if (xAxisQuestion.displayConfiguration) {
            addXAxisLabel(chart, xAxisQuestion.displayConfiguration[0], { labelLengthLimit: maxRangeLabelLength, isSmallFormat: isSmallFormat, textAnchor: "start", graphType: "scatterplot" });
            addXAxisLabel(chart, xAxisQuestion.displayConfiguration[1], { labelLengthLimit: maxRangeLabelLength, isSmallFormat: isSmallFormat, textAnchor: "end", graphType: "scatterplot" });
        }
        if (choiceQuestion) {
            addXAxisLabel(chart, nameForQuestion(xAxisQuestion) + " (" + option + ")", { isSmallFormat: isSmallFormat, graphType: "scatterplot" });
        }
        else {
            addXAxisLabel(chart, nameForQuestion(xAxisQuestion), { isSmallFormat: isSmallFormat, graphType: "scatterplot" });
        }
        // draw the y axis
        var yScale = d3.scale.linear()
            .domain([0, 100])
            .range([chart.height, 0]);
        chart.yScale = yScale;
        chart.yQuestion = yAxisQuestion;
        var yAxis = addYAxis(chart, yScale, { isSmallFormat: isSmallFormat, graphType: "scatterplot" });
        if (choiceQuestion) {
            addYAxisLabel(chart, nameForQuestion(yAxisQuestion) + " (" + option + ")", { isSmallFormat: isSmallFormat, graphType: "scatterplot" });
        }
        else {
            addYAxisLabel(chart, nameForQuestion(yAxisQuestion), { isSmallFormat: isSmallFormat, graphType: "scatterplot" });
        }
        if (yAxisQuestion.displayConfiguration) {
            addYAxisLabel(chart, yAxisQuestion.displayConfiguration[0], { labelLengthLimit: maxRangeLabelLength, isSmallFormat: isSmallFormat, textAnchor: "start", graphType: "scatterplot" });
            addYAxisLabel(chart, yAxisQuestion.displayConfiguration[1], { labelLengthLimit: maxRangeLabelLength, isSmallFormat: isSmallFormat, textAnchor: "end", graphType: "scatterplot" });
        }
        // Append brush before data to ensure titles are drown
        chart.brush = createBrush(chartBody, xScale, yScale, brushend);
        var opacity = 1.0 / graphHolder.numScatterDotOpacityLevels;
        var dotSize = graphHolder.scatterDotSize;
        var storyDisplayItems = chartBody.selectAll(".story")
            .data(allPlotItems)
            .enter().append("circle")
            .attr("class", "scatterPlot-story")
            .attr("r", dotSize)
            .style("opacity", opacity)
            .attr("cx", function (plotItem) { return xScale(plotItem.x); })
            .attr("cy", function (plotItem) { return yScale(plotItem.y); });
        // Add tooltips
        if (!graphHolder.excludeStoryTooltips) {
            storyDisplayItems
                .append("svg:title")
                .text(function (plotItem) {
                var tooltipText;
                var xyKey = plotItem.x + "|" + plotItem.y;
                if (storiesAtXYPoints[xyKey] && storiesAtXYPoints[xyKey].length > 1) {
                    tooltipText = "X (" + nameForQuestion(xAxisQuestion) + "): " + plotItem.x + "\nY (" + nameForQuestion(yAxisQuestion) + "): " + plotItem.y;
                    tooltipText += "\n------ Stories (" + storiesAtXYPoints[xyKey].length + ") ------";
                    for (var i = 0; i < storiesAtXYPoints[xyKey].length; i++) {
                        var story = storiesAtXYPoints[xyKey][i];
                        tooltipText += "\n" + story.indexInStoryCollection() + ". " + story.storyName();
                        if (i >= 9) {
                            tooltipText += "\n(and " + (storiesAtXYPoints[xyKey].length - 10) + " more)";
                            break;
                        }
                    }
                }
                else {
                    tooltipText =
                        "X (" + nameForQuestion(xAxisQuestion) + "): " + plotItem.x +
                            "\nY (" + nameForQuestion(yAxisQuestion) + "): " + plotItem.y +
                            "\nTitle: " + plotItem.story.storyName() +
                            "\nIndex: " + plotItem.story.indexInStoryCollection() +
                            "\nText: " + limitStoryTextLength(plotItem.story.storyText());
                }
                return tooltipText;
            });
        }
        // Add line if correlation is significant (if option is set)
        if (graphHolder.correlationLineChoice != "none") {
            var lineWidth = 0;
            if (statistics.p <= 0.01) {
                lineWidth = 3;
            }
            else if ((statistics.p <= 0.05) && (graphHolder.correlationLineChoice == "0.05")) {
                lineWidth = 1;
            }
            if (lineWidth > 0) {
                var x1 = chart.width / 4;
                var x2 = 3 * chart.width / 4;
                var y1 = chart.height / 2 + chart.height / 4 * statistics.rho;
                var y2 = chart.height / 2 - chart.height / 4 * statistics.rho;
                var line = chartBody.append("line")
                    .style("stroke", "red")
                    .style("stroke-width", lineWidth)
                    .attr("x1", x1)
                    .attr("y1", y1)
                    .attr("x2", x2)
                    .attr("y2", y2);
            }
        }
        supportStartingDragOverStoryDisplayItemOrCluster(chartBody, storyDisplayItems);
        function isPlotItemSelected(extent, plotItem) {
            var selected = extent[0][0] <= plotItem.x && plotItem.x <= extent[1][0] && extent[0][1] <= plotItem.y && plotItem.y <= extent[1][1];
            if (selected) {
                // x1 = [0][0], y1 = [0][1], x2 = t[1][0], y2 = [1][1]
                var itemName = "" + extent[0][0].toFixed(0) + "," + extent[0][1].toFixed(0) + " - " + extent[1][0].toFixed(0) + "," + extent[1][1].toFixed(0);
                if (graphHolder.currentSelectionExtentPercentages.selectionCategories.indexOf(itemName) < 0) {
                    graphHolder.currentSelectionExtentPercentages.selectionCategories.push(itemName);
                }
            }
            return selected;
        }
        function brushend(doNotUpdateStoryList) {
            // Clear selections in other graphs (if multiple)
            if (_.isArray(graphHolder.currentGraph) && !doNotUpdateStoryList) {
                graphHolder.currentGraph.forEach(function (otherGraph) {
                    if (otherGraph !== chart) {
                        otherGraph.brush.brush.clear();
                        otherGraph.brush.brush(otherGraph.brush.brushGroup);
                        otherGraph.brushend("doNotUpdateStoryList");
                    }
                });
            }
            var callback = storiesSelectedCallback;
            if (doNotUpdateStoryList)
                callback = null;
            updateListOfSelectedStories(chart, storyDisplayItems, graphHolder, storiesSelectedCallback, isPlotItemSelected);
        }
        chart.brushend = brushend;
        return chart;
    }
    exports.d3ScatterPlot = d3ScatterPlot;
    function multipleScatterPlot(graphHolder, xAxisQuestion, yAxisQuestion, choiceQuestion, storiesSelectedCallback, hideStatsPanel) {
        if (hideStatsPanel === void 0) { hideStatsPanel = false; }
        var unansweredText = customStatLabel("unanswered", graphHolder);
        var lumpingCommands = getLumpingCommands(graphHolder);
        var options = [];
        createEmptyDataStructureForAnswerCountsUsingArray(options, choiceQuestion, unansweredText, showNAValues(graphHolder), lumpingCommands);
        graphHolder.dataForCSVExport = {};
        var chartPane = newChartPane(graphHolder, "singleChartStyleWithChildren");
        var chartTitle = "" + nameForQuestion(xAxisQuestion) + " x " + nameForQuestion(yAxisQuestion) + " + " + nameForQuestion(choiceQuestion);
        addTitlePanelForChart(chartPane, chartTitle);
        var subCharts = [];
        for (var i = 0; i < options.length; i++) {
            var subchart = d3ScatterPlot(graphHolder, xAxisQuestion, yAxisQuestion, choiceQuestion, options[i], storiesSelectedCallback, hideStatsPanel);
            if (subchart)
                subCharts.push(subchart);
        }
        if (subCharts.length === 0)
            addNoGraphsWarningForChart(chartPane);
        var clearFloat = document.createElement("br");
        clearFloat.style.clear = "left";
        graphHolder.graphResultsPane.appendChild(clearFloat);
        return subCharts;
    }
    exports.multipleScatterPlot = multipleScatterPlot;
    //------------------------------------------------------------------------------------------------------------------------------------------
    // *contingency table*
    //------------------------------------------------------------------------------------------------------------------------------------------
    function d3ContingencyTable(graphHolder, xAxisQuestion, yAxisQuestion, scaleQuestion, storiesSelectedCallback, hideStatsPanel) {
        if (hideStatsPanel === void 0) { hideStatsPanel = false; }
        var unansweredText = customStatLabel("unanswered", graphHolder);
        var showNAs = showNAValues(graphHolder);
        var lumpingCommands = getLumpingCommands(graphHolder);
        var columnLabels = {};
        var columnLabelsArray = [];
        createEmptyDataStructureForAnswerCountsUsingDictionary(columnLabels, xAxisQuestion, unansweredText, showNAs, lumpingCommands);
        createEmptyDataStructureForAnswerCountsUsingArray(columnLabelsArray, xAxisQuestion, unansweredText, showNAs, lumpingCommands);
        var xHasCheckboxes = xAxisQuestion.displayType === "checkboxes";
        var rowLabels = {};
        var rowLabelsArray = [];
        createEmptyDataStructureForAnswerCountsUsingDictionary(rowLabels, yAxisQuestion, unansweredText, showNAs, lumpingCommands);
        createEmptyDataStructureForAnswerCountsUsingArray(rowLabelsArray, yAxisQuestion, unansweredText, showNAs, lumpingCommands);
        rowLabelsArray.reverse(); // because otherwise the Y axis labels come out bottom to top
        var yHasCheckboxes = yAxisQuestion.displayType === "checkboxes";
        var results = {};
        var plotItemStories = {};
        var stories = graphHolder.allStories;
        graphHolder.dataForCSVExport = {};
        var delimiter = Globals.clientState().csvDelimiter();
        for (var index in stories) {
            var story = stories[index];
            var xValue = calculateStatistics.getChoiceValueForQuestionAndStory(xAxisQuestion, story, unansweredText, showNAs, lumpingCommands);
            var yValue = calculateStatistics.getChoiceValueForQuestionAndStory(yAxisQuestion, story, unansweredText, showNAs, lumpingCommands);
            if (xValue !== null && yValue !== null) {
                // fast path - if neither axis has multiple-choice answers; can more quickly assign values, since they are single
                if (!xHasCheckboxes && !yHasCheckboxes) {
                    addToCountOfStoriesForChoiceCombination(results, JSON.stringify({ x: xValue, y: yValue }));
                    addToCountOfStoriesForChoiceCombination(results, JSON.stringify({ x: xValue }));
                    addToCountOfStoriesForChoiceCombination(results, JSON.stringify({ y: yValue }));
                    saveCountOfStoriesForChoiceCombination(plotItemStories, JSON.stringify({ x: xValue, y: yValue }), story);
                }
                else {
                    // one or both may have multiple-choice answers, so do a loop for each and create plot items for every combination         
                    var key = void 0;
                    var xValues = [];
                    var yValues = [];
                    if (xHasCheckboxes) {
                        for (key in xValue || {}) {
                            if (xValue[key]) {
                                xValues.push(key);
                            }
                        }
                    }
                    else {
                        xValues.push(xValue);
                    }
                    if (yHasCheckboxes) {
                        for (key in yValue || {}) {
                            if (yValue[key]) {
                                yValues.push(key);
                            }
                        }
                    }
                    else {
                        yValues.push(yValue);
                    }
                    for (var xIndex in xValues) {
                        addToCountOfStoriesForChoiceCombination(results, JSON.stringify({ x: xValues[xIndex] }));
                    }
                    for (var yIndex in yValues) {
                        addToCountOfStoriesForChoiceCombination(results, JSON.stringify({ y: yValues[yIndex] }));
                    }
                    for (var xIndex in xValues) {
                        for (var yIndex in yValues) {
                            addToCountOfStoriesForChoiceCombination(results, JSON.stringify({ x: xValues[xIndex], y: yValues[yIndex] }));
                            saveCountOfStoriesForChoiceCombination(plotItemStories, JSON.stringify({ x: xValues[xIndex], y: yValues[yIndex] }), story);
                        }
                    }
                }
            }
        }
        var labelLengthLimit = parseInt(graphHolder.customLabelLengthLimit);
        var longestColumnText = "";
        for (var columnName in columnLabels) {
            if (columnName.length > longestColumnText.length) {
                longestColumnText = columnName;
            }
        }
        var longestColumnTextLength = longestColumnText.length;
        if (longestColumnTextLength > labelLengthLimit) {
            longestColumnTextLength = labelLengthLimit + 3;
        }
        if (!graphHolder.hideNumbersOnContingencyGraphs)
            longestColumnTextLength += 7; // space, parenthesis, 4 digits, parenthesis
        var longestRowText = "";
        for (var rowName in rowLabels) {
            if (rowName.length > longestRowText.length) {
                longestRowText = rowName;
            }
        }
        var longestRowTextLength = longestRowText.length;
        if (longestRowTextLength > labelLengthLimit) {
            longestRowTextLength = labelLengthLimit + 3;
        }
        if (!graphHolder.hideNumbersOnContingencyGraphs)
            longestRowTextLength += 7; // space, parenthesis, 4 digits, parenthesis
        var rowCount = rowLabelsArray.length;
        var rowStoryCounts = {};
        var columnStoryCounts = {};
        var totalColumnCount = 0;
        for (var columnIndex in columnLabelsArray) {
            var column = columnLabelsArray[columnIndex];
            var columnSelector = JSON.stringify({ x: column });
            var columnTotal = results[columnSelector] || 0;
            totalColumnCount += columnTotal;
        }
        var observedPlotItems = [];
        var expectedPlotItems = [];
        for (var columnIndex in columnLabelsArray) {
            var column = columnLabelsArray[columnIndex];
            for (var rowIndex in rowLabelsArray) {
                var row = rowLabelsArray[rowIndex];
                var xySelector = JSON.stringify({ x: column, y: row });
                var expectedValue = null;
                if (!xHasCheckboxes && !yHasCheckboxes) {
                    // Can only calculate expected and do chi-square if choices are exclusive
                    var columnSelector = JSON.stringify({ x: column });
                    var columnTotal = results[columnSelector] || 0;
                    var rowSelector = JSON.stringify({ y: row });
                    var rowTotal = results[rowSelector] || 0;
                    expectedValue = (columnTotal * rowTotal) / totalColumnCount;
                    var expectedPlotItem = { x: column, y: row, value: expectedValue };
                    expectedPlotItems.push(expectedPlotItem);
                }
                var observedValue = results[xySelector] || 0;
                var storiesForNewPlotItem = plotItemStories[xySelector] || [];
                var observedPlotItem = { x: column, y: row, value: observedValue, stories: storiesForNewPlotItem, expectedValue: expectedValue };
                observedPlotItems.push(observedPlotItem);
                if (scaleQuestion) {
                    var scaleValues = [];
                    for (var i = 0; i < storiesForNewPlotItem.length; i++) {
                        var scaleValue = parseInt(storiesForNewPlotItem[i].fieldValue(scaleQuestion.id));
                        if (scaleValue)
                            scaleValues.push(scaleValue);
                    }
                    var mean = jStat.mean(scaleValues);
                    var sd = undefined;
                    var skewness = undefined;
                    var kurtosis = undefined;
                    if (!isNaN(mean)) {
                        observedPlotItem["mean"] = mean;
                        sd = jStat.stdev(scaleValues, true);
                        if (!isNaN(sd))
                            observedPlotItem["sd"] = sd;
                        skewness = jStat.skewness(scaleValues);
                        if (!isNaN(skewness))
                            observedPlotItem["skewness"] = skewness;
                        kurtosis = jStat.kurtosis(scaleValues);
                        if (!isNaN(kurtosis))
                            observedPlotItem["kurtosis"] = kurtosis;
                    }
                    var valuesToReport = [
                        (mean !== undefined && !isNaN(mean)) ? mean : "",
                        (sd !== undefined && !isNaN(sd)) ? sd : "",
                        (skewness !== undefined && !isNaN(skewness)) ? skewness : "",
                        (kurtosis !== undefined && !isNaN(kurtosis)) ? kurtosis : "",
                    ];
                    valuesToReport = valuesToReport.concat(scaleValues);
                    graphHolder.dataForCSVExport[observedPlotItem.x + " x " + observedPlotItem.y] = valuesToReport;
                }
                else {
                    graphHolder.dataForCSVExport[observedPlotItem.x + delimiter + observedPlotItem.y] = observedPlotItem.value;
                }
                if (!rowStoryCounts[row])
                    rowStoryCounts[row] = 0;
                rowStoryCounts[row] += storiesForNewPlotItem.length;
                if (!columnStoryCounts[column])
                    columnStoryCounts[column] = 0;
                columnStoryCounts[column] += storiesForNewPlotItem.length;
            }
        }
        // Build chart
        // TODO: Improve the way labels are drawn or ellipsed based on chart size and font size and number of rows and columns
        var chartPane = newChartPane(graphHolder, "singleChartStyleWithoutChildren");
        var chartTitle = "" + nameForQuestion(xAxisQuestion) + " x " + nameForQuestion(yAxisQuestion);
        if (scaleQuestion) {
            chartTitle += " + " + nameForQuestion(scaleQuestion);
            if (scaleQuestion.displayConfiguration && scaleQuestion.displayConfiguration.length > 1) {
                chartTitle += escapeHtml(" (" + scaleQuestion.displayConfiguration[0] + " - " + scaleQuestion.displayConfiguration[1] + ")");
            }
        }
        addTitlePanelForChart(chartPane, chartTitle);
        var letterSize = 8; // it would be better to get this from the DOM - but it would decrease performance...
        var margin = {
            top: 36,
            right: 36,
            bottom: longestColumnTextLength * letterSize + (graphHolder.customGraphPadding || 0),
            left: longestRowTextLength * letterSize + (graphHolder.customGraphPadding || 0)
        };
        // spread out chart vertically for questions that have more answers (not so much of a problem in the columns)
        var graphSize = "large";
        if (rowCount >= 8) {
            graphSize = "tall";
        }
        var chart = makeChartFramework(chartPane, "contingencyChart", graphSize, margin, graphHolder.customGraphWidth, graphHolder.customGraphHeight);
        var chartBody = chart.chartBody;
        var statistics;
        if (scaleQuestion) {
            statistics = calculateStatistics.calculateStatisticsForMiniHistograms(scaleQuestion, xAxisQuestion, yAxisQuestion, stories, graphHolder.minimumStoryCountRequiredForTest, unansweredText, showNAs, lumpingCommands);
        }
        else {
            statistics = calculateStatistics.calculateStatisticsForTable(xAxisQuestion, yAxisQuestion, stories, graphHolder.minimumStoryCountRequiredForTest, unansweredText, showNAs, lumpingCommands);
        }
        graphHolder.statisticalInfo += addStatisticsPanelForChart(chartPane, graphHolder, statistics, chartTitle, "large", hideStatsPanel);
        // X axis and label
        var columnNamesAndTotals = {};
        if (!graphHolder.hideNumbersOnContingencyGraphs) {
            columnLabelsArray.forEach(function (label) {
                columnNamesAndTotals[label] = columnStoryCounts[label] || 0;
            });
        }
        // ordinal.rangeRoundBands(interval[, padding[, outerPadding]])
        // the outerPadding prevents any numbers from overwriting the right margin and into the label
        // these numbers were arrived at by trial and error
        var outerPadding;
        if (!graphHolder.hideNumbersOnContingencyGraphs) {
            outerPadding = 1.0;
        }
        else {
            outerPadding = 0.5;
        }
        var xScale = d3.scale.ordinal()
            .domain(columnLabelsArray)
            .rangeRoundBands([0, chart.width], 0.1, outerPadding);
        chart.xScale = xScale;
        chart.xQuestion = xAxisQuestion;
        var xAxis = addXAxis(chart, xScale, {
            labelLengthLimit: labelLengthLimit,
            drawLongAxisLines: true,
            rotateAxisLabels: true,
            graphType: "table",
            namesAndTotals: columnNamesAndTotals
        });
        addXAxisLabel(chart, nameForQuestion(xAxisQuestion), { graphType: "table", placeAxisNamesInUpperRight: true });
        // Y axis and label
        var rowNamesAndTotals = {};
        if (!graphHolder.hideNumbersOnContingencyGraphs) {
            rowLabelsArray.forEach(function (label) {
                rowNamesAndTotals[label] = rowStoryCounts[label] || 0;
            });
        }
        var yScale = d3.scale.ordinal()
            .domain(rowLabelsArray)
            .rangeRoundBands([chart.height, 0], 0.1);
        chart.yScale = yScale;
        chart.yQuestion = yAxisQuestion;
        var yAxis = addYAxis(chart, yScale, {
            labelLengthLimit: labelLengthLimit,
            drawLongAxisLines: true,
            graphType: "table",
            namesAndTotals: rowNamesAndTotals
        });
        addYAxisLabel(chart, nameForQuestion(yAxisQuestion), { graphType: "table", placeAxisNamesInUpperRight: true });
        // Append brush before data to ensure titles are drown
        chart.brush = createBrush(chartBody, xScale, yScale, brushend);
        // Compute a scaling factor to map plotItem values onto a width and height
        var maxPlotItemValue = d3.max(observedPlotItems, function (plotItem) { return plotItem.value; });
        var storyDisplayClusters = undefined;
        var sdRects = undefined;
        var meanRects = undefined;
        if (scaleQuestion) {
            var yValueMultiplier_1 = 0;
            if (maxPlotItemValue !== 0)
                yValueMultiplier_1 = yScale.rangeBand() / maxPlotItemValue;
            var barWidth_1 = xScale.rangeBand();
            // rectangles
            storyDisplayClusters = chartBody.selectAll(".contingencyChart-miniHistogram")
                .data(observedPlotItems)
                .enter().append("rect")
                .attr("class", "contingencyChart-miniHistogram")
                .attr("x", function (plotItem) { return xScale(plotItem.x); })
                .attr("y", function (plotItem) {
                var centerPoint = yScale(plotItem.y) + yScale.rangeBand() / 2.0;
                var centerToTopDisplacement = yValueMultiplier_1 * plotItem.value / 2.0;
                return centerPoint - centerToTopDisplacement;
            })
                .attr("width", function (plotItem) { return xScale.rangeBand(); })
                .attr("height", function (plotItem) { return yValueMultiplier_1 * plotItem.value; });
            // std dev rectangle
            sdRects = chartBody.selectAll(".contingencyChart-miniHistogram-stdDev")
                .data(observedPlotItems)
                .enter().append("rect")
                .attr("class", "contingencyChart-miniHistogram-stdDev")
                .attr("x", function (plotItem) {
                if (plotItem.mean && plotItem.sd) {
                    var meanMinusOneSD = Math.max(0, plotItem.mean - plotItem.sd);
                    var sdDisplacement = barWidth_1 * meanMinusOneSD / 100.0;
                    return xScale(plotItem.x) + sdDisplacement;
                }
                else {
                    return 0;
                }
            })
                .attr("y", function (plotItem) {
                var centerPoint = yScale(plotItem.y) + yScale.rangeBand() / 2.0;
                var centerToTopDisplacement = yValueMultiplier_1 * plotItem.value / 2.0;
                return centerPoint - centerToTopDisplacement;
            })
                .attr("width", function (plotItem) {
                if (plotItem.mean && plotItem.sd) {
                    var meanMinusOneSD = Math.max(0, plotItem.mean - plotItem.sd);
                    var meanPlusOneSD = Math.min(100, plotItem.mean + plotItem.sd);
                    return (meanPlusOneSD - meanMinusOneSD) * barWidth_1 / 100.0;
                }
                else {
                    return 0;
                }
                ;
            })
                .attr("height", function (plotItem) { return yValueMultiplier_1 * plotItem.value; });
            // mean rectangle (line)
            meanRects = chartBody.selectAll(".contingencyChart-miniHistogram-mean")
                .data(observedPlotItems)
                .enter().append("rect")
                .attr("class", "contingencyChart-miniHistogram-mean")
                .attr("x", function (plotItem) {
                if (plotItem.mean) {
                    var meanDisplacement = barWidth_1 * plotItem.mean / 100.0;
                    return xScale(plotItem.x) + meanDisplacement - 1; // 1 is half of width
                }
                else {
                    return 0;
                }
            })
                .attr("y", function (plotItem) {
                var centerPoint = yScale(plotItem.y) + yScale.rangeBand() / 2.0;
                var centerToTopDisplacement = yValueMultiplier_1 * plotItem.value / 2.0;
                return centerPoint - centerToTopDisplacement;
            })
                .attr("width", function (plotItem) { if (plotItem.mean) {
                return 2;
            }
            else {
                return 0;
            } ; })
                .attr("height", function (plotItem) { return yValueMultiplier_1 * plotItem.value; });
        }
        else {
            var xValueMultiplier_1 = 0;
            var yValueMultiplier_2 = 0;
            if (maxPlotItemValue !== 0) {
                xValueMultiplier_1 = xScale.rangeBand() / maxPlotItemValue / 2.0;
                yValueMultiplier_2 = yScale.rangeBand() / maxPlotItemValue / 2.0;
            }
            storyDisplayClusters = chartBody.selectAll(".contingencyChart-circle-observed")
                .data(observedPlotItems)
                .enter().append("ellipse")
                .attr("class", "contingencyChart-circle-observed")
                .attr("rx", function (plotItem) { return xValueMultiplier_1 * plotItem.value; })
                .attr("ry", function (plotItem) { return yValueMultiplier_2 * plotItem.value; })
                .attr("cx", function (plotItem) { return xScale(plotItem.x) + xScale.rangeBand() / 2.0; })
                .attr("cy", function (plotItem) { return yScale(plotItem.y) + yScale.rangeBand() / 2.0; });
            if (expectedPlotItems.length) {
                var expectedDisplayClusters = chartBody.selectAll(".contingencyChart-circle-expected")
                    .data(expectedPlotItems)
                    .enter().append("ellipse")
                    .attr("class", "contingencyChart-circle-expected")
                    .attr("rx", function (plotItem) { return xValueMultiplier_1 * plotItem.value; })
                    .attr("ry", function (plotItem) { return yValueMultiplier_2 * plotItem.value; })
                    .attr("cx", function (plotItem) { return xScale(plotItem.x) + xScale.rangeBand() / 2.0; })
                    .attr("cy", function (plotItem) { return yScale(plotItem.y) + yScale.rangeBand() / 2.0; });
            }
            if (!graphHolder.hideNumbersOnContingencyGraphs) {
                var letterSize_1 = 8;
                var minSizeToDrawLabelInside = 24;
                var circleLabels = chartBody.selectAll(".contingencyChart-circle-label")
                    .data(observedPlotItems)
                    .enter().append("text")
                    .text(function (plotItem) {
                    if (plotItem.expectedValue && Math.round(plotItem.expectedValue) !== 0) {
                        plotItem.text = "" + plotItem.value + "/" + Math.round(plotItem.expectedValue);
                    }
                    else if (plotItem.value) {
                        plotItem.text = "" + plotItem.value;
                    }
                    else {
                        plotItem.text = "";
                    }
                    return plotItem.text;
                })
                    .attr("class", "contingencyChart-circle-label")
                    .attr("x", function (plotItem) { return xScale(plotItem.x) + xScale.rangeBand() / 2.0; })
                    .attr("y", function (plotItem) { return yScale(plotItem.y) + yScale.rangeBand() / 2.0; })
                    .attr("dx", function (plotItem) { if (xValueMultiplier_1 * plotItem.value >= plotItem.text.length * letterSize_1)
                    return 0;
                else
                    return "0.35em"; })
                    .attr("dy", function (plotItem) {
                    if (xValueMultiplier_1 * plotItem.value >= plotItem.text.length * letterSize_1) {
                        return "0.35em";
                    }
                    else {
                        // try to place text below bubble (note that the expected bubble is ignored)
                        var displacement = 1.2 + yValueMultiplier_2 * plotItem.value / 12; // these numbers were arrived at by trial and error
                        return "" + displacement + "em";
                    }
                })
                    .attr("text-anchor", function (plotItem) { if (xValueMultiplier_1 * plotItem.value >= plotItem.text.length * letterSize_1)
                    return "middle";
                else
                    return "left"; });
            }
        }
        function tooltipTextForPlotItem(plotItem) {
            var tooltipText = "X (" + nameForQuestion(xAxisQuestion) + "): " + plotItem.x +
                "\nY (" + nameForQuestion(yAxisQuestion) + "): " + plotItem.y;
            if (plotItem.expectedValue) {
                tooltipText += "\nObserved: " + plotItem.value.toFixed(0) + "\nExpected: " + plotItem.expectedValue.toFixed(0);
            }
            if (scaleQuestion) {
                if (plotItem.mean !== undefined)
                    tooltipText += "\nMean: " + plotItem.mean.toFixed(2);
                if (plotItem.sd !== undefined)
                    tooltipText += "\nStandard deviation: " + plotItem.sd.toFixed(2);
                if (plotItem.skewness !== undefined)
                    tooltipText += "\nSkewness: " + plotItem.skewness.toFixed(2);
                if (plotItem.kurtosis !== undefined)
                    tooltipText += "\nKurtosis: " + plotItem.kurtosis.toFixed(2);
            }
            if (!plotItem.stories || plotItem.stories.length === 0) {
                tooltipText += "\n------ No stories ------";
            }
            else {
                tooltipText += "\n------ Stories (" + plotItem.stories.length + ") ------";
                for (var i = 0; i < plotItem.stories.length; i++) {
                    var story = plotItem.stories[i];
                    tooltipText += "\n" + story.indexInStoryCollection() + ". " + story.storyName();
                    if (i >= 9) {
                        tooltipText += "\n(and " + (plotItem.stories.length - 10) + " more)";
                        break;
                    }
                }
            }
            return tooltipText;
        }
        // Add tooltips
        if (!graphHolder.excludeStoryTooltips) {
            if (storyDisplayClusters)
                storyDisplayClusters.append("svg:title").text(tooltipTextForPlotItem);
            if (sdRects)
                sdRects.append("svg:title").text(tooltipTextForPlotItem);
            if (meanRects)
                meanRects.append("svg:title").text(tooltipTextForPlotItem);
        }
        if (storyDisplayClusters)
            supportStartingDragOverStoryDisplayItemOrCluster(chartBody, storyDisplayClusters);
        function isPlotItemSelected(extent, plotItem) {
            var midPointX = xScale(plotItem.x) + xScale.rangeBand() / 2;
            var midPointY = yScale(plotItem.y) + yScale.rangeBand() / 2;
            var selected = extent[0][0] <= midPointX && midPointX <= extent[1][0] && extent[0][1] <= midPointY && midPointY <= extent[1][1];
            if (selected) {
                var itemName = plotItem.x + " x " + plotItem.y;
                if (graphHolder.currentSelectionExtentPercentages.selectionCategories.indexOf(itemName) < 0) {
                    graphHolder.currentSelectionExtentPercentages.selectionCategories.push(itemName);
                }
            }
            return selected;
        }
        function brushend() {
            if (storyDisplayClusters)
                updateListOfSelectedStories(chart, storyDisplayClusters, graphHolder, storiesSelectedCallback, isPlotItemSelected);
        }
        chart.brushend = brushend;
        return chart;
    }
    exports.d3ContingencyTable = d3ContingencyTable;
    //------------------------------------------------------------------------------------------------------------------------------------------
    // *correlation map*
    //------------------------------------------------------------------------------------------------------------------------------------------
    function d3CorrelationMapOrMaps(graphHolder, questions, hideStatsPanel) {
        if (hideStatsPanel === void 0) { hideStatsPanel = false; }
        var nodesInfo = nodeInfoForScalesWithOrWithoutChoiceQuestion(graphHolder, questions);
        var options = nodesInfo["Options"];
        var largestCount = nodesInfo["Largest count"];
        var nodes = nodesInfo["Nodes"];
        graphHolder.dataForCSVExport = {};
        if (options.length > 1) {
            var chartPane = newChartPane(graphHolder, "singleChartStyleWithChildren");
            var chartTitle = "Correlation map for " + questions[0].displayName;
            addTitlePanelForChart(chartPane, chartTitle);
            var subCharts = [];
            for (var i = 0; i < options.length; i++) {
                var subchart = d3CorrelationMap(graphHolder, questions.slice(1), questions[0], nodes[options[i]], largestCount, options[i], hideStatsPanel);
                if (subchart)
                    subCharts.push(subchart);
            }
            if (subCharts.length === 0)
                addNoGraphsWarningForChart(chartPane);
            var clearFloat = document.createElement("br");
            clearFloat.style.clear = "left";
            graphHolder.graphResultsPane.appendChild(clearFloat);
            return subCharts;
        }
        else {
            var chart = d3CorrelationMap(graphHolder, questions, null, nodes["ALL"], largestCount, null, hideStatsPanel);
            return chart;
        }
    }
    exports.d3CorrelationMapOrMaps = d3CorrelationMapOrMaps;
    function nodeInfoForScalesWithOrWithoutChoiceQuestion(graphHolder, questions) {
        var stories = graphHolder.allStories;
        var unansweredText = customStatLabel("unanswered", graphHolder);
        var showNAs = showNAValues(graphHolder);
        var lumpingCommands = getLumpingCommands(graphHolder);
        var choiceQuestion = null;
        var scaleQuestions = null;
        var options = [];
        if (questions[0].displayType !== "slider") {
            choiceQuestion = questions[0];
            createEmptyDataStructureForAnswerCountsUsingArray(options, choiceQuestion, unansweredText, showNAs, lumpingCommands);
            scaleQuestions = questions.slice(1);
        }
        else {
            options.push("ALL");
            scaleQuestions = questions;
        }
        var nodesInfo = {};
        var nodes = {};
        var largestCount = 0;
        var labelLengthLimit = parseInt(graphHolder.customLabelLengthLimit);
        for (var i = 0; i < options.length; i++) {
            var option = options[i];
            nodes[option] = [];
            for (var scaleIndex = 0; scaleIndex < scaleQuestions.length; scaleIndex++) {
                var count = 0;
                for (var storyIndex = 0; storyIndex < stories.length; storyIndex++) {
                    var scaleValue = calculateStatistics.getScaleValueForQuestionAndStory(scaleQuestions[scaleIndex], stories[storyIndex], unansweredText);
                    if (scaleValue !== undefined && scaleValue !== unansweredText) {
                        if (choiceQuestion) {
                            var choiceValue = calculateStatistics.getChoiceValueForQuestionAndStory(choiceQuestion, stories[storyIndex], unansweredText, showNAs, lumpingCommands);
                            if (!calculateStatistics.choiceValueMatchesQuestionOption(choiceValue, choiceQuestion, option))
                                continue;
                        }
                        count++;
                    }
                }
                if (count >= graphHolder.minimumStoryCountRequiredForGraph) {
                    var type = null;
                    if (scaleQuestions[scaleIndex].id.indexOf("S_") >= 0) {
                        type = "story";
                    }
                    else if (scaleQuestions[scaleIndex].id.indexOf("P_") >= 0) {
                        type = "participant";
                    }
                    else if (scaleQuestions[scaleIndex].id.indexOf("A_") >= 0) {
                        type = "annotation";
                    }
                    var scaleEnds = "";
                    if (scaleQuestions[scaleIndex].displayConfiguration && scaleQuestions[scaleIndex].displayConfiguration.length > 1) {
                        var leftEnd = scaleQuestions[scaleIndex].displayConfiguration[0];
                        var rightEnd = scaleQuestions[scaleIndex].displayConfiguration[1];
                        if (leftEnd !== "" && rightEnd !== "")
                            scaleEnds = limitLabelLength(leftEnd + " - " + rightEnd, labelLengthLimit);
                    }
                    var name_1 = limitLabelLength(scaleQuestions[scaleIndex].displayName, labelLengthLimit);
                    var node = { id: scaleIndex, name: name_1, type: type, scaleEnds: scaleEnds, count: count };
                    nodes[option].push(node);
                }
                if (count > largestCount)
                    largestCount = count;
            }
        }
        nodesInfo["Options"] = options;
        nodesInfo["Largest count"] = largestCount;
        nodesInfo["Nodes"] = nodes;
        return nodesInfo;
    }
    function d3CorrelationMap(graphHolder, scaleQuestions, choiceQuestion, nodes, largestCount, option, hideStatsPanel) {
        if (hideStatsPanel === void 0) { hideStatsPanel = false; }
        if (nodes.length < 3)
            return null;
        // set up easier access to options
        var isSmallFormat = !!choiceQuestion;
        var mapShape = graphHolder.correlationMapShape;
        var scaleEndOption = graphHolder.correlationMapIncludeScaleEndLabels;
        var delimiter = Globals.clientState().csvDelimiter();
        // set up csv data holder
        if (choiceQuestion) {
            graphHolder.dataForCSVExport[option] = [];
        }
        else {
            graphHolder.dataForCSVExport["Correlation map"] = [];
        }
        // already have node info, now get link info
        var links = [];
        var stories = graphHolder.allStories;
        var unansweredText = customStatLabel("unanswered", graphHolder);
        var showNAs = showNAValues(graphHolder);
        var lumpingCommands = getLumpingCommands(graphHolder);
        var statsInfo = [];
        var usedQuestionIndexes = [];
        for (var scaleIndex1 = 0; scaleIndex1 < scaleQuestions.length; scaleIndex1++) {
            usedQuestionIndexes.push(scaleIndex1);
            for (var scaleIndex2 = 0; scaleIndex2 < scaleQuestions.length; scaleIndex2++) {
                if (usedQuestionIndexes.indexOf(scaleIndex2) === -1) {
                    var pairStats = calculateStatistics.calculateStatisticsForScatterPlot(scaleQuestions[scaleIndex1], scaleQuestions[scaleIndex2], choiceQuestion, option, stories, graphHolder.minimumStoryCountRequiredForTest, unansweredText, showNAs, lumpingCommands);
                    var pToShowLink = parseFloat(graphHolder.correlationLineChoice);
                    if (pairStats.p <= pToShowLink && pairStats.n >= graphHolder.minimumStoryCountRequiredForGraph) {
                        var link = { source: scaleIndex1, target: scaleIndex2, value: pairStats.rho, p: pairStats.p, n: pairStats.n };
                        links.push(link);
                        if (pairStats.statsDetailed.length > 1) {
                            var pairStatsInfo = {
                                "one": scaleIndex1 + 1,
                                "one_name": scaleQuestions[scaleIndex1].displayName,
                                "two": scaleIndex2 + 1,
                                "two_name": scaleQuestions[scaleIndex2].displayName,
                                "r": pairStats.rho,
                                "p": pairStats.p,
                                "n": pairStats.n
                            };
                            statsInfo.push(pairStatsInfo);
                        }
                    }
                }
            }
        }
        // save info for csv file
        statsInfo.forEach(function (stats) {
            var csvText = stats.one_name + " x " + stats.two_name + delimiter + [stats.r, stats.p, stats.n].join(delimiter);
            if (choiceQuestion) {
                graphHolder.dataForCSVExport[option].push(csvText);
            }
            else {
                graphHolder.dataForCSVExport["Correlation map"].push(csvText);
            }
        });
        // set up chart size and objects
        var style = "singleChartStyleWithoutChildren";
        var chartSize = "large";
        if (isSmallFormat) {
            style = "mediumChartStyle";
            chartSize = "medium-large"; // really doesn't fit into the medium size
        }
        var chartPane = newChartPane(graphHolder, style);
        var margin = { top: 0, right: 10, bottom: 10, left: 0 };
        if (!isSmallFormat)
            addTitlePanelForChart(chartPane, "Correlation map");
        var chart = makeChartFramework(chartPane, "correlationMap", chartSize, margin, graphHolder.customGraphWidth, graphHolder.customGraphHeight);
        var chartBody = chart.chartBody;
        chart.subgraphQuestion = choiceQuestion;
        chart.subgraphChoice = option;
        if (isSmallFormat) {
            var graphTitle = chartBody.append("text")
                .attr("class", "narrafirma-correlation-map-option-title")
                .attr("x", chart.width / 2)
                .attr("y", "1.5em")
                .attr("text-anchor", "middle")
                .text(choiceQuestion.displayName + ": " + option);
        }
        var frameRect = chartBody.append("rect")
            .attr('width', chart.width)
            .attr('height', chart.height)
            .style("fill", "none")
            .attr('class', 'narrafirma-correlation-map-frame');
        var subgraphName = isSmallFormat ? choiceQuestion.displayName + ": " + option : "";
        var textForThisOption = addStatisticsPanelForCorrelationMap(chartPane, graphHolder, statsInfo, subgraphName, chartSize, hideStatsPanel);
        graphHolder.statisticalInfo += subgraphName + "\n\n" + textForThisOption + "\n\n";
        // save info about nodes and links for later reference
        var namesForNodeIDs = {};
        var linkInfoForNodeIDs = {};
        var linkInfoForNodeIDPairs = {};
        var longestNameLength = 0;
        var longestScaleEndLength = 0;
        nodes.forEach(function (node) {
            namesForNodeIDs[node.id] = node;
            if (node.name.length > longestNameLength)
                longestNameLength = node.name.length;
            if (node.scaleEnds.length > longestScaleEndLength)
                longestScaleEndLength = node.scaleEnds.length;
            linkInfoForNodeIDs[node.id] = [];
        });
        links.forEach(function (link) {
            linkInfoForNodeIDs[link.source].push({ otherNode: namesForNodeIDs[link.target].name, value: link.value, n: link.n, p: link.p });
            linkInfoForNodeIDs[link.target].push({ otherNode: namesForNodeIDs[link.source].name, value: link.value, n: link.n, p: link.p });
            linkInfoForNodeIDPairs[link.source + " " + link.target] = {
                sourceName: namesForNodeIDs[link.source].name,
                targetName: namesForNodeIDs[link.target].name,
                value: link.value, n: link.n, p: link.p
            };
        });
        // set up sizes for circles and placements
        var maxCircleRadius = 0.18 * chart.height / nodes.length; // number arrived at by trial and error
        var maxLinkWidth = maxCircleRadius * 2;
        var nodeValueMultiplier = maxCircleRadius / largestCount; // if choice question, largestCount is for ALL graphs
        var midX = chart.width / 2.0;
        var midY = chart.height / 2.0;
        // set up scale to place node circles vertically 
        var nodeNames = nodes.map(function (node) { return node.name; });
        var nodeScaleInAVerticalLine = d3.scale.ordinal()
            .domain(nodeNames)
            .rangeRoundPoints([(choiceQuestion === null) ? 40 : 60, chart.height - 80]);
        // set up "clock face" to place node circles in a big circle
        var nodePointsInACircle = {};
        var circleDiameter = graphHolder.correlationMapCircleDiameter;
        if (isSmallFormat)
            circleDiameter = circleDiameter / 2;
        var angleIncrement = 2.0 * Math.PI / nodes.length;
        var angle = -Math.PI / 2.0; // start at pi/2 which is twelve o'clock
        for (var i = 0; i < nodes.length; i++) {
            var x = midX + Math.cos(angle) * circleDiameter / 2;
            var y = midY + Math.sin(angle) * circleDiameter / 2;
            nodePointsInACircle[i] = { "x": x, "y": y };
            angle += angleIncrement;
        }
        function nodeCenterX(node, index) {
            if (mapShape === "line with arcs") {
                return midX;
            }
            else if (mapShape === "circle with lines") {
                return nodePointsInACircle[index].x;
            }
        }
        function nodeCenterY(node, index) {
            if (mapShape === "line with arcs") {
                return nodeScaleInAVerticalLine(node.name);
            }
            else if (mapShape === "circle with lines") {
                return nodePointsInACircle[index].y;
            }
        }
        // create link paths
        // these must be created first (beneath) because, for the circle condition, they have to go to the center points of the circles
        var linkPaths = null;
        if (mapShape === "line with arcs") {
            linkPaths = chartBody.selectAll(".narrafirma-correlation-map-link")
                .data(links)
                .enter().append("path")
                .attr('d', function (link) {
                var arcStartX, arcStartY, arcEndX, arcEndY, arcDirection = null;
                var arcDisplacement = (link.value > 0) ? maxCircleRadius : -maxCircleRadius;
                arcStartX = midX + arcDisplacement;
                arcStartY = nodeScaleInAVerticalLine(namesForNodeIDs[link.source].name);
                arcEndX = midX + arcDisplacement;
                arcEndY = nodeScaleInAVerticalLine(namesForNodeIDs[link.target].name);
                arcDirection = (link.value > 0) ? "1" : "0";
                // M x,y = Move Command (move the pen to a location)
                var result = "M " + arcStartX + "," + arcStartY + " ";
                // Elliptical Arc Curve Command
                // https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
                // A rx,ry x-axis-rotation large-arc-flag, sweep-flag x,y 
                var distance = Math.abs((arcEndY - arcStartY)) / 2;
                result += "A" + distance + "," + distance; // arc radius x and y (same)
                result += "-30"; // x-axis-rotation (-30 seems to work)
                result += " 0"; // large-arc-flag (always 0 because the angle of the arc is less than 180 degrees)
                result += "," + arcDirection; // direction arc is drawn in (1 is to the right)
                result += " " + arcEndX + "," + arcEndY; // end point
                return result;
            })
                .style("fill", "none")
                .attr("class", "narrafirma-correlation-map-link")
                .style("stroke-width", function (link) { return Math.abs(link.value * maxLinkWidth / 2); });
        }
        else if (mapShape === "circle with lines") {
            linkPaths = chartBody.selectAll(".narrafirma-correlation-map-link")
                .data(links)
                .enter().append("line")
                .attr("x1", function (link) { return nodeCenterX(null, link.source); })
                .attr("y1", function (link) { return nodeCenterY(null, link.source); })
                .attr("x2", function (link) { return nodeCenterX(null, link.target); })
                .attr("y2", function (link) { return nodeCenterY(null, link.target); })
                .style("fill", "none")
                .attr("class", "narrafirma-correlation-map-link")
                .style("stroke-dasharray", function (link) { return (link.value < 0) ? (isSmallFormat ? "3" : "5") : "none"; })
                .style("stroke-width", function (link) { return Math.abs(link.value * maxLinkWidth / 2); });
        }
        // create node circles - two for each question, max count and actual count
        // max count circles must be drawn beneath count circles (first)
        var nodeMaxCountCircles = chartBody.selectAll(".narrafirma-correlation-map-node-max")
            .data(nodes)
            .enter().append("ellipse")
            .attr("class", "narrafirma-correlation-map-node-max")
            .attr("rx", function (node) { return maxCircleRadius; })
            .attr("ry", function (node) { return maxCircleRadius; })
            .attr("cx", function (node, index) { return nodeCenterX(node, index); })
            .attr("cy", function (node, index) { return nodeCenterY(node, index); });
        var nodeCountCircles = chartBody.selectAll(".narrafirma-correlation-map-node-count")
            .data(nodes)
            .enter().append("ellipse")
            .attr("class", "narrafirma-correlation-map-node-count")
            .attr("rx", function (node) { return nodeValueMultiplier * node.count; })
            .attr("ry", function (node) { return nodeValueMultiplier * node.count; })
            .attr("cx", midX)
            .attr("cx", function (node, index) { return nodeCenterX(node, index); })
            .attr("cy", function (node, index) { return nodeCenterY(node, index); });
        // set up tooltip div to show when user hovers over node or link
        var tooltipDiv = d3.select("body")
            .append("div")
            .attr("class", "narrafirma-correlation-map-popup-graph-div")
            .style("display", "none");
        var tooltipSubchartPane = document.createElement("div");
        tooltipSubchartPane.className = "narrafirma-correlation-map-popup-graph-pane";
        var tooltipOffset = (choiceQuestion !== null) ? 24 : 32;
        // set up tooltip histogram drawing for nodes
        // sometimes the nodeCountCircle will be tiny and sometimes it will be as big as the nodeMaxCountCircle
        // so they both have to respond in the same way (hence the functions)
        function setUpMouseOverForNode(node, parent, countOrMax) {
            d3.select(parent).classed("narrafirma-correlation-map-node-" + countOrMax + "-selected", true);
            linkPaths.classed('narrafirma-correlation-map-link-selected', function (path) { return path.source === node.id || path.target === node.id; });
            var tooltipSubchart = d3HistogramChartForPopup(graphHolder, tooltipSubchartPane, scaleQuestions[node.id], choiceQuestion, option);
            var svgNode = tooltipSubchart.querySelector("svg");
            tooltipDiv
                .html('<div class="narrafirma-correlation-map-thumbnail">' + svgNode.outerHTML + "</div>")
                .style("display", "block")
                .style("left", chartPane.offsetLeft + d3.mouse(parent)[0] + tooltipOffset + "px")
                .style("top", chartPane.offsetTop + d3.mouse(parent)[1] + tooltipOffset + "px");
        }
        function setUpMouseOutForNode(node, parent, countOrMax) {
            d3.select(parent).classed("narrafirma-correlation-map-node-" + countOrMax + "-selected", false);
            d3.select(parent).classed("narrafirma-correlation-map-node-" + countOrMax, true);
            linkPaths.classed("narrafirma-correlation-map-link-selected", false);
            linkPaths.classed("narrafirma-correlation-map-link", true);
            tooltipDiv.html("").style("display", "none");
        }
        nodeMaxCountCircles
            .on("mouseover", function (node) { setUpMouseOverForNode(node, this, "max"); })
            .on("mouseout", function (node) { setUpMouseOutForNode(node, this, "max"); });
        nodeCountCircles
            .on("mouseover", function (node) { setUpMouseOverForNode(node, this, "count"); })
            .on("mouseout", function (node) { setUpMouseOutForNode(node, this, "count"); });
        // set up tooltip scatterplot graph drawing for links
        linkPaths
            .on("mouseover", function (link) {
            d3.select(this).classed("narrafirma-correlation-map-link", false);
            d3.select(this).classed("narrafirma-correlation-map-link-selected", true);
            var tooltipSubchart = d3ScatterPlotForPopup(graphHolder, tooltipSubchartPane, scaleQuestions[link.source], scaleQuestions[link.target], choiceQuestion, option);
            var svgNode = tooltipSubchart.querySelector("svg");
            tooltipDiv
                .html('<div class="narrafirma-correlation-map-thumbnail">' + svgNode.outerHTML + "</div>")
                .style("display", "block")
                .style("left", chartPane.offsetLeft + d3.mouse(this)[0] + ((mapShape === "line with arcs" && link.value < 0) ? -tooltipOffset / 2 - 101 : tooltipOffset) + "px")
                .style("top", chartPane.offsetTop + d3.mouse(this)[1] + tooltipOffset + "px");
        })
            .on("mouseout", function (link) {
            d3.select(this).classed("narrafirma-correlation-map-link-selected", false);
            d3.select(this).classed("narrafirma-correlation-map-link", true);
            tooltipDiv.html("").style("display", "none");
        });
        // finally (on top) draw node names 
        var drawScaleEndLabels = false;
        switch (scaleEndOption) {
            case "always":
                drawScaleEndLabels = true;
                break;
            case "only when there is no choice question":
                drawScaleEndLabels = !isSmallFormat;
                break;
            case "only when there are 6 or fewer questions":
                drawScaleEndLabels = nodes.length <= 6;
                break;
            case "never":
                drawScaleEndLabels = false;
                break;
            default:
                console.log("ERROR: No value for correlationMapIncludeScaleEndLabels");
        }
        function nodeTextAnchor(node, index) {
            if (mapShape === "circle with lines") {
                if (index === 0 || index === nodes.length / 2) {
                    return "middle";
                }
                else if (index < nodes.length / 2) {
                    return "start";
                }
                else if (index > nodes.length / 2) {
                    return "end";
                }
            }
            else {
                return "middle";
            }
        }
        function nodeTextY(node, index) {
            var start = nodeCenterY(node, index);
            if (mapShape === "circle with lines") {
                if (index === 0) {
                    return start - maxCircleRadius;
                }
                else if (index === nodes.length / 2) {
                    return start + maxCircleRadius;
                }
                else {
                    return start + maxCircleRadius;
                }
            }
            else {
                return start + maxCircleRadius;
            }
        }
        function nodeTextDY(node, index, level) {
            if (mapShape === "circle with lines") {
                if (index === 0) {
                    return (level === 0) ? (drawScaleEndLabels ? "-1.5em" : "-1em") : "-0.5em";
                }
                else if (index === nodes.length / 2) {
                    return (level === 0) ? (drawScaleEndLabels ? "1em" : "1em") : "2.5em";
                }
                else {
                    return (level === 0) ? (drawScaleEndLabels ? "1em" : "1em") : "2.5em";
                }
            }
            else {
                return (level === 0) ? "1em" : "2.5em";
            }
        }
        var nodeLabels = chartBody.selectAll(".narrafirma-correlation-map-node-label")
            .data(nodes)
            .enter().append("text")
            .text(function (node) { return (node.count > graphHolder.minimumStoryCountRequiredForGraph) ? node.name : ""; })
            .attr("class", "narrafirma-correlation-map-node-label")
            .attr("x", function (node, index) { return nodeCenterX(node, index); })
            .attr("y", function (node, index) { return nodeTextY(node, index); })
            .attr("dx", 0)
            .attr("dy", function (node, index) { return nodeTextDY(node, index, 0); })
            .attr("text-anchor", function (node, index) { return nodeTextAnchor(node, index); })
            .style("font-style", function (node) { return (node.type === "story") ? "normal" : "italic"; });
        if (drawScaleEndLabels) {
            var nodeLabelsScaleEnds = chartBody.selectAll(".narrafirma-correlation-map-node-scale-ends-label")
                .data(nodes)
                .enter().append("text")
                .text(function (node) { return (node.count > graphHolder.minimumStoryCountRequiredForGraph) ? node.scaleEnds : ""; })
                .attr("class", "narrafirma-correlation-map-node-scale-ends-label")
                .attr("x", function (node, index) { return nodeCenterX(node, index); })
                .attr("y", function (node, index) { return nodeTextY(node, index); })
                .attr("dx", 0)
                .attr("dy", function (node, index) { return nodeTextDY(node, index, 1); })
                .attr("text-anchor", function (node, index) { return nodeTextAnchor(node, index); })
                .style("font-style", function (node) { return (node.type === "story") ? "normal" : "italic"; });
        }
        return chart;
    }
    exports.d3CorrelationMap = d3CorrelationMap;
    function addStatisticsPanelForCorrelationMap(chartPane, graphHolder, pairStatsInfo, chartTitle, chartSize, hide) {
        if (hide === void 0) { hide = false; }
        var statsPane = document.createElement("h6");
        var html = "";
        var text = "";
        if (hide)
            statsPane.style.cssText = "display:none";
        var keyToReportForR = customStatLabel("r", graphHolder) || "r";
        var keyToReportForP = customStatLabel("p", graphHolder) || "p";
        var keyToReportForN = customStatLabel("n", graphHolder) || "n";
        if (pairStatsInfo.length > 0) {
            html += '<table class="narrafirma-correlation-map-stats-table scrolling-small">';
            html += '<tr><th></th><th></th><th>' + keyToReportForR + "</th><th>" + keyToReportForP + "</th><th>" + keyToReportForN + "</th></tr>";
        }
        for (var pairIndex = 0; pairIndex < pairStatsInfo.length; pairIndex++) {
            var thisPairInfo = pairStatsInfo[pairIndex];
            html += "<tr>";
            html += "<td>" + thisPairInfo["one"] + "</td>";
            html += "<td>" + thisPairInfo["two"] + "</td>";
            html += "<td>" + thisPairInfo["r"].toFixed(2) + "</td>";
            html += "<td>";
            html += (thisPairInfo["p"] < 0.001) ? "< 0.001" : thisPairInfo["p"].toFixed(3);
            html += "</td>";
            html += "<td>" + thisPairInfo["n"] + "</td>";
            html += "</tr>";
            text += thisPairInfo["one"] + " x " + thisPairInfo["two"];
            text += ": " + keyToReportForR + " = " + thisPairInfo["r"].toFixed(2);
            text += " " + keyToReportForP + " = ";
            text += (thisPairInfo["p"] < 0.001) ? "< 0.001" : thisPairInfo["p"].toFixed(3);
            text += " " + keyToReportForN + " = " + thisPairInfo["n"];
            text += "\n";
        }
        html += "</table>";
        if (chartSize === "large") {
            statsPane.className = "narrafirma-statistics-panel";
        }
        else {
            statsPane.className = "narrafirma-statistics-panel-small narrafirma-statistics-panel";
        }
        statsPane.innerHTML = html;
        chartPane.appendChild(statsPane);
        return text;
    }
    function d3ScatterPlotForPopup(graphHolder, parentNode, xAxisQuestion, yAxisQuestion, choiceQuestion, option) {
        var allPlotItems = [];
        var stories = graphHolder.allStories;
        var unansweredText = customStatLabel("unanswered", graphHolder);
        var showNAs = showNAValues(graphHolder);
        var lumpingCommands = getLumpingCommands(graphHolder);
        for (var index in stories) {
            var story = stories[index];
            var xValue = calculateStatistics.getScaleValueForQuestionAndStory(xAxisQuestion, story, unansweredText);
            var yValue = calculateStatistics.getScaleValueForQuestionAndStory(yAxisQuestion, story, unansweredText);
            if (xValue === unansweredText || yValue === unansweredText)
                continue;
            if (choiceQuestion) {
                var choiceValue = calculateStatistics.getChoiceValueForQuestionAndStory(choiceQuestion, story, unansweredText, showNAs, lumpingCommands);
                if (!calculateStatistics.choiceValueMatchesQuestionOption(choiceValue, choiceQuestion, option))
                    continue;
            }
            var newPlotItem = plotItemForScatterPlot(xAxisQuestion, yAxisQuestion, xValue, yValue, story, unansweredText);
            allPlotItems.push(newPlotItem);
        }
        var chartPane = document.createElement("div");
        parentNode.appendChild(chartPane);
        var margin = { top: 0, right: 0, bottom: 0, left: 0 };
        var chart = makeChartFramework(chartPane, "scatterPlot", "thumbnail", margin, null, null);
        var chartBody = chart.chartBody;
        var xScale = d3.scale.linear()
            .domain([0, 100])
            .range([0, chart.width]);
        var yScale = d3.scale.linear()
            .domain([0, 100])
            .range([chart.height, 0]);
        var opacity = 1.0 / graphHolder.numScatterDotOpacityLevels;
        var dotSize = 2;
        var storyDisplayItems = chartBody.selectAll(".story")
            .data(allPlotItems)
            .enter().append("circle")
            .attr("class", "narrafirma-correlation-map-thumbnail-scatterPlot-story")
            .attr("r", dotSize)
            .style("opacity", opacity)
            .attr("cx", function (plotItem) { return xScale(plotItem.x); })
            .attr("cy", function (plotItem) { return yScale(plotItem.y); });
        return chartPane;
    }
    exports.d3ScatterPlotForPopup = d3ScatterPlotForPopup;
    function d3HistogramChartForPopup(graphHolder, parentNode, scaleQuestion, choiceQuestion, option) {
        var unansweredText = customStatLabel("unanswered", graphHolder);
        var showNAs = showNAValues(graphHolder);
        var lumpingCommands = getLumpingCommands(graphHolder);
        var plotItems = [];
        var stories = graphHolder.allStories;
        for (var storyIndex in stories) {
            var story = stories[storyIndex];
            var scaleValue = calculateStatistics.getScaleValueForQuestionAndStory(scaleQuestion, story, unansweredText);
            if (choiceQuestion) {
                var choiceValue = calculateStatistics.getChoiceValueForQuestionAndStory(choiceQuestion, story, unansweredText, showNAs, lumpingCommands);
                if (!calculateStatistics.choiceValueMatchesQuestionOption(choiceValue, choiceQuestion, option))
                    continue;
            }
            var newPlotItem = { story: story, value: scaleValue };
            if (scaleValue !== unansweredText) {
                plotItems.push(newPlotItem);
            }
        }
        var chartPane = document.createElement("div");
        parentNode.appendChild(chartPane);
        var margin = { top: 0, right: 0, bottom: 0, left: 0 };
        var chart = makeChartFramework(chartPane, "histogram", "thumbnail", margin, null, null);
        var xScale = d3.scale.linear()
            .domain([0, 100])
            .range([0, chart.width]);
        // Generate a histogram using twenty uniformly-spaced bins.
        var data = d3.layout.histogram().bins(xScale.ticks(graphHolder.numHistogramBins)).value(function (d) { return d.value; })(plotItems);
        // Set the bin for each plotItem
        data.forEach(function (bin) {
            bin.forEach(function (plotItem) {
                plotItem.xBinStart = bin.x;
            });
        });
        var maxValue = d3.max(data, function (d) { return d.y; });
        var yScale = d3.scale.linear()
            .domain([0, maxValue])
            .range([chart.height, 0]);
        // Extra version of scale for calculating heights without subtracting as in height - yScale(value)
        var yHeightScale = d3.scale.linear()
            .domain([0, maxValue])
            .range([0, chart.height]);
        var bars = chart.chartBody.selectAll(".narrafirma-correlation-map-thumbnail-histogram-bar")
            .data(data).enter().append("g")
            .attr("class", "narrafirma-correlation-map-thumbnail-histogram-bar")
            .attr("transform", function (item) { return "translate(" + xScale(item.x) + "," + yScale(0) + ")"; });
        var storyDisplayItems = bars.selectAll(".narrafirma-correlation-map-thumbnail-histogram-story")
            .data(function (plotItem) { return plotItem; })
            .enter().append("rect")
            .attr('class', function (d, i) { return "narrafirma-correlation-map-thumbnail-histogram-story " + ((i % 2 === 0) ? "even" : "odd"); })
            .attr("x", function (plotItem) { return 0; })
            .attr("y", function (plotItem, i) { return yHeightScale(-i - 1); })
            .attr("height", function (plotItem) { return yHeightScale(1); })
            .attr("width", xScale(data[0].dx) - 1);
        return chartPane;
    }
    exports.d3HistogramChartForPopup = d3HistogramChartForPopup;
});

/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
 
(function ( global ) {
 
	function RGBColor(color_string)
	{
		this.ok = false;

		// strip any leading #
		if (color_string.charAt(0) == '#') { // remove # if any
			color_string = color_string.substr(1,6);
		}

		color_string = color_string.replace(/ /g,'');
		color_string = color_string.toLowerCase();

		// before getting into regexps, try simple matches
		// and overwrite the input
		var simple_colors = {
			aliceblue: 'f0f8ff',
			antiquewhite: 'faebd7',
			aqua: '00ffff',
			aquamarine: '7fffd4',
			azure: 'f0ffff',
			beige: 'f5f5dc',
			bisque: 'ffe4c4',
			black: '000000',
			blanchedalmond: 'ffebcd',
			blue: '0000ff',
			blueviolet: '8a2be2',
			brown: 'a52a2a',
			burlywood: 'deb887',
			cadetblue: '5f9ea0',
			chartreuse: '7fff00',
			chocolate: 'd2691e',
			coral: 'ff7f50',
			cornflowerblue: '6495ed',
			cornsilk: 'fff8dc',
			crimson: 'dc143c',
			cyan: '00ffff',
			darkblue: '00008b',
			darkcyan: '008b8b',
			darkgoldenrod: 'b8860b',
			darkgray: 'a9a9a9',
			darkgreen: '006400',
			darkkhaki: 'bdb76b',
			darkmagenta: '8b008b',
			darkolivegreen: '556b2f',
			darkorange: 'ff8c00',
			darkorchid: '9932cc',
			darkred: '8b0000',
			darksalmon: 'e9967a',
			darkseagreen: '8fbc8f',
			darkslateblue: '483d8b',
			darkslategray: '2f4f4f',
			darkturquoise: '00ced1',
			darkviolet: '9400d3',
			deeppink: 'ff1493',
			deepskyblue: '00bfff',
			dimgray: '696969',
			dodgerblue: '1e90ff',
			feldspar: 'd19275',
			firebrick: 'b22222',
			floralwhite: 'fffaf0',
			forestgreen: '228b22',
			fuchsia: 'ff00ff',
			gainsboro: 'dcdcdc',
			ghostwhite: 'f8f8ff',
			gold: 'ffd700',
			goldenrod: 'daa520',
			gray: '808080',
			green: '008000',
			greenyellow: 'adff2f',
			honeydew: 'f0fff0',
			hotpink: 'ff69b4',
			indianred : 'cd5c5c',
			indigo : '4b0082',
			ivory: 'fffff0',
			khaki: 'f0e68c',
			lavender: 'e6e6fa',
			lavenderblush: 'fff0f5',
			lawngreen: '7cfc00',
			lemonchiffon: 'fffacd',
			lightblue: 'add8e6',
			lightcoral: 'f08080',
			lightcyan: 'e0ffff',
			lightgoldenrodyellow: 'fafad2',
			lightgrey: 'd3d3d3',
			lightgreen: '90ee90',
			lightpink: 'ffb6c1',
			lightsalmon: 'ffa07a',
			lightseagreen: '20b2aa',
			lightskyblue: '87cefa',
			lightslateblue: '8470ff',
			lightslategray: '778899',
			lightsteelblue: 'b0c4de',
			lightyellow: 'ffffe0',
			lime: '00ff00',
			limegreen: '32cd32',
			linen: 'faf0e6',
			magenta: 'ff00ff',
			maroon: '800000',
			mediumaquamarine: '66cdaa',
			mediumblue: '0000cd',
			mediumorchid: 'ba55d3',
			mediumpurple: '9370d8',
			mediumseagreen: '3cb371',
			mediumslateblue: '7b68ee',
			mediumspringgreen: '00fa9a',
			mediumturquoise: '48d1cc',
			mediumvioletred: 'c71585',
			midnightblue: '191970',
			mintcream: 'f5fffa',
			mistyrose: 'ffe4e1',
			moccasin: 'ffe4b5',
			navajowhite: 'ffdead',
			navy: '000080',
			oldlace: 'fdf5e6',
			olive: '808000',
			olivedrab: '6b8e23',
			orange: 'ffa500',
			orangered: 'ff4500',
			orchid: 'da70d6',
			palegoldenrod: 'eee8aa',
			palegreen: '98fb98',
			paleturquoise: 'afeeee',
			palevioletred: 'd87093',
			papayawhip: 'ffefd5',
			peachpuff: 'ffdab9',
			peru: 'cd853f',
			pink: 'ffc0cb',
			plum: 'dda0dd',
			powderblue: 'b0e0e6',
			purple: '800080',
			red: 'ff0000',
			rosybrown: 'bc8f8f',
			royalblue: '4169e1',
			saddlebrown: '8b4513',
			salmon: 'fa8072',
			sandybrown: 'f4a460',
			seagreen: '2e8b57',
			seashell: 'fff5ee',
			sienna: 'a0522d',
			silver: 'c0c0c0',
			skyblue: '87ceeb',
			slateblue: '6a5acd',
			slategray: '708090',
			snow: 'fffafa',
			springgreen: '00ff7f',
			steelblue: '4682b4',
			tan: 'd2b48c',
			teal: '008080',
			thistle: 'd8bfd8',
			tomato: 'ff6347',
			turquoise: '40e0d0',
			violet: 'ee82ee',
			violetred: 'd02090',
			wheat: 'f5deb3',
			white: 'ffffff',
			whitesmoke: 'f5f5f5',
			yellow: 'ffff00',
			yellowgreen: '9acd32'
		};
		for (var key in simple_colors) {
			if (color_string == key) {
				color_string = simple_colors[key];
			}
		}
		// emd of simple type-in colors

		// array of color definition objects
		var color_defs = [
			{
				re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
				example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
				process: function (bits){
					return [
						parseInt(bits[1]),
						parseInt(bits[2]),
						parseInt(bits[3])
					];
				}
			},
			{
				re: /^(\w{2})(\w{2})(\w{2})$/,
				example: ['#00ff00', '336699'],
				process: function (bits){
					return [
						parseInt(bits[1], 16),
						parseInt(bits[2], 16),
						parseInt(bits[3], 16)
					];
				}
			},
			{
				re: /^(\w{1})(\w{1})(\w{1})$/,
				example: ['#fb0', 'f0f'],
				process: function (bits){
					return [
						parseInt(bits[1] + bits[1], 16),
						parseInt(bits[2] + bits[2], 16),
						parseInt(bits[3] + bits[3], 16)
					];
				}
			}
		];

		// search through the definitions to find a match
		for (var i = 0; i < color_defs.length; i++) {
			var re = color_defs[i].re;
			var processor = color_defs[i].process;
			var bits = re.exec(color_string);
			if (bits) {
				channels = processor(bits);
				this.r = channels[0];
				this.g = channels[1];
				this.b = channels[2];
				this.ok = true;
			}

		}

		// validate/cleanup values
		this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
		this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
		this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

		// some getters
		this.toRGB = function () {
			return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
		}
		this.toHex = function () {
			var r = this.r.toString(16);
			var g = this.g.toString(16);
			var b = this.b.toString(16);
			if (r.length == 1) r = '0' + r;
			if (g.length == 1) g = '0' + g;
			if (b.length == 1) b = '0' + b;
			return '#' + r + g + b;
		}

		// help
		this.getHelpXML = function () {

			var examples = new Array();
			// add regexps
			for (var i = 0; i < color_defs.length; i++) {
				var example = color_defs[i].example;
				for (var j = 0; j < example.length; j++) {
					examples[examples.length] = example[j];
				}
			}
			// add type-in colors
			for (var sc in simple_colors) {
				examples[examples.length] = sc;
			}

			var xml = document.createElement('ul');
			xml.setAttribute('id', 'rgbcolor-examples');
			for (var i = 0; i < examples.length; i++) {
				try {
					var list_item = document.createElement('li');
					var list_color = new RGBColor(examples[i]);
					var example_div = document.createElement('div');
					example_div.style.cssText =
							'margin: 3px; '
							+ 'border: 1px solid black; '
							+ 'background:' + list_color.toHex() + '; '
							+ 'color:' + list_color.toHex()
					;
					example_div.appendChild(document.createTextNode('test'));
					var list_item_value = document.createTextNode(
						' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
					);
					list_item.appendChild(example_div);
					list_item.appendChild(list_item_value);
					xml.appendChild(list_item);

				} catch(e){}
			}
			return xml;

		}

	}

    // export as AMD...
    if ( typeof define !== 'undefined' && define.amd ) {
        define( 'rgbcolor',[],function () { return RGBColor; });
    }

    // ...or as browserify
    else if ( typeof module !== 'undefined' && module.exports ) {
        module.exports = RGBColor;
    }

    global.RGBColor = RGBColor;

}( typeof window !== 'undefined' ? window : this ));
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version: 	0.5
Author:		Mario Klingemann
Contact: 	mario@quasimondo.com
Website:	http://www.quasimondo.com/StackBlurForCanvas
Twitter:	@quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

(function ( global ) {

	var mul_table = [
			512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
			454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
			482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
			437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
			497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
			320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
			446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
			329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
			505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
			399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
			324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
			268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
			451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
			385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
			332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
			289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];
			
	   
	var shg_table = [
			 9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
			17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
			19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
			20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
			21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
			21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
			22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
			22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
			23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
			23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
			23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
			23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

	function premultiplyAlpha(imageData)
	{
		var pixels = imageData.data;
		var size = imageData.width * imageData.height * 4;
		
		for (var i=0; i<size; i+=4)
		{
			var a = pixels[i+3] / 255;
			pixels[i  ] *= a;
			pixels[i+1] *= a;
			pixels[i+2] *= a;
		}
	}

	function unpremultiplyAlpha(imageData)
	{
		var pixels = imageData.data;
		var size = imageData.width * imageData.height * 4;
		
		for (var i=0; i<size; i+=4)
		{
			var a = pixels[i+3];
			if (a != 0)
			{
				a = 255 / a;
				pixels[i  ] *= a;
				pixels[i+1] *= a;
				pixels[i+2] *= a;
			}
		}
	}

	function stackBlurImage( imageID, canvasID, radius, blurAlphaChannel )
	{
				
		var img = document.getElementById( imageID );
		var w = img.naturalWidth;
		var h = img.naturalHeight;
		   
		var canvas = document.getElementById( canvasID );
		  
		canvas.style.width  = w + "px";
		canvas.style.height = h + "px";
		canvas.width = w;
		canvas.height = h;
		
		var context = canvas.getContext("2d");
		context.clearRect( 0, 0, w, h );
		context.drawImage( img, 0, 0 );

		if ( isNaN(radius) || radius < 1 ) return;
		
		if ( blurAlphaChannel )
			stackBlurCanvasRGBA( canvasID, 0, 0, w, h, radius );
		else 
			stackBlurCanvasRGB( canvasID, 0, 0, w, h, radius );
	}


	function stackBlurCanvasRGBA( id, top_x, top_y, width, height, radius )
	{
		if ( isNaN(radius) || radius < 1 ) return;
		radius |= 0;
		
		var canvas  = document.getElementById( id );
		var context = canvas.getContext("2d");
		var imageData;
		
		try {
		  try {
			imageData = context.getImageData( top_x, top_y, width, height );
		  } catch(e) {
		  
			// NOTE: this part is supposedly only needed if you want to work with local files
			// so it might be okay to remove the whole try/catch block and just use
			// imageData = context.getImageData( top_x, top_y, width, height );
			try {
				netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
				imageData = context.getImageData( top_x, top_y, width, height );
			} catch(e) {
				alert("Cannot access local image");
				throw new Error("unable to access local image data: " + e);
				return;
			}
		  }
		} catch(e) {
		  alert("Cannot access image");
		  throw new Error("unable to access image data: " + e);
		}
		
		premultiplyAlpha(imageData);
		
		var pixels = imageData.data;
				
		var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, 
		r_out_sum, g_out_sum, b_out_sum, a_out_sum,
		r_in_sum, g_in_sum, b_in_sum, a_in_sum, 
		pr, pg, pb, pa, rbs;
				
		var div = radius + radius + 1;
		var w4 = width << 2;
		var widthMinus1  = width - 1;
		var heightMinus1 = height - 1;
		var radiusPlus1  = radius + 1;
		var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
		
		var stackStart = new BlurStack();
		var stack = stackStart;
		for ( i = 1; i < div; i++ )
		{
			stack = stack.next = new BlurStack();
			if ( i == radiusPlus1 ) var stackEnd = stack;
		}
		stack.next = stackStart;
		var stackIn = null;
		var stackOut = null;
		
		yw = yi = 0;
		
		var mul_sum = mul_table[radius];
		var shg_sum = shg_table[radius];
		
		for ( y = 0; y < height; y++ )
		{
			r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
			
			r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
			g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
			b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
			a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );
			
			r_sum += sumFactor * pr;
			g_sum += sumFactor * pg;
			b_sum += sumFactor * pb;
			a_sum += sumFactor * pa;
			
			stack = stackStart;
			
			for( i = 0; i < radiusPlus1; i++ )
			{
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack.a = pa;
				stack = stack.next;
			}
			
			for( i = 1; i < radiusPlus1; i++ )
			{
				p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
				r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
				g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
				b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
				a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;
				
				r_in_sum += pr;
				g_in_sum += pg;
				b_in_sum += pb;
				a_in_sum += pa;
				
				stack = stack.next;
			}
			
			stackIn = stackStart;
			stackOut = stackEnd;
			for ( x = 0; x < width; x++ )
			{
				pixels[yi]   = (r_sum * mul_sum) >> shg_sum;
				pixels[yi+1] = (g_sum * mul_sum) >> shg_sum;
				pixels[yi+2] = (b_sum * mul_sum) >> shg_sum;
				pixels[yi+3] = (a_sum * mul_sum) >> shg_sum;
				
				r_sum -= r_out_sum;
				g_sum -= g_out_sum;
				b_sum -= b_out_sum;
				a_sum -= a_out_sum;
				
				r_out_sum -= stackIn.r;
				g_out_sum -= stackIn.g;
				b_out_sum -= stackIn.b;
				a_out_sum -= stackIn.a;
				
				p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
				
				r_in_sum += ( stackIn.r = pixels[p]);
				g_in_sum += ( stackIn.g = pixels[p+1]);
				b_in_sum += ( stackIn.b = pixels[p+2]);
				a_in_sum += ( stackIn.a = pixels[p+3]);
				
				r_sum += r_in_sum;
				g_sum += g_in_sum;
				b_sum += b_in_sum;
				a_sum += a_in_sum;
				
				stackIn = stackIn.next;
				
				r_out_sum += ( pr = stackOut.r );
				g_out_sum += ( pg = stackOut.g );
				b_out_sum += ( pb = stackOut.b );
				a_out_sum += ( pa = stackOut.a );
				
				r_in_sum -= pr;
				g_in_sum -= pg;
				b_in_sum -= pb;
				a_in_sum -= pa;
				
				stackOut = stackOut.next;

				yi += 4;
			}
			yw += width;
		}

		
		for ( x = 0; x < width; x++ )
		{
			g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
			
			yi = x << 2;
			r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
			g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
			b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
			a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);
			
			r_sum += sumFactor * pr;
			g_sum += sumFactor * pg;
			b_sum += sumFactor * pb;
			a_sum += sumFactor * pa;
			
			stack = stackStart;
			
			for( i = 0; i < radiusPlus1; i++ )
			{
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack.a = pa;
				stack = stack.next;
			}
			
			yp = width;
			
			for( i = 1; i <= radius; i++ )
			{
				yi = ( yp + x ) << 2;
				
				r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
				g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
				b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
				a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;
			   
				r_in_sum += pr;
				g_in_sum += pg;
				b_in_sum += pb;
				a_in_sum += pa;
				
				stack = stack.next;
			
				if( i < heightMinus1 )
				{
					yp += width;
				}
			}
			
			yi = x;
			stackIn = stackStart;
			stackOut = stackEnd;
			for ( y = 0; y < height; y++ )
			{
				p = yi << 2;
				pixels[p]   = (r_sum * mul_sum) >> shg_sum;
				pixels[p+1] = (g_sum * mul_sum) >> shg_sum;
				pixels[p+2] = (b_sum * mul_sum) >> shg_sum;
				pixels[p+3] = (a_sum * mul_sum) >> shg_sum;
				
				r_sum -= r_out_sum;
				g_sum -= g_out_sum;
				b_sum -= b_out_sum;
				a_sum -= a_out_sum;
			   
				r_out_sum -= stackIn.r;
				g_out_sum -= stackIn.g;
				b_out_sum -= stackIn.b;
				a_out_sum -= stackIn.a;
				
				p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
				
				r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
				g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
				b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
				a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));
			   
				stackIn = stackIn.next;
				
				r_out_sum += ( pr = stackOut.r );
				g_out_sum += ( pg = stackOut.g );
				b_out_sum += ( pb = stackOut.b );
				a_out_sum += ( pa = stackOut.a );
				
				r_in_sum -= pr;
				g_in_sum -= pg;
				b_in_sum -= pb;
				a_in_sum -= pa;
				
				stackOut = stackOut.next;
				
				yi += width;
			}
		}
		
		unpremultiplyAlpha(imageData);
		
		context.putImageData( imageData, top_x, top_y );
	}


	function stackBlurCanvasRGB( id, top_x, top_y, width, height, radius )
	{
		if ( isNaN(radius) || radius < 1 ) return;
		radius |= 0;
		
		var canvas  = document.getElementById( id );
		var context = canvas.getContext("2d");
		var imageData;
		
		try {
		  try {
			imageData = context.getImageData( top_x, top_y, width, height );
		  } catch(e) {
		  
			// NOTE: this part is supposedly only needed if you want to work with local files
			// so it might be okay to remove the whole try/catch block and just use
			// imageData = context.getImageData( top_x, top_y, width, height );
			try {
				netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
				imageData = context.getImageData( top_x, top_y, width, height );
			} catch(e) {
				alert("Cannot access local image");
				throw new Error("unable to access local image data: " + e);
				return;
			}
		  }
		} catch(e) {
		  alert("Cannot access image");
		  throw new Error("unable to access image data: " + e);
		}
				
		var pixels = imageData.data;
				
		var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum,
		r_out_sum, g_out_sum, b_out_sum,
		r_in_sum, g_in_sum, b_in_sum,
		pr, pg, pb, rbs;
				
		var div = radius + radius + 1;
		var w4 = width << 2;
		var widthMinus1  = width - 1;
		var heightMinus1 = height - 1;
		var radiusPlus1  = radius + 1;
		var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
		
		var stackStart = new BlurStack();
		var stack = stackStart;
		for ( i = 1; i < div; i++ )
		{
			stack = stack.next = new BlurStack();
			if ( i == radiusPlus1 ) var stackEnd = stack;
		}
		stack.next = stackStart;
		var stackIn = null;
		var stackOut = null;
		
		yw = yi = 0;
		
		var mul_sum = mul_table[radius];
		var shg_sum = shg_table[radius];
		
		for ( y = 0; y < height; y++ )
		{
			r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;
			
			r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
			g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
			b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
			
			r_sum += sumFactor * pr;
			g_sum += sumFactor * pg;
			b_sum += sumFactor * pb;
			
			stack = stackStart;
			
			for( i = 0; i < radiusPlus1; i++ )
			{
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack = stack.next;
			}
			
			for( i = 1; i < radiusPlus1; i++ )
			{
				p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
				r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
				g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
				b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
				
				r_in_sum += pr;
				g_in_sum += pg;
				b_in_sum += pb;
				
				stack = stack.next;
			}
			
			
			stackIn = stackStart;
			stackOut = stackEnd;
			for ( x = 0; x < width; x++ )
			{
				pixels[yi]   = (r_sum * mul_sum) >> shg_sum;
				pixels[yi+1] = (g_sum * mul_sum) >> shg_sum;
				pixels[yi+2] = (b_sum * mul_sum) >> shg_sum;
				
				r_sum -= r_out_sum;
				g_sum -= g_out_sum;
				b_sum -= b_out_sum;
				
				r_out_sum -= stackIn.r;
				g_out_sum -= stackIn.g;
				b_out_sum -= stackIn.b;
				
				p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
				
				r_in_sum += ( stackIn.r = pixels[p]);
				g_in_sum += ( stackIn.g = pixels[p+1]);
				b_in_sum += ( stackIn.b = pixels[p+2]);
				
				r_sum += r_in_sum;
				g_sum += g_in_sum;
				b_sum += b_in_sum;
				
				stackIn = stackIn.next;
				
				r_out_sum += ( pr = stackOut.r );
				g_out_sum += ( pg = stackOut.g );
				b_out_sum += ( pb = stackOut.b );
				
				r_in_sum -= pr;
				g_in_sum -= pg;
				b_in_sum -= pb;
				
				stackOut = stackOut.next;

				yi += 4;
			}
			yw += width;
		}

		
		for ( x = 0; x < width; x++ )
		{
			g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;
			
			yi = x << 2;
			r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
			g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
			b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
			
			r_sum += sumFactor * pr;
			g_sum += sumFactor * pg;
			b_sum += sumFactor * pb;
			
			stack = stackStart;
			
			for( i = 0; i < radiusPlus1; i++ )
			{
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack = stack.next;
			}
			
			yp = width;
			
			for( i = 1; i <= radius; i++ )
			{
				yi = ( yp + x ) << 2;
				
				r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
				g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
				b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
				
				r_in_sum += pr;
				g_in_sum += pg;
				b_in_sum += pb;
				
				stack = stack.next;
			
				if( i < heightMinus1 )
				{
					yp += width;
				}
			}
			
			yi = x;
			stackIn = stackStart;
			stackOut = stackEnd;
			for ( y = 0; y < height; y++ )
			{
				p = yi << 2;
				pixels[p]   = (r_sum * mul_sum) >> shg_sum;
				pixels[p+1] = (g_sum * mul_sum) >> shg_sum;
				pixels[p+2] = (b_sum * mul_sum) >> shg_sum;
				
				r_sum -= r_out_sum;
				g_sum -= g_out_sum;
				b_sum -= b_out_sum;
				
				r_out_sum -= stackIn.r;
				g_out_sum -= stackIn.g;
				b_out_sum -= stackIn.b;
				
				p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
				
				r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
				g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
				b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
				
				stackIn = stackIn.next;
				
				r_out_sum += ( pr = stackOut.r );
				g_out_sum += ( pg = stackOut.g );
				b_out_sum += ( pb = stackOut.b );
				
				r_in_sum -= pr;
				g_in_sum -= pg;
				b_in_sum -= pb;
				
				stackOut = stackOut.next;
				
				yi += width;
			}
		}
		
		context.putImageData( imageData, top_x, top_y );
		
	}

	function BlurStack()
	{
		this.r = 0;
		this.g = 0;
		this.b = 0;
		this.a = 0;
		this.next = null;
	}

	var stackBlur = {
		image: stackBlurImage,
		canvasRGBA: stackBlurCanvasRGBA,
		canvasRGB: stackBlurCanvasRGB
	};

	// export as AMD...
	if ( typeof define !== 'undefined' && define.amd ) {
	    define( 'stackblur',[],function () { return stackBlur; });
	}

	// ...or as browserify
	else if ( typeof module !== 'undefined' && module.exports ) {
	    module.exports = stackBlur;
	}

	global.stackBlur = stackBlur;

}( typeof window !== 'undefined' ? window : this ));
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
 (function ( global, factory ) {

	'use strict';

	// export as AMD...
	if ( typeof define !== 'undefined' && define.amd ) {
		define('canvgModule', [ 'rgbcolor', 'stackblur' ], factory );
	}

	// ...or as browserify
	else if ( typeof module !== 'undefined' && module.exports ) {
		module.exports = factory( require( 'rgbcolor' ), require( 'stackblur' ) );
	}

	global.canvg = factory( global.RGBColor, global.stackBlur );

}( typeof window !== 'undefined' ? window : this, function ( RGBColor, stackBlur ) {
 
	// canvg(target, s)
	// empty parameters: replace all 'svg' elements on page with 'canvas' elements
	// target: canvas element or the id of a canvas element
	// s: svg string, url to svg file, or xml document
	// opts: optional hash of options
	//		 ignoreMouse: true => ignore mouse events
	//		 ignoreAnimation: true => ignore animations
	//		 ignoreDimensions: true => does not try to resize canvas
	//		 ignoreClear: true => does not clear canvas
	//		 offsetX: int => draws at a x offset
	//		 offsetY: int => draws at a y offset
	//		 scaleWidth: int => scales horizontally to width
	//		 scaleHeight: int => scales vertically to height
	//		 renderCallback: function => will call the function after the first render is completed
	//		 forceRedraw: function => will call the function on every frame, if it returns true, will redraw
	var canvg = function (target, s, opts) {
		// no parameters
		if (target == null && s == null && opts == null) {
			var svgTags = document.querySelectorAll('svg');
			for (var i=0; i<svgTags.length; i++) {
				var svgTag = svgTags[i];
				var c = document.createElement('canvas');
				c.width = svgTag.clientWidth;
				c.height = svgTag.clientHeight;
				svgTag.parentNode.insertBefore(c, svgTag);
				svgTag.parentNode.removeChild(svgTag);
				var div = document.createElement('div');
				div.appendChild(svgTag);
				canvg(c, div.innerHTML);
			}
			return;
		}

		if (typeof target == 'string') {
			target = document.getElementById(target);
		}

		// store class on canvas
		if (target.svg != null) target.svg.stop();
		var svg = build(opts || {});
		// on i.e. 8 for flash canvas, we can't assign the property so check for it
		if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;

		var ctx = target.getContext('2d');
		if (typeof(s.documentElement) != 'undefined') {
			// load from xml doc
			svg.loadXmlDoc(ctx, s);
		}
		else if (s.substr(0,1) == '<') {
			// load from xml string
			svg.loadXml(ctx, s);
		}
		else {
			// load from url
			svg.load(ctx, s);
		}
	}

	// see https://developer.mozilla.org/en-US/docs/Web/API/Element.matches
	var matchesSelector;
	if (typeof(Element.prototype.matches) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.matches(selector);
		};
	} else if (typeof(Element.prototype.webkitMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.webkitMatchesSelector(selector);
		};
	} else if (typeof(Element.prototype.mozMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.mozMatchesSelector(selector);
		};
	} else if (typeof(Element.prototype.msMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.msMatchesSelector(selector);
		};
	} else if (typeof(Element.prototype.oMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.oMatchesSelector(selector);
		};
	} else {
		// requires Sizzle: https://github.com/jquery/sizzle/wiki/Sizzle-Documentation
		// or jQuery: http://jquery.com/download/
		// or Zepto: http://zeptojs.com/#
		// without it, this is a ReferenceError

		if (typeof jQuery === 'function' || typeof Zepto === 'function') {
			matchesSelector = function (node, selector) {
				return $(node).is(selector);
			};
		}

		if (typeof matchesSelector === 'undefined') {
			matchesSelector = Sizzle.matchesSelector;
		}
	}

	// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi;
	var pseudoClassWithBracketsRegex = /(:[\w-]+\([^\)]*\))/gi;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	function getSelectorSpecificity(selector) {
		var typeCount = [0, 0, 0];
		var findMatch = function(regex, type) {
			var matches = selector.match(regex);
			if (matches == null) {
				return;
			}
			typeCount[type] += matches.length;
			selector = selector.replace(regex, ' ');
		};

		selector = selector.replace(/:not\(([^\)]*)\)/g, '     $1 ');
		selector = selector.replace(/{[^]*/gm, ' ');
		findMatch(attributeRegex, 1);
		findMatch(idRegex, 0);
		findMatch(classRegex, 1);
		findMatch(pseudoElementRegex, 2);
		findMatch(pseudoClassWithBracketsRegex, 1);
		findMatch(pseudoClassRegex, 1);
		selector = selector.replace(/[\*\s\+>~]/g, ' ');
		selector = selector.replace(/[#\.]/g, ' ');
		findMatch(elementRegex, 2);
		return typeCount.join('');
	}

	function build(opts) {
		var svg = { opts: opts };

		svg.FRAMERATE = 30;
		svg.MAX_VIRTUAL_PIXELS = 30000;

		svg.log = function(msg) {};
		if (svg.opts['log'] == true && typeof(console) != 'undefined') {
			svg.log = function(msg) { console.log(msg); };
		};

		// globals
		svg.init = function(ctx) {
			var uniqueId = 0;
			svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;	};
			svg.Definitions = {};
			svg.Styles = {};
			svg.StylesSpecificity = {};
			svg.Animations = [];
			svg.Images = [];
			svg.ctx = ctx;
			svg.ViewPort = new (function () {
				this.viewPorts = [];
				this.Clear = function() { this.viewPorts = []; }
				this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
				this.RemoveCurrent = function() { this.viewPorts.pop(); }
				this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
				this.width = function() { return this.Current().width; }
				this.height = function() { return this.Current().height; }
				this.ComputeSize = function(d) {
					if (d != null && typeof(d) == 'number') return d;
					if (d == 'x') return this.width();
					if (d == 'y') return this.height();
					return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);
				}
			});
		}
		svg.init();

		// images loaded
		svg.ImagesLoaded = function() {
			for (var i=0; i<svg.Images.length; i++) {
				if (!svg.Images[i].loaded) return false;
			}
			return true;
		}

		// trim
		svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }

		// compress spaces
		svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }

		// ajax
		svg.ajax = function(url) {
			var AJAX;
			if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
			else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
			if(AJAX){
			   AJAX.open('GET',url,false);
			   AJAX.send(null);
			   return AJAX.responseText;
			}
			return null;
		}

		// parse xml
		svg.parseXml = function(xml) {
			if (typeof(Windows) != 'undefined' && typeof(Windows.Data) != 'undefined' && typeof(Windows.Data.Xml) != 'undefined') {
				var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
				var settings = new Windows.Data.Xml.Dom.XmlLoadSettings();
				settings.prohibitDtd = false;
				xmlDoc.loadXml(xml, settings);
				return xmlDoc;
			}
			else if (window.DOMParser)
			{
				var parser = new DOMParser();
				return parser.parseFromString(xml, 'text/xml');
			}
			else
			{
				xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
				var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
				xmlDoc.async = 'false';
				xmlDoc.loadXML(xml);
				return xmlDoc;
			}
		}

		svg.Property = function(name, value) {
			this.name = name;
			this.value = value;
		}
			svg.Property.prototype.getValue = function() {
				return this.value;
			}

			svg.Property.prototype.hasValue = function() {
				return (this.value != null && this.value !== '');
			}

			// return the numerical value of the property
			svg.Property.prototype.numValue = function() {
				if (!this.hasValue()) return 0;

				var n = parseFloat(this.value);
				if ((this.value + '').match(/%$/)) {
					n = n / 100.0;
				}
				return n;
			}

			svg.Property.prototype.valueOrDefault = function(def) {
				if (this.hasValue()) return this.value;
				return def;
			}

			svg.Property.prototype.numValueOrDefault = function(def) {
				if (this.hasValue()) return this.numValue();
				return def;
			}

			// color extensions
				// augment the current color value with the opacity
				svg.Property.prototype.addOpacity = function(opacityProp) {
					var newValue = this.value;
					if (opacityProp.value != null && opacityProp.value != '' && typeof(this.value)=='string') { // can only add opacity to colors, not patterns
						var color = new RGBColor(this.value);
						if (color.ok) {
							newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';
						}
					}
					return new svg.Property(this.name, newValue);
				}

			// definition extensions
				// get the definition from the definitions table
				svg.Property.prototype.getDefinition = function() {
					var name = this.value.match(/#([^\)'"]+)/);
					if (name) { name = name[1]; }
					if (!name) { name = this.value; }
					return svg.Definitions[name];
				}

				svg.Property.prototype.isUrlDefinition = function() {
					return this.value.indexOf('url(') == 0
				}

				svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
					var def = this.getDefinition();

					// gradient
					if (def != null && def.createGradient) {
						return def.createGradient(svg.ctx, e, opacityProp);
					}

					// pattern
					if (def != null && def.createPattern) {
						if (def.getHrefAttribute().hasValue()) {
							var pt = def.attribute('patternTransform');
							def = def.getHrefAttribute().getDefinition();
							if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
						}
						return def.createPattern(svg.ctx, e);
					}

					return null;
				}

			// length extensions
				svg.Property.prototype.getDPI = function(viewPort) {
					return 96.0; // TODO: compute?
				}

				svg.Property.prototype.getEM = function(viewPort) {
					var em = 12;

					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);

					return em;
				}

				svg.Property.prototype.getUnits = function() {
					var s = this.value+'';
					return s.replace(/[0-9\.\-]/g,'');
				}

				// get the length as pixels
				svg.Property.prototype.toPixels = function(viewPort, processPercent) {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
					if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
					if (s.match(/px$/)) return this.numValue();
					if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
					if (s.match(/pc$/)) return this.numValue() * 15;
					if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
					if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
					if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
					if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
					var n = this.numValue();
					if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
					return n;
				}

			// time extensions
				// get the time as milliseconds
				svg.Property.prototype.toMilliseconds = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/s$/)) return this.numValue() * 1000;
					if (s.match(/ms$/)) return this.numValue();
					return this.numValue();
				}

			// angle extensions
				// get the angle as radians
				svg.Property.prototype.toRadians = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
					if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
					if (s.match(/rad$/)) return this.numValue();
					return this.numValue() * (Math.PI / 180.0);
				}

			// text extensions
				// get the text baseline
				var textBaselineMapping = {
					'baseline': 'alphabetic',
					'before-edge': 'top',
					'text-before-edge': 'top',
					'middle': 'middle',
					'central': 'middle',
					'after-edge': 'bottom',
					'text-after-edge': 'bottom',
					'ideographic': 'ideographic',
					'alphabetic': 'alphabetic',
					'hanging': 'hanging',
					'mathematical': 'alphabetic'
				};
				svg.Property.prototype.toTextBaseline = function () {
					if (!this.hasValue()) return null;
					return textBaselineMapping[this.value];
				}

		// fonts
		svg.Font = new (function() {
			this.Styles = 'normal|italic|oblique|inherit';
			this.Variants = 'normal|small-caps|inherit';
			this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

			this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
				var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
				return {
					fontFamily: fontFamily || f.fontFamily,
					fontSize: fontSize || f.fontSize,
					fontStyle: fontStyle || f.fontStyle,
					fontWeight: fontWeight || f.fontWeight,
					fontVariant: fontVariant || f.fontVariant,
					toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') }
				}
			}

			var that = this;
			this.Parse = function(s) {
				var f = {};
				var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
				var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
				var ff = '';
				for (var i=0; i<d.length; i++) {
					if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
					else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;	}
					else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {	if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
					else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
					else { if (d[i] != 'inherit') ff += d[i]; }
				} if (ff != '') f.fontFamily = ff;
				return f;
			}
		});

		// points and paths
		svg.ToNumberArray = function(s) {
			var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
			for (var i=0; i<a.length; i++) {
				a[i] = parseFloat(a[i]);
			}
			return a;
		}
		svg.Point = function(x, y) {
			this.x = x;
			this.y = y;
		}
			svg.Point.prototype.angleTo = function(p) {
				return Math.atan2(p.y - this.y, p.x - this.x);
			}

			svg.Point.prototype.applyTransform = function(v) {
				var xp = this.x * v[0] + this.y * v[2] + v[4];
				var yp = this.x * v[1] + this.y * v[3] + v[5];
				this.x = xp;
				this.y = yp;
			}

		svg.CreatePoint = function(s) {
			var a = svg.ToNumberArray(s);
			return new svg.Point(a[0], a[1]);
		}
		svg.CreatePath = function(s) {
			var a = svg.ToNumberArray(s);
			var path = [];
			for (var i=0; i<a.length; i+=2) {
				path.push(new svg.Point(a[i], a[i+1]));
			}
			return path;
		}

		// bounding box
		svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
			this.x1 = Number.NaN;
			this.y1 = Number.NaN;
			this.x2 = Number.NaN;
			this.y2 = Number.NaN;

			this.x = function() { return this.x1; }
			this.y = function() { return this.y1; }
			this.width = function() { return this.x2 - this.x1; }
			this.height = function() { return this.y2 - this.y1; }

			this.addPoint = function(x, y) {
				if (x != null) {
					if (isNaN(this.x1) || isNaN(this.x2)) {
						this.x1 = x;
						this.x2 = x;
					}
					if (x < this.x1) this.x1 = x;
					if (x > this.x2) this.x2 = x;
				}

				if (y != null) {
					if (isNaN(this.y1) || isNaN(this.y2)) {
						this.y1 = y;
						this.y2 = y;
					}
					if (y < this.y1) this.y1 = y;
					if (y > this.y2) this.y2 = y;
				}
			}
			this.addX = function(x) { this.addPoint(x, null); }
			this.addY = function(y) { this.addPoint(null, y); }

			this.addBoundingBox = function(bb) {
				this.addPoint(bb.x1, bb.y1);
				this.addPoint(bb.x2, bb.y2);
			}

			this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
				var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
				var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
				this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y,	cp2y, p2x, p2y);
			}

			this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
				// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
				var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
				this.addPoint(p0[0], p0[1]);
				this.addPoint(p3[0], p3[1]);

				for (i=0; i<=1; i++) {
					var f = function(t) {
						return Math.pow(1-t, 3) * p0[i]
						+ 3 * Math.pow(1-t, 2) * t * p1[i]
						+ 3 * (1-t) * Math.pow(t, 2) * p2[i]
						+ Math.pow(t, 3) * p3[i];
					}

					var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
					var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
					var c = 3 * p1[i] - 3 * p0[i];

					if (a == 0) {
						if (b == 0) continue;
						var t = -c / b;
						if (0 < t && t < 1) {
							if (i == 0) this.addX(f(t));
							if (i == 1) this.addY(f(t));
						}
						continue;
					}

					var b2ac = Math.pow(b, 2) - 4 * c * a;
					if (b2ac < 0) continue;
					var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
					if (0 < t1 && t1 < 1) {
						if (i == 0) this.addX(f(t1));
						if (i == 1) this.addY(f(t1));
					}
					var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
					if (0 < t2 && t2 < 1) {
						if (i == 0) this.addX(f(t2));
						if (i == 1) this.addY(f(t2));
					}
				}
			}

			this.isPointInBox = function(x, y) {
				return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
			}

			this.addPoint(x1, y1);
			this.addPoint(x2, y2);
		}

		// transforms
		svg.Transform = function(v) {
			var that = this;
			this.Type = {}

			// translate
			this.Type.translate = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
				}
				this.unapply = function(ctx) {
					ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
				}
			}

			// rotate
			this.Type.rotate = function(s) {
				var a = svg.ToNumberArray(s);
				this.angle = new svg.Property('angle', a[0]);
				this.cx = a[1] || 0;
				this.cy = a[2] || 0;
				this.apply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.unapply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(-1.0 * this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.applyToPoint = function(p) {
					var a = this.angle.toRadians();
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
					p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
					p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
				}
			}

			this.Type.scale = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
				}
				this.unapply = function(ctx) {
					ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
				}
			}

			this.Type.matrix = function(s) {
				this.m = svg.ToNumberArray(s);
				this.apply = function(ctx) {
					ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
				}
				this.unapply = function(ctx) {
					var a = this.m[0];
					var b = this.m[2];
					var c = this.m[4];
					var d = this.m[1];
					var e = this.m[3];
					var f = this.m[5];
					var g = 0.0;
					var h = 0.0;
					var i = 1.0;
					var det = 1 / (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g));
					ctx.transform(
						det*(e*i-f*h),
						det*(f*g-d*i),
						det*(c*h-b*i),
						det*(a*i-c*g),
						det*(b*f-c*e),
						det*(c*d-a*f)
					);
				}
				this.applyToPoint = function(p) {
					p.applyTransform(this.m);
				}
			}

			this.Type.SkewBase = function(s) {
				this.base = that.Type.matrix;
				this.base(s);
				this.angle = new svg.Property('angle', s);
			}
			this.Type.SkewBase.prototype = new this.Type.matrix;

			this.Type.skewX = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
			}
			this.Type.skewX.prototype = new this.Type.SkewBase;

			this.Type.skewY = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
			}
			this.Type.skewY.prototype = new this.Type.SkewBase;

			this.transforms = [];

			this.apply = function(ctx) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].apply(ctx);
				}
			}

			this.unapply = function(ctx) {
				for (var i=this.transforms.length-1; i>=0; i--) {
					this.transforms[i].unapply(ctx);
				}
			}

			this.applyToPoint = function(p) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].applyToPoint(p);
				}
			}

			var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
			for (var i=0; i<data.length; i++) {
				var type = svg.trim(data[i].split('(')[0]);
				var s = data[i].split('(')[1].replace(')','');
				var transform = new this.Type[type](s);
				transform.type = type;
				this.transforms.push(transform);
			}
		}

		// aspect ratio
		svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
			// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
			aspectRatio = svg.compressSpaces(aspectRatio);
			aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
			var align = aspectRatio.split(' ')[0] || 'xMidYMid';
			var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';

			// calculate scale
			var scaleX = width / desiredWidth;
			var scaleY = height / desiredHeight;
			var scaleMin = Math.min(scaleX, scaleY);
			var scaleMax = Math.max(scaleX, scaleY);
			if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
			if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }

			refX = new svg.Property('refX', refX);
			refY = new svg.Property('refY', refY);
			if (refX.hasValue() && refY.hasValue()) {
				ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
			}
			else {
				// align
				if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);
				if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0);
				if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0);
				if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight);
			}

			// scale
			if (align == 'none') ctx.scale(scaleX, scaleY);
			else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin);
			else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);

			// translate
			ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);
		}

		// elements
		svg.Element = {}

		svg.EmptyProperty = new svg.Property('EMPTY', '');

		svg.Element.ElementBase = function(node) {
			this.attributes = {};
			this.styles = {};
			this.stylesSpecificity = {};
			this.children = [];

			// get or create attribute
			this.attribute = function(name, createIfNotExists) {
				var a = this.attributes[name];
				if (a != null) return a;

				if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
				return a || svg.EmptyProperty;
			}

			this.getHrefAttribute = function() {
				for (var a in this.attributes) {
					if (a == 'href' || a.match(/:href$/)) {
						return this.attributes[a];
					}
				}
				return svg.EmptyProperty;
			}

			// get or create style, crawls up node tree
			this.style = function(name, createIfNotExists, skipAncestors) {
				var s = this.styles[name];
				if (s != null) return s;

				var a = this.attribute(name);
				if (a != null && a.hasValue()) {
					this.styles[name] = a; // move up to me to cache
					return a;
				}

				if (skipAncestors != true) {
					var p = this.parent;
					if (p != null) {
						var ps = p.style(name);
						if (ps != null && ps.hasValue()) {
							return ps;
						}
					}
				}

				if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
				return s || svg.EmptyProperty;
			}

			// base render
			this.render = function(ctx) {
				// don't render display=none
				if (this.style('display').value == 'none') return;

				// don't render visibility=hidden
				if (this.style('visibility').value == 'hidden') return;

				ctx.save();
				if (this.style('mask').hasValue()) { // mask
					var mask = this.style('mask').getDefinition();
					if (mask != null) mask.apply(ctx, this);
				}
				else if (this.style('filter').hasValue()) { // filter
					var filter = this.style('filter').getDefinition();
					if (filter != null) filter.apply(ctx, this);
				}
				else {
					this.setContext(ctx);
					this.renderChildren(ctx);
					this.clearContext(ctx);
				}
				ctx.restore();
			}

			// base set context
			this.setContext = function(ctx) {
				// OVERRIDE ME!
			}

			// base clear context
			this.clearContext = function(ctx) {
				// OVERRIDE ME!
			}

			// base render children
			this.renderChildren = function(ctx) {
				for (var i=0; i<this.children.length; i++) {
					this.children[i].render(ctx);
				}
			}

			this.addChild = function(childNode, create) {
				var child = childNode;
				if (create) child = svg.CreateElement(childNode);
				child.parent = this;
				if (child.type != 'title') { this.children.push(child);	}
			}
			
			this.addStylesFromStyleDefinition = function () {
				// add styles
				for (var selector in svg.Styles) {
					if (selector[0] != '@' && matchesSelector(node, selector)) {
						var styles = svg.Styles[selector];
						var specificity = svg.StylesSpecificity[selector];
						if (styles != null) {
							for (var name in styles) {
								var existingSpecificity = this.stylesSpecificity[name];
								if (typeof(existingSpecificity) == 'undefined') {
									existingSpecificity = '000';
								}
								if (specificity > existingSpecificity) {
									this.styles[name] = styles[name];
									this.stylesSpecificity[name] = specificity;
								}
							}
						}
					}
				}
			};

			if (node != null && node.nodeType == 1) { //ELEMENT_NODE
				// add attributes
				for (var i=0; i<node.attributes.length; i++) {
					var attribute = node.attributes[i];
					this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.value);
				}
				
				this.addStylesFromStyleDefinition();

				// add inline styles
				if (this.attribute('style').hasValue()) {
					var styles = this.attribute('style').value.split(';');
					for (var i=0; i<styles.length; i++) {
						if (svg.trim(styles[i]) != '') {
							var style = styles[i].split(':');
							var name = svg.trim(style[0]);
							var value = svg.trim(style[1]);
							this.styles[name] = new svg.Property(name, value);
						}
					}
				}

				// add id
				if (this.attribute('id').hasValue()) {
					if (svg.Definitions[this.attribute('id').value] == null) {
						svg.Definitions[this.attribute('id').value] = this;
					}
				}

				// add children
				for (var i=0; i<node.childNodes.length; i++) {
					var childNode = node.childNodes[i];
					if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
					if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
						var text = childNode.value || childNode.text || childNode.textContent || '';
						if (svg.compressSpaces(text) != '') {
							this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
						}
					}
				}
			}
		}

		svg.Element.RenderedElementBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.setContext = function(ctx) {
				// fill
				if (this.style('fill').isUrlDefinition()) {
					var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
					if (fs != null) ctx.fillStyle = fs;
				}
				else if (this.style('fill').hasValue()) {
					var fillStyle = this.style('fill');
					if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
					if (fillStyle.value != 'inherit') ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
				}
				if (this.style('fill-opacity').hasValue()) {
					var fillStyle = new svg.Property('fill', ctx.fillStyle);
					fillStyle = fillStyle.addOpacity(this.style('fill-opacity'));
					ctx.fillStyle = fillStyle.value;
				}

				// stroke
				if (this.style('stroke').isUrlDefinition()) {
					var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
					if (fs != null) ctx.strokeStyle = fs;
				}
				else if (this.style('stroke').hasValue()) {
					var strokeStyle = this.style('stroke');
					if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
					if (strokeStyle.value != 'inherit') ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
				}
				if (this.style('stroke-opacity').hasValue()) {
					var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
					strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));
					ctx.strokeStyle = strokeStyle.value;
				}
				if (this.style('stroke-width').hasValue()) {
					var newLineWidth = this.style('stroke-width').toPixels();
					ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
			    }
				if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
				if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
				if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
				if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
					var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
					if (typeof(ctx.setLineDash) != 'undefined') { ctx.setLineDash(gaps); }
					else if (typeof(ctx.webkitLineDash) != 'undefined') { ctx.webkitLineDash = gaps; }
					else if (typeof(ctx.mozDash) != 'undefined' && !(gaps.length==1 && gaps[0]==0)) { ctx.mozDash = gaps; }

					var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
					if (typeof(ctx.lineDashOffset) != 'undefined') { ctx.lineDashOffset = offset; }
					else if (typeof(ctx.webkitLineDashOffset) != 'undefined') { ctx.webkitLineDashOffset = offset; }
					else if (typeof(ctx.mozDashOffset) != 'undefined') { ctx.mozDashOffset = offset; }
				}

				// font
				if (typeof(ctx.font) != 'undefined') {
					ctx.font = svg.Font.CreateFont(
						this.style('font-style').value,
						this.style('font-variant').value,
						this.style('font-weight').value,
						this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '',
						this.style('font-family').value).toString();
				}

				// transform
				if (this.style('transform', false, true).hasValue()) {
					var transform = new svg.Transform(this.style('transform', false, true).value);
					transform.apply(ctx);
				}

				// clip
				if (this.style('clip-path', false, true).hasValue()) {
					var clip = this.style('clip-path', false, true).getDefinition();
					if (clip != null) clip.apply(ctx);
				}

				// opacity
				if (this.style('opacity').hasValue()) {
					ctx.globalAlpha = this.style('opacity').numValue();
				}
			}
		}
		svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;

		svg.Element.PathElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.path = function(ctx) {
				if (ctx != null) ctx.beginPath();
				return new svg.BoundingBox();
			}

			this.renderChildren = function(ctx) {
				this.path(ctx);
				svg.Mouse.checkPath(this, ctx);
				if (ctx.fillStyle != '') {
					if (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.style('fill-rule').value); }
					else { ctx.fill(); }
				}
				if (ctx.strokeStyle != '') ctx.stroke();

				var markers = this.getMarkers();
				if (markers != null) {
					if (this.style('marker-start').isUrlDefinition()) {
						var marker = this.style('marker-start').getDefinition();
						marker.render(ctx, markers[0][0], markers[0][1]);
					}
					if (this.style('marker-mid').isUrlDefinition()) {
						var marker = this.style('marker-mid').getDefinition();
						for (var i=1;i<markers.length-1;i++) {
							marker.render(ctx, markers[i][0], markers[i][1]);
						}
					}
					if (this.style('marker-end').isUrlDefinition()) {
						var marker = this.style('marker-end').getDefinition();
						marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
					}
				}
			}

			this.getBoundingBox = function() {
				return this.path();
			}

			this.getMarkers = function() {
				return null;
			}
		}
		svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;

		// svg element
		svg.Element.svg = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseClearContext = this.clearContext;
			this.clearContext = function(ctx) {
				this.baseClearContext(ctx);
				svg.ViewPort.RemoveCurrent();
			}

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				// initial values and defaults
				ctx.strokeStyle = 'rgba(0,0,0,0)';
				ctx.lineCap = 'butt';
				ctx.lineJoin = 'miter';
				ctx.miterLimit = 4;
				if (typeof(ctx.font) != 'undefined' && typeof(window.getComputedStyle) != 'undefined') {
					ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
				}

				this.baseSetContext(ctx);

				// create new view port
				if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
				if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
				ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));

				var width = svg.ViewPort.width();
				var height = svg.ViewPort.height();

				if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
				if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
				if (typeof(this.root) == 'undefined') {
					width = this.attribute('width').toPixels('x');
					height = this.attribute('height').toPixels('y');

					var x = 0;
					var y = 0;
					if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
						x = -this.attribute('refX').toPixels('x');
						y = -this.attribute('refY').toPixels('y');
					}

					if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
						ctx.beginPath();
						ctx.moveTo(x, y);
						ctx.lineTo(width, y);
						ctx.lineTo(width, height);
						ctx.lineTo(x, height);
						ctx.closePath();
						ctx.clip();
					}
				}
				svg.ViewPort.SetCurrent(width, height);

				// viewbox
				if (this.attribute('viewBox').hasValue()) {
					var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
					var minX = viewBox[0];
					var minY = viewBox[1];
					width = viewBox[2];
					height = viewBox[3];

					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									svg.ViewPort.width(),
									width,
									svg.ViewPort.height(),
									height,
									minX,
									minY,
									this.attribute('refX').value,
									this.attribute('refY').value);

					svg.ViewPort.RemoveCurrent();
					svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
				}
			}
		}
		svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

		// rect element
		svg.Element.rect = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
				if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
				rx = Math.min(rx, width / 2.0);
				ry = Math.min(ry, height / 2.0);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(x + rx, y);
					ctx.lineTo(x + width - rx, y);
					ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
					ctx.lineTo(x + width, y + height - ry);
					ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
					ctx.lineTo(x + rx, y + height);
					ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
					ctx.lineTo(x, y + ry);
					ctx.quadraticCurveTo(x, y, x + rx, y)
					ctx.closePath();
				}

				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.rect.prototype = new svg.Element.PathElementBase;

		// circle element
		svg.Element.circle = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');
				var r = this.attribute('r').toPixels();

				if (ctx != null) {
					ctx.beginPath();
					ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
					ctx.closePath();
				}

				return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
			}
		}
		svg.Element.circle.prototype = new svg.Element.PathElementBase;

		// ellipse element
		svg.Element.ellipse = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');

				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(cx, cy - ry);
					ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
					ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
					ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
					ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
					ctx.closePath();
				}

				return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
			}
		}
		svg.Element.ellipse.prototype = new svg.Element.PathElementBase;

		// line element
		svg.Element.line = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.getPoints = function() {
				return [
					new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
					new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
			}

			this.path = function(ctx) {
				var points = this.getPoints();

				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(points[0].x, points[0].y);
					ctx.lineTo(points[1].x, points[1].y);
				}

				return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
			}

			this.getMarkers = function() {
				var points = this.getPoints();
				var a = points[0].angleTo(points[1]);
				return [[points[0], a], [points[1], a]];
			}
		}
		svg.Element.line.prototype = new svg.Element.PathElementBase;

		// polyline element
		svg.Element.polyline = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.points = svg.CreatePath(this.attribute('points').value);
			this.path = function(ctx) {
				var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(this.points[0].x, this.points[0].y);
				}
				for (var i=1; i<this.points.length; i++) {
					bb.addPoint(this.points[i].x, this.points[i].y);
					if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
				}
				return bb;
			}

			this.getMarkers = function() {
				var markers = [];
				for (var i=0; i<this.points.length - 1; i++) {
					markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
				}
				markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
				return markers;
			}
		}
		svg.Element.polyline.prototype = new svg.Element.PathElementBase;

		// polygon element
		svg.Element.polygon = function(node) {
			this.base = svg.Element.polyline;
			this.base(node);

			this.basePath = this.path;
			this.path = function(ctx) {
				var bb = this.basePath(ctx);
				if (ctx != null) {
					ctx.lineTo(this.points[0].x, this.points[0].y);
					ctx.closePath();
				}
				return bb;
			}
		}
		svg.Element.polygon.prototype = new svg.Element.polyline;

		// path element
		svg.Element.path = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			var d = this.attribute('d').value;
			// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
			d = d.replace(/,/gm,' '); // get rid of all commas
			// As the end of a match can also be the start of the next match, we need to run this replace twice.
			for(var i=0; i<2; i++)
				d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // suffix commands with spaces
			d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // prefix commands with spaces
			d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits on +- signs
			// Again, we need to run this twice to find all occurances
			for(var i=0; i<2; i++)
				d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when they start with a comma
			d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
			d = svg.compressSpaces(d); // compress multiple spaces
			d = svg.trim(d);
			this.PathParser = new (function(d) {
				this.tokens = d.split(' ');

				this.reset = function() {
					this.i = -1;
					this.command = '';
					this.previousCommand = '';
					this.start = new svg.Point(0, 0);
					this.control = new svg.Point(0, 0);
					this.current = new svg.Point(0, 0);
					this.points = [];
					this.angles = [];
				}

				this.isEnd = function() {
					return this.i >= this.tokens.length - 1;
				}

				this.isCommandOrEnd = function() {
					if (this.isEnd()) return true;
					return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
				}

				this.isRelativeCommand = function() {
					switch(this.command)
					{
						case 'm':
						case 'l':
						case 'h':
						case 'v':
						case 'c':
						case 's':
						case 'q':
						case 't':
						case 'a':
						case 'z':
							return true;
							break;
					}
					return false;
				}

				this.getToken = function() {
					this.i++;
					return this.tokens[this.i];
				}

				this.getScalar = function() {
					return parseFloat(this.getToken());
				}

				this.nextCommand = function() {
					this.previousCommand = this.command;
					this.command = this.getToken();
				}

				this.getPoint = function() {
					var p = new svg.Point(this.getScalar(), this.getScalar());
					return this.makeAbsolute(p);
				}

				this.getAsControlPoint = function() {
					var p = this.getPoint();
					this.control = p;
					return p;
				}

				this.getAsCurrentPoint = function() {
					var p = this.getPoint();
					this.current = p;
					return p;
				}

				this.getReflectedControlPoint = function() {
					if (this.previousCommand.toLowerCase() != 'c' &&
					    this.previousCommand.toLowerCase() != 's' &&
						this.previousCommand.toLowerCase() != 'q' &&
						this.previousCommand.toLowerCase() != 't' ){
						return this.current;
					}

					// reflect point
					var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
					return p;
				}

				this.makeAbsolute = function(p) {
					if (this.isRelativeCommand()) {
						p.x += this.current.x;
						p.y += this.current.y;
					}
					return p;
				}

				this.addMarker = function(p, from, priorTo) {
					// if the last angle isn't filled in because we didn't have this point yet ...
					if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
						this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
					}
					this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
				}

				this.addMarkerAngle = function(p, a) {
					this.points.push(p);
					this.angles.push(a);
				}

				this.getMarkerPoints = function() { return this.points; }
				this.getMarkerAngles = function() {
					for (var i=0; i<this.angles.length; i++) {
						if (this.angles[i] == null) {
							for (var j=i+1; j<this.angles.length; j++) {
								if (this.angles[j] != null) {
									this.angles[i] = this.angles[j];
									break;
								}
							}
						}
					}
					return this.angles;
				}
			})(d);

			this.path = function(ctx) {
				var pp = this.PathParser;
				pp.reset();

				var bb = new svg.BoundingBox();
				if (ctx != null) ctx.beginPath();
				while (!pp.isEnd()) {
					pp.nextCommand();
					switch (pp.command) {
					case 'M':
					case 'm':
						var p = pp.getAsCurrentPoint();
						pp.addMarker(p);
						bb.addPoint(p.x, p.y);
						if (ctx != null) ctx.moveTo(p.x, p.y);
						pp.start = pp.current;
						while (!pp.isCommandOrEnd()) {
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, pp.start);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'L':
					case 'l':
						while (!pp.isCommandOrEnd()) {
							var c = pp.current;
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, c);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'H':
					case 'h':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'V':
					case 'v':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'C':
					case 'c':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'S':
					case 's':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getReflectedControlPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'Q':
					case 'q':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'T':
					case 't':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getReflectedControlPoint();
							pp.control = cntrl;
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'A':
					case 'a':
						while (!pp.isCommandOrEnd()) {
						    var curr = pp.current;
							var rx = pp.getScalar();
							var ry = pp.getScalar();
							var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
							var largeArcFlag = pp.getScalar();
							var sweepFlag = pp.getScalar();
							var cp = pp.getAsCurrentPoint();

							// Conversion from endpoint to center parameterization
							// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
							// x1', y1'
							var currp = new svg.Point(
								Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
								-Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
							);
							// adjust radii
							var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
							if (l > 1) {
								rx *= Math.sqrt(l);
								ry *= Math.sqrt(l);
							}
							// cx', cy'
							var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
								((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
								(Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
							);
							if (isNaN(s)) s = 0;
							var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
							// cx, cy
							var centp = new svg.Point(
								(curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
								(curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
							);
							// vector magnitude
							var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
							// ratio between two vectors
							var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
							// angle between two vectors
							var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
							// initial angle
							var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
							// angle delta
							var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
							var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
							var ad = a(u, v);
							if (r(u,v) <= -1) ad = Math.PI;
							if (r(u,v) >= 1) ad = 0;

							// for markers
							var dir = 1 - sweepFlag ? 1.0 : -1.0;
							var ah = a1 + dir * (ad / 2.0);
							var halfWay = new svg.Point(
								centp.x + rx * Math.cos(ah),
								centp.y + ry * Math.sin(ah)
							);
							pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
							pp.addMarkerAngle(cp, ah - dir * Math.PI);

							bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
							if (ctx != null) {
								var r = rx > ry ? rx : ry;
								var sx = rx > ry ? 1 : rx / ry;
								var sy = rx > ry ? ry / rx : 1;

								ctx.translate(centp.x, centp.y);
								ctx.rotate(xAxisRotation);
								ctx.scale(sx, sy);
								ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
								ctx.scale(1/sx, 1/sy);
								ctx.rotate(-xAxisRotation);
								ctx.translate(-centp.x, -centp.y);
							}
						}
						break;
					case 'Z':
					case 'z':
						if (ctx != null) ctx.closePath();
						pp.current = pp.start;
					}
				}

				return bb;
			}

			this.getMarkers = function() {
				var points = this.PathParser.getMarkerPoints();
				var angles = this.PathParser.getMarkerAngles();

				var markers = [];
				for (var i=0; i<points.length; i++) {
					markers.push([points[i], angles[i]]);
				}
				return markers;
			}
		}
		svg.Element.path.prototype = new svg.Element.PathElementBase;

		// pattern element
		svg.Element.pattern = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.createPattern = function(ctx, element) {
				var width = this.attribute('width').toPixels('x', true);
				var height = this.attribute('height').toPixels('y', true);

				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
				tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
				tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
				tempSvg.children = this.children;

				var c = document.createElement('canvas');
				c.width = width;
				c.height = height;
				var cctx = c.getContext('2d');
				if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
					cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
				}
				// render 3x3 grid so when we transform there's no white space on edges
				for (var x=-1; x<=1; x++) {
					for (var y=-1; y<=1; y++) {
						cctx.save();
						tempSvg.attributes['x'] = new svg.Property('x', x * c.width);
						tempSvg.attributes['y'] = new svg.Property('y', y * c.height);
						tempSvg.render(cctx);
						cctx.restore();
					}
				}
				var pattern = ctx.createPattern(c, 'repeat');
				return pattern;
			}
		}
		svg.Element.pattern.prototype = new svg.Element.ElementBase;

		// marker element
		svg.Element.marker = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.baseRender = this.render;
			this.render = function(ctx, point, angle) {
				ctx.translate(point.x, point.y);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
				ctx.save();

				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
				tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
				tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
				tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
				tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
				tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
				tempSvg.children = this.children;
				tempSvg.render(ctx);

				ctx.restore();
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
				ctx.translate(-point.x, -point.y);
			}
		}
		svg.Element.marker.prototype = new svg.Element.ElementBase;

		// definitions element
		svg.Element.defs = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.render = function(ctx) {
				// NOOP
			}
		}
		svg.Element.defs.prototype = new svg.Element.ElementBase;

		// base for gradients
		svg.Element.GradientBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.stops = [];
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'stop') this.stops.push(child);
			}

			this.getGradient = function() {
				// OVERRIDE ME!
			}
			
			this.gradientUnits = function () {
				return this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
			}
			
			this.attributesToInherit = ['gradientUnits'];
			
			this.inheritStopContainer = function (stopsContainer) {
				for (var i=0; i<this.attributesToInherit.length; i++) {
					var attributeToInherit = this.attributesToInherit[i];
					if (!this.attribute(attributeToInherit).hasValue() && stopsContainer.attribute(attributeToInherit).hasValue()) {
						this.attribute(attributeToInherit, true).value = stopsContainer.attribute(attributeToInherit).value;
					}
				}
			}

			this.createGradient = function(ctx, element, parentOpacityProp) {
				var stopsContainer = this;
				if (this.getHrefAttribute().hasValue()) {
					stopsContainer = this.getHrefAttribute().getDefinition();
					this.inheritStopContainer(stopsContainer);
				}

				var addParentOpacity = function (color) {
					if (parentOpacityProp.hasValue()) {
						var p = new svg.Property('color', color);
						return p.addOpacity(parentOpacityProp).value;
					}
					return color;
				};

				var g = this.getGradient(ctx, element);
				if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
				for (var i=0; i<stopsContainer.stops.length; i++) {
					g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
				}

				if (this.attribute('gradientTransform').hasValue()) {
					// render as transformed pattern on temporary canvas
					var rootView = svg.ViewPort.viewPorts[0];

					var rect = new svg.Element.rect();
					rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
					rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);

					var group = new svg.Element.g();
					group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
					group.children = [ rect ];

					var tempSvg = new svg.Element.svg();
					tempSvg.attributes['x'] = new svg.Property('x', 0);
					tempSvg.attributes['y'] = new svg.Property('y', 0);
					tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
					tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
					tempSvg.children = [ group ];

					var c = document.createElement('canvas');
					c.width = rootView.width;
					c.height = rootView.height;
					var tempCtx = c.getContext('2d');
					tempCtx.fillStyle = g;
					tempSvg.render(tempCtx);
					return tempCtx.createPattern(c, 'no-repeat');
				}

				return g;
			}
		}
		svg.Element.GradientBase.prototype = new svg.Element.ElementBase;

		// linear gradient element
		svg.Element.linearGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.attributesToInherit.push('x1');
			this.attributesToInherit.push('y1');
			this.attributesToInherit.push('x2');
			this.attributesToInherit.push('y2');

			this.getGradient = function(ctx, element) {
				var bb = this.gradientUnits() == 'objectBoundingBox' ? element.getBoundingBox() : null;

				if (!this.attribute('x1').hasValue()
				 && !this.attribute('y1').hasValue()
				 && !this.attribute('x2').hasValue()
				 && !this.attribute('y2').hasValue()) {
					this.attribute('x1', true).value = 0;
					this.attribute('y1', true).value = 0;
					this.attribute('x2', true).value = 1;
					this.attribute('y2', true).value = 0;
				 }

				var x1 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('x1').numValue()
					: this.attribute('x1').toPixels('x'));
				var y1 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('y1').numValue()
					: this.attribute('y1').toPixels('y'));
				var x2 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('x2').numValue()
					: this.attribute('x2').toPixels('x'));
				var y2 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('y2').numValue()
					: this.attribute('y2').toPixels('y'));

				if (x1 == x2 && y1 == y2) return null;
				return ctx.createLinearGradient(x1, y1, x2, y2);
			}
		}
		svg.Element.linearGradient.prototype = new svg.Element.GradientBase;

		// radial gradient element
		svg.Element.radialGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.attributesToInherit.push('cx');
			this.attributesToInherit.push('cy');
			this.attributesToInherit.push('r');
			this.attributesToInherit.push('fx');
			this.attributesToInherit.push('fy');

			this.getGradient = function(ctx, element) {
				var bb = element.getBoundingBox();

				if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
				if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
				if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';

				var cx = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('cx').numValue()
					: this.attribute('cx').toPixels('x'));
				var cy = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('cy').numValue()
					: this.attribute('cy').toPixels('y'));

				var fx = cx;
				var fy = cy;
				if (this.attribute('fx').hasValue()) {
					fx = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('fx').numValue()
					: this.attribute('fx').toPixels('x'));
				}
				if (this.attribute('fy').hasValue()) {
					fy = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('fy').numValue()
					: this.attribute('fy').toPixels('y'));
				}

				var r = (this.gradientUnits() == 'objectBoundingBox'
					? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
					: this.attribute('r').toPixels());

				return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
			}
		}
		svg.Element.radialGradient.prototype = new svg.Element.GradientBase;

		// gradient stop element
		svg.Element.stop = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.offset = this.attribute('offset').numValue();
			if (this.offset < 0) this.offset = 0;
			if (this.offset > 1) this.offset = 1;

			var stopColor = this.style('stop-color', true);
			if (stopColor.value === '') stopColor.value = '#000';
			if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));
			this.color = stopColor.value;
		}
		svg.Element.stop.prototype = new svg.Element.ElementBase;

		// animation base element
		svg.Element.AnimateBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			svg.Animations.push(this);

			this.duration = 0.0;
			this.begin = this.attribute('begin').toMilliseconds();
			this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();

			this.getProperty = function() {
				var attributeType = this.attribute('attributeType').value;
				var attributeName = this.attribute('attributeName').value;

				if (attributeType == 'CSS') {
					return this.parent.style(attributeName, true);
				}
				return this.parent.attribute(attributeName, true);
			};

			this.initialValue = null;
			this.initialUnits = '';
			this.removed = false;

			this.calcValue = function() {
				// OVERRIDE ME!
				return '';
			}

			this.update = function(delta) {
				// set initial value
				if (this.initialValue == null) {
					this.initialValue = this.getProperty().value;
					this.initialUnits = this.getProperty().getUnits();
				}

				// if we're past the end time
				if (this.duration > this.maxDuration) {
					// loop for indefinitely repeating animations
					if (this.attribute('repeatCount').value == 'indefinite'
					 || this.attribute('repeatDur').value == 'indefinite') {
						this.duration = 0.0
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {
						this.frozen = true;
						this.parent.animationFrozen = true;
						this.parent.animationFrozenValue = this.getProperty().value;
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
						this.removed = true;
						this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
						return true;
					}
					return false;
				}
				this.duration = this.duration + delta;

				// if we're past the begin time
				var updated = false;
				if (this.begin < this.duration) {
					var newValue = this.calcValue(); // tween

					if (this.attribute('type').hasValue()) {
						// for transform, etc.
						var type = this.attribute('type').value;
						newValue = type + '(' + newValue + ')';
					}

					this.getProperty().value = newValue;
					updated = true;
				}

				return updated;
			}

			this.from = this.attribute('from');
			this.to = this.attribute('to');
			this.values = this.attribute('values');
			if (this.values.hasValue()) this.values.value = this.values.value.split(';');

			// fraction of duration we've covered
			this.progress = function() {
				var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
				if (this.values.hasValue()) {
					var p = ret.progress * (this.values.value.length - 1);
					var lb = Math.floor(p), ub = Math.ceil(p);
					ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
					ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
					ret.progress = (p - lb) / (ub - lb);
				}
				else {
					ret.from = this.from;
					ret.to = this.to;
				}
				return ret;
			}
		}
		svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;

		// animate element
		svg.Element.animate = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();

				// tween value linearly
				var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;
				return newValue + this.initialUnits;
			};
		}
		svg.Element.animate.prototype = new svg.Element.AnimateBase;

		// animate color element
		svg.Element.animateColor = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();
				var from = new RGBColor(p.from.value);
				var to = new RGBColor(p.to.value);

				if (from.ok && to.ok) {
					// tween color linearly
					var r = from.r + (to.r - from.r) * p.progress;
					var g = from.g + (to.g - from.g) * p.progress;
					var b = from.b + (to.b - from.b) * p.progress;
					return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
				}
				return this.attribute('from').value;
			};
		}
		svg.Element.animateColor.prototype = new svg.Element.AnimateBase;

		// animate transform element
		svg.Element.animateTransform = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();

				// tween value linearly
				var from = svg.ToNumberArray(p.from.value);
				var to = svg.ToNumberArray(p.to.value);
				var newValue = '';
				for (var i=0; i<from.length; i++) {
					newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
				}
				return newValue;
			};
		}
		svg.Element.animateTransform.prototype = new svg.Element.animate;

		// font element
		svg.Element.font = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();

			this.isRTL = false;
			this.isArabic = false;
			this.fontFace = null;
			this.missingGlyph = null;
			this.glyphs = [];
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'font-face') {
					this.fontFace = child;
					if (child.style('font-family').hasValue()) {
						svg.Definitions[child.style('font-family').value] = this;
					}
				}
				else if (child.type == 'missing-glyph') this.missingGlyph = child;
				else if (child.type == 'glyph') {
					if (child.arabicForm != '') {
						this.isRTL = true;
						this.isArabic = true;
						if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
						this.glyphs[child.unicode][child.arabicForm] = child;
					}
					else {
						this.glyphs[child.unicode] = child;
					}
				}
			}
		}
		svg.Element.font.prototype = new svg.Element.ElementBase;

		// font-face element
		svg.Element.fontface = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.ascent = this.attribute('ascent').value;
			this.descent = this.attribute('descent').value;
			this.unitsPerEm = this.attribute('units-per-em').numValue();
		}
		svg.Element.fontface.prototype = new svg.Element.ElementBase;

		// missing-glyph element
		svg.Element.missingglyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);

			this.horizAdvX = 0;
		}
		svg.Element.missingglyph.prototype = new svg.Element.path;

		// glyph element
		svg.Element.glyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();
			this.unicode = this.attribute('unicode').value;
			this.arabicForm = this.attribute('arabic-form').value;
		}
		svg.Element.glyph.prototype = new svg.Element.path;

		// text element
		svg.Element.text = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);

				var textBaseline = this.style('dominant-baseline').toTextBaseline();
				if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
				if (textBaseline != null) ctx.textBaseline = textBaseline;
			}

			this.getBoundingBox = function () {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
				return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
			}

			this.renderChildren = function(ctx) {
				this.x = this.attribute('x').toPixels('x');
				this.y = this.attribute('y').toPixels('y');
				if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
				if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
				this.x += this.getAnchorDelta(ctx, this, 0);
				for (var i=0; i<this.children.length; i++) {
					this.renderChild(ctx, this, i);
				}
			}

			this.getAnchorDelta = function (ctx, parent, startI) {
				var textAnchor = this.style('text-anchor').valueOrDefault('start');
				if (textAnchor != 'start') {
					var width = 0;
					for (var i=startI; i<parent.children.length; i++) {
						var child = parent.children[i];
						if (i > startI && child.attribute('x').hasValue()) break; // new group
						width += child.measureTextRecursive(ctx);
					}
					return -1 * (textAnchor == 'end' ? width : width / 2.0);
				}
				return 0;
			}

			this.renderChild = function(ctx, parent, i) {
				var child = parent.children[i];
				if (child.attribute('x').hasValue()) {
					child.x = child.attribute('x').toPixels('x') + parent.getAnchorDelta(ctx, parent, i);
					if (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');
				}
				else {
					if (child.attribute('dx').hasValue()) parent.x += child.attribute('dx').toPixels('x');
					child.x = parent.x;
				}
				parent.x = child.x + child.measureText(ctx);

				if (child.attribute('y').hasValue()) {
					child.y = child.attribute('y').toPixels('y');
					if (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');
				}
				else {
					if (child.attribute('dy').hasValue()) parent.y += child.attribute('dy').toPixels('y');
					child.y = parent.y;
				}
				parent.y = child.y;

				child.render(ctx);

				for (var i=0; i<child.children.length; i++) {
					parent.renderChild(ctx, child, i);
				}
			}
		}
		svg.Element.text.prototype = new svg.Element.RenderedElementBase;

		// text base
		svg.Element.TextElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.getGlyph = function(font, text, i) {
				var c = text[i];
				var glyph = null;
				if (font.isArabic) {
					var arabicForm = 'isolated';
					if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal';
					if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
					if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
					if (typeof(font.glyphs[c]) != 'undefined') {
						glyph = font.glyphs[c][arabicForm];
						if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
					}
				}
				else {
					glyph = font.glyphs[c];
				}
				if (glyph == null) glyph = font.missingGlyph;
				return glyph;
			}

			this.renderChildren = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");

					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						var scale = fontSize / customFont.fontFace.unitsPerEm;
						ctx.translate(this.x, this.y);
						ctx.scale(scale, -scale);
						var lw = ctx.lineWidth;
						ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
						if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
						glyph.render(ctx);
						if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
						ctx.lineWidth = lw;
						ctx.scale(1/scale, -1/scale);
						ctx.translate(-this.x, -this.y);

						this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
						if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
							this.x += dx[i];
						}
					}
					return;
				}

				if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
				if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
			}

			this.getText = function() {
				// OVERRIDE ME
			}

			this.measureTextRecursive = function(ctx) {
				var width = this.measureText(ctx);
				for (var i=0; i<this.children.length; i++) {
					width += this.children[i].measureTextRecursive(ctx);
				}
				return width;
			}

			this.measureText = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var measure = 0;
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");
					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
						if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
							measure += dx[i];
						}
					}
					return measure;
				}

				var textToMeasure = svg.compressSpaces(this.getText());
				if (!ctx.measureText) return textToMeasure.length * 10;

				ctx.save();
				this.setContext(ctx);
				var width = ctx.measureText(textToMeasure).width;
				ctx.restore();
				return width;
			}
		}
		svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;

		// tspan
		svg.Element.tspan = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.text = svg.compressSpaces(node.value || node.text || node.textContent || '');
			this.getText = function() {
				// if this node has children, then they own the text
				if (this.children.length > 0) { return ''; }
				return this.text;
			}
		}
		svg.Element.tspan.prototype = new svg.Element.TextElementBase;

		// tref
		svg.Element.tref = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.getText = function() {
				var element = this.getHrefAttribute().getDefinition();
				if (element != null) return element.children[0].getText();
			}
		}
		svg.Element.tref.prototype = new svg.Element.TextElementBase;

		// a element
		svg.Element.a = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.hasText = node.childNodes.length > 0;
			for (var i=0; i<node.childNodes.length; i++) {
				if (node.childNodes[i].nodeType != 3) this.hasText = false;
			}

			// this might contain text
			this.text = this.hasText ? node.childNodes[0].value : '';
			this.getText = function() {
				return this.text;
			}

			this.baseRenderChildren = this.renderChildren;
			this.renderChildren = function(ctx) {
				if (this.hasText) {
					// render as text element
					this.baseRenderChildren(ctx);
					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));
				}
				else if (this.children.length > 0) {
					// render as temporary group
					var g = new svg.Element.g();
					g.children = this.children;
					g.parent = this;
					g.render(ctx);
				}
			}

			this.onclick = function() {
				window.open(this.getHrefAttribute().value);
			}

			this.onmousemove = function() {
				svg.ctx.canvas.style.cursor = 'pointer';
			}
		}
		svg.Element.a.prototype = new svg.Element.TextElementBase;

		// image element
		svg.Element.image = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			var href = this.getHrefAttribute().value;
			if (href == '') { return; }
			var isSvg = href.match(/\.svg$/)

			svg.Images.push(this);
			this.loaded = false;
			if (!isSvg) {
				this.img = document.createElement('img');
				if (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }
				var self = this;
				this.img.onload = function() { self.loaded = true; }
				this.img.onerror = function() { svg.log('ERROR: image "' + href + '" not found'); self.loaded = true; }
				this.img.src = href;
			}
			else {
				this.img = svg.ajax(href);
				this.loaded = true;
			}

			this.renderChildren = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');

				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				if (width == 0 || height == 0) return;

				ctx.save();
				if (isSvg) {
					ctx.drawSvg(this.img, x, y, width, height);
				}
				else {
					ctx.translate(x, y);
					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									width,
									this.img.width,
									height,
									this.img.height,
									0,
									0);
					ctx.drawImage(this.img, 0, 0);
				}
				ctx.restore();
			}

			this.getBoundingBox = function() {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.image.prototype = new svg.Element.RenderedElementBase;

		// group element
		svg.Element.g = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.getBoundingBox = function() {
				var bb = new svg.BoundingBox();
				for (var i=0; i<this.children.length; i++) {
					bb.addBoundingBox(this.children[i].getBoundingBox());
				}
				return bb;
			};
		}
		svg.Element.g.prototype = new svg.Element.RenderedElementBase;

		// symbol element
		svg.Element.symbol = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.render = function(ctx) {
				// NO RENDER
			};
		}
		svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;

		// style element
		svg.Element.style = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			// text, or spaces then CDATA
			var css = ''
			for (var i=0; i<node.childNodes.length; i++) {
			  css += node.childNodes[i].data;
			}
			css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
			css = svg.compressSpaces(css); // replace whitespace
			var cssDefs = css.split('}');
			for (var i=0; i<cssDefs.length; i++) {
				if (svg.trim(cssDefs[i]) != '') {
					var cssDef = cssDefs[i].split('{');
					var cssClasses = cssDef[0].split(',');
					var cssProps = cssDef[1].split(';');
					for (var j=0; j<cssClasses.length; j++) {
						var cssClass = svg.trim(cssClasses[j]);
						if (cssClass != '') {
							var props = svg.Styles[cssClass] || {};
							for (var k=0; k<cssProps.length; k++) {
								var prop = cssProps[k].indexOf(':');
								var name = cssProps[k].substr(0, prop);
								var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
								if (name != null && value != null) {
									props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
								}
							}
							svg.Styles[cssClass] = props;
							svg.StylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
							if (cssClass == '@font-face') {
								var fontFamily = props['font-family'].value.replace(/"/g,'');
								var srcs = props['src'].value.split(',');
								for (var s=0; s<srcs.length; s++) {
									if (srcs[s].indexOf('format("svg")') > 0) {
										var urlStart = srcs[s].indexOf('url');
										var urlEnd = srcs[s].indexOf(')', urlStart);
										var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
										var doc = svg.parseXml(svg.ajax(url));
										var fonts = doc.getElementsByTagName('font');
										for (var f=0; f<fonts.length; f++) {
											var font = svg.CreateElement(fonts[f]);
											svg.Definitions[fontFamily] = font;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		svg.Element.style.prototype = new svg.Element.ElementBase;

		// use element
		svg.Element.use = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);
				if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
				if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
			}

			var element = this.getHrefAttribute().getDefinition();

			this.path = function(ctx) {
				if (element != null) element.path(ctx);
			}

			this.getBoundingBox = function() {
				if (element != null) return element.getBoundingBox();
			}

			this.renderChildren = function(ctx) {
				if (element != null) {
					var tempSvg = element;
					if (element.type == 'symbol') {
						// render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
						tempSvg = new svg.Element.svg();
						tempSvg.type = 'svg';
						tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
						tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
						tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
						tempSvg.children = element.children;
					}
					if (tempSvg.type == 'svg') {
						// if symbol or svg, inherit width/height from me
						if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
						if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
					}
					var oldParent = tempSvg.parent;
					tempSvg.parent = null;
					tempSvg.render(ctx);
					tempSvg.parent = oldParent;
				}
			}
		}
		svg.Element.use.prototype = new svg.Element.RenderedElementBase;

		// mask element
		svg.Element.mask = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, element) {
				// render as temp svg
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');

				if (width == 0 && height == 0) {
					var bb = new svg.BoundingBox();
					for (var i=0; i<this.children.length; i++) {
						bb.addBoundingBox(this.children[i].getBoundingBox());
					}
					var x = Math.floor(bb.x1);
					var y = Math.floor(bb.y1);
					var width = Math.floor(bb.width());
					var	height = Math.floor(bb.height());
				}

				// temporarily remove mask to avoid recursion
				var mask = element.attribute('mask').value;
				element.attribute('mask').value = '';

					var cMask = document.createElement('canvas');
					cMask.width = x + width;
					cMask.height = y + height;
					var maskCtx = cMask.getContext('2d');
					this.renderChildren(maskCtx);

					var c = document.createElement('canvas');
					c.width = x + width;
					c.height = y + height;
					var tempCtx = c.getContext('2d');
					element.render(tempCtx);
					tempCtx.globalCompositeOperation = 'destination-in';
					tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
					tempCtx.fillRect(0, 0, x + width, y + height);

					ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
					ctx.fillRect(0, 0, x + width, y + height);

				// reassign mask
				element.attribute('mask').value = mask;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.mask.prototype = new svg.Element.ElementBase;

		// clip element
		svg.Element.clipPath = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx) {
				var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
				CanvasRenderingContext2D.prototype.beginPath = function () { };

				var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
				CanvasRenderingContext2D.prototype.closePath = function () { };

				oldBeginPath.call(ctx);
				for (var i=0; i<this.children.length; i++) {
					var child = this.children[i];
					if (typeof(child.path) != 'undefined') {
						var transform = null;
						if (child.style('transform', false, true).hasValue()) {
							transform = new svg.Transform(child.style('transform', false, true).value);
							transform.apply(ctx);
						}
						child.path(ctx);
						CanvasRenderingContext2D.prototype.closePath = oldClosePath;
						if (transform) { transform.unapply(ctx); }
					}
				}
				oldClosePath.call(ctx);
				ctx.clip();

				CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
				CanvasRenderingContext2D.prototype.closePath = oldClosePath;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.clipPath.prototype = new svg.Element.ElementBase;

		// filters
		svg.Element.filter = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, element) {
				// render as temp svg
				var bb = element.getBoundingBox();
				var x = Math.floor(bb.x1);
				var y = Math.floor(bb.y1);
				var width = Math.floor(bb.width());
				var	height = Math.floor(bb.height());

				// temporarily remove filter to avoid recursion
				var filter = element.style('filter').value;
				element.style('filter').value = '';

				var px = 0, py = 0;
				for (var i=0; i<this.children.length; i++) {
					var efd = this.children[i].extraFilterDistance || 0;
					px = Math.max(px, efd);
					py = Math.max(py, efd);
				}

				var c = document.createElement('canvas');
				c.width = width + 2*px;
				c.height = height + 2*py;
				var tempCtx = c.getContext('2d');
				tempCtx.translate(-x + px, -y + py);
				element.render(tempCtx);

				// apply filters
				for (var i=0; i<this.children.length; i++) {
					if (typeof(this.children[i].apply) === 'function') {
						this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
					}
				}

				// render on me
				ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);

				// reassign filter
				element.style('filter', true).value = filter;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.filter.prototype = new svg.Element.ElementBase;

		svg.Element.feMorphology = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feMorphology.prototype = new svg.Element.ElementBase;

		svg.Element.feComposite = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feComposite.prototype = new svg.Element.ElementBase;

		svg.Element.feColorMatrix = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			var matrix = svg.ToNumberArray(this.attribute('values').value);
			switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
				case 'saturate':
					var s = matrix[0];
					matrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,
							  0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,
							  0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,
							  0,0,0,1,0,
							  0,0,0,0,1];
					break;
				case 'hueRotate':
					var a = matrix[0] * Math.PI / 180.0;
					var c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };
					matrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,
							  c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,
							  c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,
							  0,0,0,1,0,
							  0,0,0,0,1];
					break;
				case 'luminanceToAlpha':
					matrix = [0,0,0,0,0,
							  0,0,0,0,0,
							  0,0,0,0,0,
							  0.2125,0.7154,0.0721,0,0,
							  0,0,0,0,1];
					break;
			}

			function imGet(img, x, y, width, height, rgba) {
				return img[y*width*4 + x*4 + rgba];
			}

			function imSet(img, x, y, width, height, rgba, val) {
				img[y*width*4 + x*4 + rgba] = val;
			}

			function m(i, v) {
				var mi = matrix[i];
				return mi * (mi < 0 ? v - 255 : v);
			}

			this.apply = function(ctx, x, y, width, height) {
				// assuming x==0 && y==0 for now
				var srcData = ctx.getImageData(0, 0, width, height);
				for (var y = 0; y < height; y++) {
					for (var x = 0; x < width; x++) {
						var r = imGet(srcData.data, x, y, width, height, 0);
						var g = imGet(srcData.data, x, y, width, height, 1);
						var b = imGet(srcData.data, x, y, width, height, 2);
						var a = imGet(srcData.data, x, y, width, height, 3);
						imSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));
						imSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));
						imSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));
						imSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));
					}
				}
				ctx.clearRect(0, 0, width, height);
				ctx.putImageData(srcData, 0, 0);
			}
		}
		svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;

		svg.Element.feGaussianBlur = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
			this.extraFilterDistance = this.blurRadius;

			this.apply = function(ctx, x, y, width, height) {
				if (typeof(stackBlur.canvasRGBA) == 'undefined') {
					svg.log('ERROR: StackBlur.js must be included for blur to work');
					return;
				}

				// StackBlur requires canvas be on document
				ctx.canvas.id = svg.UniqueId();
				ctx.canvas.style.display = 'none';
				document.body.appendChild(ctx.canvas);
				stackBlur.canvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
				document.body.removeChild(ctx.canvas);
			}
		}
		svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;

		// title element, do nothing
		svg.Element.title = function(node) {
		}
		svg.Element.title.prototype = new svg.Element.ElementBase;

		// desc element, do nothing
		svg.Element.desc = function(node) {
		}
		svg.Element.desc.prototype = new svg.Element.ElementBase;

		svg.Element.MISSING = function(node) {
			svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
		}
		svg.Element.MISSING.prototype = new svg.Element.ElementBase;

		// element factory
		svg.CreateElement = function(node) {
			var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
			className = className.replace(/\-/g,''); // remove dashes
			var e = null;
			if (typeof(svg.Element[className]) != 'undefined') {
				e = new svg.Element[className](node);
			}
			else {
				e = new svg.Element.MISSING(node);
			}

			e.type = node.nodeName;
			return e;
		}

		// load from url
		svg.load = function(ctx, url) {
			svg.loadXml(ctx, svg.ajax(url));
		}

		// load from xml
		svg.loadXml = function(ctx, xml) {
			svg.loadXmlDoc(ctx, svg.parseXml(xml));
		}

		svg.loadXmlDoc = function(ctx, dom) {
			svg.init(ctx);

			var mapXY = function(p) {
				var e = ctx.canvas;
				while (e) {
					p.x -= e.offsetLeft;
					p.y -= e.offsetTop;
					e = e.offsetParent;
				}
				if (window.scrollX) p.x += window.scrollX;
				if (window.scrollY) p.y += window.scrollY;
				return p;
			}

			// bind mouse
			if (svg.opts['ignoreMouse'] != true) {
				ctx.canvas.onclick = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onclick(p.x, p.y);
				};
				ctx.canvas.onmousemove = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onmousemove(p.x, p.y);
				};
			}

			var e = svg.CreateElement(dom.documentElement);
			e.root = true;
			e.addStylesFromStyleDefinition();

			// render loop
			var isFirstRender = true;
			var draw = function() {
				svg.ViewPort.Clear();
				if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);

				if (svg.opts['ignoreDimensions'] != true) {
					// set canvas size
					if (e.style('width').hasValue()) {
						ctx.canvas.width = e.style('width').toPixels('x');
						ctx.canvas.style.width = ctx.canvas.width + 'px';
					}
					if (e.style('height').hasValue()) {
						ctx.canvas.height = e.style('height').toPixels('y');
						ctx.canvas.style.height = ctx.canvas.height + 'px';
					}
				}
				var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
				var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
				if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
					cWidth = e.style('width').toPixels('x');
					cHeight = e.style('height').toPixels('y');
				}
				svg.ViewPort.SetCurrent(cWidth, cHeight);

				if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
				if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
				if (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {
					var xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);

					if (svg.opts['scaleWidth'] != null) {
						if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
						else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
					}

					if (svg.opts['scaleHeight'] != null) {
						if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
						else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
					}

					if (xRatio == null) { xRatio = yRatio; }
					if (yRatio == null) { yRatio = xRatio; }

					e.attribute('width', true).value = svg.opts['scaleWidth'];
					e.attribute('height', true).value = svg.opts['scaleHeight'];
					e.style('transform', true, true).value += ' scale('+(1.0/xRatio)+','+(1.0/yRatio)+')';
				}

				// clear and render
				if (svg.opts['ignoreClear'] != true) {
					ctx.clearRect(0, 0, cWidth, cHeight);
				}
				e.render(ctx);
				if (isFirstRender) {
					isFirstRender = false;
					if (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);
				}
			}

			var waitingForImages = true;
			if (svg.ImagesLoaded()) {
				waitingForImages = false;
				draw();
			}
			svg.intervalID = setInterval(function() {
				var needUpdate = false;

				if (waitingForImages && svg.ImagesLoaded()) {
					waitingForImages = false;
					needUpdate = true;
				}

				// need update from mouse events?
				if (svg.opts['ignoreMouse'] != true) {
					needUpdate = needUpdate | svg.Mouse.hasEvents();
				}

				// need update from animations?
				if (svg.opts['ignoreAnimation'] != true) {
					for (var i=0; i<svg.Animations.length; i++) {
						needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
					}
				}

				// need update from redraw?
				if (typeof(svg.opts['forceRedraw']) == 'function') {
					if (svg.opts['forceRedraw']() == true) needUpdate = true;
				}

				// render if needed
				if (needUpdate) {
					draw();
					svg.Mouse.runEvents(); // run and clear our events
				}
			}, 1000 / svg.FRAMERATE);
		}

		svg.stop = function() {
			if (svg.intervalID) {
				clearInterval(svg.intervalID);
			}
		}

		svg.Mouse = new (function() {
			this.events = [];
			this.hasEvents = function() { return this.events.length != 0; }

			this.onclick = function(x, y) {
				this.events.push({ type: 'onclick', x: x, y: y,
					run: function(e) { if (e.onclick) e.onclick(); }
				});
			}

			this.onmousemove = function(x, y) {
				this.events.push({ type: 'onmousemove', x: x, y: y,
					run: function(e) { if (e.onmousemove) e.onmousemove(); }
				});
			}

			this.eventElements = [];

			this.checkPath = function(element, ctx) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
				}
			}

			this.checkBoundingBox = function(element, bb) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
				}
			}

			this.runEvents = function() {
				svg.ctx.canvas.style.cursor = '';

				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					var element = this.eventElements[i];
					while (element) {
						e.run(element);
						element = element.parent;
					}
				}

				// done running, clear
				this.events = [];
				this.eventElements = [];
			}
		});

		return svg;
	};

	if (typeof(CanvasRenderingContext2D) != 'undefined') {
		CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
			canvg(this.canvas, s, {
				ignoreMouse: true,
				ignoreAnimation: true,
				ignoreDimensions: true,
				ignoreClear: true,
				offsetX: dx,
				offsetY: dy,
				scaleWidth: dw,
				scaleHeight: dh
			});
		}
	}

	return canvg;

}));

define('js/graphStyle',["require", "exports", "canvgModule"], function (require, exports, canvg) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    function replaceAll(str, find, replace) {
        return str.replace(new RegExp(find, 'g'), replace);
    }
    function graphResultsPaneCSS(svgNode) {
        // modified from https://stackoverflow.com/questions/20394041/convert-svg-to-png-and-maintain-css-integrity
        // also https://spin.atomicobject.com/2014/01/21/convert-svg-to-png/
        var styleDefs = "";
        var rootDefs = {};
        var sheets = document.styleSheets;
        for (var i = 0; i < sheets.length; i++) {
            var sheet = sheets[i];
            if (!sheet.href || sheet.href.indexOf("standard.css") < 0)
                continue;
            var rules = sheet.cssRules;
            for (var j = 0; j < rules.length; j++) {
                var rule = rules[j];
                if (rule.style) {
                    // because canvg does not work with css variables, we must replace them with non-var colors
                    if (rule.selectorText === ":root") {
                        var rootRules = rule.style.cssText.split(";").map(function (item) { return item.trim(); });
                        for (var k = 0; k < rootRules.length; k++) {
                            if (rootRules[k].indexOf("color-graph") >= 0) {
                                var variableAndColor = rootRules[k].split(": ");
                                if (variableAndColor.length > 1) {
                                    var varStatement = "var(" + variableAndColor[0] + ")";
                                    var color = variableAndColor[1];
                                    rootDefs[varStatement] = color;
                                }
                            }
                        }
                    }
                    if (svgNode) {
                        var elements = svgNode.querySelectorAll(rule.selectorText);
                        if (elements.length) {
                            styleDefs += rule.selectorText + " { " + rule.style.cssText + " }\n";
                        }
                    }
                    else {
                        styleDefs += rule.selectorText + " { " + rule.style.cssText + " }\n";
                    }
                }
            }
        }
        var varStatements = Object.keys(rootDefs);
        for (var index = 0; index < varStatements.length; index++) {
            var find = varStatements[index];
            find = find.replace("(", "\\(");
            find = find.replace(")", "\\)");
            var replace = rootDefs[varStatements[index]];
            var regex = new RegExp(find, 'g');
            styleDefs = styleDefs.replace(regex, replace);
        }
        return styleDefs;
    }
    exports.graphResultsPaneCSS = graphResultsPaneCSS;
    function modifyFontSize(css, outputFontModifierPercent) {
        if (!outputFontModifierPercent)
            return css;
        var regex = /font-size:/gi;
        var searchResult;
        var fontSizeIndices = [];
        while (searchResult = regex.exec(css)) {
            fontSizeIndices.push(searchResult.index);
        }
        regex = /em/gi;
        var emIndices = [];
        while (searchResult = regex.exec(css)) {
            emIndices.push(searchResult.index);
        }
        var result = "";
        var readingFontSize = false;
        var currentFontSize = "";
        var position = 0;
        while (position < css.length) {
            if (fontSizeIndices.indexOf(position) >= 0) {
                readingFontSize = true;
                position += "font-size:".length; // jump over
                currentFontSize += css[position]; // record current font size
            }
            else if (emIndices.indexOf(position) >= 0) {
                if (readingFontSize) {
                    position += "em;".length; // jump over (assumes there is always a semicolon after em)
                    result += "font-size: " + (parseFloat(currentFontSize) * outputFontModifierPercent / 100) + "em;";
                    readingFontSize = false;
                    currentFontSize = "";
                }
                else {
                    result += css[position];
                    position++;
                }
            }
            else {
                if (readingFontSize) {
                    currentFontSize += css[position]; // continue reading current font size
                }
                else {
                    result += css[position]; // continue reading other text than font size
                }
                position++;
            }
        }
        // console.log(result);
        return result;
    }
    exports.modifyFontSize = modifyFontSize;
    function prepareSVGToSaveToFile(svgNode, customCSS, outputFontModifierPercent) {
        if (outputFontModifierPercent === void 0) { outputFontModifierPercent = null; }
        var svgText = svgNode.outerHTML;
        var styleText = graphResultsPaneCSS(svgNode);
        styleText = "<style>" + modifyFontSize(styleText, outputFontModifierPercent);
        if (customCSS)
            styleText += customCSS;
        styleText += "</style>";
        var head = '<svg title="graph" version="1.1" xmlns="http://www.w3.org/2000/svg">';
        var foot = "</svg>";
        return head + "\n" + styleText + "\n" + svgText + "\n" + foot;
    }
    exports.prepareSVGToSaveToFile = prepareSVGToSaveToFile;
    function preparePNGToSaveToFile(svgNode, customCSS, outputFontModifierPercent) {
        if (outputFontModifierPercent === void 0) { outputFontModifierPercent = null; }
        var styleNode = document.createElement("style");
        styleNode.setAttribute('type', 'text/css');
        var styleText = graphResultsPaneCSS(svgNode);
        styleText = "<![CDATA[" + modifyFontSize(styleText, outputFontModifierPercent);
        if (customCSS)
            styleText += customCSS;
        styleText += "]]>";
        styleNode.innerHTML = styleText;
        svgNode.insertBefore(styleNode, svgNode.firstChild);
        var canvas = document.createElement("canvas");
        canvg(canvas, svgNode.outerHTML);
        return canvas;
    }
    exports.preparePNGToSaveToFile = preparePNGToSaveToFile;
    function dataURItoBlob(dataURI) {
        // copied from https://stackoverflow.com/questions/55385369/jszip-creating-corrupt-jpg-image
        // Convert Base64 to raw binary data held in a string.
        var byteString = atob(dataURI.split(',')[1]);
        // Separate the MIME component.
        var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
        // Write the bytes of the string to an ArrayBuffer.
        var arrayBuffer = new ArrayBuffer(byteString.length);
        var uint8Array = new Uint8Array(arrayBuffer);
        for (var i = 0; i < byteString.length; i++) {
            uint8Array[i] = byteString.charCodeAt(i);
        }
        // Write the ArrayBuffer to a BLOB and you're done.
        var blob = new Blob([arrayBuffer]);
        return blob;
    }
    exports.dataURItoBlob = dataURItoBlob;
});

define('js/storyCardDisplay',["require", "exports", "mithril", "./questionnaireGeneration", "./Globals"], function (require, exports, m, questionnaireGeneration, Globals) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    var defaultBetweenAnswerText = " / ";
    function replaceAll(str, find, replace) {
        return str.replace(new RegExp(find, 'g'), replace);
    }
    function replaceSpacesWithDashes(text) {
        if (text) {
            return replaceAll(text.trim(), " ", "-");
        }
        else {
            return "";
        }
    }
    function wrap(elementType, cssClass, text) {
        return m(elementType, { "class": cssClass }, text);
    }
    function displayHTMLForSlider(fieldSpecification, fieldName, value, options) {
        var lowLabel = "";
        var highLabel = "";
        if (fieldSpecification.displayConfiguration !== undefined && fieldSpecification.displayConfiguration.length > 1) {
            lowLabel = fieldSpecification.displayConfiguration[0];
            highLabel = fieldSpecification.displayConfiguration[1];
        }
        var sliderText = [];
        var sliderTextBefore = "";
        var sliderTextAfter = "";
        // Assumes values go from 0 to 100; places 100.0 in last bucket
        var bucketCount = options.sliderBucketCount || 50;
        var bucketSize = 100.0 / bucketCount;
        var placed = false;
        var answerClass = "narrafirma-story-card-answer-for-" + replaceSpacesWithDashes(fieldName);
        if (value !== undefined && value !== "") {
            for (var i = 0; i < bucketCount; i++) {
                var bucketHigh = i * bucketSize + bucketSize;
                if (!placed) {
                    if (value && ((value < bucketHigh) || (value && i === bucketCount - 1))) {
                        sliderText.push(m("span", { "class": "narrafirma-story-card-slider-bars-before " + answerClass + '-slider-bars-before' }, sliderTextBefore));
                        sliderText.push(m("span", { "class": "narrafirma-story-card-slider-button " + answerClass + "-slider-button" }, options.sliderButtonCharacter || "|"));
                        placed = true;
                    }
                    else {
                        sliderTextBefore += options.beforeSliderCharacter || "-";
                    }
                }
                else {
                    sliderTextAfter += options.afterSliderCharacter || "-";
                }
            }
            sliderText.push(m("span", { "class": "narrafirma-story-card-slider-bars-after " + answerClass + "-slider-bars-after" }, sliderTextAfter));
        }
        else {
            // no answer
            sliderTextAfter = new Array(bucketCount + 1).join(options.noAnswerSliderCharacter || "-");
            sliderText.push(m("span", { "class": "narrafirma-story-card-slider-bars-no-answer " + answerClass + "-slider-bars-no-answer" }, sliderTextAfter));
        }
        return m("tr", [
            wrap("td", "narrafirma-story-card-slider-name", m("span", { "class": "narrafirma-story-card-field-name-" + replaceSpacesWithDashes(fieldName) }, fieldName)),
            wrap("td", "narrafirma-story-card-slider-label-left", lowLabel),
            wrap("td", "narrafirma-story-card-slider-contents", sliderText),
            wrap("td", "narrafirma-story-card-slider-label-right", highLabel)
        ]);
    }
    function displayHTMLForCheckboxes(fieldSpecification, fieldName, value, hideNonSelectedAnswers, betweenAnswerText) {
        var result = [];
        var atLeastOneAnswerWasChecked = false;
        var answerClass = "narrafirma-story-card-answer-for-" + replaceSpacesWithDashes(fieldName);
        result.push(m("span", { "class": "narrafirma-story-card-field-name-" + replaceSpacesWithDashes(fieldName) }, fieldName + ": "));
        // TODO: What if value is not currently available option?
        var answersAlreadyConsidered = [];
        var answerElements = [];
        for (var i = 0; i < fieldSpecification.valueOptions.length; i++) {
            var answerBeingConsidered = fieldSpecification.valueOptions[i];
            if (answersAlreadyConsidered.indexOf(answerBeingConsidered) >= 0)
                continue; // hide duplicate options, if any, due to lumping during import
            answersAlreadyConsidered.push(answerBeingConsidered);
            if (value && value[answerBeingConsidered]) {
                if (!hideNonSelectedAnswers) {
                    answerElements.push(wrap("span", "narrafirma-story-card-checkboxes-selected " + answerClass + "-selected", answerBeingConsidered));
                }
                else {
                    answerElements.push(wrap("span", "narrafirma-story-card-checkboxes-visible " + answerClass + "-visible", answerBeingConsidered));
                }
                atLeastOneAnswerWasChecked = true;
            }
            else if (!hideNonSelectedAnswers) {
                answerElements.push(wrap("span", "narrafirma-story-card-checkboxes-unselected " + answerClass + "-unselected", answerBeingConsidered));
            }
        }
        for (var i = 0; i < answerElements.length; i++) {
            result.push(answerElements[i]);
            if (i < answerElements.length - 1)
                result.push(m("span", betweenAnswerText));
        }
        return [result, atLeastOneAnswerWasChecked];
    }
    function displayHTMLForRadioButtons(fieldSpecification, fieldName, value, hideNonSelectedAnswers, betweenAnswerText) {
        var result = [];
        var atLeastOneAnswerWasChecked = false;
        var answerClass = "narrafirma-story-card-answer-for-" + replaceSpacesWithDashes(fieldName);
        result.push(m("span", { "class": "narrafirma-story-card-field-name-" + replaceSpacesWithDashes(fieldName) }, fieldName + ": "));
        // TODO: What if value is not currently available option?
        var answersAlreadyConsidered = [];
        var answerElements = [];
        for (var i = 0; i < fieldSpecification.valueOptions.length; i++) {
            var answerBeingConsidered = fieldSpecification.valueOptions[i];
            if (answersAlreadyConsidered.indexOf(answerBeingConsidered) >= 0)
                continue; // hide duplicate options, if any, due to lumping during import
            answersAlreadyConsidered.push(answerBeingConsidered);
            if (value && value === answerBeingConsidered) {
                if (!hideNonSelectedAnswers) {
                    answerElements.push(wrap("span", "narrafirma-story-card-radiobuttons-selected " + answerClass + "-selected", answerBeingConsidered));
                }
                else {
                    answerElements.push(wrap("span", "narrafirma-story-card-radiobuttons-visible " + answerClass + "-visible", answerBeingConsidered));
                }
                atLeastOneAnswerWasChecked = true;
            }
            else if (!hideNonSelectedAnswers) {
                answerElements.push(wrap("span", "narrafirma-story-card-radiobuttons-unselected " + answerClass + "-unselected", answerBeingConsidered));
            }
        }
        for (var i = 0; i < answerElements.length; i++) {
            result.push(answerElements[i]);
            if (i < answerElements.length - 1)
                result.push(m("span", betweenAnswerText));
        }
        return [result, atLeastOneAnswerWasChecked];
    }
    function displayHTMLForSelect(fieldSpecification, fieldName, value, hideNonSelectedAnswers, betweenAnswerText) {
        var result = [];
        var atLeastOneAnswerWasChecked = false;
        var answerClass = "narrafirma-story-card-answer-for-" + replaceSpacesWithDashes(fieldName);
        result.push(m("span", { "class": "narrafirma-story-card-field-name-" + replaceSpacesWithDashes(fieldName) }, fieldName + ": "));
        // TODO: What if value is not currently available option?
        var answersAlreadyConsidered = [];
        var answerElements = [];
        for (var i = 0; i < fieldSpecification.valueOptions.length; i++) {
            var answerBeingConsidered = fieldSpecification.valueOptions[i];
            if (answersAlreadyConsidered.indexOf(answerBeingConsidered) >= 0)
                continue; // hide duplicate options, if any, due to lumping during import
            answersAlreadyConsidered.push(answerBeingConsidered);
            if (value && value === answerBeingConsidered) {
                if (!hideNonSelectedAnswers) {
                    answerElements.push(wrap("span", "narrafirma-story-card-select-selected " + answerClass + "-selected", answerBeingConsidered));
                }
                else {
                    answerElements.push(wrap("span", "narrafirma-story-card-select-visible " + answerClass + "-visible", answerBeingConsidered));
                }
                atLeastOneAnswerWasChecked = true;
            }
            else if (!hideNonSelectedAnswers) {
                answerElements.push(wrap("span", "narrafirma-story-card-select-unselected " + answerClass + "-unselected", answerBeingConsidered));
            }
        }
        for (var i = 0; i < answerElements.length; i++) {
            result.push(answerElements[i]);
            if (i < answerElements.length - 1)
                result.push(m("span", betweenAnswerText));
        }
        return [result, atLeastOneAnswerWasChecked];
    }
    function displayHTMLForField(storyModel, fieldSpecification, options, nobreak) {
        if (nobreak === void 0) { nobreak = null; }
        // if (!model[fieldSpecification.id]) return "";
        var value = storyModel.fieldValue(fieldSpecification.id);
        var displayValue = value;
        var isAnnotationQuestion = fieldSpecification.id.indexOf("A_") >= 0;
        if (options.lumpingCommands && options.lumpingCommands.hasOwnProperty(fieldSpecification.displayName)) {
            if (fieldSpecification.displayType === "checkboxes") {
                var answersToReport = {};
                var valueKeys = Object.keys(value);
                for (var i = 0; i < valueKeys.length; i++) {
                    // see note in calculateStatistics about lumping commands and trimming
                    var trimmedKey = valueKeys[i].trim();
                    answersToReport[trimmedKey] = value[valueKeys[i]];
                }
                var answersToLumpTogether = Object.keys(options.lumpingCommands[fieldSpecification.displayName]);
                for (var i = 0; i < answersToLumpTogether.length; i++) {
                    var thisAnswer = answersToLumpTogether[i];
                    if (answersToReport.hasOwnProperty(thisAnswer)) {
                        var substituteAnswer = options.lumpingCommands[fieldSpecification.displayName][thisAnswer];
                        delete answersToReport[thisAnswer];
                        answersToReport[substituteAnswer] = true;
                    }
                }
                displayValue = answersToReport;
            }
            else {
                // see note in calculateStatistics about lumping commands and trimming
                var trimmedValue = value.trim();
                if (options.lumpingCommands[fieldSpecification.displayName].hasOwnProperty(trimmedValue))
                    displayValue = options.lumpingCommands[fieldSpecification.displayName][trimmedValue];
            }
        }
        var fieldNameToShow = fieldSpecification.displayName || fieldSpecification.displayPrompt;
        var displayType = fieldSpecification.displayType;
        var result = [];
        var answerClass = "narrafirma-story-card-answer-for-" + replaceSpacesWithDashes(fieldNameToShow);
        if (displayType === "slider") {
            result.push(displayHTMLForSlider(fieldSpecification, fieldNameToShow, displayValue, options));
        }
        else if (["checkboxes", "select", "radiobuttons"].indexOf(displayType) >= 0) {
            var answerHTMLDivsAndWhetherAtLeastOneIsSelected = [];
            if (displayType === "checkboxes") {
                answerHTMLDivsAndWhetherAtLeastOneIsSelected = displayHTMLForCheckboxes(fieldSpecification, fieldNameToShow, displayValue, options.hideNonSelectedAnswers || false, options.betweenAnswerText || defaultBetweenAnswerText);
            }
            else if (displayType === "select") {
                answerHTMLDivsAndWhetherAtLeastOneIsSelected = displayHTMLForSelect(fieldSpecification, fieldNameToShow, displayValue, options.hideNonSelectedAnswers || false, options.betweenAnswerText || defaultBetweenAnswerText);
            }
            else if (displayType === "radiobuttons") {
                answerHTMLDivsAndWhetherAtLeastOneIsSelected = displayHTMLForRadioButtons(fieldSpecification, fieldNameToShow, displayValue, options.hideNonSelectedAnswers || false, options.betweenAnswerText || defaultBetweenAnswerText);
            }
            var answerHTMLDivs = [];
            var atLeastOneAnswerIsSelected = false;
            if (answerHTMLDivsAndWhetherAtLeastOneIsSelected.length > 0) {
                answerHTMLDivs = answerHTMLDivs.concat(answerHTMLDivsAndWhetherAtLeastOneIsSelected[0]);
                if (answerHTMLDivsAndWhetherAtLeastOneIsSelected.length > 0) {
                    atLeastOneAnswerIsSelected = answerHTMLDivsAndWhetherAtLeastOneIsSelected[1];
                }
            }
            if (options.hideNonSelectedAnswers) {
                if (atLeastOneAnswerIsSelected) {
                    result.push(wrap("div", "narrafirma-story-card-question-line-basic", answerHTMLDivs));
                }
                else {
                    // hide question if there is no answer to it?
                }
            }
            else {
                if (atLeastOneAnswerIsSelected) {
                    result.push(wrap("div", "narrafirma-story-card-question-line-with-selected-item", answerHTMLDivs));
                }
                else if (options.hideNon) {
                    result.push(wrap("div", "narrafirma-story-card-question-line-without-selected-item", answerHTMLDivs));
                }
            }
        }
        else if (displayType === "boolean") {
            var thisBit = [];
            thisBit.push(m("span", { "class": "narrafirma-story-card-field-name-" + replaceSpacesWithDashes(fieldNameToShow) }, fieldNameToShow + ": "));
            if (displayValue === true) {
                thisBit.push(m("span", { "class": answerClass }, "yes"));
            }
            else if (displayValue === false) {
                thisBit.push(m("span", { "class": answerClass }, "no"));
            }
            else {
                thisBit.push(m("span", { "class": answerClass }, ""));
            }
            result.push(wrap("div", "narrafirma-story-card-question-line-basic", thisBit));
        }
        else if (displayType === "checkbox") {
            var thisBit = [];
            thisBit.push(m("span", { "class": "narrafirma-story-card-field-name-" + replaceSpacesWithDashes(fieldNameToShow) }, fieldNameToShow + ": "));
            if (displayValue === true) {
                thisBit.push(m("span", { "class": answerClass }, "true"));
            }
            else if (displayValue === false) {
                thisBit.push(m("span", { "class": answerClass }, "false"));
            }
            else {
                thisBit.push(m("span", { "class": answerClass }, ""));
            }
            result.push(wrap("div", "narrafirma-story-card-question-line-basic", thisBit));
        }
        else if (displayType === "label" || fieldSpecification.displayType === "header") {
            return [];
        }
        else {
            // TODO: May need more handling here for other cases
            var thisBit = [];
            thisBit.push(m("span", { "class": "narrafirma-story-card-field-name-" + replaceSpacesWithDashes(fieldNameToShow) }, fieldNameToShow + ": "));
            thisBit.push(m("span", { "class": answerClass }, value));
            result.push(wrap("div", "narrafirma-story-card-question-line-basic", thisBit));
        }
        if (options.includeWriteInAnswers) {
            var writeInEntry = storyModel.fieldValueWriteIn(fieldSpecification.id);
            if (writeInEntry) {
                result.push(wrap("span", "narrafirma-story-card-write-in-answer", writeInEntry));
            }
        }
        if (isAnnotationQuestion) {
            return wrap("div", "narrafirma-story-card-annotation", result);
        }
        else {
            return result;
        }
    }
    function generateStoryCardContent(storyModel, questionsToInclude, options) {
        if (options === void 0) { options = {}; }
        var elicitingQuestion = storyModel.elicitingQuestion();
        var numStoriesTold = storyModel.numStoriesTold();
        var storyLength = storyModel.storyLength();
        var storyName = storyModel.storyName();
        var storyCollectionDate = storyModel.storyCollectionDate();
        var language = storyModel.storyLanguage();
        var storyText = storyModel.storyText();
        if (options.cutoff && options.cutoff !== "no limit") {
            var cutoffValue = parseInt(options.cutoff);
            var cutoffMessageToUse = options.cutoffMessage || "... (truncated)";
            if (!isNaN(cutoffValue)) {
                if (storyText.length > cutoffValue) {
                    storyText = storyText.slice(0, cutoffValue) + cutoffMessageToUse;
                }
            }
        }
        var formattedFields = [];
        var questionnaire = storyModel.questionnaire();
        if (options.questionnaire)
            questionnaire = options.questionnaire;
        var allQuestions = [];
        if (questionnaire) {
            if (options["location"] || options["location"] !== "storyAnnotationBrowser") {
                allQuestions = allQuestions.concat(questionnaire.storyQuestions);
                allQuestions = allQuestions.concat(questionnaire.participantQuestions);
            }
            var allAnnotationQuestions = questionnaireGeneration.convertEditorQuestions(Globals.project().collectAllAnnotationQuestions(), "A_");
            if (allAnnotationQuestions)
                allQuestions = allQuestions.concat(allAnnotationQuestions);
        }
        var questions = [];
        if (questionsToInclude) {
            allQuestions.forEach(function (question) {
                if (questionsToInclude[question.id]) {
                    questions.push(question);
                }
            });
        }
        else {
            questions = allQuestions;
        }
        if (options.lumpingCommands) {
            questions.forEach(function (question) {
                if (options.lumpingCommands.hasOwnProperty(question.displayName)) {
                    var lumpedAnswersToAdd_1 = [];
                    question.valueOptions = question.valueOptions.filter(function (answer) {
                        // see note in calculateStatistics about lumping commands and trimming
                        var trimmedAnswer = answer.trim();
                        var lumpedAnswer = options.lumpingCommands[question.displayName][trimmedAnswer];
                        if (lumpedAnswer) {
                            if (lumpedAnswersToAdd_1.indexOf(lumpedAnswer) < 0)
                                lumpedAnswersToAdd_1.push(lumpedAnswer);
                            return false;
                        }
                        return true;
                    });
                    lumpedAnswersToAdd_1.forEach(function (answer) { if (question.valueOptions.indexOf(answer) < 0)
                        question.valueOptions.push(answer); });
                }
            });
        }
        //valueOptions: [
        //    "order on story form, scales separate",
        //    "order on story form, scales mixed in",
        //    "alphabetical order, scales separate",
        //    "alphabetical order, scales mixed in"
        //],
        var sortAlphabetically = options.order != undefined && options.order.indexOf("alphabetical") >= 0;
        var sortScalesSeparately = options.order != undefined && options.order.indexOf("scales separate") >= 0;
        if (sortAlphabetically) {
            questions.sort(function (a, b) {
                var aName = a.displayName || a.displayPrompt || "";
                aName = aName.toLowerCase();
                var bName = b.displayName || b.displayPrompt || "";
                bName = bName.toLowerCase();
                var aIsAnnotationQuestion = a.id.indexOf("A_") >= 0;
                var bIsAnnotationQuestion = b.id.indexOf("A_") >= 0;
                if ((aIsAnnotationQuestion && bIsAnnotationQuestion) || (!aIsAnnotationQuestion && !bIsAnnotationQuestion)) {
                    if (aName < bName)
                        return -1;
                    if (aName > bName)
                        return 1;
                }
                else if (aIsAnnotationQuestion && !bIsAnnotationQuestion) {
                    return 1;
                }
                else if (!aIsAnnotationQuestion && bIsAnnotationQuestion) {
                    return -1;
                }
                return 0;
            });
        }
        var question;
        var i;
        // Put sliders in a table at the start, so loop twice with different conditions (but only if they chose that option)
        if (sortScalesSeparately) {
            for (var i_1 = 0; i_1 < questions.length; i_1++) {
                question = questions[i_1];
                if (question.displayType !== "slider")
                    continue;
                var fieldHTML = displayHTMLForField(storyModel, question, options, "nobreak");
                formattedFields.push(fieldHTML);
            }
            if (formattedFields.length)
                formattedFields = [m("table", { "class": "narrafirma-story-card-sliders-table" }, formattedFields), m("br.storyCard")];
        }
        for (var i_2 = 0; i_2 < questions.length; i_2++) {
            question = questions[i_2];
            if (sortScalesSeparately && question.displayType === "slider")
                continue;
            var fieldHTML = displayHTMLForField(storyModel, question, options);
            if (!sortScalesSeparately && question.displayType === "slider") {
                fieldHTML = [m("div", { "class": "narrafirma-story-card-question-line-with-slider" }, m("table", { "class": "narrafirma-story-card-one-slider-table" }, fieldHTML))];
            }
            formattedFields.push(fieldHTML);
        }
        var textForElicitingQuestion = [];
        // if questionsToInclude is unspecified, it is not being called in the "print story cards" page, so include this
        if (!questionsToInclude || questionsToInclude["elicitingQuestion"]) {
            textForElicitingQuestion = m(".narrafirma-story-card-eliciting-question", [wrap("span", "narrafirma-story-card-eliciting-question-name", "Eliciting question: "),
                elicitingQuestion]);
        }
        var textForNumStoriesTold = [];
        // if questionsToInclude is unspecified, it is not being called in the "print story cards" page, so include this
        if (!questionsToInclude || questionsToInclude["numStoriesTold"]) {
            textForNumStoriesTold = m(".narrafirma-story-card-num-stories-question", [wrap("span", "narrafirma-story-card-num-stories-question-name", "Number of stories told by this participant: "),
                numStoriesTold]);
        }
        var textForStoryLength = [];
        // if questionsToInclude is unspecified, it is not being called in the "print story cards" page, so include this
        if (!questionsToInclude || questionsToInclude["storyLength"]) {
            textForStoryLength = m(".narrafirma-story-card-story-length-question", [wrap("span", "narrafirma-story-card-story-length-question-name", "Story length: "),
                storyLength, " characters", m("br.storyCard")]);
        }
        var textForCollectionDate = [];
        // if questionsToInclude is unspecified, it is not being called in the "print story cards" page, so include this
        if (!questionsToInclude || questionsToInclude["collectionDate"]) {
            textForCollectionDate = m(".narrafirma-story-card-collection-date-question", [wrap("span", "narrafirma-story-card-collection-date-question-name", "Collection date: "),
                storyCollectionDate, m("br.storyCard")]);
        }
        var textForLanguage = [];
        // if questionsToInclude is unspecified, it is not being called in the "print story cards" page, so include this
        if (!questionsToInclude || questionsToInclude["language"]) {
            textForCollectionDate = m(".narrafirma-story-card-language-question", [wrap("span", "narrafirma-story-card-language-question-name", "Language: "),
                language, m("br.storyCard")]);
        }
        var storyTextAtTop = [];
        var storyTextClass = "";
        if (options["location"] && options["location"] === "storyBrowser") {
            storyTextClass = "narrafirma-story-card-story-text-in-story-browser";
        }
        else if (options["location"] && options["location"] === "storyAnnotationBrowser") {
            storyTextClass = "narrafirma-story-card-story-text-in-story-annotation-browser";
        }
        else {
            storyTextClass = "narrafirma-story-card-story-text-in-printed-story-cards";
        }
        var storyTextAtBottom = null;
        if (options.blankLineAfterStory) {
            // the empty line is for copying into word processors, so there is a blank line after the story
            storyTextAtBottom = [wrap("div", storyTextClass, storyText), m("br.storyCard")];
        }
        else {
            storyTextAtBottom = wrap("div", storyTextClass, storyText);
        }
        if (options.storyTextAtTop) {
            storyTextAtTop = storyTextAtBottom;
            storyTextAtBottom = [];
        }
        var bottomHrDiv = [];
        if (options.hrAtBottom) {
            bottomHrDiv = m("hr.storyCardForPrinting");
        }
        var storyCardContent = m("div.storyCard", [
            wrap("div", "narrafirma-story-card-story-title", m("b", storyName)),
            storyTextAtTop,
            formattedFields,
            storyTextAtBottom,
            textForElicitingQuestion,
            textForNumStoriesTold,
            textForStoryLength,
            textForCollectionDate,
            textForLanguage,
            options.includeIndex ? m("div.narrafirma-story-card-story-number", "#" + storyModel.indexInStoryCollection()) : "",
            bottomHrDiv
        ]);
        return storyCardContent;
    }
    exports.generateStoryCardContent = generateStoryCardContent;
});

define('js/panelBuilder/valuePathResolver',["require", "exports", "../Globals"], function (require, exports, Globals) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    /*
    ValuePathResolver helps with getting and setting values that are nested inside multiple objects.
    It also helps with getting and setting valeus stores in a triple store.
    
    ValuePathResolver will start from a supplied baseModel and sequentially move along a series of fields
    defined in a valuePath string and separated by slashes.
    It resolves the object at each position in the path and uses that to resolve the next part of the valuePath.
    
    If the baseModel is a string instead of a JavaScript objects,
    it uses that as the "A" field of a triple to use with a triple store lookup.
    In that case, the "B" field of the tripel is the field in the value path.
    If a value is beign set, the "C" field in the triple is the new value being set, and A and B are the same as for the lookup.
    
    If part of a path is a function, it uses that function to get the field's value -- or set the value, if it is the final field.
    
    If the valuePath starts with "/", the resolution process will use an optional supplied context object instead of the baseModel.
    This is useful when building a panel where most of the panel fields use the same model,
    but one or two fields or options may relay on values in the project or configuration or such.
    
    An example valuePath starting from the baseModel with three segments is "a/b/c".
    That would resolve to "baseModel.a.b.c" or set as "baseModel.a.b.c = newValue".
    
    An example valuePath starting from the context with two segments is: "/project/userIdentifier".
    That would resolve to "context.project.userIdentifier".
    */
    var ValuePathResolver = (function () {
        function ValuePathResolver(baseModel, valuePath, isAccessFunctionRequired) {
            if (isAccessFunctionRequired === void 0) { isAccessFunctionRequired = false; }
            this.baseModel = baseModel;
            this.valuePath = valuePath;
            this.isAccessFunctionRequired = isAccessFunctionRequired;
        }
        ValuePathResolver.prototype.failIfAccessFunctionRequired = function () {
            if (this.isAccessFunctionRequired) {
                console.log("access function required", this);
                // alert("access function required");
                throw new Error("access function required " + this.valuePath);
            }
        };
        ValuePathResolver.prototype.resolveModelAndField = function () {
            var currentModel = this.baseModel;
            var currentKey;
            // Parse the dependency path
            var pathParts = this.valuePath.split("/");
            var isGlobalReference = false;
            var useTripleStore = false;
            // If the path starts with "/", use the context as the model
            if (pathParts[0] === "") {
                isGlobalReference = true;
                pathParts.shift();
                currentModel = Globals;
                if (!currentModel) {
                    console.log("no object for context", currentKey, this.valuePath, Globals);
                    return undefined;
                }
            }
            if (pathParts.length < 1)
                throw new Error("Incorrect dependency path specified: " + this.valuePath);
            while (pathParts.length > 1) {
                currentKey = pathParts.shift();
                // TODO: Hard to distinguish with this between an incorrect path that might reference a field set somewhere to a string
                if (typeof currentModel === "string") {
                    useTripleStore = true;
                }
                var nextModel = void 0;
                var currentModelDirectFieldValue = currentModel[currentKey];
                var useAccessorFunction = !useTripleStore && typeof currentModelDirectFieldValue === "function";
                if (useTripleStore) {
                    this.failIfAccessFunctionRequired();
                    nextModel = Globals.project().tripleStore.queryLatestC(currentModel, currentKey);
                }
                else if (useAccessorFunction) {
                    nextModel = currentModel[currentKey]();
                }
                else if (currentModelDirectFieldValue === undefined && currentModel.fieldValue && typeof currentModel.fieldValue === "function") {
                    nextModel = currentModel.fieldValue(currentKey);
                }
                else {
                    this.failIfAccessFunctionRequired();
                    nextModel = currentModel[currentKey];
                }
                if (!nextModel) {
                    console.log("model is null while iterating", currentKey, pathParts.length, this.valuePath, currentModel);
                    return undefined;
                }
                currentModel = nextModel;
                if (typeof currentModel === "string") {
                    useTripleStore = true;
                }
            }
            if (typeof currentModel === "string") {
                useTripleStore = true;
            }
            var field = pathParts[0];
            var result = {
                model: currentModel,
                field: field,
                isGlobalReference: isGlobalReference,
                useTripleStore: useTripleStore
            };
            return result;
        };
        ValuePathResolver.prototype.resolve = function (value) {
            if (value === void 0) { value = undefined; }
            var modelAndField = this.resolveModelAndField();
            if (!modelAndField) {
                console.log("ERROR: modelAndField is undefined or null", this);
                return null;
            }
            var modelFieldDirectValue = modelAndField.model[modelAndField.field];
            var useAccessorFunction = !modelAndField.useTripleStore && typeof modelFieldDirectValue === "function";
            if (value !== undefined) {
                if (modelAndField === undefined) {
                    console.log("Model missing; can't set value", this.valuePath, this.baseModel, Globals);
                    return undefined;
                }
                if (modelAndField.useTripleStore) {
                    this.failIfAccessFunctionRequired();
                    Globals.project().tripleStore.addTriple(modelAndField.model, modelAndField.field, value);
                }
                else if (useAccessorFunction) {
                    modelAndField.model[modelAndField.field](value);
                }
                else if (modelFieldDirectValue === undefined && modelAndField.model.fieldValue && typeof modelAndField.model.fieldValue === "function") {
                    modelAndField.model.fieldValue(modelAndField.field, value);
                }
                else {
                    this.failIfAccessFunctionRequired();
                    modelAndField.model[modelAndField.field] = value;
                }
                // console.log("resolve-set", this.valuePath, value, modelAndField, this);
                // Design issue: Should a set return this or the value? Using value to me like m.prop, but prevents chaining
                return value;
            }
            else {
                if (modelAndField === undefined)
                    return undefined;
                if (modelAndField.useTripleStore) {
                    this.failIfAccessFunctionRequired();
                    value = Globals.project().tripleStore.queryLatestC(modelAndField.model, modelAndField.field);
                }
                else if (useAccessorFunction) {
                    value = modelAndField.model[modelAndField.field]();
                }
                else if (modelFieldDirectValue === undefined && modelAndField.model.fieldValue && typeof modelAndField.model.fieldValue === "function") {
                    return modelAndField.model.fieldValue(modelAndField.field);
                }
                else {
                    this.failIfAccessFunctionRequired();
                    value = modelAndField.model[modelAndField.field];
                }
                // console.log("resolve-get", this.valuePath, value, modelAndField, this);
                return value;
            }
        };
        return ValuePathResolver;
    }());
    function newValuePathForFieldSpecification(model, fieldSpecification) {
        var valuePath = fieldSpecification.valuePath;
        if (!valuePath)
            valuePath = fieldSpecification.id;
        return newValuePath(model, valuePath);
    }
    exports.newValuePathForFieldSpecification = newValuePathForFieldSpecification;
    function newValuePath(model, valuePath) {
        var valuePathResolver = new ValuePathResolver(model, valuePath);
        return valuePathResolver.resolve.bind(valuePathResolver);
    }
    exports.newValuePath = newValuePath;
});

// From CryptoJS: http://crypto-js.googlecode.com/svn/tags/3.1.2/src/sha256.js
define('js/pointrel20150417/sha256',["require", "exports"], function (require, exports) {
    "use strict";
    /* tslint:disable no-bitwise */
    /**
     * CryptoJS namespace.
     */
    var C = {
        SHA256: undefined
    };
    /**
     * Base object for prototypal inheritance.
     */
    var Base = (function () {
        function F() { }
        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                if (overrides === void 0) { overrides = undefined; }
                // Spawn
                F.prototype = this;
                var subtype = new F();
                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }
                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }
                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;
                // Reference supertype
                subtype.$super = this;
                return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);
                return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }
                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());
    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            }
            else {
                this.sigBytes = words.length * 4;
            }
        },
        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },
        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            // Clamp excess bits
            this.clamp();
            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            }
            else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            }
            else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;
            // Chainable
            return this;
        },
        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;
            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },
        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
        },
        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }
            return new WordArray.init(words, nBytes);
        }
    });
    /**
     * Hex encoding strategy.
     */
    var Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }
            return hexChars.join('');
        },
        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;
            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }
            return new WordArray.init(words, hexStrLength / 2);
        }
    };
    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join('');
        },
        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;
            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }
            return new WordArray.init(words, latin1StrLength);
        }
    };
    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            }
            catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },
        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };
    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },
        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }
            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },
        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            }
            else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;
            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }
                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }
            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },
        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
        },
        _minBufferSize: 0
    });
    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),
        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);
            // Set initial values
            this.reset();
        },
        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);
            // Perform concrete-hasher logic
            this._doReset();
        },
        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);
            // Update the hash
            this._process();
            // Chainable
            return this;
        },
        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }
            // Perform concrete-hasher logic
            var hash = this._doFinalize();
            return hash;
        },
        blockSize: 512 / 32,
        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },
    });
    // Initialization and round constants tables
    var H = [];
    var K = [];
    // Compute constants
    (function () {
        function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n % factor)) {
                    return false;
                }
            }
            return true;
        }
        function getFractionalBits(n) {
            return ((n - (n | 0)) * 0x100000000) | 0;
        }
        var n = 2;
        var nPrime = 0;
        while (nPrime < 64) {
            if (isPrime(n)) {
                if (nPrime < 8) {
                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                }
                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
                nPrime++;
            }
            n++;
        }
    }());
    // Reusable object
    var W = [];
    /**
     * SHA-256 hash algorithm.
     */
    var SHA256 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init(H.slice(0));
        },
        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;
            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];
            // Computation
            for (var i = 0; i < 64; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                }
                else {
                    var gamma0x = W[i - 15];
                    var gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^
                        ((gamma0x << 14) | (gamma0x >>> 18)) ^
                        (gamma0x >>> 3);
                    var gamma1x = W[i - 2];
                    var gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                        ((gamma1x << 13) | (gamma1x >>> 19)) ^
                        (gamma1x >>> 10);
                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                }
                var ch = (e & f) ^ (~e & g);
                var maj = (a & b) ^ (a & c) ^ (b & c);
                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));
                var t1 = h + sigma1 + ch + K[i] + W[i];
                var t2 = sigma0 + maj;
                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }
            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
            H[5] = (H[5] + f) | 0;
            H[6] = (H[6] + g) | 0;
            H[7] = (H[7] + h) | 0;
        },
        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            // Hash final blocks
            this._process();
            // Return final computed hash
            return this._hash;
        },
        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
        }
    });
    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA256('message');
     *     var hash = CryptoJS.SHA256(wordArray);
     */
    C.SHA256 = Hasher._createHelper(SHA256);
    return C;
});

define('js/pointrel20150417/stringToUtf8',["require", "exports"], function (require, exports) {
    "use strict";
    // From http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
    function stringToUtf8(input) {
        return unescape(encodeURIComponent(input));
    }
    ;
    return stringToUtf8;
});

define('js/pointrel20150417/topic',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var subscriptions = {};
    var subscriptionsCount = 0;
    function subscribe(topic, callback) {
        var topicKey = JSON.stringify(topic);
        if (!subscriptions[topicKey])
            subscriptions[topicKey] = {};
        var uniqueIndex = subscriptionsCount++;
        subscriptions[topicKey][uniqueIndex] = callback;
        // Return a handle with a remove function to remove this this subscription
        return {
            remove: function () {
                delete subscriptions[topicKey][uniqueIndex];
            }
        };
    }
    exports.subscribe = subscribe;
    function publish(topic) {
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            data[_i - 1] = arguments[_i];
        }
        var topicKey = JSON.stringify(topic);
        if (!subscriptions[topicKey])
            return;
        var callbacksForTopic = subscriptions[topicKey];
        for (var callbackKey in callbacksForTopic) {
            var callback = callbacksForTopic[callbackKey];
            callback.apply(null, data);
        }
    }
    exports.publish = publish;
});

// Pointrel20150417 for NodeJS and WordPress
// The focus is on client getting all messages of interest as they are received by the server and indexing them locally
// Each message needs to have enough easily available metadata for the server and client to do that filtering
define('js/pointrel20150417/PointrelClient',["require", "exports", "./sha256", "./stringToUtf8", "./topic"], function (require, exports, sha256, stringToUtf8, topic) {
    "use strict";
    "use strict";
    var defaultCheckFrequency_ms = 15000;
    var shortTimeout_ms = 10000;
    var longTimeout_ms = 30000;
    var debugMessaging = false;
    ;
    var PointrelClient = (function () {
        function PointrelClient(apiURL, journalIdentifier, userCredentials, messageReceivedCallback, serverStatusCallback) {
            if (messageReceivedCallback === void 0) { messageReceivedCallback = null; }
            if (serverStatusCallback === void 0) { serverStatusCallback = null; }
            this.apiURL = null;
            this.journalIdentifier = null;
            this.userIdentifier = null;
            this.started = false;
            this.frequencyOfChecks_ms = defaultCheckFrequency_ms;
            this.timer = null;
            // By default, includeMessageContents of true will retrieve the message contents when polling to reduce back-and-forth latency to server
            // Clients might want to turn this off if they cache messages locally
            // or if they application selectively downloads big messages like images or other media perhaps depending on the topic they are in
            this.includeMessageContents = true;
            // This field is used to ensure only one request at a time is sent to the server
            this.outstandingServerRequestSentAtTimestamp = null;
            // TODO: This flag may no longer be needed on the client libary side; app should implement something like it somehow?
            this.serverResponseWarningIssued = false;
            this.lastReceivedTimestampConsidered = null;
            this.incomingMessageRecords = [];
            this.messagesSortedByReceivedTimeArray = [];
            this.sha256AndLengthToMessageMap = {};
            this.areOutgoingMessagesSuspended = false;
            this.outgoingMessageQueue = [];
            this.messageReceivedCallback = null;
            this.serverStatusCallback = null;
            this.messageSentCount = 0;
            this.messageReceivedCount = 0;
            this.topicIdentifier = undefined;
            this.idleCallback = null;
            if (!apiURL)
                throw new Error("No apiURL supplied");
            if (!journalIdentifier)
                throw new Error("No journalIdentifier supplied");
            if (!userCredentials)
                throw new Error("No userCredentials supplied");
            if (typeof userCredentials === "string" || userCredentials instanceof String) {
                userCredentials = {
                    userIdentifier: userCredentials
                };
            }
            // Use the WordPress AJAX api instead as an override if it is defined
            this.apiURL = window["ajaxurl"] || apiURL;
            this.journalIdentifier = journalIdentifier;
            this.userIdentifier = userCredentials.userIdentifier;
            // private variable to protect against access by other code; see: http://javascript.crockford.com/private.html
            var _userCredentials = userCredentials;
            // privileged method that can access private variable
            this["_prepareApiRequestForSending"] = function (apiRequest) {
                apiRequest.userCredentials = _userCredentials;
            };
            this.messageReceivedCallback = messageReceivedCallback;
            this.serverStatusCallback = serverStatusCallback;
        }
        PointrelClient.prototype.resetJournalContents = function () {
            this.lastReceivedTimestampConsidered = null;
            this.incomingMessageRecords = [];
            this.messagesSortedByReceivedTimeArray = [];
            this.sha256AndLengthToMessageMap = {};
            this.areOutgoingMessagesSuspended = false;
            this.outgoingMessageQueue = [];
        };
        PointrelClient.prototype.prepareApiRequestForSending = function (apiRequest) {
            // Call privileged method that can access private variable
            return this["_prepareApiRequestForSending"](apiRequest);
        };
        // This should be called to start the polling process to keep a client up-to-date with what is in a Journal
        // You should not start polling though if you just want to get the latest message in a topic
        //  like for an application that selectively loads just a bit of published data
        PointrelClient.prototype.startup = function () {
            console.log(new Date().toISOString(), "starting up PointrelClient", this);
            if (this.apiURL === "loopback") {
                console.log("No polling done on loopback");
            }
            else {
                this.started = true;
                this.startTimer();
                this.pollServerForNewMessages();
            }
        };
        // Call this to shut down polling, like when you destroy a related GUI component
        PointrelClient.prototype.shutdown = function () {
            console.log(new Date().toISOString(), "shutting down PointrelClient", this);
            this.stopTimer();
            this.started = false;
        };
        /*
        createAndSendAddTriplesMessage(topicIdentifier, triples) {
            const change = {
                action: "addTriples",
                triples: triples
            };
            return this.createAndSendChangeMessage(topicIdentifier, "TripleStore", change);
        }
        */
        PointrelClient.prototype.apiRequestSend = function (apiRequest, timeout_ms, successCallback, errorCallback) {
            var httpRequest = new XMLHttpRequest();
            httpRequest.onreadystatechange = function () {
                if (httpRequest.readyState === 4) {
                    if (httpRequest.status >= 200 && httpRequest.status < 300) {
                        if (successCallback) {
                            try {
                                var response = JSON.parse(httpRequest.responseText);
                                successCallback(response);
                            }
                            catch (error) {
                                var message = 'Error: Unexpected XMLHttpRequest.responseText (should be JSON format):\n\n' + httpRequest.responseText;
                                console.error(message);
                                alert(message);
                                errorCallback({ status: httpRequest.status, message: httpRequest.responseText });
                            }
                        }
                    }
                    else {
                        // TODO: Might these sometimes be JSON?
                        if (errorCallback)
                            errorCallback({ status: httpRequest.status, message: httpRequest.responseText });
                    }
                }
            };
            httpRequest.ontimeout = function () {
                errorCallback({ status: 0, message: "Timeout" });
            };
            var isWordPressAJAX = !!window["ajaxurl"];
            var apiURL = this.apiURL;
            var contentType = 'application/json; charset=utf-8';
            var data = JSON.stringify(apiRequest);
            if (isWordPressAJAX) {
                apiURL = apiURL + "?action=pointrel20150417";
            }
            httpRequest.open('POST', apiURL, true);
            httpRequest.setRequestHeader('Content-Type', contentType);
            httpRequest.setRequestHeader("Accept", "application/json");
            httpRequest.timeout = timeout_ms;
            httpRequest.send(data);
        };
        PointrelClient.prototype.createChangeMessage = function (topicIdentifier, messageType, change, other) {
            var timestamp = this.getCurrentUniqueTimestamp();
            var message = {
                // TODO: Simplify redundancy in timestamps
                _topicIdentifier: topicIdentifier,
                _topicTimestamp: timestamp,
                // messageIdentifier: generateRandomUuid("Message"), // Is this needed, as we have a unique ID from SHA256?
                creator: this.userIdentifier,
                creationTimestamp: timestamp,
                // TODO: createdAfter: something involving incoming records...
                messageType: messageType,
                change: change
            };
            if (other) {
                for (var key in other) {
                    message[key] = other[key];
                }
            }
            return message;
        };
        PointrelClient.prototype.createAndSendChangeMessage = function (topicIdentifier, messageType, change, other, callback) {
            var message = this.createChangeMessage(topicIdentifier, messageType, change, other);
            this.sendMessage(message, callback);
            return message;
        };
        // Suggested to use createAndSendChangeMessage instead, unless you are doing a special import
        PointrelClient.prototype.sendMessage = function (message, callback) {
            if (debugMessaging)
                console.log("sendMessage", this.areOutgoingMessagesSuspended, message);
            // Calculate the sha256AndLength without the pointrel fields
            delete message.__pointrel_sha256AndLength;
            var oldTrace = message.__pointrel_trace;
            delete message.__pointrel_trace;
            message.__pointrel_sha256AndLength = PointrelClient.makeSHA256AndLength(PointrelClient.calculateCanonicalSHA256AndLengthForObject(message));
            // TODO: Maybe should put in local sender information here?
            if (!oldTrace)
                oldTrace = [];
            message.__pointrel_trace = oldTrace;
            // TODO: What should really go in this trace entry if anything???
            var traceEntry = {
                // TODO: Should sentBy be used???
                sentByClient: this.userIdentifier,
                // TODO: Should the journalIdentifier really be split from the URL?
                sentToJournalIdentifier: this.journalIdentifier,
                sentToURL: this.apiURL,
                sentTimestamp: PointrelClient.getCurrentUniqueTimestamp()
            };
            message.__pointrel_trace.push(traceEntry);
            var previouslySent = this.sha256AndLengthToMessageMap[message.__pointrel_sha256AndLength];
            if (previouslySent) {
                console.log("A message with the same sha256AndLength was previously received (supplied/existing)", message, previouslySent);
                throw new Error("Trying to send a message with the same sha256AndLength of a message previously received");
            }
            // TODO: Extra copyObjectWithSortedKeys is not needed, but makes log messages look nicer so leaving for now
            message = PointrelClient.copyObjectWithSortedKeys(message);
            // TODO: This field ideally should go in a wrapper object and will be deleted later
            if (callback)
                message.__pointrel_callback = callback;
            this.outgoingMessageQueue.push(message);
            this.sendOutgoingMessage();
        };
        PointrelClient.prototype.suspendOutgoingMessages = function (suspend) {
            console.log("suspendOutgoingMessages", suspend);
            if (this.areOutgoingMessagesSuspended === suspend)
                return;
            this.areOutgoingMessagesSuspended = suspend;
            if (!this.areOutgoingMessagesSuspended) {
                this.sendOutgoingMessage();
            }
        };
        PointrelClient.prototype.fetchLatestMessageForTopic = function (topicIdentifier, callback) {
            var self = this;
            if (this.apiURL === "loopback") {
                callback(null, {
                    success: true,
                    statusCode: 200,
                    description: "Success",
                    detail: "latest",
                    timestamp: this.getCurrentUniqueTimestamp(),
                    status: 'OK',
                    currentTimestamp: this.getCurrentUniqueTimestamp(),
                    latestRecord: {
                        messageContents: self.latestMessageForTopic(topicIdentifier),
                        // TODO: Fill these in correctly
                        sha256AndLength: null,
                        receivedTimestamp: null,
                        topicTimestamp: null
                    }
                });
            }
            else {
                // Send to a real server immediately
                var apiRequest = {
                    action: "pointrel20150417_queryForLatestMessage",
                    journalIdentifier: this.journalIdentifier,
                    topicIdentifier: topicIdentifier
                };
                if (debugMessaging)
                    console.log("sending queryForLatestMessage request", apiRequest);
                this.prepareApiRequestForSending(apiRequest);
                // Do not set outstandingServerRequestSentAtTimestamp as this is an immediate request that does not block polling
                this.serverStatus("waiting", "requesting latest message " + new Date().toISOString());
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got latest message for topic response", response);
                    if (!response.success) {
                        console.log("ERROR: report queryForLatestMessage failure", response);
                        self.serverStatus("failure", "Report queryForLatestMessage failure: " + response.statusCode + " :: " + response.description);
                        callback(response || "Failed");
                    }
                    else {
                        self.okStatus();
                        callback(null, response);
                    }
                }, function (error) {
                    self.serverStatus("failure", "Problem fetching latest message for topic from server: " + error.message);
                    console.log("Got server error when fetching latest message for topic from server", error.message);
                    callback(error);
                });
            }
        };
        PointrelClient.prototype.createJournal = function (journalIdentifier, callback) {
            if (this.apiURL === "loopback") {
                callback(null, {
                    success: true,
                    statusCode: 200,
                    description: "Success",
                    timestamp: this.getCurrentUniqueTimestamp(),
                    status: 'OK',
                    version: "PointrelServer-loopback",
                    currentUniqueTimestamp: this.getCurrentUniqueTimestamp(),
                    journalIdentifier: journalIdentifier
                });
            }
            else {
                // Send to a real server immediately
                var apiRequest = {
                    action: "pointrel20150417_createJournal",
                    journalIdentifier: journalIdentifier
                };
                if (debugMessaging)
                    console.log("sending createJournal request", apiRequest);
                this.prepareApiRequestForSending(apiRequest);
                // Do not set outstandingServerRequestSentAtTimestamp as this is an immediate request that does not block polling
                this.serverStatus("waiting", "requesting createJournal " + new Date().toISOString());
                var self_1 = this;
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got createJournal response", response);
                    if (!response.success) {
                        console.log("ERROR: report createJournal failure", response);
                        self_1.serverStatus("failure", "Report createJournal failure: " + response.statusCode + " :: " + response.description);
                        callback(response || "Failed");
                    }
                    else {
                        self_1.okStatus();
                        callback(null, response);
                    }
                }, function (error) {
                    self_1.serverStatus("failure", "Problem with createJournal from server: " + error.description);
                    console.log("Got server error for createJournal", error.message);
                    callback(error);
                });
            }
        };
        PointrelClient.prototype.resetJournal = function (journalIdentifier, callback) {
            if (this.apiURL === "loopback") {
                callback(null, {
                    success: true,
                    statusCode: 200,
                    description: "Success",
                    timestamp: this.getCurrentUniqueTimestamp(),
                    status: 'OK',
                    version: "PointrelServer-loopback",
                    currentUniqueTimestamp: this.getCurrentUniqueTimestamp(),
                    journalIdentifier: journalIdentifier
                });
            }
            else {
                // Send to a real server immediately
                var apiRequest = {
                    action: "pointrel20150417_resetJournal",
                    journalIdentifier: journalIdentifier
                };
                if (debugMessaging)
                    console.log("sending resetJournal request", apiRequest);
                this.prepareApiRequestForSending(apiRequest);
                // Do not set outstandingServerRequestSentAtTimestamp as this is an immediate request that does not block polling
                this.serverStatus("waiting", "requesting resetJournal " + new Date().toISOString());
                var self_2 = this;
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got resetJournal response", response);
                    if (!response.success) {
                        console.log("ERROR: report resetJournal failure", response);
                        self_2.serverStatus("failure", "Report resetJournal failure: " + response.statusCode + " :: " + response.description);
                        callback(response || "Failed");
                    }
                    else {
                        self_2.okStatus();
                        self_2.resetJournalContents();
                        callback(null, response);
                    }
                }, function (error) {
                    self_2.serverStatus("failure", "Problem with resetJournal from server: " + error.description);
                    console.log("Got server error for resetJournal", error.message);
                    callback(error);
                });
            }
        };
        PointrelClient.prototype.hideJournal = function (journalIdentifier, callback) {
            if (this.apiURL === "loopback") {
                callback(null, {
                    success: true,
                    statusCode: 200,
                    description: "Success",
                    timestamp: this.getCurrentUniqueTimestamp(),
                    status: 'OK',
                    version: "PointrelServer-loopback",
                    currentUniqueTimestamp: this.getCurrentUniqueTimestamp(),
                    journalIdentifier: journalIdentifier
                });
            }
            else {
                // Send to a real server immediately
                var apiRequest = {
                    action: "pointrel20150417_hideJournal",
                    journalIdentifier: journalIdentifier
                };
                if (debugMessaging)
                    console.log("sending hideJournal request", apiRequest);
                this.prepareApiRequestForSending(apiRequest);
                // Do not set outstandingServerRequestSentAtTimestamp as this is an immediate request that does not block polling
                this.serverStatus("waiting", "requesting hideJournal " + new Date().toISOString());
                var self_3 = this;
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got hideJournal response", response);
                    if (!response.success) {
                        console.log("ERROR: report hideJournal failure", response);
                        self_3.serverStatus("failure", "Report hideJournal failure: " + response.statusCode + " :: " + response.description);
                        callback(response || "Failed");
                    }
                    else {
                        self_3.okStatus();
                        //self.resetJournalContents();  don't need this because it is only called from the admin screen
                        callback(null, response);
                    }
                }, function (error) {
                    self_3.serverStatus("failure", "Problem with hideJournal from server: " + error.description);
                    console.log("Got server error for hideJournal", error.message);
                    callback(error);
                });
            }
        };
        PointrelClient.prototype.reportJournalStatus = function (callback) {
            if (this.apiURL === "loopback") {
                callback(null, {
                    success: true,
                    statusCode: 200,
                    description: "Success",
                    timestamp: this.getCurrentUniqueTimestamp(),
                    status: 'OK',
                    version: "PointrelServer-loopback",
                    currentUniqueTimestamp: this.getCurrentUniqueTimestamp(),
                    journalIdentifier: this.journalIdentifier,
                    // TODO: need to create earliest and latest record for loopback using messagesSortedByReceivedTimeArray
                    journalEarliestRecord: null,
                    journalLatestRecord: null,
                    journalRecordCount: this.messagesSortedByReceivedTimeArray.length,
                    readOnly: false,
                    permissions: {
                        read: true,
                        write: true,
                        admin: true,
                        superUser: true
                    }
                });
            }
            else {
                // Send to a real server immediately
                var apiRequest = {
                    action: "pointrel20150417_reportJournalStatus",
                    journalIdentifier: this.journalIdentifier
                };
                if (debugMessaging)
                    console.log("sending reportJournalStatus request", apiRequest);
                this.prepareApiRequestForSending(apiRequest);
                // Do not set outstandingServerRequestSentAtTimestamp as this is an immediate request that does not block polling
                this.serverStatus("waiting", "requesting journal status " + new Date().toISOString());
                var self_4 = this;
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got journal status response", response);
                    if (!response.success) {
                        console.log("ERROR: report journal status failure", response);
                        self_4.serverStatus("failure", "Report journal status failure: " + response.statusCode + " :: " + response.description);
                        callback(response || "Failed");
                    }
                    else {
                        self_4.okStatus();
                        callback(null, response);
                    }
                }, function (error) {
                    self_4.serverStatus("failure", "Problem requesting status for journal from server: " + error.message);
                    console.log("Got server error for report journal status", error.message);
                    callback(error);
                });
            }
        };
        PointrelClient.prototype.getCurrentUserInformation = function (callback) {
            if (this.apiURL === "loopback") {
                callback(null, {
                    success: true,
                    statusCode: 200,
                    description: "Success",
                    timestamp: this.getCurrentUniqueTimestamp(),
                    status: 'OK',
                    userIdentifier: this.userIdentifier
                });
            }
            else {
                // Send to a real server immediately
                var apiRequest = {
                    action: "pointrel20150417_currentUserInformation"
                };
                if (debugMessaging)
                    console.log("sending currentUserInformation request", apiRequest);
                // Do not send credentials: this.prepareApiRequestForSending(apiRequest);
                // Do not set outstandingServerRequestSentAtTimestamp as this is an immediate request that does not block polling
                this.serverStatus("waiting", "requesting current user information " + new Date().toISOString());
                var self_5 = this;
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got currentUserInformation response", response);
                    if (!response.success) {
                        console.log("ERROR: currentUserInformation request failure", response);
                        self_5.serverStatus("failure", "Current user information request failure: " + response.statusCode + " :: " + response.description);
                        callback(response || "Failed");
                    }
                    else {
                        self_5.okStatus();
                        callback(null, response);
                    }
                }, function (error) {
                    self_5.serverStatus("failure", "Problem requesting current user information from server: " + error.message);
                    console.log("Got server error for current user information", error.message);
                    callback(error);
                });
            }
        };
        PointrelClient.prototype.latestMessageForTopic = function (topicIdentifier) {
            // TODO: Inefficient to search all messages; keep sorted message list per topic or just track latest for each topic?
            var messages = this.messagesSortedByReceivedTimeArray;
            for (var i = messages.length - 1; i >= 0; i--) {
                var message = messages[i];
                if (message._topicIdentifier === topicIdentifier) {
                    return message;
                }
            }
            return null;
        };
        PointrelClient.prototype.filterMessages = function (filterFunction) {
            return this.messagesSortedByReceivedTimeArray.filter(filterFunction);
        };
        PointrelClient.prototype.getCurrentUniqueTimestamp = function () {
            return PointrelClient.getCurrentUniqueTimestamp();
        };
        /* TODO: Maybe make these other static utility functions available at instance levels?
        PointrelClient.prototype.copyObjectWithSortedKeys = copyObjectWithSortedKeys;
        PointrelClient.prototype.randomUUID = generateRandomUuid;
        PointrelClient.prototype.calculateCanonicalSHA256AndLengthForObject = calculateCanonicalSHA256AndLengthForObject;
        PointrelClient.prototype.calculateSHA256 = calculateSHA256;
        */
        // TODO: Next few from server code -- should have common routines to avoid duplicate code
        // TODO: Note that this approach depends on object keys maintaining their order, which is not guaranteed by the JS standards but most browsers support it
        // isObject and copyObjectWithSortedKeys are from Mirko Kiefer (with added semicolons):
        // https://raw.githubusercontent.com/mirkokiefer/canonical-json/master/index2.js
        PointrelClient.isObject = function (a) {
            return Object.prototype.toString.call(a) === '[object Object]';
        };
        PointrelClient.copyObjectWithSortedKeys = function (object) {
            if (PointrelClient.isObject(object)) {
                var newObj = {};
                var keysSorted = Object.keys(object).sort();
                for (var i = 0, len = keysSorted.length; i < len; i++) {
                    var key = keysSorted[i];
                    newObj[key] = PointrelClient.copyObjectWithSortedKeys(object[key]);
                }
                return newObj;
            }
            else if (Array.isArray(object)) {
                return object.map(PointrelClient.copyObjectWithSortedKeys);
            }
            else {
                return object;
            }
        };
        PointrelClient.makeSHA256AndLength = function (sha256AndLengthObject) {
            if (!sha256AndLengthObject.sha256 || !sha256AndLengthObject.length) {
                console.log("Problem making sha256AndLength identifier", sha256AndLengthObject);
                throw new Error("Problem making sha256AndLength identifier from: " + JSON.stringify(sha256AndLengthObject));
            }
            return sha256AndLengthObject.sha256 + "_" + sha256AndLengthObject.length;
        };
        PointrelClient.calculateCanonicalSHA256AndLengthForObject = function (someObject, doNotSortFlag) {
            if (doNotSortFlag === void 0) { doNotSortFlag = false; }
            if (!doNotSortFlag)
                someObject = PointrelClient.copyObjectWithSortedKeys(someObject);
            var minimalJSON = JSON.stringify(someObject);
            // const buffer = new Buffer(minimalJSON, "utf8");
            // console.log("minimalJSON", minimalJSON);
            //let max = 0;
            //for (let i = 0; i < minimalJSON.length; i++) {
            //    const c = minimalJSON.charAt(i);
            //    if (minimalJSON.charCodeAt(i) > 127) console.log("i # c", i, minimalJSON.charCodeAt(i), c);
            //    if (minimalJSON.charCodeAt(i) > max) max = minimalJSON.charCodeAt(i);
            //}
            //console.log("max", max);
            var utf8String = stringToUtf8(minimalJSON);
            //console.log("utf8String", utf8String);
            // console.log("match?", minimalJSON === utf8String, "minimal length", minimalJSON.length, "utf8 length", utf8String.length);
            //for (let i = 0; i < minimalJSON.length; i++) {
            //    console.log("char at i", i, minimalJSON[i]);
            //}
            /*
            const shaObj = new JS_SHA("SHA-256", "TEXT");
            shaObj.update(minimalJSON);
            // console.log("Without string conversion", shaObj.getHash("HEX"));
            */
            var sha256 = PointrelClient.calculateSHA256(minimalJSON);
            var length = utf8String.length;
            var sha256AndLength = "" + sha256 + "_" + length;
            return { sha256: "" + sha256, length: length };
        };
        PointrelClient.calculateSHA256 = function (text) {
            // console.log("calculateSHA256", utf8Bytes);
            return "" + sha256.SHA256(text);
        };
        // Ensure unique timestamps are always incremented from the next by adding values at end...
        // In theory, if the server were to be stopped and be restarted in the same millisecond, these values could overlap for a millisecond in the new session
        PointrelClient.getCurrentUniqueTimestamp = function () {
            // TODO: Add random characters at end of number part of timestamp before Z
            var currentTimestamp = new Date().toISOString();
            var randomNumber = Math.floor(Math.random() * 1000);
            var randomPadding = (PointrelClient.timestampRandomPadding + randomNumber).slice(-(PointrelClient.timestampRandomPadding.length));
            if (PointrelClient.lastTimestamp !== currentTimestamp) {
                PointrelClient.lastTimestamp = currentTimestamp;
                PointrelClient.lastTimestampIncrement = 0;
                return currentTimestamp.replace("Z", PointrelClient.timestampIncrementPadding + randomPadding + "Z");
            }
            // Need to increment timestamp;
            PointrelClient.lastTimestampIncrement++;
            if (PointrelClient.lastTimestampIncrement === 1000) {
                // About to overrun timestamps -- this should probably never be possible in practice
                // on a single thread doing any actual work other than a tight loop for a couple decades (circa 2015).
                // Possible short-term fix is to pad "999999" then add more digits afterwards;
                // long-term fix is to add more zeros to padding string or have better approach
                // Note also that if this condition is reached, ISO timestamp comparisons could be incorrect
                // as the final "Z" interferes with collation
                // Another temporary option would be to introduce a delay in this situation to get
                // to the next millisecond before the timestamp's final text value is determined
                console.log("getCurrentUniqueTimestamp: failure with timestamp padding from fast CPU -- add more timestamp padding");
            }
            var extraDigits = (PointrelClient.timestampIncrementPadding + PointrelClient.lastTimestampIncrement).slice(-(PointrelClient.timestampIncrementPadding.length));
            currentTimestamp = currentTimestamp.replace("Z", extraDigits + randomPadding + "Z");
            return currentTimestamp;
        };
        // End -- from server
        // ------------- Internal methods below not meant to be called by users
        PointrelClient.prototype.sendOutgoingMessage = function () {
            var callback;
            if (debugMessaging)
                console.log("sendOutgoingMessage");
            if (this.outgoingMessageQueue.length === 0)
                return;
            if (debugMessaging)
                console.log("sendOutgoingMessage proceeding");
            var self = this;
            if (this.apiURL === "loopback" || this.areOutgoingMessagesSuspended) {
                // Pretend to send all the outgoing messages we have
                while (this.outgoingMessageQueue.length) {
                    var loopbackMessage = this.outgoingMessageQueue.shift();
                    callback = loopbackMessage.__pointrel_callback;
                    if (callback !== undefined)
                        delete loopbackMessage.__pointrel_callback;
                    this.messageSentCount++;
                    // Simulating eventual response from server, generally for testing
                    this.messageReceived(PointrelClient.copyObjectWithSortedKeys(loopbackMessage));
                    if (callback)
                        callback(null, { success: true });
                }
            }
            else {
                // Send to a real server
                // Wait for later if a request is outstanding already, like polling for new messages
                if (this.outstandingServerRequestSentAtTimestamp)
                    return;
                // If this fails, and there is no callback, this will leave message on outgoing queue (unless it was rejected for some reason)
                // If there is a callback, the message will be discarded as presumably the caller will handle resending it
                var message = this.outgoingMessageQueue[0];
                callback = message.__pointrel_callback;
                if (callback !== undefined)
                    delete message.__pointrel_callback;
                var apiRequest = {
                    action: "pointrel20150417_storeMessage",
                    journalIdentifier: this.journalIdentifier,
                    message: message
                };
                if (debugMessaging)
                    console.log("sending store message request", apiRequest);
                this.prepareApiRequestForSending(apiRequest);
                this.outstandingServerRequestSentAtTimestamp = new Date();
                this.serverStatus("waiting", "storing " + this.outstandingServerRequestSentAtTimestamp);
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got store response", response);
                    self.outstandingServerRequestSentAtTimestamp = null;
                    if (!response.success) {
                        console.log("ERROR: Message store failure", response, self.outgoingMessageQueue[0], JSON.stringify(self.outgoingMessageQueue[0]));
                        if (callback) {
                            self.serverStatus("failure", "Message store failure: " + response.statusCode + " :: " + response.description);
                            // Discard the message from the queue as presumably the caller will resend it
                            self.outgoingMessageQueue.shift();
                            callback(response || "Failed");
                            return;
                        }
                        // Need to otherwise decide whether to discard the message based on the nature of the problem
                        // Should leave it in the queue if it is not malformed and it is just a possibly temporary problem with server
                        // If the message we sent was rejected because it was malformed or a duplicate, we should discard it
                        // Do not continue with requests until next poll...
                        // TODO: Should we not discard messages for an internal server error (500)?
                        if (response.statusCode !== "403") {
                            // Discard all problematical messages except for ones that are not authenticated and might succeed if resent after (re)authetication
                            self.outgoingMessageQueue.shift();
                            self.serverStatus("failure-loss", "Data loss from message store failure: " + response.statusCode + " :: " + response.description);
                        }
                        return;
                    }
                    else {
                        self.okStatus();
                        self.messageSentCount++;
                        self.outgoingMessageQueue.shift();
                    }
                    // Keep sending outgoing messages if there are any more, or do other task as needed
                    // Do this as a timeout so the event loop can finish its cycle first
                    // Only do this if polling has been started; otherwis just assume user is sending individual messages
                    if (callback)
                        callback(null, response);
                    if (self.started) {
                        setTimeout(function () {
                            // Could instead just send outgoing messages and let the timer restart the others, this will cause some extra polls
                            self.sendFetchOrPollIfNeeded();
                        }, 0);
                    }
                }, function (error) {
                    // TODO: Need to check for rejected status and then remove the message from the outgoing queue
                    self.serverStatus("failure", "Problem storing message to server: " + error.message +
                        "<br>You may need to reload the page to synchronize it with the current state of the server if a message was rejected for some reason.");
                    console.log("Got store error", error.message);
                    self.outstandingServerRequestSentAtTimestamp = null;
                    if (callback) {
                        // Discard the message from the queue as presumably the caller will resend it
                        self.outgoingMessageQueue.shift();
                        callback(error);
                    }
                });
            }
        };
        PointrelClient.prototype.messageReceived = function (message) {
            // if (debugMessaging) console.log("messageReceived", JSON.stringify(message, null, 2));
            if (!message) {
                console.log("ERROR: Problem with server response. No message!");
                return;
            }
            this.messageReceivedCount++;
            // Ignore the message if we already have it
            if (this.sha256AndLengthToMessageMap[message.__pointrel_sha256AndLength]) {
                // console.log("Message already received", message.__pointrel_sha256AndLength);
                return;
            }
            if (!message.__pointrel_trace)
                message.__pointrel_trace = [];
            // TODO: Still unsure about how to implement trace???
            var traceEntry = {
                // TODO: Should receivedBy be used???
                receivedByClient: this.userIdentifier,
                // TODO: Should the journalIdentifier really be split from the URL?
                receivedFromJournalIdentifier: this.journalIdentifier,
                receivedFromURL: this.apiURL,
                receivedTimestamp: this.getCurrentUniqueTimestamp()
            };
            message.__pointrel_trace.push(traceEntry);
            // TODO: Make sure the list stays sorted -- copy code from server
            this.messagesSortedByReceivedTimeArray.push(message);
            this.sha256AndLengthToMessageMap[message.__pointrel_sha256AndLength] = message;
            // TODO: Maybe do excepting handling for callback, as otherwise could break incoming message handling?
            if (this.messageReceivedCallback)
                this.messageReceivedCallback(message);
            topic.publish("messageReceived", message);
            if (message.messageType) {
                // console.log("publishing message", message);
                topic.publish(message.messageType, message);
            }
        };
        // Start boiler plate for timer management
        PointrelClient.prototype.startTimer = function () {
            // Stop the timer in case it was running already
            // TODO: Is stopTimer/clearTimeout safe to call if the timer has already completed?
            this.stopTimer();
            this.timer = window.setTimeout(this.timerSentSignal.bind(this), this.frequencyOfChecks_ms);
        };
        PointrelClient.prototype.stopTimer = function () {
            if (this.timer) {
                window.clearTimeout(this.timer);
                this.timer = null;
            }
        };
        // In addition to doing polling if there are no other messages to send or recieve,
        // the timer will give everything a kick to get going again shortly after something errors out
        PointrelClient.prototype.timerSentSignal = function () {
            // if (debugMessaging) console.log(new Date().toISOString(), "should do check now for new messages", this);
            this.timer = null;
            // catch any exceptions to ensure timer is started again
            try {
                this.sendFetchOrPollIfNeeded();
            }
            catch (e) {
                console.log("Exception when trying to server for changes", e);
            }
            this.startTimer();
        };
        PointrelClient.prototype.sendFetchOrPollIfNeeded = function () {
            // TODO: Prioritizing outgoing messages -- might want to revisit this for some applications?
            if (!this.areOutgoingMessagesSuspended && this.outgoingMessageQueue.length) {
                this.sendOutgoingMessage();
            }
            else if (this.incomingMessageRecords.length) {
                this.fetchIncomingMessage();
            }
            else {
                this.pollServerForNewMessages();
            }
        };
        // End boilerplate for timer management
        PointrelClient.prototype.pollServerForNewMessages = function () {
            // Do not poll if the document is not visible
            if (document.hidden === true) {
                // console.log("pollServerForNewMessages: not polling because not visible");
                return;
            }
            if (this.outstandingServerRequestSentAtTimestamp) {
                // TODO: Warn if connection seems to have failed
                console.log("Still waiting on previous server request");
                var waiting_ms = new Date().getTime() - this.outstandingServerRequestSentAtTimestamp.getTime();
                console.log("Have been waiting on server for waiting_ms", waiting_ms);
                if (waiting_ms > 10000) {
                    // Should never get here if timeout is 2000ms and timers get the process restarted
                    if (!this.serverResponseWarningIssued) {
                        console.log("Server not responding");
                        this.serverStatus("falure", "The server is not responding...");
                        this.serverResponseWarningIssued = true;
                    }
                }
                return;
            }
            if (debugMessaging)
                console.log("Polling server for changes...");
            var apiRequest = {
                action: "pointrel20150417_queryForNextMessage",
                journalIdentifier: this.journalIdentifier,
                fromTimestampExclusive: this.lastReceivedTimestampConsidered,
                // The server may return less than this number of message if including message contents and they exceed about 1MB in total
                limitCount: 100,
                includeMessageContents: this.includeMessageContents,
                topicIdentifier: undefined
            };
            if (this.topicIdentifier !== undefined) {
                apiRequest.topicIdentifier = this.topicIdentifier;
            }
            if (debugMessaging)
                console.log("sending polling request", apiRequest);
            this.prepareApiRequestForSending(apiRequest);
            // TODO: What do do if it fails? Leave message on outgoing queue?
            this.outstandingServerRequestSentAtTimestamp = new Date();
            this.serverStatus("waiting", "polling " + this.outstandingServerRequestSentAtTimestamp);
            var self = this;
            // Use longer timeout to account for reading multiple records on server
            this.apiRequestSend(apiRequest, longTimeout_ms, function (response) {
                if (debugMessaging)
                    console.log("Got query response", response);
                if (!response.success) {
                    console.log("Response was a failure", response);
                    self.serverStatus("failure", "Polling response failure: " + response.statusCode + " :: " + response.description);
                }
                else {
                    self.okStatus();
                    for (var i = 0; i < response.receivedRecords.length; i++) {
                        var receivedRecord = response.receivedRecords[i];
                        // if (debugMessaging) console.log("New message", receivedRecord);
                        if (receivedRecord.messageContents !== undefined) {
                            /// console.log("got contents directly", receivedRecord);
                            if (receivedRecord.messageContents !== null) {
                                self.messageReceived(receivedRecord.messageContents);
                            }
                            else {
                                // Would be issue with the messages becoming out of order if did not just reject messages
                                //   with null contents when requesting contents with polling result, like if did a retry instead
                                console.log("Message contents not available for message", receivedRecord);
                            }
                            // delete receivedRecord.messageContents;
                        }
                        else {
                            self.incomingMessageRecords.push(receivedRecord);
                        }
                    }
                    self.lastReceivedTimestampConsidered = response.lastReceivedTimestampConsidered;
                }
                self.outstandingServerRequestSentAtTimestamp = null;
                if (response.receivedRecords && response.receivedRecords.length) {
                    // Schedule another request immediately if getting contents
                    setTimeout(function () {
                        self.sendFetchOrPollIfNeeded();
                    }, 0);
                }
                else {
                    if (self.idleCallback) {
                        var callback = self.idleCallback;
                        self.idleCallback = null;
                        console.log("Doing one-time idle callback");
                        callback();
                    }
                }
            }, function (error) {
                console.log("Got query error", error.message);
                self.serverStatus("failure", "Something went wrong talking to the server when querying for new messages: " + error.message);
                // TODO: How to recover?
                self.outstandingServerRequestSentAtTimestamp = null;
            });
        };
        PointrelClient.prototype.fetchIncomingMessage = function () {
            if (this.incomingMessageRecords.length === 0) {
                this.serverStatus("waiting", "waiting");
                return;
            }
            if (this.outstandingServerRequestSentAtTimestamp)
                return;
            if (debugMessaging)
                console.log("Trying to fetch incoming message");
            var incomingMessageRecord = this.incomingMessageRecords[0];
            if (incomingMessageRecord.messageContents) {
                this.incomingMessageRecords.shift();
                this.messageReceived(incomingMessageRecord.messageContents);
                this.sendFetchOrPollIfNeeded();
                return;
            }
            if (debugMessaging)
                console.log("Retrieving new message...");
            var apiRequest = {
                action: "pointrel20150417_loadMessage",
                journalIdentifier: this.journalIdentifier,
                sha256AndLength: incomingMessageRecord.sha256AndLength,
                topicIdentifier: undefined
            };
            if (this.topicIdentifier !== undefined) {
                // The topicIdentifier is needed in case we only have permission to read within a specific topic
                apiRequest.topicIdentifier = this.topicIdentifier;
            }
            if (debugMessaging)
                console.log("sending load request", apiRequest);
            this.prepareApiRequestForSending(apiRequest);
            this.outstandingServerRequestSentAtTimestamp = new Date();
            this.serverStatus("waiting", "loading " + this.outstandingServerRequestSentAtTimestamp);
            var self = this;
            this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                self.okStatus();
                if (debugMessaging)
                    console.log("Got load response", response);
                self.outstandingServerRequestSentAtTimestamp = null;
                self.incomingMessageRecords.shift();
                if (!response.success) {
                    console.log("Problem retrieving message; response:", response, "for message record:", incomingMessageRecord);
                    // TODO; Is this really a "serverStatus" to display?
                    self.serverStatus("failure", "Message retrieval failure: " + response.statusCode + " :: " + response.description);
                    // TODO: Just assuming that this was an error that the item is not available, as opposed to authentication error or other
                    // TODO: so assuming it is OK to discard it from incomingMessageRecords
                    // TODO: maybe also want to move record to an unavalible records list?
                }
                else {
                    self.messageReceived(response.message);
                }
                // Keep loading incoming messages if there are any more, or do other task as needed
                // Do this as a timeout so the event loop can finish its cycle first
                setTimeout(function () {
                    self.sendFetchOrPollIfNeeded();
                }, 0);
            }, function (error) {
                console.log("Got load error", error.message);
                self.serverStatus("failure", "Something went wrong talking to the server when loading a message: " + error.message);
                self.outstandingServerRequestSentAtTimestamp = null;
            });
        };
        // Status should be ok, waiting, or failure
        PointrelClient.prototype.serverStatus = function (status, message) {
            if (this.serverStatusCallback)
                this.serverStatusCallback(status, message);
        };
        PointrelClient.prototype.okStatus = function () {
            this.serverStatus("ok", "OK (sent: " + this.messageSentCount + ", received: " + this.messageReceivedCount + ")");
        };
        // Variables related to generating unique timestamps
        // Note: timestamp padding needs to get longer as computers get faster
        PointrelClient.lastTimestamp = null;
        PointrelClient.lastTimestampIncrement = 0;
        PointrelClient.timestampIncrementPadding = "000";
        PointrelClient.timestampRandomPadding = "000";
        return PointrelClient;
    }());
    return PointrelClient;
});

define('js/pointrel20150417/TripleStore',["require", "exports", "./topic", "./generateRandomUuid"], function (require, exports, topic, generateRandomUuid) {
    "use strict";
    "use strict";
    function stringUpTo(aString, separator) {
        if (separator !== "") {
            var pieces = aString.split(separator);
            if (pieces.length > 1) {
                return pieces[0];
            }
            else {
                return aString;
            }
        }
        else {
            return aString;
        }
    }
    function replaceAll(str, find, replace) {
        return str.replace(new RegExp(find, 'g'), replace);
    }
    function isUUIDWithDefinedPrefix(text, prefixes) {
        if (!text)
            return false;
        if (typeof text !== "string")
            return false;
        var parts = text.split("_");
        if (parts.length !== 2) {
            return false;
        }
        var possiblePrefix = parts[0], possibleUUID = parts[1];
        if (possibleUUID.length !== 36)
            return false;
        if (!prefixes[possiblePrefix])
            return false;
        return true;
    }
    function mightBeUUID(text) {
        if (!text)
            return false;
        if (typeof text !== "string")
            return false;
        var parts = text.split("_");
        if (parts.length !== 2) {
            return false;
        }
        var possiblePrefix = parts[0], possibleUUID = parts[1];
        if (possibleUUID.length !== 36)
            return false;
        return true;
    }
    function repeatStringNumTimes(string, times) {
        var repeatedString = "";
        while (times > 0) {
            repeatedString += string;
            times--;
        }
        return repeatedString;
    }
    function isObject(a) {
        return Object.prototype.toString.call(a) === '[object Object]';
    }
    function makeTopicKey(object) {
        // TODO: Should really canonicalize the a,b,c values
        return object;
    }
    function defensiveCopy(value) {
        if (value === undefined)
            return value;
        if (value === null)
            return value;
        if (typeof value === "number")
            return value;
        if (typeof value === "string")
            return value;
        if (typeof value === "boolean")
            return value;
        // Value might be mutable, so return a copy of it
        return JSON.parse(JSON.stringify(value));
    }
    var TripleStore = (function () {
        function TripleStore(pointrelClient, topicIdentifier) {
            this.pointrelClient = null;
            this.topicIdentifier = null;
            this.tripleMessages = [];
            this.tripleMessagesBySHA256AndLength = {};
            this.indexABC = {};
            this.subscriptions = [];
            this.pointrelClient = pointrelClient;
            this.topicIdentifier = topicIdentifier;
            this.subscriptions.push(topic.subscribe("messageReceived", this.messageReceivedFromPointrelClient.bind(this)));
        }
        TripleStore.prototype.remove = function () {
            // console.log("TripleStore remove called");
            this.subscriptions.forEach(function (subscription) {
                subscription.remove();
            });
            this.subscriptions = [];
        };
        TripleStore.prototype.makeAddTripleMessage = function (a, b, c) {
            if (a === undefined || b === undefined || c === undefined) {
                throw new Error("Triple should not have undefined fields");
            }
            var triple = {
                a: a,
                b: b,
                c: c
            };
            var change = {
                action: "addTriple",
                triple: triple
            };
            var timestamp = this.pointrelClient.getCurrentUniqueTimestamp();
            var message = {
                _topicIdentifier: this.topicIdentifier,
                _topicTimestamp: timestamp,
                change: change,
                messageType: "tripleStore",
                userIdentifier: this.pointrelClient.userIdentifier
            };
            return message;
        };
        TripleStore.prototype.addTriple = function (a, b, c, callback) {
            // console.log("TripleStore addTriple", a, b, c);
            if (callback === void 0) { callback = undefined; }
            var message = this.makeAddTripleMessage(a, b, c);
            this.pointrelClient.sendMessage(message, callback);
            // Process locally to have current value
            this.processTripleStoreMessage(message);
        };
        TripleStore.prototype.processTripleStoreMessage = function (message) {
            // TODO: Keep the list sorted by time
            this.tripleMessages.push(message);
            this.addMessageToIndexes(message);
        };
        TripleStore.prototype.addMessageToIndexes = function (message) {
            this.tripleMessagesBySHA256AndLength[message.__pointrel_sha256AndLength] = message;
            if (message.change.action === "addTriple") {
                var triple = message.change.triple;
                var aKey = JSON.stringify(triple.a);
                var aIndex = this.indexABC[aKey];
                if (!aIndex) {
                    aIndex = {};
                    this.indexABC[aKey] = aIndex;
                }
                var bKey = JSON.stringify(triple.b);
                var bIndex = aIndex[bKey];
                if (!bIndex) {
                    bIndex = {};
                    aIndex[bKey] = bIndex;
                }
                var versions = bIndex.versions;
                if (!versions) {
                    versions = [];
                    bIndex.versions = versions;
                }
                versions.push(message);
                if (!bIndex.latestCTimestamp || bIndex.latestCTimestamp <= message._topicTimestamp) {
                    bIndex.latestCTimestamp = message._topicTimestamp;
                    bIndex.latestC = triple.c;
                }
            }
        };
        TripleStore.prototype.getIndexEntries = function (a, b) {
            if (b === void 0) { b = undefined; }
            if (a === undefined)
                throw ("a should not be undefined");
            var aKey = JSON.stringify(a);
            var aIndex = this.indexABC[aKey];
            if (!aIndex)
                return null;
            if (b === undefined)
                return aIndex;
            var bKey = JSON.stringify(b);
            var bIndex = aIndex[bKey];
            if (!bIndex)
                return null;
            return bIndex;
        };
        TripleStore.prototype.messageReceivedFromPointrelClient = function (message) {
            // console.log("TripleStore.messageReceivedFromPointrelClient", message);
            if (message.messageType !== "tripleStore")
                return;
            if (message._topicIdentifier !== this.topicIdentifier)
                return;
            if (message.change.action === "addTriple") {
                // Ignore the message if it was previously received (probably because this client sent it)
                // TODO: track sent and bump and report conflicts
                if (this.tripleMessagesBySHA256AndLength[message.__pointrel_sha256AndLength]) {
                    // MAYBE: Could check JSON of stored and received to confirm they are identical
                    // console.log("compare previous/new", previouslyReceivedMessage, message);
                    // console.log("TripleStore message previously received, so ignoring", message);
                    return;
                }
                this.processTripleStoreMessage(message);
                var triple = message.change.triple;
                // console.log("TripleStore: About to publish changes...");
                topic.publish(makeTopicKey({ type: "TripleStore.addTriple" }), triple, message);
                // TODO: Improve this dispatching so don't have to do JSON string conversion
                // Some other common events. Other variations would need to be listened for using the more general event above
                // TODO: Maybe want to distinguish when a later C value is put in that superceeds an old C value
                // console.log("publish", makeTopicKey({type: "TripleStore.addForAB", a: triple.a, b: triple.b}));
                topic.publish(makeTopicKey({ type: "TripleStore.addForA", a: triple.a }), triple, message);
                topic.publish(makeTopicKey({ type: "TripleStore.addForAB", a: triple.a, b: triple.b }), triple, message);
                topic.publish(makeTopicKey({ type: "TripleStore.addForBC", b: triple.b, c: triple.c }), triple, message);
            }
            else {
                console.log("messageReceivedFromPointrelClient: Unsupported action", message);
            }
        };
        TripleStore.prototype.subscribe = function (a, b, c, callback) {
            // console.log("TripleStore.subscribe", a, b, c, callback);
            // TODO: Should these subscriptions be stored in this object or be caller responsibility?
            if (a === undefined && b === undefined && c === undefined) {
                return topic.subscribe(makeTopicKey({ type: "TripleStore.addTriple" }), callback);
            }
            if (a !== undefined) {
                if (b !== undefined) {
                    // console.log("subscribe", makeTopicKey({type: "TripleStore.addForAB", a: a, b: b}));
                    return topic.subscribe(makeTopicKey({ type: "TripleStore.addForAB", a: a, b: b }), callback);
                }
                return topic.subscribe(makeTopicKey({ type: "TripleStore.addForA", a: a }), callback);
            }
            if (b !== undefined) {
                if (c !== undefined) {
                    return topic.subscribe(makeTopicKey({ type: "TripleStore.addForBC", b: b, c: c }), callback);
                }
            }
            // TODO: Need to subscribe to addTriple and do filter
            console.log("Unsupported subscription", a, b, c);
            throw new Error("TripleStore.subscribe: Unfinished -- subscription type not yet supported");
        };
        /*
        // TODO: Optimize with indexes
        // TODO: Ignoring actual timestamps, so only "latest" by receipt is considered, but that is not correct
        // TODO: need to use actual timestamp in sorted comparison to deal with collissions
        queryLatest(a, b, c) {
            // console.log("queryLatest", a, b, c);
            for (let i = this.tripleMessages.length - 1; i >= 0; i--) {
                const tripleMessage = this.tripleMessages[i];
                // console.log("queryLatest loop", i, tripleMessage);
                if ((a === undefined || tripleMessage.change.triple.a === a) &&
                    (b === undefined || tripleMessage.change.triple.b === b) &&
                    (c === undefined || tripleMessage.change.triple.c === c)) {
                    // console.log("match", tripleMessage.change.triple);
                    return tripleMessage.change.triple;
                }
            }
            
            // TODO: Maybe should return empty triple instead?
            return null;
        }
        */
        TripleStore.prototype.queryLatestC = function (a, b) {
            // console.log("queryLatestC", a, b);
            if (a === undefined) {
                throw new Error("a should not be undefined; b: " + b);
            }
            if (b === undefined) {
                throw new Error("b should not be undefined; a: " + a);
            }
            var bIndex = this.getIndexEntries(a, b);
            if (!bIndex)
                return undefined;
            // console.log("queryLatestC result", a, b, bIndex.latestC);
            return defensiveCopy(bIndex.latestC);
        };
        TripleStore.prototype.queryAllC = function (a, b) {
            if (a === undefined) {
                throw new Error("a should not be undefined; b: " + b);
            }
            if (b === undefined) {
                throw new Error("b should not be undefined; a: " + a);
            }
            var bIndex = this.getIndexEntries(a, b);
            if (!bIndex)
                return [];
            return defensiveCopy(bIndex.versions);
        };
        // The b keys returned here are stringified objects (could be strings, or other) and should be parsed by called code if needed
        TripleStore.prototype.queryAllLatestBCForA = function (a) {
            if (a === undefined) {
                throw new Error("a should not be undefined");
            }
            var result = {};
            var aIndex = this.getIndexEntries(a);
            if (!aIndex)
                return result;
            for (var bKey in aIndex) {
                var bIndex = aIndex[bKey];
                if (bIndex && bIndex.latestC !== undefined) {
                    result[bKey] = defensiveCopy(bIndex.latestC);
                }
            }
            return result;
        };
        // Utility methods
        // Make a function that either returns the latest value with no arguments or sets it with one argument
        TripleStore.prototype.makeStorageFunction = function (a, b) {
            var _this = this;
            return function (c) {
                if (c === void 0) { c = undefined; }
                if (c === undefined) {
                    return _this.queryLatestC(a, b);
                }
                else {
                    _this.addTriple(a, b, c);
                }
            };
        };
        // Make a function that either returns the latest value for a model field with one argument (fieldName) or sets it with two arguments (fieldName, value)
        TripleStore.prototype.makeModelFunction = function (a) {
            var _this = this;
            if (a === undefined) {
                throw new Error("expected a to be defined");
            }
            return function (b, c) {
                if (c === void 0) { c = undefined; }
                if (c === undefined) {
                    return _this.queryLatestC(a, b);
                }
                else {
                    _this.addTriple(a, b, c);
                }
            };
        };
        TripleStore.prototype.makeObject = function (a, isKeyJSON) {
            if (isKeyJSON === void 0) { isKeyJSON = true; }
            if (a === undefined) {
                throw new Error("expected a to be defined");
            }
            var result = {};
            var latestBC = this.queryAllLatestBCForA(a);
            for (var bKey in latestBC) {
                var b = bKey;
                if (isKeyJSON) {
                    b = JSON.parse(bKey);
                }
                var c = latestBC[bKey];
                if (typeof b === "string") {
                    if (c !== undefined) {
                        result[b] = defensiveCopy(c);
                    }
                }
                else {
                    console.log("Expected b to be a string", a, b);
                    // throw new Error("Expected b to be a string");
                }
            }
            return result;
        };
        // Sets
        // TODO: Id does not have to be restricted to a string, but doing it for now to catch errors
        TripleStore.prototype.newIdForSet = function (setClassName) {
            // const setIdentifier = {"type": "set", "id":  generateRandomUuid(setClassName)};
            var setIdentifier = generateRandomUuid(setClassName);
            return setIdentifier;
        };
        TripleStore.prototype.newIdForItemClass = function (stringToStartWith) {
            var newId = generateRandomUuid(stringToStartWith);
            return newId;
        };
        TripleStore.prototype.newIdForSetItem = function (itemClassName) {
            // return new Date().toISOString();
            return generateRandomUuid(itemClassName);
        };
        TripleStore.prototype.makeNewSetItem = function (setIdentifier, itemClassName, template, idProperty) {
            if (template === void 0) { template = undefined; }
            if (idProperty === void 0) { idProperty = "id"; }
            if (setIdentifier === undefined) {
                throw new Error("expected setIdentifier to be defined");
            }
            var newId;
            if (template) {
                newId = template[idProperty];
                if (!newId) {
                    newId = this.newIdForSetItem(itemClassName);
                    template[idProperty] = newId;
                }
            }
            else {
                newId = this.newIdForSetItem(itemClassName);
            }
            if (template) {
                for (var key in template) {
                    this.addTriple(newId, key, template[key]);
                }
            }
            // TODO: Should there be another layer of indirection with a UUID for the "item" different from idPropery?
            // this.tripleStore.addTriple(newId????, this.idProperty, newId);
            this.addTriple(setIdentifier, { setItem: newId }, newId);
            return newId;
        };
        TripleStore.prototype.makeCopyOfItemOrSetWithNewId = function (level, existingItemId, itemOrSetClassName, setClassNames, itemClassNames, oldAndNewIDs) {
            if (existingItemId === undefined)
                throw new Error("expected existingItemId to be defined");
            var doCopy = true;
            var doReport = false;
            var baseIndent = repeatStringNumTimes("    ", level);
            var moreIndent = repeatStringNumTimes("    ", level + 1);
            var evenMoreIndent = repeatStringNumTimes("    ", level + 2);
            var newID = doCopy ? generateRandomUuid(itemOrSetClassName) : null;
            if (doReport)
                console.log(baseIndent + "COPYING [", itemOrSetClassName, "] with id [", existingItemId, "] to [", newID, "]");
            var latestBC = this.queryAllLatestBCForA(existingItemId);
            for (var bKey in latestBC) {
                var b = JSON.parse(bKey);
                var c = latestBC[bKey];
                var reportC = (typeof c === "string") ? replaceAll(c, "\n", " / ") : c;
                if (c !== undefined && c !== null && c !== "") {
                    if (doReport)
                        console.log(moreIndent, b, '=', reportC);
                    var isSet = isUUIDWithDefinedPrefix(c, setClassNames);
                    var isItem = isUUIDWithDefinedPrefix(c, itemClassNames) && b !== "id";
                    if (isSet || isItem) {
                        var classNameInC = stringUpTo(c, "_");
                        var copyOfC = this.makeCopyOfItemOrSetWithNewId(level + 1, c, classNameInC, setClassNames, itemClassNames, oldAndNewIDs);
                        oldAndNewIDs[c] = copyOfC;
                        if (b && b.setItem && b.setItem === c) {
                            if (doCopy)
                                this.addTriple(newID, { setItem: copyOfC }, copyOfC);
                            if (doReport)
                                console.log(moreIndent + "Copied", isSet ? "set" : "item", copyOfC, 'as set element:', copyOfC, 'of set', newID);
                        }
                        else {
                            // the ObservationSet and Observation class names save connections differently 
                            if (doCopy)
                                this.addTriple(newID, b, copyOfC);
                            console.log(moreIndent + "Copied", isSet ? "set" : "item", copyOfC, 'as field value:', b, copyOfC, 'of item', newID);
                        }
                    }
                    else {
                        var isNameOfTopLevelItem = (b.indexOf("_shortName") >= 0 || b.indexOf("_name") >= 0) && level === 0;
                        var isIDOfItem = b === "id";
                        if (isNameOfTopLevelItem) {
                            if (doCopy)
                                this.addTriple(newID, b, "Copy of " + c);
                            if (doReport)
                                console.log(evenMoreIndent + "Copied name to:", "Copy of " + c);
                        }
                        else if (isIDOfItem) {
                            if (doCopy)
                                this.addTriple(newID, b, newID);
                            if (doReport)
                                console.log(evenMoreIndent + "Updated ID field to:", newID);
                        }
                        else {
                            if (doCopy)
                                this.addTriple(newID, b, c);
                            if (doReport)
                                console.log(evenMoreIndent + "Copied non-item data:", reportC);
                        }
                    }
                }
                else {
                    if (doReport)
                        console.log("Not copying:", existingItemId, c);
                }
            }
            oldAndNewIDs[existingItemId] = newID;
            if (doReport && level === 0)
                console.log("Old and new ids:", oldAndNewIDs);
            return newID;
        };
        TripleStore.prototype.deleteSetItem = function (setIdentifier, itemIdentifier) {
            if (setIdentifier === undefined) {
                throw new Error("expected setIdentifier to be defined");
            }
            if (itemIdentifier === undefined) {
                throw new Error("expected itemIdentifier to be defined");
            }
            // TODO: Should the C be undefined instead of null?
            this.addTriple(setIdentifier, { setItem: itemIdentifier }, null);
        };
        TripleStore.prototype.getListForSetIdentifier = function (setIdentifier) {
            var result = [];
            if (!setIdentifier)
                return result;
            var aIndex = this.getIndexEntries(setIdentifier);
            if (!aIndex)
                return result;
            for (var bKey in aIndex) {
                var b = JSON.parse(bKey);
                // Set items should have a "setItem" field in b key as a "standard"; possible collision with other usages though
                if (b.setItem) {
                    var bIndex = aIndex[bKey];
                    if (bIndex) {
                        var c = bIndex.latestC;
                        if (c !== undefined && c !== null) {
                            result.push(defensiveCopy(c));
                        }
                    }
                }
            }
            return result;
        };
        return TripleStore;
    }());
    return TripleStore;
});

define('js/Project',["require", "exports", "./pointrel20150417/PointrelClient", "./surveyCollection", "./pointrel20150417/TripleStore", "./questionnaireGeneration"], function (require, exports, PointrelClient, surveyCollection, TripleStore, questionnaireGeneration) {
    "use strict";
    "use strict";
    var serverURL = "/api/pointrel20150417";
    // TODO: Rethink this as a more general way to watch models within the project (so, with arbitrary object IDs, not just the project ID)
    function stringUpTo(aString, upToWhat) {
        if (upToWhat !== "") {
            return aString.split(upToWhat)[0];
        }
        else {
            return aString;
        }
    }
    function stringBeyond(aString, beyondWhat) {
        if (beyondWhat !== "") {
            return aString.split(beyondWhat).pop();
        }
        else {
            return aString;
        }
    }
    function stringBetween(wholeString, startString, endString) {
        if (wholeString.indexOf(startString) < 0 || wholeString.indexOf(endString) < 0)
            return "";
        return stringUpTo(stringBeyond(wholeString.trim(), startString), endString);
    }
    var Project = (function () {
        function Project(journalIdentifier, projectIdentifier, userIdentifier, updateServerStatus, redrawCallback) {
            this.readOnly = false;
            this.currentUserHasAdminAccess = false;
            this.currentUserIsSuperUser = false;
            // The activeQuestionnaires field tracks what should be available to survey users and to construct related messages
            this.activeQuestionnaires = {};
            this.journalIdentifier = journalIdentifier;
            this.projectIdentifier = projectIdentifier;
            this.userIdentifier = userIdentifier;
            this.redrawCallback = redrawCallback;
            this.pointrelClient = new PointrelClient(serverURL, this.journalIdentifier, this.userIdentifier, this.receivedMessage.bind(this), updateServerStatus);
            // For now, listen on all topics in the journal
            // TODO: Think about how to move topicIdentifier into pointrelClient initialization
            // const topicIdentifier = "project001";
            // pointrelClient.topicIdentifier = topicIdentifier;
            this.tripleStore = new TripleStore(this.pointrelClient, "narrafirmaProject");
            // console.log("tripleStore", this.tripleStore);
            // Redraw on any new tripleStore message (however, the ones we send will not get callbacks)
            this.tripleStore.subscribe(undefined, undefined, undefined, this.redrawCallback.bind(this));
        }
        Project.prototype.startup = function (callback) {
            var _this = this;
            this.pointrelClient.reportJournalStatus(function (error, response) {
                console.log("reportJournalStatus response", error, response);
                if (error) {
                    console.log("Failed to startup project", error);
                    callback(error);
                }
                else {
                    _this.pointrelClient.startup();
                    _this.currentUserIsSuperUser = response.permissions.superUser;
                    callback(null, response);
                }
            });
        };
        Project.prototype.projectName = function () {
            return this.journalIdentifier.substring("NarraFirmaProject-".length);
        };
        Project.prototype.projectNameOrNickname = function () {
            var nickname = this.tripleStore.queryLatestC(this.projectIdentifier, "projectOptions_projectNickname");
            if (nickname) {
                return nickname;
            }
            else {
                return this.projectName();
            }
        };
        Project.prototype.projectNameAndNickname = function () {
            var nickname = this.tripleStore.queryLatestC(this.projectIdentifier, "projectOptions_projectNickname");
            if (nickname) {
                return this.projectName() + ' (' + nickname + ')';
            }
            else {
                return this.projectName();
            }
        };
        // TODO: Redundant code with what is in GridWithItemPanel
        Project.prototype.getListForField = function (fieldName) {
            var setIdentifier = this.getFieldValue(fieldName);
            return this.tripleStore.getListForSetIdentifier(setIdentifier);
        };
        Project.prototype.getFieldValue = function (fieldName) {
            return this.tripleStore.queryLatestC(this.projectIdentifier, fieldName);
        };
        Project.prototype.setFieldValue = function (fieldName, newValue, oldValue) {
            if (oldValue === void 0) { oldValue = undefined; }
            // TODO: Need to add support in tripleStore for oldValue; note callback is the fourth parameter
            this.tripleStore.addTriple(this.projectIdentifier, fieldName, newValue);
        };
        Project.prototype.fieldValue = function (fieldName, newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue === undefined) {
                return this.getFieldValue(fieldName);
            }
            else {
                return this.setFieldValue(fieldName, newValue);
            }
        };
        // TODO: What do do about this function? Especially if want to track chat messages or log messages or undoable changes for project?
        Project.prototype.receivedMessage = function (message) {
            // console.log("Project receivedMessage", message);
            if (message.change && message.change.action === "addTriple") {
                // Ignore addTriple messages as we handle only the ones we did not send via a subscription
                // console.log("Ignoring tripleStore message", message);
                return;
            }
            if (message.messageType === "questionnairesMessage") {
                // console.log("Project receivedMessage questionnairesMessage", message);
                surveyCollection.updateActiveQuestionnaires(message.change, false, null);
            }
            // Since this event came from the network, queue a Mithril redraw
            // The tripleStore may not be updated yet, so this redraw needs to get queued for later by the application
            if (this.redrawCallback) {
                // console.log("project calling redrawCallback");
                this.redrawCallback();
            }
        };
        // Project-specific data lookup
        Project.prototype.findCatalysisReport = function (shortName) {
            var catalysisReports = this.tripleStore.queryLatestC(this.projectIdentifier, "project_catalysisReports");
            if (!catalysisReports)
                return null;
            var catalysisReportIdentifiers = this.tripleStore.getListForSetIdentifier(catalysisReports);
            for (var i = 0; i < catalysisReportIdentifiers.length; i++) {
                var reportShortName = this.tripleStore.queryLatestC(catalysisReportIdentifiers[i], "catalysisReport_shortName");
                if (reportShortName === shortName) {
                    return catalysisReportIdentifiers[i];
                }
            }
            return null;
        };
        Project.prototype.findStoryFormID = function (shortName) {
            var storyFormIDs = this.getListForField("project_storyForms");
            for (var i = 0; i < storyFormIDs.length; i++) {
                var formShortName = this.tripleStore.queryLatestC(storyFormIDs[i], "questionForm_shortName");
                if (formShortName === shortName) {
                    return storyFormIDs[i];
                }
            }
            return null;
        };
        Project.prototype.listOfAllStoryFormNames = function () {
            var storyFormIDs = this.getListForField("project_storyForms");
            var result = [];
            for (var i = 0; i < storyFormIDs.length; i++) {
                var formShortName = this.tripleStore.queryLatestC(storyFormIDs[i], "questionForm_shortName");
                result.push(formShortName);
            }
            return result;
        };
        Project.prototype.findStoryCollectionID = function (shortName) {
            var storyCollections = this.getListForField("project_storyCollections");
            for (var i = 0; i < storyCollections.length; i++) {
                if (this.tripleStore.queryLatestC(storyCollections[i], "storyCollection_shortName") === shortName) {
                    return storyCollections[i];
                }
            }
            return null;
        };
        Project.prototype.listOfAllStoryCollectionNames = function () {
            var storyCollectionIDs = this.getListForField("project_storyCollections");
            var result = [];
            for (var i = 0; i < storyCollectionIDs.length; i++) {
                var collectionShortName = this.tripleStore.queryLatestC(storyCollectionIDs[i], "storyCollection_shortName");
                result.push(collectionShortName);
            }
            return result;
        };
        Project.prototype.collectAllQuestionsForQuestionList = function (questionListName) {
            var _this = this;
            var shortNameKey = stringBetween(questionListName, "project_", "QuestionsList") + "Question_shortName";
            var questionIdentifiers = this.getListForField(questionListName);
            var questions = [];
            questionIdentifiers.forEach(function (questionIdentifier) {
                var question = _this.tripleStore.makeObject(questionIdentifier, true);
                // if a question does not have a short name, pass over it (it may be an empty question they entered by mistake)
                var shortName = question[shortNameKey];
                if (shortName) {
                    // fill in id if missing
                    if (!question.id)
                        question.id = questionIdentifier;
                    questions.push(question);
                }
            });
            return questions;
        };
        Project.prototype.collectAllElicitingQuestions = function () {
            var questions = this.collectAllQuestionsForQuestionList("project_elicitingQuestionsList");
            return questions;
        };
        Project.prototype.collectAllStoryQuestions = function () {
            var questions = this.collectAllQuestionsForQuestionList("project_storyQuestionsList");
            return questions;
        };
        Project.prototype.collectAllParticipantQuestions = function () {
            var questions = this.collectAllQuestionsForQuestionList("project_participantQuestionsList");
            return questions;
        };
        Project.prototype.collectAllAnnotationQuestions = function () {
            var questions = this.collectAllQuestionsForQuestionList("project_annotationQuestionsList");
            return questions;
        };
        Project.prototype.collectAllQuestionsOfAnyKind = function () {
            var questions = [];
            questions = questions.concat(this.collectAllElicitingQuestions(), this.collectAllStoryQuestions(), this.collectAllParticipantQuestions(), this.collectAllAnnotationQuestions());
            return questions;
        };
        Project.prototype.questionsForCategory = function (questionCategory) {
            switch (questionCategory) {
                case "elicitingQuestion":
                    return this.collectAllElicitingQuestions();
                case "storyQuestion":
                    return this.collectAllStoryQuestions();
                case "participantQuestion":
                    return this.collectAllParticipantQuestions();
                case "annotationQuestion":
                    return this.collectAllAnnotationQuestions();
                default:
                    throw new Error("Unexpected question category: " + questionCategory);
            }
        };
        Project.prototype.addQuestionForCategory = function (question, questionCategory) {
            var questionListName;
            var questionClass;
            switch (questionCategory) {
                case "elicitingQuestion":
                    questionListName = "project_elicitingQuestionsList";
                    questionClass = "ElicitingQuestion";
                    break;
                case "storyQuestion":
                    questionListName = "project_storyQuestionsList";
                    questionClass = "StoryQuestion";
                    break;
                case "participantQuestion":
                    questionListName = "project_participantQuestionsList";
                    questionClass = "ParticipantQuestion";
                    break;
                case "annotationQuestion":
                    questionListName = "project_annotationQuestionsList";
                    questionClass = "AnnotationQuestion";
                    break;
                default:
                    throw new Error("Unexpected question category: " + questionCategory);
            }
            var setIdentifier = this.getFieldValue(questionListName);
            if (!setIdentifier) {
                // Need to create list
                setIdentifier = this.tripleStore.newIdForSet(questionClass + "Set");
                // console.log("Making set for ", questionListName, setIdentifier); 
                this.setFieldValue(questionListName, setIdentifier);
            }
            this.tripleStore.makeNewSetItem(setIdentifier, questionClass, question);
        };
        Project.prototype.deleteQuestionInCategory = function (question, questionCategory) {
            var questionListName;
            var questionClass;
            switch (questionCategory) {
                case "elicitingQuestion":
                    questionListName = "project_elicitingQuestionsList";
                    questionClass = "ElicitingQuestion";
                    break;
                case "storyQuestion":
                    questionListName = "project_storyQuestionsList";
                    questionClass = "StoryQuestion";
                    break;
                case "participantQuestion":
                    questionListName = "project_participantQuestionsList";
                    questionClass = "ParticipantQuestion";
                    break;
                case "annotationQuestion":
                    questionListName = "project_annotationQuestionsList";
                    questionClass = "AnnotationQuestion";
                    break;
                default:
                    throw new Error("Unexpected question category: " + questionCategory);
            }
            // sometimes questions are missing ids? not sure why
            if (!question.id) {
                question.id = this.questionIDForQuestionShortNameGivenQuestionCategory(question.shortName, questionCategory);
            }
            var setIdentifier = this.getFieldValue(questionListName);
            if (!setIdentifier) {
                // Need to create list
                setIdentifier = this.tripleStore.newIdForSet(questionClass + "Set");
                // console.log("Making set for ", questionListName, setIdentifier); 
                this.setFieldValue(questionListName, setIdentifier);
            }
            this.tripleStore.deleteSetItem(setIdentifier, question.id);
        };
        Project.prototype.addOptionToAnnotationChoiceQuestion = function (questionID, newAnswer) {
            var annotationQuestions = this.collectAllAnnotationQuestions();
            var foundQuestion = false;
            for (var i = 0; i < annotationQuestions.length; i++) {
                var aQuestion = annotationQuestions[i];
                if (!foundQuestion && ("A_" + aQuestion.annotationQuestion_shortName == questionID)) {
                    foundQuestion = true;
                    if (aQuestion.annotationQuestion_options === undefined || aQuestion.annotationQuestion_options === "") {
                        aQuestion.annotationQuestion_options = newAnswer;
                        if (aQuestion.id) {
                            this.tripleStore.addTriple(aQuestion.id, "annotationQuestion_options", aQuestion.annotationQuestion_options);
                        }
                    }
                    else {
                        var parts = aQuestion.annotationQuestion_options.split("\n");
                        if (parts.indexOf(newAnswer) < 0) {
                            parts.push(newAnswer);
                            aQuestion.annotationQuestion_options = parts.join("\n");
                            if (aQuestion.id) {
                                this.tripleStore.addTriple(aQuestion.id, "annotationQuestion_options", aQuestion.annotationQuestion_options);
                            }
                        }
                    }
                }
            }
        };
        Project.prototype.allQuestionsThatCouldBeGraphedForCatalysisReport = function (catalysisReportIdentifier, considerExclusions) {
            if (considerExclusions === void 0) { considerExclusions = true; }
            var elicitingQuestions = this.elicitingQuestionsForCatalysisReport(catalysisReportIdentifier);
            var numStoriesToldQuestions = this.numStoriesToldQuestionsForCatalysisReport(catalysisReportIdentifier);
            var storyLengthQuestions = this.storyLengthQuestionsForCatalysisReport(catalysisReportIdentifier);
            var collectionDateQuestions = this.collectionDateQuestionsForCatalysisReport(catalysisReportIdentifier);
            var languageQuestions = this.languageQuestionsForCatalysisReport(catalysisReportIdentifier);
            var storyQuestions = this.storyQuestionsForCatalysisReport(catalysisReportIdentifier);
            var participantQuestions = this.participantQuestionsForCatalysisReport(catalysisReportIdentifier);
            var annotationQuestions = questionnaireGeneration.convertEditorQuestions(this.collectAllAnnotationQuestions(), "A_");
            var allQuestions = [];
            allQuestions = allQuestions.concat(elicitingQuestions, numStoriesToldQuestions, storyLengthQuestions, collectionDateQuestions, languageQuestions, storyQuestions, participantQuestions, annotationQuestions);
            if (considerExclusions) {
                var questionIDsToInclude_1 = this.tripleStore.queryLatestC(catalysisReportIdentifier, "questionsToInclude");
                var result_1 = [];
                allQuestions.forEach(function (question) {
                    if (questionIDsToInclude_1 && questionIDsToInclude_1[question.id]) {
                        result_1.push(question);
                    }
                });
                return result_1;
            }
            else {
                return allQuestions;
            }
        };
        Project.prototype.numStoryCollectionsInCatalysisReport = function (catalysisReportIdentifier) {
            var storyCollectionsIdentifier = this.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_storyCollections");
            var storyCollectionItems = this.tripleStore.getListForSetIdentifier(storyCollectionsIdentifier);
            return storyCollectionItems.length;
        };
        Project.prototype.storiesForCatalysisReport = function (catalysisReportIdentifier, showWarnings) {
            var _this = this;
            if (showWarnings === void 0) { showWarnings = false; }
            // the reason to have showWarnings is that this method gets called twice on the configure report page (once by the filter warning and once by the questions chooser)
            var result = [];
            var storyCollectionsIdentifier = this.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_storyCollections");
            var storyCollectionItems = this.tripleStore.getListForSetIdentifier(storyCollectionsIdentifier);
            if (storyCollectionItems.length === 0)
                return [];
            var filter = this.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_filter");
            if (filter) {
                return this.storiesForCatalysisReportWithFilter(catalysisReportIdentifier, storyCollectionItems, filter.trim(), showWarnings);
            }
            else {
                storyCollectionItems.forEach(function (storyCollectionPointer) {
                    if (!storyCollectionPointer) {
                        console.log("ERROR: null or undefined story collection pointer in catalysis report ", catalysisReportIdentifier);
                    }
                    else {
                        var storyCollectionIdentifier = _this.tripleStore.queryLatestC(storyCollectionPointer, "storyCollection");
                        var storiesForThisCollection = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier);
                        result = result.concat(storiesForThisCollection);
                    }
                });
            }
            return result;
        };
        Project.prototype.storiesForCatalysisReportWithFilter = function (catalysisReportIdentifier, storyCollectionItems, filter, showWarnings) {
            var _this = this;
            if (showWarnings === void 0) { showWarnings = false; }
            var result = [];
            storyCollectionItems.forEach(function (storyCollectionPointer) {
                if (!storyCollectionPointer) {
                    console.log("ERROR: null or undefined story collection pointer in catalysis report ", catalysisReportIdentifier);
                }
                else {
                    var storyCollectionIdentifier = _this.tripleStore.queryLatestC(storyCollectionPointer, "storyCollection");
                    var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionIdentifier);
                    var storiesForThisCollection = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier);
                    storiesForThisCollection = _this.storiesForStoryCollectionWithFilter(storyCollectionIdentifier, storiesForThisCollection, questionnaire, filter, showWarnings);
                    result = result.concat(storiesForThisCollection);
                }
            });
            return result;
        };
        Project.prototype.storiesForStoryCollectionWithFilter = function (storyCollectionIdentifier, storiesForThisCollection, questionnaire, filter, showWarnings) {
            if (showWarnings === void 0) { showWarnings = false; }
            var result = [];
            result = result.concat(storiesForThisCollection);
            var filterParts = filter.split("&&").map(function (item) { return item.trim(); });
            for (var partIndex = 0; partIndex < filterParts.length; partIndex++) {
                result = this.storiesForStoryCollectionWithSingleFilter(storyCollectionIdentifier, result, questionnaire, filterParts[partIndex], showWarnings);
            }
            return result;
        };
        Project.prototype.storiesForStoryCollectionWithSingleFilter = function (storyCollectionIdentifier, storiesToFilter, questionnaire, filter, showWarnings) {
            if (showWarnings === void 0) { showWarnings = false; }
            var result = [];
            var questionAndAnswers = filter.split("==").map(function (item) { return item.trim(); });
            var questionShortName = questionAndAnswers[0];
            var negateFilter = false;
            if (questionShortName[0] === "!") {
                negateFilter = true;
                questionShortName = questionShortName.slice(1);
            }
            // special case: filtering on story length
            // notation: [ denotes an inclusive range; ( denotes an exclusive range
            // e.g., [start, end) means the length must be >= start and < end
            // if [ or ( is left out, [ is assumed
            if (filter.indexOf("Story length") >= 0) {
                var lowerAndUpperLimits = questionAndAnswers.slice(1);
                var lowerLimit = undefined;
                var upperLimit = undefined;
                if (lowerAndUpperLimits.length < 2) {
                    if (showWarnings)
                        alert("To filter by story length, you must enter two numbers.");
                    return storiesToFilter;
                }
                var lowerLimitString = lowerAndUpperLimits[0];
                var lowerLimitIsInclusive = lowerLimitString.indexOf("(") < 0;
                lowerLimitString = lowerLimitString.replace("[", "");
                lowerLimitString = lowerLimitString.replace("(", "");
                if (isNaN(Number(lowerLimitString))) {
                    if (showWarnings)
                        alert("The lower story length limit you entered (" + lowerLimitString + ") is not a number.");
                    return storiesToFilter;
                }
                lowerLimit = Number(lowerLimitString);
                var upperLimitString = lowerAndUpperLimits[1];
                var upperLimitIsInclusive = upperLimitString.indexOf(")") < 0;
                upperLimitString = upperLimitString.replace("]", "");
                upperLimitString = upperLimitString.replace(")", "");
                if (isNaN(Number(upperLimitString))) {
                    if (showWarnings)
                        alert("The upper story length limit you entered (" + upperLimitString + ") is not a number.");
                    return storiesToFilter;
                }
                upperLimit = Number(upperLimitString);
                if (lowerLimit >= upperLimit) {
                    if (showWarnings)
                        alert("The lower story length limit must be less than the upper story length limit.");
                    return storiesToFilter;
                }
                var storiesThatMatchFilter_1 = [];
                for (var storyIndex = 0; storyIndex < storiesToFilter.length; storyIndex++) {
                    var story = storiesToFilter[storyIndex];
                    var storyLength = story.storyLength();
                    var storyLengthIsAboveLowerLimit = lowerLimitIsInclusive ? storyLength >= lowerLimit : storyLength > lowerLimit;
                    var storyLengthIsBelowUpperLimit = upperLimitIsInclusive ? storyLength <= upperLimit : storyLength < upperLimit;
                    var storyMatches = storyLengthIsAboveLowerLimit && storyLengthIsBelowUpperLimit;
                    if (negateFilter)
                        storyMatches = !storyMatches;
                    if (storyMatches)
                        storiesThatMatchFilter_1.push(story);
                }
                return storiesThatMatchFilter_1;
            }
            // special case: filtering on story text
            if (filter.indexOf("Story text") >= 0) {
                var searchTexts = questionAndAnswers.slice(1);
                var storiesThatMatchFilter_2 = [];
                var _loop_1 = function (storyIndex) {
                    var story = storiesToFilter[storyIndex];
                    var storyText = story.storyText();
                    var storyMatches = false;
                    searchTexts.forEach(function (text) { storyMatches = storyMatches || storyText.indexOf(text) >= 0; });
                    if (negateFilter)
                        storyMatches = !storyMatches;
                    if (storyMatches)
                        storiesThatMatchFilter_2.push(story);
                };
                for (var storyIndex = 0; storyIndex < storiesToFilter.length; storyIndex++) {
                    _loop_1(storyIndex);
                }
                return storiesThatMatchFilter_2;
            }
            // general case: filtering on answers to questions
            var questionID = this.questionIDForQuestionShortNameGivenQuestionnaire(questionShortName, questionnaire);
            var question = this.questionForQuestionIDGivenQuestionnaire(questionID, questionnaire, storyCollectionIdentifier);
            var answersInFilter = [];
            var lowerSliderLimit = undefined;
            var upperSliderLimit = undefined;
            if (question) {
                answersInFilter = questionAndAnswers.slice(1);
                if (question.displayType == "boolean") {
                    if (answersInFilter[0] != "yes" && answersInFilter[0] != "no") {
                        if (showWarnings)
                            alert("This question (" + questionShortName + ") is a boolean question. The specified answer must be either yes or no.");
                        return storiesToFilter;
                    }
                }
                else if (question.displayType == "checkbox") {
                    if (answersInFilter[0] != "true" && answersInFilter[0] != "false") {
                        if (showWarnings)
                            alert("This question (" + questionShortName + ")  is a checkbox question. The specified answer must be either true or false.");
                        return storiesToFilter;
                    }
                }
                else if (question.displayType == "slider") {
                    lowerSliderLimit = parseInt(answersInFilter[0]);
                    if (isNaN(lowerSliderLimit)) {
                        if (showWarnings)
                            alert("This question (" + questionShortName + ") has a numerical range, and the lower limit you specified (" + answersInFilter[0] + ") doesn't seem to be a number.");
                        return storiesToFilter;
                    }
                    if (answersInFilter.length > 1) {
                        upperSliderLimit = parseInt(answersInFilter[1]);
                        if (isNaN(upperSliderLimit)) {
                            if (showWarnings)
                                alert("This question (" + questionShortName + ") has a numerical range, and the upper limit you specified (" + answersInFilter[1] + ") doesn't seem to be a number.");
                            return storiesToFilter;
                        }
                    }
                    else {
                        if (showWarnings)
                            alert("This question (" + questionShortName + ") has a numerical range, but you only specified one number. You need to specify a lower and upper limit (inclusive).");
                        return storiesToFilter;
                    }
                }
            }
            else {
                if (showWarnings)
                    alert('No question used by the story collection "' + storyCollectionIdentifier + '" matches the name: ' + questionShortName);
                return storiesToFilter;
            }
            if (!question) {
                return storiesToFilter;
            }
            var storiesThatMatchFilter = [];
            for (var storyIndex = 0; storyIndex < storiesToFilter.length; storyIndex++) {
                var story = storiesToFilter[storyIndex];
                var value = story.fieldValue(question.id);
                var storyMatches = false;
                if (question.displayType == "boolean") {
                    storyMatches = (answersInFilter[0] == "yes" && value) || (answersInFilter[0] == "no" && !value);
                }
                else if (question.displayType == "checkbox") {
                    storyMatches = (answersInFilter[0] == "true" && value) || (answersInFilter[0] == "false" && !value);
                }
                else if (value !== undefined && value !== null && value !== "") {
                    if (question.displayType == "slider") {
                        var valueAsInt = parseInt(value);
                        if (valueAsInt >= lowerSliderLimit && valueAsInt <= upperSliderLimit) {
                            storyMatches = true;
                        }
                    }
                    else if (typeof (value) == "string") {
                        for (var answerIndex = 0; answerIndex < answersInFilter.length; answerIndex++) {
                            if (value.trim() == answersInFilter[answerIndex]) {
                                storyMatches = true;
                                break;
                            }
                        }
                    }
                    else {
                        var answersToReport = {};
                        var valueKeys = Object.keys(value);
                        for (var i = 0; i < valueKeys.length; i++) {
                            // see note in calculateStatistics about lumping commands and trimming
                            var trimmedKey = valueKeys[i].trim();
                            answersToReport[trimmedKey] = value[valueKeys[i]];
                        }
                        for (var answerIndex = 0; answerIndex < answersInFilter.length; answerIndex++) {
                            if (answersToReport[answersInFilter[answerIndex]] && answersToReport[answersInFilter[answerIndex]] == true) {
                                storyMatches = true;
                                break;
                            }
                        }
                    }
                }
                if (negateFilter)
                    storyMatches = !storyMatches;
                if (storyMatches)
                    storiesThatMatchFilter.push(story);
            }
            result = result.concat(storiesThatMatchFilter);
            return result;
        };
        Project.prototype.allStoriesInProject = function () {
            var _this = this;
            var result = [];
            var storyCollectionsIdentifier = this.tripleStore.queryLatestC(this.projectIdentifier, "project_storyCollections");
            var storyCollectionItems = this.tripleStore.getListForSetIdentifier(storyCollectionsIdentifier);
            if (storyCollectionItems.length === 0)
                return [];
            storyCollectionItems.forEach(function (storyCollectionPointer) {
                if (!storyCollectionPointer) {
                    console.log("ERROR: null or undefined story collection pointer");
                }
                else {
                    var storyCollectionName = _this.tripleStore.queryLatestC(storyCollectionPointer, "storyCollection_shortName");
                    var storiesForThisCollection = surveyCollection.getStoriesForStoryCollection(storyCollectionName);
                    result = result.concat(storiesForThisCollection);
                }
            });
            return result;
        };
        Project.prototype.questionIDForQuestionShortNameGivenQuestionnaire = function (questionShortName, questionnaire) {
            // to add correct prefix (S_, P_, A_) to question name supplied by user (for catalysis report filter)
            if (questionShortName == "Eliciting question") {
                return "elicitingQuestion";
            }
            // not an eliciting question, check story questions next
            for (var i = 0; i < questionnaire.storyQuestions.length; i++) {
                if (questionnaire.storyQuestions[i].displayName == questionShortName) {
                    return questionnaire.storyQuestions[i].id;
                }
            }
            // not eliciting or story question, check participant questions next
            for (var i = 0; i < questionnaire.participantQuestions.length; i++) {
                if (questionnaire.participantQuestions[i].displayName == questionShortName) {
                    return questionnaire.participantQuestions[i].id;
                }
            }
            // must be an annotation question - these are ID'd differently
            return "A_" + questionShortName;
        };
        Project.prototype.questionIDForQuestionShortNameGivenQuestionCategory = function (questionShortName, questionCategory) {
            // to add correct prefix (S_, P_, A_) to question name supplied by user (for catalysis report filter)
            switch (questionCategory) {
                case "elicitingQuestion":
                    return "elicitingQuestion";
                case "storyQuestion":
                    return "S_" + questionShortName;
                case "participantQuestion":
                    return "P_" + questionShortName;
                case "annotationQuestion":
                    return "A_" + questionShortName;
                default:
                    throw new Error("Unexpected question category: " + questionCategory);
            }
        };
        Project.prototype.questionForQuestionIDGivenQuestionnaire = function (questionID, questionnaire, storyCollectionIdentifier) {
            if (!questionID)
                return null;
            if (questionID == "elicitingQuestion") {
                return this.elicitingQuestionForStoryCollection(storyCollectionIdentifier);
            }
            for (var index in questionnaire.storyQuestions) {
                var question = questionnaire.storyQuestions[index];
                if (question.id === questionID)
                    return question;
            }
            for (var index in questionnaire.participantQuestions) {
                var question = questionnaire.participantQuestions[index];
                if (question.id === questionID)
                    return question;
            }
            var annotationQuestions = this.collectAllAnnotationQuestions();
            for (var index in annotationQuestions) {
                var question = annotationQuestions[index];
                if ("A_" + question.annotationQuestion_shortName === questionID) {
                    var convertedAnnotationQuestion = {
                        id: "A_" + question.annotationQuestion_shortName,
                        displayName: question.annotationQuestion_shortName,
                        displayPrompt: question.annotationQuestion_text,
                        displayType: question.annotationQuestion_type,
                        valueOptions: question.annotationQuestion_options
                    };
                    return convertedAnnotationQuestion;
                }
            }
            console.log("ERROR: question not found for id", questionID);
            return null;
        };
        Project.prototype.elicitingQuestionForStoryCollection = function (storyCollectionIdentifier) {
            var convertedElicitingQuestion = null;
            var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionIdentifier);
            if (questionnaire) {
                var elicitingQuestionValues = [];
                for (var elicitingQuestionIndex in questionnaire.elicitingQuestions) {
                    var elicitingQuestionSpecification = questionnaire.elicitingQuestions[elicitingQuestionIndex];
                    elicitingQuestionValues.push(elicitingQuestionSpecification.id || elicitingQuestionSpecification.shortName || elicitingQuestionSpecification.text);
                }
                convertedElicitingQuestion = {
                    id: "elicitingQuestion",
                    displayName: "Eliciting question",
                    displayPrompt: "Please choose a question you would like to respond to",
                    displayType: "select",
                    valueOptions: elicitingQuestionValues
                };
            }
            return convertedElicitingQuestion;
        };
        Project.prototype.elicitingQuestionsForCatalysisReport = function (catalysisReportIdentifier) {
            var _this = this;
            var result = [];
            var elicitingQuestionValues = [];
            var storyCollectionsIdentifier = this.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_storyCollections");
            var storyCollectionItems = this.tripleStore.getListForSetIdentifier(storyCollectionsIdentifier);
            if (storyCollectionItems.length === 0)
                return null;
            storyCollectionItems.forEach(function (storyCollectionPointer) {
                if (storyCollectionPointer) {
                    var storyCollectionIdentifier = _this.tripleStore.queryLatestC(storyCollectionPointer, "storyCollection");
                    var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionIdentifier);
                    if (questionnaire) {
                        for (var elicitingQuestionIndex in questionnaire.elicitingQuestions) {
                            var elicitingQuestionSpecification = questionnaire.elicitingQuestions[elicitingQuestionIndex];
                            elicitingQuestionValues.push(elicitingQuestionSpecification.id || elicitingQuestionSpecification.shortName || elicitingQuestionSpecification.text);
                        }
                    }
                }
            });
            // create ONE eliciting question to cover all story collections, with all possible answers to question
            var convertedElicitingQuestion = {
                id: "elicitingQuestion",
                displayName: "Eliciting question",
                displayPrompt: "Please choose a question you would like to respond to",
                displayType: "select",
                valueOptions: elicitingQuestionValues
            };
            result.push(convertedElicitingQuestion);
            return result;
        };
        Project.prototype.storyQuestionsForStoryCollection = function (storyCollectionIdentifier) {
            var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionIdentifier);
            if (questionnaire) {
                return questionnaire.storyQuestions;
            }
            else {
                return [];
            }
        };
        Project.prototype.storyQuestionsForCatalysisReport = function (catalysisReportIdentifier) {
            var _this = this;
            var result = [];
            var storyCollectionsIdentifier = this.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_storyCollections");
            var storyCollectionItems = this.tripleStore.getListForSetIdentifier(storyCollectionsIdentifier);
            if (storyCollectionItems.length === 0)
                return [];
            storyCollectionItems.forEach(function (storyCollectionPointer) {
                if (storyCollectionPointer) {
                    var storyCollectionIdentifier = _this.tripleStore.queryLatestC(storyCollectionPointer, "storyCollection");
                    var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionIdentifier);
                    if (questionnaire) {
                        for (var questionIndex in questionnaire.storyQuestions) {
                            var question = questionnaire.storyQuestions[questionIndex];
                            // check for existing question (possibly from another story collection) in results
                            var alreadyThere = false;
                            for (var resultQuestionIndex in result) {
                                var resultQuestion = result[resultQuestionIndex];
                                if (question.displayName === resultQuestion.displayName) {
                                    alreadyThere = true;
                                    break;
                                }
                            }
                            if (!alreadyThere) {
                                result.push(question);
                            }
                        }
                    }
                }
            });
            return result;
        };
        Project.prototype.participantQuestionsForStoryCollection = function (storyCollectionIdentifier) {
            var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionIdentifier);
            if (questionnaire) {
                return questionnaire.participantQuestions;
            }
            else {
                return [];
            }
        };
        Project.prototype.participantQuestionsForCatalysisReport = function (catalysisReportIdentifier) {
            var _this = this;
            var result = [];
            var storyCollectionsIdentifier = this.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_storyCollections");
            var storyCollectionItems = this.tripleStore.getListForSetIdentifier(storyCollectionsIdentifier);
            if (storyCollectionItems.length === 0)
                return [];
            storyCollectionItems.forEach(function (storyCollectionPointer) {
                if (storyCollectionPointer) {
                    var storyCollectionIdentifier = _this.tripleStore.queryLatestC(storyCollectionPointer, "storyCollection");
                    var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionIdentifier);
                    if (questionnaire) {
                        for (var questionIndex in questionnaire.participantQuestions) {
                            var question = questionnaire.participantQuestions[questionIndex];
                            var alreadyThere = false;
                            for (var resultQuestionIndex in result) {
                                var resultQuestion = result[resultQuestionIndex];
                                if (question.displayName === resultQuestion.displayName) {
                                    alreadyThere = true;
                                    break;
                                }
                            }
                            if (!alreadyThere) {
                                result.push(question);
                            }
                        }
                    }
                }
            });
            return result;
        };
        Project.prototype.storyLengthQuestion = function (maxStoryLength, numStoryLengthBins) {
            var choices = [];
            var increment = Math.round(maxStoryLength / numStoryLengthBins);
            for (var i = 1; i <= numStoryLengthBins; i++) {
                choices.push("" + i * increment);
            }
            var storyLengthQuestion = {
                id: "storyLength",
                displayName: "Story length",
                displayPrompt: "This is the length (in characters) of the story.",
                displayType: "select",
                valueOptions: choices
            };
            return storyLengthQuestion;
        };
        Project.prototype.storyLengthQuestionForStoryCollection = function (storyCollectionIdentifier) {
            var stories = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier);
            var maxStoryLength = 0;
            for (var storyIndex in stories) {
                var storyLength = stories[storyIndex].storyLength();
                if (storyLength > maxStoryLength)
                    maxStoryLength = storyLength;
            }
            // outside of catalysis report, use hard-coded upper limit
            if (maxStoryLength > 5000) {
                maxStoryLength = 5000;
            }
            // outside of catalysis report, use hard-coded number of bins
            var numStoryLengthBins = 4;
            return this.storyLengthQuestion(maxStoryLength, numStoryLengthBins);
        };
        Project.prototype.storyLengthQuestionsForCatalysisReport = function (catalysisReportIdentifier) {
            var _this = this;
            var maxStoryLength = 0;
            var storyCollectionsIdentifier = this.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_storyCollections");
            var storyCollectionItems = this.tripleStore.getListForSetIdentifier(storyCollectionsIdentifier);
            if (storyCollectionItems.length === 0)
                return [];
            storyCollectionItems.forEach(function (storyCollectionPointer) {
                if (storyCollectionPointer) {
                    var storyCollectionIdentifier = _this.tripleStore.queryLatestC(storyCollectionPointer, "storyCollection");
                    var stories = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier);
                    for (var storyIndex in stories) {
                        var storyLength = stories[storyIndex].storyLength();
                        if (storyLength > maxStoryLength)
                            maxStoryLength = storyLength;
                    }
                }
            });
            var maxStoryLengthToShow = this.tripleStore.queryLatestC(catalysisReportIdentifier, "maxStoryLengthToShow");
            if (maxStoryLengthToShow) {
                var maxStoryLengthToShowAsNumber = parseInt(maxStoryLengthToShow);
                maxStoryLength = Math.min(maxStoryLengthToShowAsNumber, maxStoryLength);
            }
            var numStoryLengthBinsAsNumber = Project.default_numStoryLengthCategories;
            var numStoryLengthBins = this.tripleStore.queryLatestC(catalysisReportIdentifier, "numStoryLengthBins");
            if (numStoryLengthBins) {
                numStoryLengthBinsAsNumber = parseInt(numStoryLengthBins);
            }
            return this.storyLengthQuestion(maxStoryLength, numStoryLengthBinsAsNumber);
        };
        Project.prototype.collectionDateQuestionForStoryCollection = function (storyCollectionIdentifier) {
            var stories = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier);
            var dateUnit = "days"; // outside of catalysis report, hard-code option
            var binNames = this.collectionDateBinNamesForListOfStories(stories, dateUnit);
            binNames = binNames.sort();
            return this.collectionDateQuestion(dateUnit, binNames);
        };
        Project.prototype.collectionDateQuestionsForCatalysisReport = function (catalysisReportIdentifier) {
            var _this = this;
            var dateUnit = this.tripleStore.queryLatestC(catalysisReportIdentifier, "storyCollectionDateUnit") || "days";
            var storyCollectionsIdentifier = this.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_storyCollections");
            var storyCollectionItems = this.tripleStore.getListForSetIdentifier(storyCollectionsIdentifier);
            if (storyCollectionItems.length === 0)
                return [];
            var binNames = [];
            storyCollectionItems.forEach(function (storyCollectionPointer) {
                if (storyCollectionPointer) {
                    var storyCollectionIdentifier = _this.tripleStore.queryLatestC(storyCollectionPointer, "storyCollection");
                    var stories = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier);
                    var binNamesForStoryCollection = _this.collectionDateBinNamesForListOfStories(stories, dateUnit);
                    for (var i = 0; i < binNamesForStoryCollection.length; i++) {
                        if (binNames.indexOf(binNamesForStoryCollection[i]) < 0) {
                            binNames.push(binNamesForStoryCollection[i]);
                        }
                    }
                }
            });
            binNames = binNames.sort();
            return this.collectionDateQuestion(dateUnit, binNames);
        };
        Project.prototype.collectionDateBinNamesForListOfStories = function (stories, dateUnit) {
            var binNames = [];
            stories.forEach(function (story) {
                var valueToAdd = undefined;
                if (dateUnit === "years") {
                    valueToAdd = story.storyCollectionYear();
                }
                else if (dateUnit === "quarters") {
                    valueToAdd = story.storyCollectionQuarter();
                }
                else if (dateUnit === "months") {
                    valueToAdd = story.storyCollectionYearAndMonth();
                }
                else if (dateUnit === "days") {
                    valueToAdd = story.storyCollectionDate();
                }
                if (valueToAdd && binNames.indexOf(valueToAdd) < 0) {
                    binNames.push(valueToAdd);
                }
            });
            return binNames;
        };
        Project.prototype.collectionDateQuestion = function (dateUnit, unitDescriptors) {
            return {
                id: "collectionDate",
                displayName: "Collection date",
                displayPrompt: "This is the date on which the story was collected.",
                displayType: "select",
                displayConfiguration: dateUnit || "days",
                valueOptions: unitDescriptors
            };
        };
        Project.prototype.languageQuestionForStoryCollection = function (storyCollectionIdentifier) {
            var stories = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier);
            var languages = this.languagesForListOfStories(stories);
            languages = languages.sort();
            return this.languageQuestion(languages);
        };
        Project.prototype.languageQuestionsForCatalysisReport = function (catalysisReportIdentifier) {
            var _this = this;
            var storyCollectionsIdentifier = this.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_storyCollections");
            var storyCollectionItems = this.tripleStore.getListForSetIdentifier(storyCollectionsIdentifier);
            if (storyCollectionItems.length === 0)
                return [];
            var languages = [];
            storyCollectionItems.forEach(function (storyCollectionPointer) {
                if (storyCollectionPointer) {
                    var storyCollectionIdentifier = _this.tripleStore.queryLatestC(storyCollectionPointer, "storyCollection");
                    var stories = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier);
                    var languagesForStoryCollection = _this.languagesForListOfStories(stories);
                    languagesForStoryCollection.forEach(function (language) {
                        if (languages.indexOf(language) < 0) {
                            languages.push(language);
                        }
                    });
                }
            });
            languages = languages.sort();
            return this.languageQuestion(languages);
        };
        Project.prototype.languagesForListOfStories = function (stories) {
            var languages = [];
            stories.forEach(function (story) {
                var language = story.storyLanguage();
                if (language && languages.indexOf(language) < 0) {
                    languages.push(language);
                }
            });
            return languages;
        };
        Project.prototype.languageQuestion = function (languages) {
            return {
                id: "language",
                displayName: "Language",
                displayPrompt: "This is the language in which the story form was displayed when the story was collected.",
                displayType: "select",
                valueOptions: languages
            };
        };
        Project.prototype.numStoriesToldQuestion = function (maxNumQuestions) {
            var choices = [];
            for (var i = 1; i <= maxNumQuestions; i++) {
                choices.push("" + i);
            }
            var numStoriesToldQuestion = {
                id: "numStoriesTold",
                displayName: "Number of stories told",
                displayPrompt: "This is the number of stories told by each participant.",
                displayType: "select",
                valueOptions: choices
            };
            return numStoriesToldQuestion;
        };
        Project.prototype.numStoriesToldQuestionForStoryCollection = function (storyCollectionIdentifier) {
            var stories = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier);
            var maxNumStoriesTold = 0;
            for (var storyIndex in stories) {
                var numStoriesToldForThisStory = stories[storyIndex].numStoriesTold();
                if (typeof numStoriesToldForThisStory === "string") {
                    var numStoriesToldForThisStoryAsInt = parseInt(numStoriesToldForThisStory);
                    if (numStoriesToldForThisStoryAsInt > maxNumStoriesTold) {
                        maxNumStoriesTold = numStoriesToldForThisStoryAsInt;
                    }
                }
            }
            return this.numStoriesToldQuestion(maxNumStoriesTold);
        };
        Project.prototype.numStoriesToldQuestionsForCatalysisReport = function (catalysisReportIdentifier) {
            var _this = this;
            var maxNumStoriesTold = 0;
            var storyCollectionsIdentifier = this.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_storyCollections");
            var storyCollectionItems = this.tripleStore.getListForSetIdentifier(storyCollectionsIdentifier);
            if (storyCollectionItems.length === 0)
                return [];
            storyCollectionItems.forEach(function (storyCollectionPointer) {
                if (storyCollectionPointer) {
                    var storyCollectionIdentifier = _this.tripleStore.queryLatestC(storyCollectionPointer, "storyCollection");
                    var stories = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier);
                    for (var storyIndex in stories) {
                        var numStoriesToldForThisStory = stories[storyIndex].numStoriesTold();
                        if (typeof numStoriesToldForThisStory === "string") {
                            var numStoriesToldForThisStoryAsInt = parseInt(numStoriesToldForThisStory);
                            if (numStoriesToldForThisStoryAsInt > maxNumStoriesTold) {
                                maxNumStoriesTold = numStoriesToldForThisStoryAsInt;
                            }
                        }
                    }
                }
            });
            return this.numStoriesToldQuestion(maxNumStoriesTold);
        };
        Project.prototype.lumpingCommandsForCatalysisReport = function (catalysisReportIdentifier) {
            var lumpingCommandsString = this.tripleStore.queryLatestC(catalysisReportIdentifier, "lumpingCommands") || "";
            if (lumpingCommandsString)
                return this.lumpingCommandsFromString(lumpingCommandsString);
            return "";
        };
        Project.prototype.lumpingCommandsForStoryCollection = function (storyCollectionIdentifier) {
            var lumpingCommandsString = this.tripleStore.queryLatestC(storyCollectionIdentifier, "printStoryCards_lumpingCommands") || "";
            if (lumpingCommandsString)
                return this.lumpingCommandsFromString(lumpingCommandsString);
            return "";
        };
        Project.prototype.lumpingCommandsFromString = function (lumpingCommandsString) {
            // example: Come from == second hand || rumor == not first hand
            var lumpingCommands = {};
            var lines = lumpingCommandsString.split("\n");
            for (var lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                if (lines[lineIndex].indexOf(";") === 0)
                    continue; // user can commment out line with semicolon
                var lineParts = lines[lineIndex].split("==");
                if (lineParts.length == 3) {
                    var answersToLump = lineParts[1].split("||").map(function (part) { return part.trim(); });
                    // prior to NF v1.6.6, you had to have at least two answers to lump 
                    // this has now changed to add the "ignore" functionality, so you just need one
                    // this also means you can use the lumping facility to rename a single answer
                    if (answersToLump.length >= 1) {
                        var questionName = lineParts[0].trim();
                        var lumpedAnswer = lineParts[2].trim();
                        if (!lumpingCommands.hasOwnProperty(questionName))
                            lumpingCommands[questionName] = {};
                        for (var answerIndex = 0; answerIndex < answersToLump.length; answerIndex++) {
                            var key = answersToLump[answerIndex];
                            lumpingCommands[questionName][key] = lumpedAnswer;
                        }
                    }
                }
            }
            return lumpingCommands;
        };
        Project.default_minimumStoryCountRequiredForTest = 20;
        Project.default_minimumStoryCountRequiredForGraph = 1;
        Project.default_numHistogramBins = 20;
        Project.default_numScatterDotOpacityLevels = 3;
        Project.default_scatterDotSize = 8;
        Project.default_correlationMapShape = "line with arcs";
        Project.default_correlationMapIncludeScaleEndLabels = "only when there is no choice question";
        Project.default_correlationMapCircleDiameter = 300;
        Project.default_correlationLineChoice = "0.05";
        Project.default_customLabelLengthLimit = "30";
        Project.default_customReportGraphWidth = 800;
        Project.default_customReportGraphHeight = 600;
        Project.default_customDisplayGraphWidth = 800;
        Project.default_customDisplayGraphHeight = 600;
        Project.default_customGraphPadding = 0;
        Project.default_numStoryLengthCategories = 4;
        Project.default_graphTypesToCreate = {
            "data integrity graphs": false,
            "texts": false,
            "write-in texts": false,
            "bar graphs": false,
            "histograms": false,
            "tables": false,
            "contingency-histogram tables": false,
            "multiple histograms": false,
            "scatterplots": false,
            "multiple scatterplots": false,
            "correlation maps": false
        };
        return Project;
    }());
    return Project;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define('js/panelBuilder/GridWithItemPanel',["require", "exports", "mithril", "./translate", "../pointrel20150417/generateRandomUuid", "./valuePathResolver", "../Globals", "lodash"], function (require, exports, m, translate, generateRandomUuid, valuePathResolver, Globals, _) {
    "use strict";
    "use strict";
    // This defines a gui component which has a grid, some buttons, and a detail panel do display the currently selected item or enter a new item
    // TODO: Probably need to prevent user surveys from having a question with a short name of "_id".
    var gridsMade = 0;
    var debug = false;
    var displayTypesToDisplayAsColumns = {
        text: true,
        textarea: true,
        boolean: true,
        checkbox: true,
        select: true,
        radiobuttons: true,
        checkboxes: true,
        slider: true
    };
    // embedded sets to copy when duplicating item
    var SetClassNames = {
        // planning
        ObservedStorySet: true,
        // collection
        CollectionSessionActivitySet: true,
        StoryFormSet: true,
        ElicitingQuestionChoiceSet: true,
        StoryQuestionChoiceSet: true,
        ParticipantQuestionChoiceSet: true,
        TranslationDictionarySet: true,
        CollectionSessionConstructionSet: true,
        // catalysis
        StoryCollectionChoiceSet: true,
        ObservationSet: true,
        InterpretationSet: true,
        // sensemaking
        SensemakingSessionActivityPlanSet: true,
        SensemakingSessionConstructionSet: true,
        SensemakingSessionOutcomeSet: true,
        ResonantPatternSet: true,
        ResonantStorySet: true,
    };
    // embedded set items to copy when duplicating item
    var ItemClassNames = {
        // planning
        ObservedStory: true,
        // collection
        CollectionSessionActivity: true,
        StoryForm: true,
        ElicitingQuestionChoice: true,
        StoryQuestionChoice: true,
        ParticipantQuestionChoice: true,
        TranslationDictionary: true,
        CollectionSessionConstruction: true,
        // catalysis
        StoryCollectionChoice: true,
        Observation: true,
        Interpretation: true,
        // sensemaking
        SensemakingSessionActivityPlan: true,
        SensemakingSessionConstruction: true,
        SensemakingSessionOutcome: true,
        ResonantPattern: true,
        ResonantStory: true,
    };
    // items for which short names are lookups:
    // eliciting, story, and participant questions
    // story forms
    // story collections
    // none of these are ever listed in nested grids
    function computeColumnsForItemPanelSpecification(itemPanelSpecification, gridConfiguration) {
        var columns = [];
        var panelFields = itemPanelSpecification.panelFields;
        if (!panelFields || !gridConfiguration)
            return columns;
        if (gridConfiguration.maxColumnCount == undefined)
            gridConfiguration.maxColumnCount = 5;
        var columnCount = 0;
        var fieldsToInclude = [];
        var columnsToDisplay = gridConfiguration.columnsToDisplay;
        // Put the columns in the order supplied if using columnsToDisplay, otherwise put them in order of panel specification
        if (columnsToDisplay && columnsToDisplay.constructor === Array) {
            columnsToDisplay.forEach(function (fieldName) {
                panelFields.forEach(function (fieldSpecification) {
                    if (fieldSpecification.id === fieldName)
                        fieldsToInclude.push(fieldSpecification);
                });
            });
        }
        else {
            panelFields.forEach(function (fieldSpecification) {
                if (columnsToDisplay) {
                    // TODO: improve this check if need to exclude other fields?
                    if (fieldSpecification.displayType !== "label" && fieldSpecification.displayType !== "header") {
                        fieldsToInclude.push(fieldSpecification);
                    }
                }
                else {
                    if (columnCount < gridConfiguration.maxColumnCount) {
                        if (displayTypesToDisplayAsColumns[fieldSpecification.displayType])
                            fieldsToInclude.push(fieldSpecification);
                        columnCount++;
                    }
                }
            });
        }
        fieldsToInclude.forEach(function (fieldSpecification) {
            // this is for one particular case (the patterns table in PatternExplorer) 
            // where the string to translate is literally "id" 
            // this causes the translate function to show "ID" instead of fieldSpecification.displayName 
            // because the "messages" data structure in applicationMessages has the lookup string "id::shortname"
            // this was a mistake that can't be changed because the "id" field is saved in the data for patterns
            var columnLabel = "";
            if (fieldSpecification.id === "id") {
                columnLabel = fieldSpecification.displayName;
            }
            else {
                columnLabel = translate(fieldSpecification.id + "::shortName", fieldSpecification.displayName);
            }
            var newColumn = {
                field: fieldSpecification.id,
                label: columnLabel,
                displayType: fieldSpecification.displayType
            };
            columns.push(newColumn);
        });
        return columns;
    }
    function isElementInViewport(parent, element) {
        var elementRect = element.getBoundingClientRect();
        var parentRect = parent.getBoundingClientRect();
        return (elementRect.top >= parentRect.top &&
            elementRect.left >= parentRect.left &&
            elementRect.bottom <= parentRect.bottom &&
            elementRect.right <= parentRect.right);
    }
    var ItemPanel = (function () {
        function ItemPanel() {
        }
        ItemPanel.controller = function (args) {
            return new ItemPanel();
        };
        ItemPanel.view = function (controller, args) {
            return controller.calculateView(args);
        };
        ItemPanel.prototype.calculateView = function (args) {
            // TODO: Should provide copy of item?
            var panelBuilder = args.panelBuilder;
            // Possible recursion if the panels contain a table
            var theClass = "narrafirma-griditempanel-viewing";
            if (args.mode === "edit") {
                theClass = "narrafirma-griditempanel-editing";
            }
            var oldReadOnly = panelBuilder.readOnly;
            if (args.mode === "view") {
                panelBuilder.readOnly = true;
            }
            try {
                var div = m("div", { "class": theClass }, panelBuilder.buildPanel(args.grid.itemPanelSpecification, args.item));
                return div;
            }
            finally {
                panelBuilder.readOnly = oldReadOnly;
            }
        };
        return ItemPanel;
    }());
    var defaultGridConfiguration = {
        idProperty: undefined,
        addButton: true,
        removeButton: true,
        columnsToDisplay: false,
        inlineButtons: false,
        navigationButtons: true,
        navigationButtonsAtBottom: false,
        customButton: null,
        validateAdd: null,
        validateEdit: null,
    };
    var sortCharacterUp = "\u25B2";
    var sortCharacterDown = "\u25BC";
    var sortCharacterBoth = "\u2003"; // Blank space equal to 1em
    // GridWithItemPanel needs to be a component so it can maintain a local sorted list
    var GridWithItemPanel = (function () {
        function GridWithItemPanel(args) {
            this.gridID = "grid_" + (++gridsMade);
            this.gridConfiguration = null;
            this.columns = [];
            this.fieldSpecification = null;
            this.itemPanelSpecification = null;
            this.idProperty = "_id";
            this.model = null;
            this.panelBuilder = null;
            // viewing, editing, adding - these are no longer being used
            // except for the one case, in the pattern explorer, where nothing is shown
            this.displayMode = null;
            // TODO: Multiple select
            this.selectedItem = null;
            this.isNavigationalScrollingNeeded = null;
            this.sortBy = null;
            this.sortDirection = "ascending";
            this.readOnly = false;
            this.panelBuilder = args.panelBuilder;
            this.fieldSpecification = args.fieldSpecification;
            this.model = args.model;
            this.readOnly = args.readOnly;
            this.updateDisplayConfigurationAndData(this.fieldSpecification.displayConfiguration);
        }
        GridWithItemPanel.prototype.onunload = function () {
        };
        GridWithItemPanel.prototype.updateDisplayConfigurationAndData = function (theDisplayConfiguration) {
            var itemPanelID;
            var itemPanelSpecification = null;
            if (_.isString(theDisplayConfiguration)) {
                itemPanelID = theDisplayConfiguration;
                this.gridConfiguration = defaultGridConfiguration;
            }
            else {
                itemPanelID = theDisplayConfiguration.itemPanelID;
                if (theDisplayConfiguration.gridConfiguration) {
                    this.gridConfiguration = theDisplayConfiguration.gridConfiguration;
                }
                else {
                    this.gridConfiguration = defaultGridConfiguration;
                }
                itemPanelSpecification = theDisplayConfiguration.itemPanelSpecification;
            }
            if (!itemPanelSpecification && itemPanelID) {
                itemPanelSpecification = this.panelBuilder.getPanelDefinitionForPanelID(itemPanelID);
            }
            this.itemPanelSpecification = itemPanelSpecification;
            if (!this.itemPanelSpecification) {
                console.log("Error: no itemPanelSpecification for options: ", this.fieldSpecification);
            }
            if (!this.model) {
                console.log("Error: no model is defined for grid", this.fieldSpecification);
                throw new Error("Error: no model is defined for grid");
            }
            if (this.gridConfiguration.idProperty)
                this.idProperty = this.gridConfiguration.idProperty;
            this.columns = computeColumnsForItemPanelSpecification(this.itemPanelSpecification, this.gridConfiguration);
            if (this.columns.length) {
                this.sortBy = this.columns[0].field;
            }
            // viewing, editing
            this.displayMode = null;
            // TODO: Multiple select
            this.setSelectedItem(null);
            this.isNavigationalScrollingNeeded = null;
            this.valueProperty = valuePathResolver.newValuePathForFieldSpecification(this.model, this.fieldSpecification);
            var itemClassName = itemPanelSpecification.modelClass;
            if (!itemClassName) {
                console.log("Error: No modelClass in panel specification", itemPanelSpecification);
                throw new Error("Error: No modelClass in panel specification for grid");
            }
            var setClassName = itemPanelSpecification.modelClass + "Set";
            if (this.useTriples()) {
                this.dataStore = new TripleSetDataStore(this.valueProperty, this.idProperty, this.gridConfiguration.transformDisplayedValues, setClassName, itemClassName, Globals.project().tripleStore);
            }
            else {
                this.dataStore = new DataStore(this.valueProperty, this.idProperty, this.gridConfiguration.transformDisplayedValues, setClassName, itemClassName);
            }
            this.updateData();
        };
        GridWithItemPanel.prototype.updateData = function () {
            this.dataStore.getDataArrayFromModel();
            this.sortData();
            if (this.selectedItem) {
                if (this.dataStore.data.indexOf(this.selectedItem) === -1) {
                    this.setSelectedItem(null);
                }
            }
        };
        GridWithItemPanel.prototype.sortData = function () {
            // TODO: This may need work for set???
            this.dataStore.sortData(this.sortBy, this.sortDirection);
        };
        GridWithItemPanel.controller = function (args) {
            return new GridWithItemPanel(args);
        };
        GridWithItemPanel.view = function (controller, args) {
            return controller.calculateView(args);
        };
        GridWithItemPanel.prototype.addNavigationButtons = function (buttons) {
            var navigationDisabled = this.dataStore.data.indexOf(this.selectedItem) === -1 || this.dataStore.isEmpty() || undefined;
            if (this.dataStore.data.length >= 6)
                buttons.push(m("button", { onclick: this.navigateClicked.bind(this, "start"), disabled: navigationDisabled }, m("span", { class: "buttonWithNoTextImage navigateToStartIconImage" })));
            if (this.dataStore.data.length >= 2)
                buttons.push(m("button", { onclick: this.navigateClicked.bind(this, "previous"), disabled: navigationDisabled }, m("span", { class: "buttonWithNoTextImage navigatePreviousIconImage" })));
            if (this.dataStore.data.length >= 2)
                buttons.push(m("button", { onclick: this.navigateClicked.bind(this, "next"), disabled: navigationDisabled }, m("span", { class: "buttonWithNoTextImage navigateNextIconImage" })));
            if (this.dataStore.data.length >= 6)
                buttons.push(m("button", { onclick: this.navigateClicked.bind(this, "end"), disabled: navigationDisabled }, m("span", { class: "buttonWithNoTextImage navigateToEndIconImage" })));
            if (this.gridConfiguration.randomButton)
                buttons.push(m("button", { onclick: this.navigateClicked.bind(this, "random"), disabled: navigationDisabled }, m("span", { class: "buttonWithTextImage navigateRandomButtonImage" }), translate("#button_navigateRandom|Random")));
        };
        GridWithItemPanel.prototype.calculateView = function (args) {
            var _this = this;
            // Deal with the fact that new items might be added at any time by other users
            // TODO: This is very inefficient. Alternatives include: listening for changes that add or remove items; or determing nature of change prompting redraw
            this.updateData();
            var panelBuilder = this.panelBuilder;
            var columnHeaders = this.columns.map(function (column) {
                var sortCharacter = sortCharacterBoth;
                if (column.field === _this.sortBy) {
                    if (_this.sortDirection === "ascending") {
                        sortCharacter = sortCharacterDown;
                    }
                    else if (_this.sortDirection === "descending") {
                        sortCharacter = sortCharacterUp;
                    }
                }
                return m("th[data-sort-by=" + column.field + "]", { "text-overflow": "ellipsis" }, column.label + sortCharacter);
            });
            if (this.gridConfiguration.inlineButtons) {
                columnHeaders.push(m("th", ""));
            }
            var table = m("table.scrolling", this.tableConfigurationWithSortingOnHeaderClick(), [
                m("tr", { "class": "grid-header-row" }, columnHeaders),
                this.dataStore.map(function (item, index) {
                    return _this.rowForItem(item, index);
                })
            ]);
            var addButtonDisabled = this.readOnly || this.isEditing() || undefined;
            var buttons = [];
            if (this.gridConfiguration.addButton) {
                var addButton = m("button", { onclick: this.addItem.bind(this), disabled: addButtonDisabled }, m("span", { class: "buttonWithTextImage addButtonImage" }), translate("#button_Add|Add"));
                buttons.push(addButton);
            }
            if (!this.gridConfiguration.inlineButtons) {
                buttons = buttons.concat(this.createButtons());
            }
            if (this.gridConfiguration.navigationButtons) {
                this.addNavigationButtons(buttons);
            }
            var buttonPanel = m("div.narrafirma-button-panel", buttons);
            var parts = [m("div.narrafirm-grid", { id: this.gridID }, [table]), buttonPanel];
            if (this.isViewing()) {
                parts.push(this.bottomEditorForItem(panelBuilder, this.selectedItem, "view"));
            }
            if (this.isEditing()) {
                parts.push(this.bottomEditorForItem(panelBuilder, this.selectedItem, "edit"));
            }
            if (this.gridConfiguration.navigationButtonsAtBottom && (this.isViewing() || this.isEditing())) {
                var bottomButtons = [];
                this.addNavigationButtons(bottomButtons);
                var bottomButtonPanel = m("div.narrafirma-button-panel", buttons);
                parts.push(bottomButtonPanel);
            }
            return m("div", { "class": "questionExternal narrafirma-question-type-grid" }, parts);
        };
        GridWithItemPanel.prototype.tableConfigurationWithSortingOnHeaderClick = function () {
            var _this = this;
            return {
                onclick: function (e) {
                    var sortBy = e.target.getAttribute("data-sort-by");
                    if (sortBy) {
                        // Sorting derived from: http://lhorie.github.io/mithril-blog/vanilla-table-sorting.htm
                        if (_this.sortBy === sortBy) {
                            if (_this.sortDirection === "ascending") {
                                _this.sortDirection = "descending";
                                _this.dataStore.reverseData();
                            }
                            else {
                                _this.sortDirection = "ascending";
                                _this.dataStore.reverseData();
                            }
                        }
                        else {
                            _this.sortBy = sortBy;
                            _this.sortDirection = "ascending";
                            _this.sortData();
                        }
                    }
                    else {
                        _this.selectItemInList(e);
                    }
                },
                config: this.ensureTableRowIsVisibleConfig.bind(this)
            };
        };
        GridWithItemPanel.prototype.selectItemInList = function (e) {
            if (!this.validateSelectedItem())
                return;
            var itemID = e.target.getAttribute("data-item-index");
            var item = this.dataStore.itemForId(itemID);
            if (item !== undefined) {
                this.setSelectedItem(item);
                if (!this.gridConfiguration.specialHiddenPanelForPatternExplorer) {
                    this.displayMode = "editing";
                }
            }
        };
        GridWithItemPanel.prototype.setSelectedItem = function (item) {
            this.selectedItem = item;
            // invalidate any gridwithitempanel inside this panel so it will be reconstructed with new model
            if (this.gridConfiguration.selectCallback) {
                this.gridConfiguration.selectCallback(this.selectedItem);
            }
        };
        GridWithItemPanel.prototype.isEditing = function () {
            return (this.displayMode === "editing" || this.displayMode === "adding") && this.selectedItem;
        };
        GridWithItemPanel.prototype.isViewing = function () {
            return (this.displayMode === "viewing") && this.selectedItem;
        };
        GridWithItemPanel.prototype.getSelectedItem = function () {
            return this.selectedItem;
        };
        GridWithItemPanel.prototype.validateItem = function (item) {
            var validationMethodIdentifier = this.gridConfiguration.validateEdit;
            if (this.displayMode === "adding")
                validationMethodIdentifier = this.gridConfiguration.validateAdd || validationMethodIdentifier;
            if (validationMethodIdentifier) {
                var fakeFieldSpecification = { displayConfiguration: validationMethodIdentifier, value: item };
                var errors = this.panelBuilder.calculateFunctionResult(null, fakeFieldSpecification);
                if (!errors)
                    return [];
                return errors;
            }
            return [];
        };
        GridWithItemPanel.prototype.validateSelectedItem = function () {
            if (this.isEditing()) {
                var item = this.selectedItem;
                if (item) {
                    var errors = this.validateItem(item);
                    if (errors.length) {
                        // TODO: Translate
                        alert(errors);
                        return false;
                    }
                }
            }
            return true;
        };
        GridWithItemPanel.prototype.bottomEditorForItem = function (panelBuilder, item, mode) {
            var itemID = item && (typeof item === "string" ? item : item.id);
            return m("div.narrafirma-griditempanel-divwithbutton" + "-" + mode + "ing", [
                m("button", { onclick: this.doneClicked.bind(this, item), class: "narrafirma-griditempanel-close-button" }, m("span", { class: "buttonWithTextImage closeButtonImage" }), "Close"),
                m.component(ItemPanel, { key: this.fieldSpecification.id + "_" + itemID + "_" + "bottomEditor" + "_" + mode, panelBuilder: panelBuilder, item: item, grid: this, mode: mode }),
                m("button", { onclick: this.doneClicked.bind(this, item), class: "narrafirma-griditempanel-bottom-close-button" }, m("span", { class: "buttonWithTextImage closeButtonImage" }), "Close")
            ]);
        };
        // Event handlers
        GridWithItemPanel.prototype.addItem = function () {
            var newItem = this.dataStore.makeNewItem();
            this.setSelectedItem(newItem);
            this.displayMode = "adding";
        };
        GridWithItemPanel.prototype.deleteItem = function (item) {
            if (!item)
                item = this.selectedItem;
            // TODO: Translate
            if (!confirm("Are you sure you want to delete this item?"))
                return;
            var index = this.dataStore.deleteItem(item);
            if (item === this.selectedItem) {
                this.setSelectedItem(null);
            }
        };
        GridWithItemPanel.prototype.duplicateItem = function (item) {
            if (!item)
                item = this.selectedItem;
            this.dataStore.makeCopyOfItemWithNewId(item);
        };
        GridWithItemPanel.prototype.editItem = function (item) {
            if (!item)
                item = this.selectedItem;
            // TODO: This needs to create an action that affects original list  
            this.setSelectedItem(item);
            this.displayMode = "editing";
        };
        GridWithItemPanel.prototype.viewItem = function (item, index) {
            if (!item)
                item = this.selectedItem;
            this.setSelectedItem(item);
            this.displayMode = "viewing";
        };
        GridWithItemPanel.prototype.doneClicked = function (item) {
            // TODO: Should ensure the data is saved
            if (this.isEditing()) {
                var errors = this.validateItem(item);
                if (errors.length) {
                    // TODO: Translate
                    alert(errors);
                    return true;
                }
            }
            // Leave item selected: this.setSelection(null);
            this.displayMode = null;
            return false;
        };
        GridWithItemPanel.prototype.navigateClicked = function (direction) {
            if (this.dataStore.isEmpty())
                return;
            var newPosition;
            switch (direction) {
                case "start":
                    newPosition = 0;
                    break;
                case "previous":
                    newPosition = this.dataStore.indexOf(this.selectedItem);
                    if (newPosition === -1)
                        newPosition = 0;
                    if (newPosition > 0)
                        newPosition--;
                    break;
                case "next":
                    newPosition = this.dataStore.indexOf(this.selectedItem);
                    if (newPosition < this.dataStore.length() - 1)
                        newPosition++;
                    break;
                case "end":
                    newPosition = this.dataStore.length() - 1;
                    break;
                case "random":
                    newPosition = Math.round(Math.random() * (this.dataStore.length() - 1));
                    break;
                default:
                    throw new Error("Unexpected direction: " + direction);
            }
            if (!this.validateSelectedItem())
                return;
            this.setSelectedItem(this.dataStore.itemForIndex(newPosition));
            this.isNavigationalScrollingNeeded = direction;
        };
        GridWithItemPanel.prototype.createButtons = function (item) {
            var _this = this;
            if (item === void 0) { item = undefined; }
            var buttons = [];
            var unavailable = (!item && !this.selectedItem) || undefined;
            var disabled = this.readOnly || unavailable;
            if (this.gridConfiguration.removeButton) {
                var removeButton = m("button", { onclick: this.deleteItem.bind(this, item), disabled: disabled, "class": "fader" }, m("span", { class: "buttonWithTextImage removeButtonImage" }), translate("#button_Remove|Remove"));
                buttons.push(removeButton);
            }
            if (this.gridConfiguration.duplicateButton) {
                var duplicateButton = m("button", { onclick: this.duplicateItem.bind(this, item), disabled: disabled, "class": "fader" }, m("span", { class: "buttonWithTextImage copyButtonImage" }), translate("#button_Duplicate|Duplicate"));
                buttons.push(duplicateButton);
            }
            if (this.gridConfiguration.customButton) {
                var options_1 = this.gridConfiguration.customButton;
                var customButtonClickedPartial = void 0;
                if (_.isString(options_1.callback)) {
                    var fakeFieldSpecification = { id: this.fieldSpecification.id, displayConfiguration: options_1.callback, grid: this, item: item };
                    customButtonClickedPartial = this.panelBuilder.buttonClicked.bind(this.panelBuilder, this.model, fakeFieldSpecification);
                }
                else {
                    customButtonClickedPartial = function (event) { options_1.callback(_this, item); };
                }
                var customButton = m("button", { onclick: customButtonClickedPartial, disabled: disabled }, m("span", { class: options_1.customButtonIconClass }), translate(options_1.customButtonLabel));
                buttons.push(customButton);
            }
            return buttons;
        };
        GridWithItemPanel.prototype.rowForItem = function (item, index) {
            var _this = this;
            var selected = (item === this.selectedItem);
            var selectionClass = "";
            if (selected) {
                if (index % 2 === 0) {
                    selectionClass = "narrafirma-grid-row-selected-even";
                }
                else {
                    selectionClass = "narrafirma-grid-row-selected-odd";
                }
            }
            else {
                if (index % 2 === 0) {
                    selectionClass = "narrafirma-grid-row-unselected-even";
                }
                else {
                    selectionClass = "narrafirma-grid-row-unselected-odd";
                }
            }
            var fields = this.columns.map(function (column) {
                var value = _this.dataStore.valueForField(item, column.field);
                var reformattedValue = undefined;
                if (value !== undefined && value !== "") {
                    if (column.field === "indexInStoryCollection") {
                        reformattedValue = value.toString();
                    }
                    else if (column.displayType == "boolean") {
                        reformattedValue = value ? "yes" : "no";
                    }
                    else if (column.displayType == "checkbox") {
                        if (typeof (value) === "string") {
                            reformattedValue = value; // for "is web form enabled" on "start story collection" page, the value is "yes" or "no"
                        }
                        else {
                            reformattedValue = value ? "checked" : "unchecked";
                        }
                    }
                    else if (column.displayType == "checkboxes") {
                        var positiveValues_1 = [];
                        Object.keys(value).forEach(function (key, index) { if (key && value[key])
                            positiveValues_1.push(key); });
                        reformattedValue = positiveValues_1.join(" / ");
                        // everything else is (probably) a string
                        // if there are carriage returns, convert them to slashes to fit into the table cell
                    }
                    else {
                        if (typeof value == "string") {
                            var find = "\n";
                            var re = new RegExp(find, 'g');
                            value = value.replace(re, " / ");
                            reformattedValue = value;
                        }
                        else {
                            reformattedValue = value;
                        }
                    }
                }
                if (reformattedValue == undefined)
                    reformattedValue = "";
                if (debug) {
                    return m("td", { "text-overflow": "ellipsis", "data-item-index": _this.dataStore.idForItem(item),
                        id: _this.makeHtmlIdForItem(item) }, reformattedValue + "|" + _this.dataStore.idForItem(item) + ", " + _this.dataStore["setIdentifier"]);
                }
                else {
                    return m("td", { "text-overflow": "ellipsis", "data-item-index": _this.dataStore.idForItem(item), id: _this.makeHtmlIdForItem(item) }, reformattedValue);
                }
            });
            if (this.gridConfiguration.inlineButtons) {
                var buttons = this.createButtons(item);
                fields = fields.concat(m("td", { nowrap: true }, buttons));
            }
            return m("tr", { key: this.dataStore.idForItem(item), "class": selectionClass }, fields);
        };
        GridWithItemPanel.prototype.ensureTableRowIsVisibleConfig = function (tableElement, isInitialized, context) {
            // Ensure the selected item is visible in the table
            // TODO: Could improve this so when navigating down the item is still near the bottom
            if (this.selectedItem && this.isNavigationalScrollingNeeded) {
                var rowElement = document.getElementById(this.makeHtmlIdForItem(this.selectedItem));
                if (rowElement && !isElementInViewport(tableElement, rowElement)) {
                    if (this.isNavigationalScrollingNeeded === "next" || this.isNavigationalScrollingNeeded === "end") {
                        tableElement.scrollTop = rowElement.offsetTop - tableElement.clientHeight + rowElement.offsetHeight;
                    }
                    else {
                        tableElement.scrollTop = rowElement.offsetTop;
                    }
                }
                this.isNavigationalScrollingNeeded = null;
            }
        };
        GridWithItemPanel.prototype.makeHtmlIdForItem = function (item) {
            return this.gridID + this.dataStore.idForItem(item);
        };
        GridWithItemPanel.prototype.useTriples = function () {
            if (typeof this.model === "string")
                return true;
            var storage = this.valueProperty();
            return typeof storage === "string";
        };
        return GridWithItemPanel;
    }());
    // ObjectArray datastore as base
    var DataStore = (function () {
        function DataStore(valueProperty, idProperty, valueTransform, setClassName, itemClassName) {
            this.valueProperty = valueProperty;
            this.idProperty = idProperty;
            this.valueTransform = valueTransform;
            this.setClassName = setClassName;
            this.itemClassName = itemClassName;
        }
        DataStore.prototype.newIdForItem = function () {
            return generateRandomUuid(this.itemClassName);
        };
        DataStore.prototype.length = function () {
            return this.data.length;
        };
        DataStore.prototype.isEmpty = function () {
            return this.data.length === 0;
        };
        DataStore.prototype.getDataArrayFromModel = function () {
            var data = this.valueProperty();
            if (!data) {
                data = [];
                this.valueProperty(data);
            }
            // Make a copy of the data because we will be sorting it
            // TODO: Copying data creates a problem because up/down movement wil not be reflected in original
            this.data = data.slice();
        };
        DataStore.prototype.makeCopyOfItemWithNewId = function (item) {
            // TODO: This needs to create an action that affects original list
            // Make a copy of the selected item
            var newItem = JSON.parse(JSON.stringify(item));
            // Set new id for copy
            // TODO: Will not work right if item is an object with some class
            newItem[this.idProperty] = this.newIdForItem();
            this.data.push(newItem);
            // TODO: This item will not be sorted
            return newItem;
        };
        DataStore.prototype.makeNewItem = function () {
            // TODO: This needs to create an action that affects original list
            var newItem = {};
            // TODO: Will not work right if item is an object with some class
            newItem[this.idProperty] = this.newIdForItem();
            this.data.push(newItem);
            // TODO: This item will not be sorted
            return newItem;
        };
        DataStore.prototype.deleteItem = function (item) {
            // TODO: This needs to create an action that affects original list
            var index = this.data.indexOf(item);
            this.data.splice(index, 1);
            return index;
        };
        DataStore.prototype.moveItemUp = function (item) {
            // TODO: How to move this change back to project data???
            var index = this.data.indexOf(item);
            if (index <= 0)
                return;
            this.data[index] = this.data[index - 1];
            this.data[index - 1] = item;
        };
        DataStore.prototype.moveItemDown = function (item) {
            // TODO: How to move this change back to project data???
            var index = this.data.indexOf(item);
            if (index === -1 || index === this.data.length - 1)
                return;
            this.data[index] = this.data[index + 1];
            this.data[index + 1] = item;
        };
        DataStore.prototype.idForItem = function (item) {
            var value = item[this.idProperty];
            if (typeof value === "function") {
                value = value.bind(item)();
            }
            return value;
        };
        DataStore.prototype.itemForId = function (itemID) {
            for (var i = 0; i < this.data.length; i++) {
                var item = this.data[i];
                if (this.idForItem(item) === itemID) {
                    return item;
                }
            }
            return undefined;
        };
        DataStore.prototype.valueForField = function (item, fieldName) {
            var value = item[fieldName];
            if (typeof item === "object" && item.model)
                value = item.fieldValue(fieldName);
            if (typeof value === "function")
                value = value.bind(item)();
            if (this.valueTransform)
                value = this.valueTransform(value, fieldName);
            return value;
        };
        DataStore.prototype.itemForIndex = function (index) {
            return this.data[index];
        };
        DataStore.prototype.map = function (callback) {
            return this.data.map(callback);
        };
        DataStore.prototype.indexOf = function (item) {
            return this.data.indexOf(item);
        };
        DataStore.prototype.sortData = function (fieldIdentifier, sortDirection) {
            var _this = this;
            // TODO: This may need work for set???
            this.data.sort(function (a, b) {
                var aValue = _this.valueForField(a, fieldIdentifier);
                if (aValue === null || aValue === undefined)
                    aValue = "";
                if (typeof aValue === "string")
                    aValue = aValue.toLowerCase();
                var bValue = _this.valueForField(b, fieldIdentifier);
                if (bValue === null || bValue === undefined)
                    bValue = "";
                if (typeof bValue === "string")
                    bValue = bValue.toLowerCase();
                // always sort empty values at the end, even if reversing the sort order
                if (sortDirection === "ascending") {
                    if (aValue === "" && bValue !== "")
                        return 1;
                    if (aValue !== "" && bValue === "")
                        return -1;
                }
                else {
                    if (aValue === "" && bValue !== "")
                        return -1;
                    if (aValue !== "" && bValue === "")
                        return 1;
                }
                // deal with special case of sider values, which are numbers converted to text
                // and will sort alphabetically if not converted back to numbers before sorting
                if (!isNaN(Number(aValue)) && !isNaN(Number(bValue))) {
                    return Number(aValue) > Number(bValue) ? 1 : Number(aValue) < Number(bValue) ? -1 : 0;
                }
                return aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
            });
            if (sortDirection === "descending") {
                this.data.reverse();
            }
        };
        DataStore.prototype.reverseData = function () {
            this.data.reverse();
        };
        return DataStore;
    }());
    var TripleSetDataStore = (function (_super) {
        __extends(TripleSetDataStore, _super);
        function TripleSetDataStore(valueProperty, idProperty, valueTransform, setClassName, itemClassName, tripleStore) {
            var _this = _super.call(this, valueProperty, idProperty, valueTransform, setClassName, itemClassName) || this;
            _this.tripleStore = tripleStore;
            return _this;
        }
        TripleSetDataStore.prototype.getDataArrayFromModel = function () {
            this.setIdentifier = this.valueProperty();
            // Design issue: Should we make a set if none exists at this time as opposed to lazily at first insertion of data?
            if (this.setIdentifier) {
                this.data = this.tripleStore.getListForSetIdentifier(this.setIdentifier);
            }
            else {
                this.data = [];
            }
        };
        // We don't make the set at startup; lazily make it if needed now
        TripleSetDataStore.prototype.ensureSetExists = function () {
            // TODO: Remove temporary addition with comparison on string type (for upgrading old data)
            if (!this.setIdentifier || typeof this.setIdentifier !== "string") {
                this.setIdentifier = this.tripleStore.newIdForSet(this.setClassName);
                this.valueProperty(this.setIdentifier);
            }
        };
        TripleSetDataStore.prototype.updateIDsInClusteringDiagram = function (newID, diagramFieldName, oldAndNewIDs) {
            var newReport = this.tripleStore.makeObject(newID, true);
            if (!newReport)
                return;
            var newDiagram = newReport[diagramFieldName];
            if (!newDiagram || !newDiagram.items)
                return;
            for (var _i = 0, _a = newDiagram.items; _i < _a.length; _i++) {
                var newItem = _a[_i];
                newItem.uuid = this.tripleStore.newIdForItemClass("ClusteringDiagramItem");
                newItem.referenceUUID = oldAndNewIDs[newItem.referenceUUID];
            }
            this.tripleStore.addTriple(newID, diagramFieldName, newDiagram);
        };
        TripleSetDataStore.prototype.makeCopyOfItemWithNewId = function (item) {
            // TODO: This needs to create an action that affects original list
            // Make a copy of the selected item
            this.ensureSetExists();
            var oldAndNewIDs = {};
            var newId = this.tripleStore.makeCopyOfItemOrSetWithNewId(0, item, this.itemClassName, SetClassNames, ItemClassNames, oldAndNewIDs);
            this.tripleStore.addTriple(this.setIdentifier, { setItem: newId }, newId);
            this.data.push(newId);
            // special treatment for catalysis report clustering diagrams
            // which have internal uuids, plus uuid references to interpretations or observations
            if (this.itemClassName === "CatalysisReport") {
                this.updateIDsInClusteringDiagram(newId, "interpretationsClusteringDiagram", oldAndNewIDs);
                this.updateIDsInClusteringDiagram(newId, "observationsClusteringDiagram", oldAndNewIDs);
            }
            return newId;
        };
        TripleSetDataStore.prototype.makeNewItem = function () {
            // TODO: This needs to create an action that affects original list
            this.ensureSetExists();
            var newId = this.tripleStore.makeNewSetItem(this.setIdentifier, this.itemClassName);
            this.data.push(newId);
            return newId;
        };
        TripleSetDataStore.prototype.deleteItem = function (item) {
            // TODO: This needs to create an action that affects original list
            // TODO: Should the C be undefined instead of null?
            this.tripleStore.deleteSetItem(this.setIdentifier, item);
            var index = this.data.indexOf(item);
            this.data.splice(index, 1);
            return index;
        };
        TripleSetDataStore.prototype.moveItemUp = function (item) {
            throw new Error("TripleSetDataStore moveItemUp Unfinished");
        };
        TripleSetDataStore.prototype.moveItemDown = function (item) {
            throw new Error("TripleSetDataStore moveItemDown Unfinished");
        };
        TripleSetDataStore.prototype.idForItem = function (item) {
            return item;
        };
        TripleSetDataStore.prototype.valueForField = function (item, fieldName) {
            var value = this.tripleStore.queryLatestC(item, fieldName);
            if (this.valueTransform)
                value = this.valueTransform(value, fieldName);
            return value;
        };
        return TripleSetDataStore;
    }(DataStore));
    return GridWithItemPanel;
});

/*!

JSZip v3.2.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('jszip',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.JSZip = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var support = require('./support');
// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";


// public method for encoding
exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
        }

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;
        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));

    }

    return output.join("");
};

// public method for decoding
exports.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength|0);
    } else {
        output = new Array(totalLength|0);
    }

    while (i < input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }

    }

    return output;
};

},{"./support":30,"./utils":32}],2:[function(require,module,exports){
'use strict';

var external = require("./external");
var DataWorker = require('./stream/DataWorker');
var DataLengthProbe = require('./stream/DataLengthProbe');
var Crc32Probe = require('./stream/Crc32Probe');
var DataLengthProbe = require('./stream/DataLengthProbe');

/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */
function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}

CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker : function () {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
        .pipe(this.compression.uncompressWorker())
        .pipe(new DataLengthProbe("data_length"));

        var that = this;
        worker.on("end", function () {
            if(this.streamInfo['data_length'] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
            }
        });
        return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker : function () {
        return new DataWorker(external.Promise.resolve(this.compressedContent))
        .withStreamInfo("compressedSize", this.compressedSize)
        .withStreamInfo("uncompressedSize", this.uncompressedSize)
        .withStreamInfo("crc32", this.crc32)
        .withStreamInfo("compression", this.compression)
        ;
    }
};

/**
 * Chain the given worker with other workers to compress the content with the
 * given compresion.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker
    .pipe(new Crc32Probe())
    .pipe(new DataLengthProbe("uncompressedSize"))
    .pipe(compression.compressWorker(compressionOptions))
    .pipe(new DataLengthProbe("compressedSize"))
    .withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(require,module,exports){
'use strict';

var GenericWorker = require("./stream/GenericWorker");

exports.STORE = {
    magic: "\x00\x00",
    compressWorker : function (compressionOptions) {
        return new GenericWorker("STORE compression");
    },
    uncompressWorker : function () {
        return new GenericWorker("STORE decompression");
    }
};
exports.DEFLATE = require('./flate');

},{"./flate":7,"./stream/GenericWorker":28}],4:[function(require,module,exports){
'use strict';

var utils = require('./utils');

/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c, table = [];

    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[n] = c;
    }

    return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

// That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */
function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if(isArray) {
        return crc32(crc|0, input, input.length, 0);
    } else {
        return crc32str(crc|0, input, input.length, 0);
    }
};

},{"./utils":32}],5:[function(require,module,exports){
'use strict';
exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

},{}],6:[function(require,module,exports){
/* global Promise */


// load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)
var ES6Promise = null;
if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
} else {
    ES6Promise = require("lie");
}

/**
 * Let the user use/change some implementations.
 */
module.exports = {
    Promise: ES6Promise
};

},{"lie":37}],7:[function(require,module,exports){
'use strict';
var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');

var pako = require("pako");
var utils = require("./utils");
var GenericWorker = require("./stream/GenericWorker");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

exports.magic = "\x08\x00";

/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */
function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);

    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    // the `meta` object from the last chunk received
    // this allow this worker to pass around metadata
    this.meta = {};
}

utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */
FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
};

/**
 * Create the _pako object.
 * TODO: lazy-loading this object isn't the best solution but it's the
 * quickest. The best solution is to lazy-load the worker list. See also the
 * issue #446.
 */
FlateWorker.prototype._createPako = function () {
    this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1 // default compression
    });
    var self = this;
    this._pako.onData = function(data) {
        self.push({
            data : data,
            meta : self.meta
        });
    };
};

exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
};
exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
};

},{"./stream/GenericWorker":28,"./utils":32,"pako":38}],8:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');
var utf8 = require('../utf8');
var crc32 = require('../crc32');
var signature = require('../signature');

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
var decToHex = function(dec, bytes) {
    var hex = "", i;
    for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
    }
    return hex;
};

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
var generateUnixExternalFileAttr = function (unixPermissions, isDir) {

    var result = unixPermissions;
    if (!unixPermissions) {
        // I can't use octal values in strict mode, hence the hexa.
        //  040775 => 0x41fd
        // 0100664 => 0x81b4
        result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
};

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
var generateDosExternalFileAttr = function (dosPermissions, isDir) {

    // the dir flag is already set for compatibility
    return (dosPermissions || 0)  & 0x3F;
};

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with informations about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
    compression = streamInfo['compression'],
    useCustomEncoding = encodeFileName !== utf8.utf8encode,
    encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
    utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
    comment = file.comment,
    encodedComment = utils.transformTo("string", encodeFileName(comment)),
    utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
    useUTF8ForComment = utfEncodedComment.length !== comment.length,
    dosTime,
    dosDate,
    extraFields = "",
    unicodePathExtraField = "",
    unicodeCommentExtraField = "",
    dir = file.dir,
    date = file.date;


    var dataInfo = {
        crc32 : 0,
        compressedSize : 0,
        uncompressedSize : 0
    };

    // if the content is streamed, the sizes/crc32 are only available AFTER
    // the end of the stream.
    if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo['crc32'];
        dataInfo.compressedSize = streamInfo['compressedSize'];
        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }

    var bitflag = 0;
    if (streamedContent) {
        // Bit 3: the sizes/crc32 are set to zero in the local header.
        // The correct values are put in the data descriptor immediately
        // following the compressed data.
        bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        // Bit 11: Language encoding flag (EFS).
        bitflag |= 0x0800;
    }


    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
        // dos or unix, we set the dos dir flag
        extFileAttr |= 0x00010;
    }
    if(platform === "UNIX") {
        versionMadeBy = 0x031E; // UNIX, version 3.0
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else { // DOS or other, fallback to DOS
        versionMadeBy = 0x0014; // DOS, version 2.0
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }

    // date
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;

    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | (date.getUTCMonth() + 1);
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();

    if (useUTF8ForFileName) {
        // set the unicode path extra field. unzip needs at least one extra
        // field to correctly handle unicode path, so using the path is as good
        // as any other information. This could improve the situation with
        // other archive managers too.
        // This field is usually used without the utf8 flag, with a non
        // unicode path in the header (winrar, winzip). This helps (a bit)
        // with the messy Windows' default compressed folders feature but
        // breaks on p7zip which doesn't seek the unicode path extra field.
        // So for now, UTF-8 everywhere !
        unicodePathExtraField =
            // Version
            decToHex(1, 1) +
            // NameCRC32
            decToHex(crc32(encodedFileName), 4) +
            // UnicodeName
            utfEncodedFileName;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x70" +
            // size
            decToHex(unicodePathExtraField.length, 2) +
            // content
            unicodePathExtraField;
    }

    if(useUTF8ForComment) {

        unicodeCommentExtraField =
            // Version
            decToHex(1, 1) +
            // CommentCRC32
            decToHex(crc32(encodedComment), 4) +
            // UnicodeName
            utfEncodedComment;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x63" +
            // size
            decToHex(unicodeCommentExtraField.length, 2) +
            // content
            unicodeCommentExtraField;
    }

    var header = "";

    // version needed to extract
    header += "\x0A\x00";
    // general purpose bit flag
    header += decToHex(bitflag, 2);
    // compression method
    header += compression.magic;
    // last mod file time
    header += decToHex(dosTime, 2);
    // last mod file date
    header += decToHex(dosDate, 2);
    // crc-32
    header += decToHex(dataInfo.crc32, 4);
    // compressed size
    header += decToHex(dataInfo.compressedSize, 4);
    // uncompressed size
    header += decToHex(dataInfo.uncompressedSize, 4);
    // file name length
    header += decToHex(encodedFileName.length, 2);
    // extra field length
    header += decToHex(extraFields.length, 2);


    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

    var dirRecord = signature.CENTRAL_FILE_HEADER +
        // version made by (00: DOS)
        decToHex(versionMadeBy, 2) +
        // file header (common to file and central directory)
        header +
        // file comment length
        decToHex(encodedComment.length, 2) +
        // disk number start
        "\x00\x00" +
        // internal file attributes TODO
        "\x00\x00" +
        // external file attributes
        decToHex(extFileAttr, 4) +
        // relative offset of local header
        decToHex(offset, 4) +
        // file name
        encodedFileName +
        // extra field
        extraFields +
        // file comment
        encodedComment;

    return {
        fileRecord: fileRecord,
        dirRecord: dirRecord
    };
};

/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */
var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
        // number of this disk
        "\x00\x00" +
        // number of the disk with the start of the central directory
        "\x00\x00" +
        // total number of entries in the central directory on this disk
        decToHex(entriesCount, 2) +
        // total number of entries in the central directory
        decToHex(entriesCount, 2) +
        // size of the central directory   4 bytes
        decToHex(centralDirLength, 4) +
        // offset of start of central directory with respect to the starting disk number
        decToHex(localDirLength, 4) +
        // .ZIP file comment length
        decToHex(encodedComment.length, 2) +
        // .ZIP file comment
        encodedComment;

    return dirEnd;
};

/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing informations
 * on the file entry.
 * @return {String} the data descriptors.
 */
var generateDataDescriptors = function (streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR +
        // crc-32                          4 bytes
        decToHex(streamInfo['crc32'], 4) +
        // compressed size                 4 bytes
        decToHex(streamInfo['compressedSize'], 4) +
        // uncompressed size               4 bytes
        decToHex(streamInfo['uncompressedSize'], 4);

    return descriptor;
};


/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */
function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emited metadata.
    this.currentFile = null;



    this._sources = [];
}
utils.inherits(ZipFileWorker, GenericWorker);

/**
 * @see GenericWorker.push
 */
ZipFileWorker.prototype.push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if(this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data : chunk.data,
            meta : {
                currentFile : this.currentFile,
                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
};

/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */
ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    var streamedContent = this.streamFiles && !streamInfo['file'].dir;

    // don't stream folders (because they don't have any content)
    if(streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
};

/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */
ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

    this.dirRecords.push(record.dirRecord);
    if(streamedContent) {
        // after the streamed file, we put data descriptors
        this.push({
            data : generateDataDescriptors(streamInfo),
            meta : {percent:100}
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
        while(this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
};

/**
 * @see GenericWorker.flush
 */
ZipFileWorker.prototype.flush = function () {

    var localDirLength = this.bytesWritten;
    for(var i = 0; i < this.dirRecords.length; i++) {
        this.push({
            data : this.dirRecords[i],
            meta : {percent:100}
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

    this.push({
        data : dirEnd,
        meta : {percent:100}
    });
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if(self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};

/**
 * @see GenericWorker.resume
 */
ZipFileWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
    }
};

/**
 * @see GenericWorker.error
 */
ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if(!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for(var i = 0; i < sources.length; i++) {
        try {
            sources[i].error(e);
        } catch(e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
};

/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for(var i = 0; i < sources.length; i++) {
        sources[i].lock();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(require,module,exports){
'use strict';

var compressions = require('../compressions');
var ZipFileWorker = require('./ZipFileWorker');

/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */
var getCompression = function (fileCompression, zipCompression) {

    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
};

/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir, date = file.date;

            file._compressWorker(compression, compressionOptions)
            .withStreamInfo("file", {
                name : relativePath,
                dir : dir,
                date : date,
                comment : file.comment || "",
                unixPermissions : file.unixPermissions,
                dosPermissions : file.dosPermissions
            })
            .pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
};

},{"../compressions":3,"./ZipFileWorker":8}],10:[function(require,module,exports){
'use strict';

/**
 * Representation a of zip file in js
 * @constructor
 */
function JSZip() {
    // if this constructor is used without `new`, it adds `new` before itself:
    if(!(this instanceof JSZip)) {
        return new JSZip();
    }

    if(arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}
JSZip.prototype = require('./object');
JSZip.prototype.loadAsync = require('./load');
JSZip.support = require('./support');
JSZip.defaults = require('./defaults');

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.2.0";

JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var external = require("./external");
var utf8 = require('./utf8');
var utils = require('./utils');
var ZipEntries = require('./zipEntries');
var Crc32Probe = require('./stream/Crc32Probe');
var nodejsUtils = require("./nodejsUtils");

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function (e) {
            reject(e);
        })
        .on("end", function () {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
                resolve();
            }
        })
        .resume();
    });
}

module.exports = function(data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
    .then(function(data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment : input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions : input.unixPermissions,
                dosPermissions : input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
};

},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(require,module,exports){
"use strict";

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');

/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */
function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);

/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */
NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream
    .on("data", function (chunk) {
        self.push({
            data: chunk,
            meta : {
                percent : 0
            }
        });
    })
    .on("error", function (e) {
        if(self.isPaused) {
            this.generatedError = e;
        } else {
            self.error(e);
        }
    })
    .on("end", function () {
        if(self.isPaused) {
            self._upstreamEnded = true;
        } else {
            self.end();
        }
    });
};
NodejsStreamInputAdapter.prototype.pause = function () {
    if(!GenericWorker.prototype.pause.call(this)) {
        return false;
    }
    this._stream.pause();
    return true;
};
NodejsStreamInputAdapter.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if(this._upstreamEnded) {
        this.end();
    } else {
        this._stream.resume();
    }

    return true;
};

module.exports = NodejsStreamInputAdapter;

},{"../stream/GenericWorker":28,"../utils":32}],13:[function(require,module,exports){
'use strict';

var Readable = require('readable-stream').Readable;

var utils = require('../utils');
utils.inherits(NodejsStreamOutputAdapter, Readable);

/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/
function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if(updateCb) {
            updateCb(meta);
        }
    })
    .on("error", function(e) {
        self.emit('error', e);
    })
    .on("end", function () {
        self.push(null);
    });
}


NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

},{"../utils":32,"readable-stream":16}],14:[function(require,module,exports){
'use strict';

module.exports = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode : typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer from an existing content.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBufferFrom: function(data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
            return Buffer.from(data, encoding);
        } else {
            if (typeof data === "number") {
                // Safeguard for old Node.js versions. On newer versions,
                // Buffer.from(number) / Buffer(number, encoding) already throw.
                throw new Error("The \"data\" argument must not be a number");
            }
            return new Buffer(data, encoding);
        }
    },
    /**
     * Create a new nodejs Buffer with the specified size.
     * @param {Integer} size the size of the buffer.
     * @return {Buffer} a new Buffer.
     */
    allocBuffer: function (size) {
        if (Buffer.alloc) {
            return Buffer.alloc(size);
        } else {
            var buf = new Buffer(size);
            buf.fill(0);
            return buf;
        }
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer : function(b){
        return Buffer.isBuffer(b);
    },

    isStream : function (obj) {
        return obj &&
            typeof obj.on === "function" &&
            typeof obj.pause === "function" &&
            typeof obj.resume === "function";
    }
};

},{}],15:[function(require,module,exports){
'use strict';
var utf8 = require('./utf8');
var utils = require('./utils');
var GenericWorker = require('./stream/GenericWorker');
var StreamHelper = require('./stream/StreamHelper');
var defaults = require('./defaults');
var CompressedObject = require('./compressedObject');
var ZipObject = require('./zipObject');
var generate = require("./generate");
var nodejsUtils = require("./nodejsUtils");
var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");


/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */
var fileAdd = function(name, data, originalOptions) {
    // be sure sub folders exist
    var dataType = utils.getTypeOf(data),
        parent;


    /*
     * Correct options.
     */

    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date();
    if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
    }

    if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
    }

    // UNX_IFDIR  0040000 see zipinfo.c
    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {
        o.dir = true;
    }
    // Bit 4    Directory
    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {
        o.dir = true;
    }

    if (o.dir) {
        name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
    }

    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
    }


    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;

    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
    }

    /*
     * Convert content to fit.
     */

    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }

    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
    /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?

    return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
};

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
var parentFolder = function (path) {
    if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf('/');
    return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
};

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
var forceTrailingSlash = function(path) {
    // Check the name ends with a /
    if (path.slice(-1) !== "/") {
        path += "/"; // IE doesn't like substr(-1)
    }
    return path;
};

/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
var folderAdd = function(name, createFolders) {
    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;

    name = forceTrailingSlash(name);

    // Does this folder already exist?
    if (!this.files[name]) {
        fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
        });
    }
    return this.files[name];
};

/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}

// return the actual prototype of JSZip
var out = {
    /**
     * @see loadAsync
     */
    load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },


    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
                continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root
                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
            }
        }
    },

    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function(search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
            if (search(relativePath, entry)) { // the file matches the function
                result.push(entry);
            }

        });
        return result;
    },

    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function(name, data, o) {
        if (arguments.length === 1) {
            if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function(relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                });
            }
            else { // text
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                    return obj;
                } else {
                    return null;
                }
            }
        }
        else { // more than one argument : we have data !
            name = this.root + name;
            fileAdd.call(this, name, data, o);
        }
        return this;
    },

    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function(arg) {
        if (!arg) {
            return this;
        }

        if (isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
                return file.dir && arg.test(relativePath);
            });
        }

        // else, name is a new folder
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);

        // Allow chaining by returning a new object with this folder as the root
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
    },

    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
            // Look for any folders
            if (name.slice(-1) !== "/") {
                name += "/";
            }
            file = this.files[name];
        }

        if (file && !file.dir) {
            // file
            delete this.files[name];
        } else {
            // maybe a folder, delete recursively
            var kids = this.filter(function(relativePath, file) {
                return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
            }
        }

        return this;
    },

    /**
     * Generate the complete zip file
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
     */
    generate: function(options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
          opts = utils.extend(options || {}, {
              streamFiles: false,
              compression: "STORE",
              compressionOptions : null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: 'application/zip',
              encodeFileName: utf8.utf8encode
          });

          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();

          // "binarystring" is prefered but the internals use "string".
          if(opts.type === "binarystring") {
            opts.type = "string";
          }

          if (!opts.type) {
            throw new Error("No output type specified.");
          }

          utils.checkSupport(opts.type);

          // accept nodejs `process.platform`
          if(
              opts.platform === 'darwin' ||
              opts.platform === 'freebsd' ||
              opts.platform === 'linux' ||
              opts.platform === 'sunos'
          ) {
              opts.platform = "UNIX";
          }
          if (opts.platform === 'win32') {
              opts.platform = "DOS";
          }

          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
            options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
};
module.exports = out;

},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(require,module,exports){
/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = require("stream");

},{"stream":undefined}],17:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function ArrayReader(data) {
    DataReader.call(this, data);
	for(var i = 0; i < this.data.length; i++) {
		data[i] = data[i] & 0xFF;
	}
}
utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function(i) {
    return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = ArrayReader;

},{"../utils":32,"./DataReader":18}],18:[function(require,module,exports){
'use strict';
var utils = require('../utils');

function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}
DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specified index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");
        }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function(n) {
        this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function(i) {
        // see implementations
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function(size) {
        var result = 0,
            i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function(size) {
        return utils.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function(size) {
        // see implementations
    },
    /**
     * Find the last occurence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurence, -1 if not found.
     */
    lastIndexOfSignature: function(sig) {
        // see implementations
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function(sig) {
        // see implementations
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
        ((dostime >> 25) & 0x7f) + 1980, // year
        ((dostime >> 21) & 0x0f) - 1, // month
        (dostime >> 16) & 0x1f, // day
        (dostime >> 11) & 0x1f, // hour
        (dostime >> 5) & 0x3f, // minute
        (dostime & 0x1f) << 1)); // second
    }
};
module.exports = DataReader;

},{"../utils":32}],19:[function(require,module,exports){
'use strict';
var Uint8ArrayReader = require('./Uint8ArrayReader');
var utils = require('../utils');

function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}
utils.inherits(NodeBufferReader, Uint8ArrayReader);

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = NodeBufferReader;

},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function StringReader(data) {
    DataReader.call(this, data);
}
utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function(i) {
    return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */
StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function(size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "& 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = StringReader;

},{"../utils":32,"./DataReader":18}],21:[function(require,module,exports){
'use strict';
var ArrayReader = require('./ArrayReader');
var utils = require('../utils');

function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}
utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = Uint8ArrayReader;

},{"../utils":32,"./ArrayReader":17}],22:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var support = require('../support');
var ArrayReader = require('./ArrayReader');
var StringReader = require('./StringReader');
var NodeBufferReader = require('./NodeBufferReader');
var Uint8ArrayReader = require('./Uint8ArrayReader');

/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */
module.exports = function (data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
        return new StringReader(data);
    }
    if (type === "nodebuffer") {
        return new NodeBufferReader(data);
    }
    if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
};

},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(require,module,exports){
'use strict';
exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

},{}],24:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var utils = require('../utils');

/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */
function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}
utils.inherits(ConvertWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : utils.transformTo(this.destType, chunk.data),
        meta : chunk.meta
    });
};
module.exports = ConvertWorker;

},{"../utils":32,"./GenericWorker":28}],25:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var crc32 = require('../crc32');
var utils = require('../utils');

/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */
function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
}
utils.inherits(Crc32Probe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Crc32Probe.prototype.processChunk = function (chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
};
module.exports = Crc32Probe;

},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */
function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}
utils.inherits(DataLengthProbe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
DataLengthProbe.prototype.processChunk = function (chunk) {
    if(chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
};
module.exports = DataLengthProbe;


},{"../utils":32,"./GenericWorker":28}],27:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

// the size of the generated chunks
// TODO expose this as a public variable
var DEFAULT_BLOCK_SIZE = 16 * 1024;

/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */
function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data && data.length || 0;
        self.type = utils.getTypeOf(data);
        if(!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);

/**
 * @see GenericWorker.cleanUp
 */
DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
};

/**
 * @see GenericWorker.resume
 */
DataWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
};

/**
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if(this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if(!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
 * Read and push a chunk.
 */
DataWorker.prototype._tick = function() {

    if(this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
        // EOF
        return this.end();
    } else {
        switch(this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
            break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
            break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
            data : data,
            meta : {
                percent : this.max ? this.index / this.max * 100 : 0
            }
        });
    }
};

module.exports = DataWorker;

},{"../utils":32,"./GenericWorker":28}],28:[function(require,module,exports){
'use strict';

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */
function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data':[],
        'end':[],
        'error':[]
    };
    // the previous worker, if any
    this.previous = null;
}

GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push : function (chunk) {
        this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end : function () {
        if (this.isFinished) {
            return false;
        }

        this.flush();
        try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
        } catch (e) {
            this.emit("error", e);
        }
        return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error : function (e) {
        if (this.isFinished) {
            return false;
        }

        if(this.isPaused) {
            this.generatedError = e;
        } else {
            this.isFinished = true;

            this.emit("error", e);

            // in the workers chain exploded in the middle of the chain,
            // the error event will go downward but we also need to notify
            // workers upward that there has been an error.
            if(this.previous) {
                this.previous.error(e);
            }

            this.cleanUp();
        }
        return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on : function (name, listener) {
        this._listeners[name].push(listener);
        return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp : function () {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit : function (name, arg) {
        if (this._listeners[name]) {
            for(var i = 0; i < this._listeners[name].length; i++) {
                this._listeners[name][i].call(this, arg);
            }
        }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe : function (next) {
        return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious : function (previous) {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }

        // sharing the streamInfo...
        this.streamInfo = previous.streamInfo;
        // ... and adding our own bits
        this.mergeStreamInfo();
        this.previous =  previous;
        var self = this;
        previous.on('data', function (chunk) {
            self.processChunk(chunk);
        });
        previous.on('end', function () {
            self.end();
        });
        previous.on('error', function (e) {
            self.error(e);
        });
        return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause : function () {
        if(this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = true;

        if(this.previous) {
            this.previous.pause();
        }
        return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume : function () {
        if(!this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = false;

        // if true, the worker tried to resume but failed
        var withError = false;
        if(this.generatedError) {
            this.error(this.generatedError);
            withError = true;
        }
        if(this.previous) {
            this.previous.resume();
        }

        return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush : function () {},
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk : function(chunk) {
        this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo : function (key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo : function () {
        for(var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
        }
    },

    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function () {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
            this.previous.lock();
        }
    },

    /**
     *
     * Pretty print the workers chain.
     */
    toString : function () {
        var me = "Worker " + this.name;
        if (this.previous) {
            return this.previous + " -> " + me;
        } else {
            return me;
        }
    }
};

module.exports = GenericWorker;

},{}],29:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var ConvertWorker = require('./ConvertWorker');
var GenericWorker = require('./GenericWorker');
var base64 = require('../base64');
var support = require("../support");
var external = require("../external");

var NodejsStreamOutputAdapter = null;
if (support.nodestream) {
    try {
        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
    } catch(e) {}
}

/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(type, content, mimeType) {
    switch(type) {
        case "blob" :
            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64" :
            return base64.encode(content);
        default :
            return utils.transformTo(type, content);
    }
}

/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */
function concat (type, dataArray) {
    var i, index = 0, res = null, totalLength = 0;
    for(i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
    }
    switch(type) {
        case "string":
            return dataArray.join("");
          case "array":
            return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
            res = new Uint8Array(totalLength);
            for(i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index);
                index += dataArray[i].length;
            }
            return res;
        case "nodebuffer":
            return Buffer.concat(dataArray);
        default:
            throw new Error("concat : unsupported type '"  + type + "'");
    }
}

/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */
function accumulate(helper, updateCallback) {
    return new external.Promise(function (resolve, reject){
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper
        .on('data', function (data, meta) {
            dataArray.push(data);
            if(updateCallback) {
                updateCallback(meta);
            }
        })
        .on('error', function(err) {
            dataArray = [];
            reject(err);
        })
        .on('end', function (){
            try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
            } catch (e) {
                reject(e);
            }
            dataArray = [];
        })
        .resume();
    });
}

/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */
function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch(outputType) {
        case "blob":
        case "arraybuffer":
            internalType = "uint8array";
        break;
        case "base64":
            internalType = "string";
        break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch(e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}

StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate : function (updateCb) {
        return accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on : function (evt, fn) {
        var self = this;

        if(evt === "data") {
            this._worker.on(evt, function (chunk) {
                fn.call(self, chunk.data, chunk.meta);
            });
        } else {
            this._worker.on(evt, function () {
                utils.delay(fn, arguments, self);
            });
        }
        return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume : function () {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause : function () {
        this._worker.pause();
        return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream : function (updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
            // an object stream containing blob/arraybuffer/uint8array/string
            // is strange and I don't know if it would be useful.
            // I you find this comment and have a good usecase, please open a
            // bug report !
            throw new Error(this._outputType + " is not supported by this method");
        }

        return new NodejsStreamOutputAdapter(this, {
            objectMode : this._outputType !== "nodebuffer"
        }, updateCb);
    }
};


module.exports = StreamHelper;

},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(require,module,exports){
'use strict';

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if JSZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
}
else {
    var buffer = new ArrayBuffer(0);
    try {
        exports.blob = new Blob([buffer], {
            type: "application/zip"
        }).size === 0;
    }
    catch (e) {
        try {
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
        }
        catch (e) {
            exports.blob = false;
        }
    }
}

try {
    exports.nodestream = !!require('readable-stream').Readable;
} catch(e) {
    exports.nodestream = false;
}

},{"readable-stream":16}],31:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
var nodejsUtils = require('./nodejsUtils');
var GenericWorker = require('./stream/GenericWorker');

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i=0; i<256; i++) {
  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);
}
_utf8len[254]=_utf8len[254]=1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = function (str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    if (support.uint8array) {
        buf = new Uint8Array(buf_len);
    } else {
        buf = new Array(buf_len);
    }

    // convert
    for (i=0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            /* one byte */
            buf[i++] = c;
        } else if (c < 0x800) {
            /* two bytes */
            buf[i++] = 0xC0 | (c >>> 6);
            buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
            /* three bytes */
            buf[i++] = 0xE0 | (c >>> 12);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        } else {
            /* four bytes */
            buf[i++] = 0xf0 | (c >>> 18);
            buf[i++] = 0x80 | (c >>> 12 & 0x3f);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        }
    }

    return buf;
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function(buf, max) {
    var pos;

    max = max || buf.length;
    if (max > buf.length) { max = buf.length; }

    // go back from last position, until start of sequence found
    pos = max-1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

    // Fuckup - very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) { return max; }

    // If we came to start of buffer - that means vuffer is too small,
    // return max too.
    if (pos === 0) { return max; }

    return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

// convert array to string
var buf2string = function (buf) {
    var str, i, out, c, c_len;
    var len = buf.length;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len*2);

    for (out=0, i=0; i<len;) {
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) { utf16buf[out++] = c; continue; }

        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
            c = (c << 6) | (buf[i++] & 0x3f);
            c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
            utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
    }

    // shrinkBuf(utf16buf, out)
    if (utf16buf.length !== out) {
        if(utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.applyFromCharCode(utf16buf);
};


// That's all for the pako functions.


/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
    }

    return string2buf(str);
};


/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};

/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */
function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}
utils.inherits(Utf8DecodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8DecodeWorker.prototype.processChunk = function (chunk) {

    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

    // 1st step, re-use what's left of the previous chunk
    if (this.leftOver && this.leftOver.length) {
        if(support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
        } else {
            data = this.leftOver.concat(data);
        }
        this.leftOver = null;
    }

    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
        if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
        }
    }

    this.push({
        data : exports.utf8decode(usableData),
        meta : chunk.meta
    });
};

/**
 * @see GenericWorker.flush
 */
Utf8DecodeWorker.prototype.flush = function () {
    if(this.leftOver && this.leftOver.length) {
        this.push({
            data : exports.utf8decode(this.leftOver),
            meta : {}
        });
        this.leftOver = null;
    }
};
exports.Utf8DecodeWorker = Utf8DecodeWorker;

/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */
function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : exports.utf8encode(chunk.data),
        meta : chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;

},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(require,module,exports){
'use strict';

var support = require('./support');
var base64 = require('./base64');
var nodejsUtils = require('./nodejsUtils');
var setImmediate = require('set-immediate-shim');
var external = require("./external");


/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */
function string2binary(str) {
    var result = null;
    if (support.uint8array) {
      result = new Uint8Array(str.length);
    } else {
      result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
}

/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 *
 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 * when a large amount of Array is used to create the Blob, the amount of
 * memory consumed is nearly 100 times the original data amount.
 *
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function(part, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob([part], {
            type: type
        });
    }
    catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
        }
        catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }


};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
    return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
    for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
    }
    return array;
}

/**
 * An helper for the function arrayLikeToString.
 * This contains static informations and functions that
 * can be optimized by the browser JIT compiler.
 */
var arrayToStringHelper = {
    /**
     * Transform an array of int into a string, chunk by chunk.
     * See the performances notes on arrayLikeToString.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @param {String} type the type of the array.
     * @param {Integer} chunk the chunk size.
     * @return {String} the resulting string.
     * @throws Error if the chunk is too big for the stack.
     */
    stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        // shortcut
        if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
            if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            }
            else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
        }
        return result.join("");
    },
    /**
     * Call String.fromCharCode on every item in the array.
     * This is the naive implementation, which generate A LOT of intermediate string.
     * This should be used when everything else fail.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @return {String} the result.
     */
    stringifyByChar: function(array){
        var resultStr = "";
        for(var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
    },
    applyCanBeUsed : {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array : (function () {
            try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
                return false;
            }
        })(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer : (function () {
            try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
            } catch (e) {
                return false;
            }
        })()
    }
};

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk > 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;


/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform["string"] = {
    "string": identity,
    "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
};

// array to ?
transform["array"] = {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function(input) {
        return (new Uint8Array(input)).buffer;
    },
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// arraybuffer to ?
transform["arraybuffer"] = {
    "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
    },
    "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
};

// uint8array to ?
transform["uint8array"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return input.buffer;
    },
    "uint8array": identity,
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// nodebuffer to ?
transform["nodebuffer"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function(outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function(input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function(type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function(str) {
    var res = '',
        code, i;
    for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
};

/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */
exports.delay = function(callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
};

/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */
exports.inherits = function (ctor, superCtor) {
    var Obj = function() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function() {
    var result = {}, i, attr;
    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
};

/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */
exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function(data) {
        
        
        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

        if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function(e) {
                    resolve(e.target.result);
                };
                reader.onerror = function(e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function(data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(
                new Error("Can't read the data of '" + name + "'. Is it " +
                          "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
            );
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            }
            else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
};

},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var sig = require('./signature');
var ZipEntry = require('./zipEntry');
var utf8 = require('./utf8');
var support = require('./support');
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}
ZipEntries.prototype = {
    /**
     * Check that the reader is on the specified signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);

        this.zipCommentLength = this.reader.readInt(2);
        // warning : the encoding depends of the system locale
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
        // On a windows machine, this field is encoded with the localized windows code page.
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        // To get consistent behavior with the generation part, we will assume that
        // this is utf8 encoded unless specified otherwise.
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        // this.versionMadeBy = this.reader.readString(2);
        // this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);

        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
        }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
        }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function() {
        var file;

        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
                zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
        }

        if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
                // We expected some records but couldn't find ANY.
                // This is really suspicious, as if something went wrong.
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
                // We found some records but not all.
                // Something is wrong but we got something for the user: no error here.
                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
            }
        }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
            // Check if the content is a truncated zip or complete garbage.
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
            // extractible zip for example) but it can give a good hint.
            // If an ajax request was used without responseType, we will also
            // get unreadable data.
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

            if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? " +
                                "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
                throw new Error("Corrupted zip: can't find end of central directory");
            }

        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();


        /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;

            /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

            // should look for a zip64 EOCD locator
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();

            // now the zip64 EOCD record
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                // console.warn("ZIP64 end of central directory not where expected.");
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
        }

        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
        }

        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

        if (extraBytes > 0) {
            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                // The offsets seem wrong, but we have something at the specified offset.
                // So… we keep it.
            } else {
                // the offset is wrong, update the "zero" of the reader
                // this happens if data has been prepended (crx files for example)
                this.reader.zero = extraBytes;
            }
        } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
    },
    prepareReader: function(data) {
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var CompressedObject = require('./compressedObject');
var crc32fn = require('./crc32');
var utf8 = require('./utf8');
var compressions = require('./compressions');
var support = require('./support');

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */
var findCompression = function(compressionMethod) {
    for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
            continue;
        }
        if (compressions[method].magic === compressionMethod) {
            return compressions[method];
        }
    }
    return null;
};

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function() {
        // bit 1 is set
        return (this.bitFlag & 0x0001) === 0x0001;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function() {
        // bit 11 is set
        return (this.bitFlag & 0x0800) === 0x0800;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;

        // we already know everything from the central dir !
        // If the central dir data are false, we are doomed.
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
        // The less data we get here, the more reliable this should be.
        // Let's skip the whole header and dash to the data !
        reader.skip(22);
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
        // Strangely, the filename here is OK.
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on
        // the internet.
        //
        // I think I see the logic here : the central directory is used to display
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);

        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }

        compression = findCompression(this.compressionMethod);
        if (compression === null) { // no compression found
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },

    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        // this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);

        if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
        }

        // will be read in the local part, see the comments there
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
    },

    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function () {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;

        // Check if we have the DOS directory flag set.
        // We look for it in the DOS and UNIX permissions
        // but some unknown platform could set it as a compatibility flag.
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;

        if(madeBy === MADE_BY_DOS) {
            // first 6 bits (0 to 5)
            this.dosPermissions = this.externalFileAttributes & 0x3F;
        }

        if(madeBy === MADE_BY_UNIX) {
            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
        }

        // fail safe : if the name ends with a / it probably means a folder
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
        }
    },

    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function(reader) {

        if (!this.extraFields[0x0001]) {
            return;
        }

        // should be something, preparing the extra reader
        var extraReader = readerFor(this.extraFields[0x0001].value);

        // I really hope that these 64bits integer can fit in 32 bits integer, because js
        // won't let us have more.
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
        }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;

        if (!this.extraFields) {
            this.extraFields = {};
        }

        while (reader.index < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);

            this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
                this.fileNameStr = upath;
            } else {
                // ASCII text or unsupported code page
                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }

            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
                this.fileCommentStr = ucomment;
            } else {
                // ASCII text or unsupported code page
                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
        }
    },

    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
            var extraReader = readerFor(upathField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the filename changed, this field is out of date.
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
    },

    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the comment changed, this field is out of date.
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
    }
};
module.exports = ZipEntry;

},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(require,module,exports){
'use strict';

var StreamHelper = require('./stream/StreamHelper');
var DataWorker = require('./stream/DataWorker');
var utf8 = require('./utf8');
var CompressedObject = require('./compressedObject');
var GenericWorker = require('./stream/GenericWorker');

/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
var ZipObject = function(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression : options.compression,
        compressionOptions : options.compressionOptions
    };
};

ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function (type) {
        var result = null, outputType = "string";
        try {
            if (!type) {
                throw new Error("No output type specified.");
            }
            outputType = type.toLowerCase();
            var askUnicodeString = outputType === "string" || outputType === "text";
            if (outputType === "binarystring" || outputType === "text") {
                outputType = "string";
            }
            result = this._decompressWorker();

            var isUnicodeString = !this._dataBinary;

            if (isUnicodeString && !askUnicodeString) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            if (!isUnicodeString && askUnicodeString) {
                result = result.pipe(new utf8.Utf8DecodeWorker());
            }
        } catch (e) {
            result = new GenericWorker("error");
            result.error(e);
        }

        return new StreamHelper(result, outputType, "");
    },

    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function (type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
    },

    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function (type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },

    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function (compression, compressionOptions) {
        if (
            this._data instanceof CompressedObject &&
            this._data.compression.magic === compression.magic
        ) {
            return this._data.getCompressedWorker();
        } else {
            var result = this._decompressWorker();
            if(!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker : function () {
        if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
            return this._data;
        } else {
            return new DataWorker(this._data);
        }
    }
};

var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for(var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
}
module.exports = ZipObject;

},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(require,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],37:[function(require,module,exports){
'use strict';
var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["finally"] = function (callback) {
  if (typeof callback !== 'function') {
    return this;
  }
  var p = this.constructor;
  return this.then(resolve, reject);

  function resolve(value) {
    function yes () {
      return value;
    }
    return p.resolve(callback()).then(yes);
  }
  function reject(reason) {
    function no () {
      throw reason;
    }
    return p.resolve(callback()).then(no);
  }
};
Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":36}],38:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants


var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overriden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],42:[function(require,module,exports){
// String encode/decode helpers



var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":41}],43:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],44:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],45:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],46:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],48:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],49:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":41}],51:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],52:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":41}],53:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],54:[function(require,module,exports){
'use strict';
module.exports = typeof setImmediate === 'function' ? setImmediate :
	function setImmediate() {
		var args = [].slice.apply(arguments);
		args.splice(1, 0, 0);
		setTimeout.apply(null, args);
	};

},{}]},{},[10])(10)
});
/* Blob.js
 * A Blob implementation.
 * 2014-07-24
 *
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/dsamarin
 * License: X11/MIT
 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

define('Blob',[],function() {
 
(function (view) {
	"use strict";

	view.URL = view.URL || view.webkitURL;

	if (view.Blob && view.URL) {
		try {
			new Blob;
			return;
		} catch (e) {}
	}

	// Internally we use a BlobBuilder implementation to base Blob off of
	// in order to support older browsers that only have BlobBuilder
	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
		var
			  get_class = function(object) {
				return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
			}
			, FakeBlobBuilder = function BlobBuilder() {
				this.data = [];
			}
			, FakeBlob = function Blob(data, type, encoding) {
				this.data = data;
				this.size = data.length;
				this.type = type;
				this.encoding = encoding;
			}
			, FBB_proto = FakeBlobBuilder.prototype
			, FB_proto = FakeBlob.prototype
			, FileReaderSync = view.FileReaderSync
			, FileException = function(type) {
				this.code = this[this.name = type];
			}
			, file_ex_codes = (
				  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
				+ "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
			).split(" ")
			, file_ex_code = file_ex_codes.length
			, real_URL = view.URL || view.webkitURL || view
			, real_create_object_URL = real_URL.createObjectURL
			, real_revoke_object_URL = real_URL.revokeObjectURL
			, URL = real_URL
			, btoa = view.btoa
			, atob = view.atob

			, ArrayBuffer = view.ArrayBuffer
			, Uint8Array = view.Uint8Array

			, origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/
		;
		FakeBlob.fake = FB_proto.fake = true;
		while (file_ex_code--) {
			FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
		}
		// Polyfill URL
		if (!real_URL.createObjectURL) {
			URL = view.URL = function(uri) {
				var
					  uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a")
					, uri_origin
				;
				uri_info.href = uri;
				if (!("origin" in uri_info)) {
					if (uri_info.protocol.toLowerCase() === "data:") {
						uri_info.origin = null;
					} else {
						uri_origin = uri.match(origin);
						uri_info.origin = uri_origin && uri_origin[1];
					}
				}
				return uri_info;
			};
		}
		URL.createObjectURL = function(blob) {
			var
				  type = blob.type
				, data_URI_header
			;
			if (type === null) {
				type = "application/octet-stream";
			}
			if (blob instanceof FakeBlob) {
				data_URI_header = "data:" + type;
				if (blob.encoding === "base64") {
					return data_URI_header + ";base64," + blob.data;
				} else if (blob.encoding === "URI") {
					return data_URI_header + "," + decodeURIComponent(blob.data);
				} if (btoa) {
					return data_URI_header + ";base64," + btoa(blob.data);
				} else {
					return data_URI_header + "," + encodeURIComponent(blob.data);
				}
			} else if (real_create_object_URL) {
				return real_create_object_URL.call(real_URL, blob);
			}
		};
		URL.revokeObjectURL = function(object_URL) {
			if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
				real_revoke_object_URL.call(real_URL, object_URL);
			}
		};
		FBB_proto.append = function(data/*, endings*/) {
			var bb = this.data;
			// decode data to a binary string
			if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
				var
					  str = ""
					, buf = new Uint8Array(data)
					, i = 0
					, buf_len = buf.length
				;
				for (; i < buf_len; i++) {
					str += String.fromCharCode(buf[i]);
				}
				bb.push(str);
			} else if (get_class(data) === "Blob" || get_class(data) === "File") {
				if (FileReaderSync) {
					var fr = new FileReaderSync;
					bb.push(fr.readAsBinaryString(data));
				} else {
					// async FileReader won't work as BlobBuilder is sync
					throw new FileException("NOT_READABLE_ERR");
				}
			} else if (data instanceof FakeBlob) {
				if (data.encoding === "base64" && atob) {
					bb.push(atob(data.data));
				} else if (data.encoding === "URI") {
					bb.push(decodeURIComponent(data.data));
				} else if (data.encoding === "raw") {
					bb.push(data.data);
				}
			} else {
				if (typeof data !== "string") {
					data += ""; // convert unsupported types to strings
				}
				// decode UTF-16 to binary string
				bb.push(unescape(encodeURIComponent(data)));
			}
		};
		FBB_proto.getBlob = function(type) {
			if (!arguments.length) {
				type = null;
			}
			return new FakeBlob(this.data.join(""), type, "raw");
		};
		FBB_proto.toString = function() {
			return "[object BlobBuilder]";
		};
		FB_proto.slice = function(start, end, type) {
			var args = arguments.length;
			if (args < 3) {
				type = null;
			}
			return new FakeBlob(
				  this.data.slice(start, args > 1 ? end : this.data.length)
				, type
				, this.encoding
			);
		};
		FB_proto.toString = function() {
			return "[object Blob]";
		};
		FB_proto.close = function() {
			this.size = 0;
			delete this.data;
		};
		return FakeBlobBuilder;
	}(view));

	view.Blob = function(blobParts, options) {
		var type = options ? (options.type || "") : "";
		var builder = new BlobBuilder();
		if (blobParts) {
			for (var i = 0, len = blobParts.length; i < len; i++) {
				if (Uint8Array && blobParts[i] instanceof Uint8Array) {
					builder.append(blobParts[i].buffer);
				}
				else {
					builder.append(blobParts[i]);
				}
			}
		}
		var blob = builder.getBlob(type);
		if (!blob.slice && blob.webkitSlice) {
			blob.slice = blob.webkitSlice;
		}
		return blob;
	};

	var getPrototypeOf = Object.getPrototypeOf || function(object) {
		return object.__proto__;
	};
	view.Blob.prototype = getPrototypeOf(new view.Blob());
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));

});

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2015-05-07.2
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
		// https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
		// for the reasoning behind the timeout and revocation flow
		, arbitrary_revoke_timeout = 500 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			if (view.chrome) {
				revoker();
			} else {
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob(["\ufeff", blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name) {
			blob = auto_bom(blob);
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						var new_tab = view.open(object_url, "_blank");
						if (new_tab == undefined && typeof safari !== "undefined") {
							//Apple do not allow window.open, see http://bit.ly/1kZffRI
							view.location.href = object_url
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				save_link.href = object_url;
				save_link.download = name;
				setTimeout(function() {
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name) {
			return navigator.msSaveOrOpenBlob(auto_bom(blob), name);
		};
	}

	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  // TODO: Would need to load Blob polyfill somehow...
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define('FileSaver',["Blob"], function(discardBlobPolyfillResult) {
    return saveAs;
  });
}
;
define('js/applicationWidgets/PatternExplorer',["require", "exports", "./charting", "../graphStyle", "../calculateStatistics", "../storyCardDisplay", "../questionnaireGeneration", "../panelBuilder/valuePathResolver", "../panelBuilder/dialogSupport", "mithril", "../Project", "../panelBuilder/GridWithItemPanel", "../pointrel20150417/generateRandomUuid", "../Globals", "lodash", "../panelBuilder/toaster", "jszip", "FileSaver", "../csvImportExport"], function (require, exports, charting, graphStyle, calculateStatistics, storyCardDisplay, questionnaireGeneration, valuePathResolver, dialogSupport, m, Project, GridWithItemPanel, generateRandomUuid, Globals, _, toaster, jszip, saveAs, csvImportExport) {
    "use strict";
    "use strict";
    //------------------------------------------------------------------------------------------------------------------------------------------
    // support types and functions
    //------------------------------------------------------------------------------------------------------------------------------------------
    // Question types that have choice (not scale) data associated with them for filters and graphs
    var nominalQuestionTypes = ["select", "boolean", "checkbox", "checkboxes", "radiobuttons"];
    var patternsPanelSpecification = {
        id: "patternsPanel",
        modelClass: "Pattern",
        panelFields: [
            { id: "id", displayName: "Index", valueOptions: [] },
            { id: "patternName", displayName: "Name", valueOptions: [] },
            { id: "remarkable", displayName: "Remarkable?", valueOptions: [] },
            { id: "note", displayName: "Notes", valueOptions: [] },
            { id: "q1DisplayName", displayName: "Q1", valueOptions: [] },
            { id: "q2DisplayName", displayName: "Q2", valueOptions: [] },
            { id: "q3DisplayName", displayName: "Q3", valueOptions: [] },
            { id: "graphType", displayName: "Type", valueOptions: [] },
            { id: "statsSummary", displayName: "Significance", valueOptions: [] },
            { id: "observation", displayName: "Observations", valueOptions: [] },
            { id: "strength", displayName: "Strengths", valueOptions: [] },
        ]
    };
    var columnIDsToDisplayNamesMap = {
        "patternName": "Name",
        "remarkable": "Remarkable?",
        "note": "Notes",
        "q1DisplayName": "Q1",
        "q2DisplayName": "Q2",
        "q3DisplayName": "Q3",
        "graphType": "Type",
        "statsSummary": "Significance",
        "observation": "Observations",
        "strength": "Strengths",
        "interpretations": "Interpretations",
    };
    var columnIDsToShowIfNoOptionsSaved = {
        "patternName": "Name",
        "remarkable": "Remarkable?",
        "graphType": "Type",
        "statsSummary": "Significance",
        "observation": "Observations",
        "strength": "Strengths",
        "interpretations": "Interpretations",
    };
    function nameForQuestion(question) {
        if (question.displayName)
            return question.displayName;
        if (question.displayPrompt)
            return question.displayPrompt;
        return question.id;
    }
    function replaceAll(str, find, replace) {
        return str.replace(new RegExp(find, 'g'), replace);
    }
    function buildStoryDisplayPanel(panelBuilder, model) {
        var storyCardDiv = storyCardDisplay.generateStoryCardContent(model, undefined, {
            location: "storyBrowser",
            storyTextAtTop: true,
            includeWriteInAnswers: true,
            blankLineAfterStory: false
        });
        return storyCardDiv;
    }
    function makeItemPanelSpecificationForQuestions(questions) {
        var storyItemPanelSpecification = {
            id: "patternBrowserQuestions",
            modelClass: "Story",
            panelFields: questions,
            buildPanel: buildStoryDisplayPanel
        };
        storyItemPanelSpecification.panelFields.push({ id: "indexInStoryCollection", displayName: "Index", valueOptions: [] });
        return storyItemPanelSpecification;
    }
    function decodeCurlyBraces(optionText) {
        return optionText.replace("&#123;", "{").replace("&#125;", "}");
    }
    function findOrCreateObservationIDForPatternAndIndex(project, catalysisReportObservationSetIdentifier, pattern, index, createIfNotFound) {
        var patternReference = PatternExplorer.patternReferenceForPatternAndIndex(pattern, index);
        if (!catalysisReportObservationSetIdentifier)
            throw new Error("findOrCreateObservationIDForPatternAndIndex: catalysisReportObservationSetIdentifier is undefined");
        var observationID = project.tripleStore.queryLatestC(catalysisReportObservationSetIdentifier, patternReference);
        if (!observationID && createIfNotFound) {
            observationID = generateRandomUuid("Observation");
            project.tripleStore.addTriple(catalysisReportObservationSetIdentifier, patternReference, observationID);
            var copyOfPatternForPrinting = { id: pattern.id, graphType: pattern.graphType, patternName: pattern.patternName, questions: pattern.questions };
            project.tripleStore.addTriple(observationID, "pattern", copyOfPatternForPrinting);
        }
        return observationID;
    }
    function transposeCSVData(data, delimiter) {
        var rows = data.split("\n");
        var cells = [];
        var highestColumnCount = 0;
        rows.forEach(function (row) {
            cells.push(row.split(delimiter));
            if (row.length > highestColumnCount)
                highestColumnCount = row.length;
        });
        var newCells = [];
        for (var colIndex = 0; colIndex < highestColumnCount; colIndex++) {
            var newRow = [];
            for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                newRow.push(cells[rowIndex][colIndex]);
            }
            newCells.push(newRow);
        }
        var result = "";
        newCells.forEach(function (newRow) {
            result += newRow.join(delimiter) + "\n";
        });
        return result;
    }
    //------------------------------------------------------------------------------------------------------------------------------------------
    // PatternExplorer
    //------------------------------------------------------------------------------------------------------------------------------------------
    var PatternExplorer = (function () {
        function PatternExplorer(args) {
            var _this = this;
            this.project = null;
            this.catalysisReportIdentifier = null;
            this.catalysisReportObservationSetIdentifier = null;
            this.questions = [];
            this.questionsToInclude = null;
            this.patternsGridFieldSpecification = null;
            this.thingsYouCanDoPanelSpecification = null;
            this.thingsYouCanDoIfNoSelectionPanelSpecification = null;
            this.textAnswersPanelSpecification = null;
            this.writeInTextAnswersPanelSpecification = null;
            this.observationsPanelSpecification = null;
            this.interpretationsPanelSpecification = null;
            this.modelForPatternsGrid = { patterns: [] };
            this.currentPattern = null;
            this.activeObservationTab = 0;
            this.observationAccessors = [];
            this.modelForStoryGrid = { storiesSelectedInGraph: [] };
            this.storyGridFieldSpecification = null;
            this.storyGrid = null;
            this.graphMultiChoiceQuestionsAgainstThemselves = false;
            this.hidePatternsWithoutStoryQuestions = false;
            this.hideStatsPanels = false;
            this.graphTypesToCreate = Project.default_graphTypesToCreate;
            this.numStoryCollectionsIncludedInReport = 0;
            this.progressMessage = "Calculating statistics";
            this.calculationsCanceled = false;
            this.project = Globals.project();
            var clientState = Globals.clientState();
            clientState.leavingPageCallback(function () {
                _this.calculationsCanceled = true;
            });
            this.graphHolder = {
                graphResultsPane: charting.createGraphResultsPane("narrafirma-graph-results-pane chartEnclosure"),
                chartPanes: [],
                allStories: [],
                currentGraph: null,
                currentSelectionExtentPercentages: null,
                minimumStoryCountRequiredForTest: Project.default_minimumStoryCountRequiredForTest,
                minimumStoryCountRequiredForGraph: Project.default_minimumStoryCountRequiredForGraph,
                numHistogramBins: Project.default_numHistogramBins,
                numScatterDotOpacityLevels: Project.default_numScatterDotOpacityLevels,
                scatterDotSize: Project.default_scatterDotSize,
                correlationMapShape: Project.default_correlationMapShape,
                correlationMapIncludeScaleEndLabels: Project.default_correlationMapIncludeScaleEndLabels,
                correlationMapCircleDiameter: Project.default_correlationMapCircleDiameter,
                correlationLineChoice: Project.default_correlationLineChoice,
                customLabelLengthLimit: Project.default_customLabelLengthLimit,
                customGraphWidth: Project.default_customDisplayGraphWidth,
                customGraphHeight: Project.default_customDisplayGraphHeight,
                customGraphPadding: Project.default_customGraphPadding,
                hideNumbersOnContingencyGraphs: false,
                graphTypesToCreate: Project.default_graphTypesToCreate,
                patternDisplayConfiguration: { hideNoAnswerValues: false, useLumpingCommands: true },
                lumpingCommands: {}
            };
            this.setUpEditingPanels(args);
            // Pattern grid initialization
            this.questionsToInclude = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "questionsToInclude");
            this.modelForPatternsGrid.patterns = this.buildPatternList();
            var patternsGridConfiguration = {
                idProperty: "id",
                columnsToDisplay: true,
                navigationButtons: true,
                specialHiddenPanelForPatternExplorer: true,
                selectCallback: this.patternSelected.bind(this)
            };
            var patternsGridFieldSpecification = {
                id: "patterns",
                itemPanelID: undefined,
                // TODO: Why is itemPanelSpecification in here twice (also in displayConfiguration)?
                itemPanelSpecification: patternsPanelSpecification,
                displayConfiguration: {
                    itemPanelSpecification: patternsPanelSpecification,
                    gridConfiguration: patternsGridConfiguration
                },
                // TODO: Why is gridConfiguration in here twice (also in displayConfiguration)?
                gridConfiguration: patternsGridConfiguration
            };
            this.patternsGridFieldSpecification = patternsGridFieldSpecification;
            this.patternsGrid = new GridWithItemPanel({ panelBuilder: args.panelBuilder, model: this.modelForPatternsGrid, fieldSpecification: patternsGridFieldSpecification });
            // TODO: selections in observation should be stored in original domain units, not scaled display units
            // Put up a "please pick pattern" message
            this.updateGraphForNewPattern(null);
        }
        //------------------------------------------------------------------------------------------------------------------------------------------
        // static functions - used from printing and csv import/export
        //------------------------------------------------------------------------------------------------------------------------------------------
        PatternExplorer.patternReferenceForPatternAndIndex = function (pattern, index) {
            var questionReferences = [];
            if (pattern.graphType == "data integrity") {
                questionReferences = [pattern.patternName];
            }
            else {
                questionReferences = pattern.questions.map(function (question) { return question.id; });
            }
            if (index !== undefined && index !== null && index !== 0)
                questionReferences.push({ observationIndex: index });
            return { setItem: questionReferences };
        };
        PatternExplorer.getOrSetWhetherNoAnswerValuesShouldBeHiddenForPattern = function (project, catalysisReportIdentifier, pattern, newValue) {
            if (newValue === void 0) { newValue = undefined; }
            var patternReference = JSON.stringify({ "patternDisplayConfiguration": PatternExplorer.patternReferenceForPatternAndIndex(pattern, 0) });
            var configurationObject = project.tripleStore.queryLatestC(catalysisReportIdentifier, patternReference) || {};
            if (newValue === undefined) {
                if (configurationObject.hideNoAnswerValues !== undefined) {
                    return configurationObject.hideNoAnswerValues;
                }
                else {
                    return project.tripleStore.queryLatestC(catalysisReportIdentifier, "hideNoAnswerValues_reportDefault") || false;
                }
            }
            else {
                configurationObject.hideNoAnswerValues = newValue;
                project.tripleStore.addTriple(catalysisReportIdentifier, patternReference, configurationObject);
                return configurationObject.hideNoAnswerValues;
            }
        };
        PatternExplorer.getOrSetWhetherLumpingCommandsShouldBeUsedForPattern = function (project, catalysisReportIdentifier, pattern, newValue) {
            if (newValue === void 0) { newValue = undefined; }
            var patternReference = JSON.stringify({ "patternDisplayConfiguration": PatternExplorer.patternReferenceForPatternAndIndex(pattern, 0) });
            var configurationObject = project.tripleStore.queryLatestC(catalysisReportIdentifier, patternReference) || {};
            if (newValue === undefined) {
                if (configurationObject.useLumpingCommands !== undefined) {
                    return configurationObject.useLumpingCommands;
                }
                else {
                    return true; // assume that lumping commands are being used unless they are turned off for a pattern
                }
            }
            else {
                configurationObject.useLumpingCommands = newValue;
                project.tripleStore.addTriple(catalysisReportIdentifier, patternReference, configurationObject);
                return configurationObject.useLumpingCommands;
            }
        };
        PatternExplorer.getOrSetWhetherPatternIsMarkedAsRemarkable = function (project, catalysisReportIdentifier, pattern, newValue) {
            if (newValue === void 0) { newValue = undefined; }
            var patternReference = JSON.stringify({ "patternDisplayConfiguration": PatternExplorer.patternReferenceForPatternAndIndex(pattern, 0) });
            var configurationObject = project.tripleStore.queryLatestC(catalysisReportIdentifier, patternReference) || {};
            if (newValue === undefined) {
                if (configurationObject.remarkable !== undefined) {
                    return configurationObject.remarkable;
                }
                else {
                    return undefined;
                }
            }
            else {
                configurationObject.remarkable = newValue;
                project.tripleStore.addTriple(catalysisReportIdentifier, patternReference, configurationObject);
                return configurationObject.remarkable;
            }
        };
        PatternExplorer.prototype.setUpEditingPanels = function (args) {
            var storyItemPanelSpecification = makeItemPanelSpecificationForQuestions(this.questions);
            var storyGridConfiguration = {
                idProperty: "storyID",
                columnsToDisplay: ["indexInStoryCollection", "storyName", "storyText"],
                viewButton: true,
                navigationButtons: true
            };
            this.storyGridFieldSpecification = {
                id: "storiesSelectedInGraph",
                itemPanelID: undefined,
                // TODO: Why is itemPanelSpecification in here twice (also in displayConfiguration)?
                itemPanelSpecification: storyItemPanelSpecification,
                displayConfiguration: {
                    itemPanelSpecification: storyItemPanelSpecification,
                    gridConfiguration: storyGridConfiguration
                },
                // TODO: Why is gridConfiguration in here twice (also in displayConfiguration)?
                gridConfiguration: storyGridConfiguration
            };
            this.storyGrid = new GridWithItemPanel({ panelBuilder: args.panelBuilder, model: this.modelForStoryGrid, fieldSpecification: this.storyGridFieldSpecification });
            this.thingsYouCanDoPanelSpecification = {
                "id": "thingsYouCanDoPanel",
                panelFields: [
                    {
                        id: "thingsYouCanDoPanel_actionRequested",
                        valuePath: "selectionActionRequested",
                        displayPrompt: "These are some <strong>things you can do</strong> based on the pattern above and the selection you have made in it (if any).",
                        displayType: "select",
                        displayWithoutQuestionDivs: true,
                        valueOptions: [
                            "Show survey questions for this pattern",
                            "Show statistical results",
                            "Show selected stories in separate window for copying",
                            "Show random sample of 10 selected stories",
                            "Show random sample of 20 selected stories",
                            "Show random sample of 30 selected stories",
                            'Toggle display of "No answer" values for this pattern',
                            'Toggle display lumping for this pattern',
                            "Save current selection (will appear in text box below)",
                            "Restore saved selection (position cursor in text box)",
                            "Save graph(s) as SVG file(s)",
                            "Save graph(s) as PNG file(s)",
                            "Save graph(s) as CSV file"
                        ],
                    },
                    {
                        id: "thingsYouCanDoPanel_doThingsWithSelectedStories",
                        displayPrompt: "Do it",
                        displayIconClass: "doItButtonImage",
                        displayType: "button",
                        displayPreventBreak: true,
                        displayConfiguration: this.doThingsWithSelectedStories.bind(this),
                    },
                ]
            };
            this.thingsYouCanDoIfNoSelectionPanelSpecification = {
                "id": "thingsYouCanDoPanel",
                panelFields: [
                    {
                        id: "thingsYouCanDoPanel_actionRequested",
                        valuePath: "selectionActionRequested",
                        displayPrompt: "These are some <strong>things you can do</strong> based on the pattern above.",
                        displayType: "select",
                        displayWithoutQuestionDivs: true,
                        valueOptions: [
                            "Show statistical results",
                            "Save graph(s) as SVG file(s)",
                            "Save graph(s) as PNG file(s)",
                            "Save graph(s) as CSV file"
                        ],
                    },
                    {
                        id: "thingsYouCanDoPanel_doThingsWithSelectedStories",
                        displayPrompt: "Do it",
                        displayIconClass: "doItButtonImage",
                        displayType: "button",
                        displayPreventBreak: true,
                        displayConfiguration: this.doThingsWithSelectedStories.bind(this),
                    },
                ]
            };
            this.textAnswersPanelSpecification = {
                "id": "textAnswersPanel",
                panelFields: [
                    {
                        id: "textAnswersPanel_texts",
                        valuePath: "currentTextAnswers",
                        displayName: "Text answers",
                        displayPrompt: "These are the <strong>answers</strong> your participants gave to this text question. They are sorted alphabetically. Answers with a number in parentheses were entered more than once. To include any of these answers in your catalysis report, copy and paste them into your observation.",
                        displayType: "textarea",
                    }
                ]
            };
            this.writeInTextAnswersPanelSpecification = {
                "id": "writeInTextAnswersPanel",
                panelFields: [
                    {
                        id: "writeInTextAnswersPanel_texts",
                        valuePath: "currentWriteInTextAnswers",
                        displayName: "Write-in text answers",
                        displayPrompt: "These are the <strong>write-in texts</strong> your participants wrote for this question. They are sorted alphabetically. Answers with a number in parentheses were entered more than once. To include any of these answers in your catalysis report, copy and paste them into your observation.",
                        displayType: "textarea",
                    }
                ]
            };
            this.observationsPanelSpecification = {
                "id": "observationPanel",
                panelFields: [
                    {
                        id: "observationPanel_description",
                        valuePath: "/clientState/observationAccessor/observationDescription",
                        displayName: "Observation description",
                        displayPrompt: "Enter an <strong>observation</strong> about the pattern here. (To add another, click the plus button.)",
                        displayType: "textarea"
                    },
                    {
                        id: "observationPanel_title",
                        valuePath: "/clientState/observationAccessor/observationTitle",
                        displayName: "Observation title",
                        displayPrompt: "Give the observation a short <strong>name</strong>. This name will represent it during clustering and will be its heading in the printed report.",
                        displayType: "text",
                        displayConfiguration: "20"
                    },
                    {
                        id: "observationPanel_strength",
                        valuePath: "/clientState/observationAccessor/observationStrength",
                        displayName: "Observation strength",
                        displayPrompt: "How <strong>strong</strong> is this pattern?",
                        displayType: "select",
                        valueOptions: ["1 (weak)", "2 (medium)", "3 (strong)"]
                    },
                    {
                        id: "observationPanel_showOrHideAdvancedOptions",
                        valueType: "none",
                        displayType: "button",
                        displayConfiguration: "showOrHideAdvancedOptions",
                        displayName: "Show/hide advanced options",
                        displayIconClass: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "hideButtonImage" : "showButtonImage"; },
                        displayPrompt: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "Hide advanced options" : "Show advanced options"; },
                        displayPreventBreak: false,
                        displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
                    },
                    {
                        id: "observationPanel_linkingQuestion",
                        valuePath: "/clientState/observationAccessor/observationLinkingQuestion",
                        displayName: "Observation linking question",
                        displayPrompt: "You might want to enter a <strong>linking question</strong> that will connect this observation \n                        to its interpretations (e.g., \"Why did people say ___?\").\n                        It will be printed in the report before the interpretations.",
                        displayType: "text",
                        displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
                    },
                    {
                        id: "observationPanel_observationNote",
                        valuePath: "/clientState/observationAccessor/observationNote",
                        displayName: "Observation note",
                        displayPrompt: "You might want to save a <strong>note</strong> to yourself about this observation. \n                        It will not be printed in the report.",
                        displayType: "textarea",
                        displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
                    },
                    {
                        id: "observationPanel_extraPatterns",
                        valuePath: "/clientState/observationAccessor/observationExtraPatterns",
                        displayName: "Observation extra patterns",
                        displayPrompt: "To <strong>include additional patterns</strong>, describe each pattern on a separate line. \n                        Enter its question names exactly as you see them in the table above, in the same order, separated by two equals signs.\n                        (For details, see the help system.)",
                        displayType: "textarea",
                        displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
                    },
                    {
                        id: "observationPanel_savedGraphSelections",
                        valuePath: "/clientState/observationAccessor/observationSavedGraphSelections",
                        displayName: "Graph selections",
                        displayPrompt: 'These are <strong>selections you have saved</strong> for this pattern. (For details, see the help system.)',
                        displayType: "textarea",
                        displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
                    },
                ]
            };
            this.interpretationsPanelSpecification = {
                "id": "interpretationsPanel",
                panelFields: [
                    {
                        id: "interpretationsPanel_interpretationsList",
                        valuePath: "/clientState/observationAccessor/observationInterpretations",
                        valueType: "array",
                        displayType: "grid",
                        displayConfiguration: {
                            itemPanelID: "panel_addInterpretation",
                            gridConfiguration: {
                                addButton: true,
                                removeButton: true,
                                duplicateButton: true,
                            }
                        },
                        displayName: "Interpretations",
                        displayPrompt: "Enter at least two <strong>competing interpretations</strong> for this observation. Click on an interpretation to edit it.",
                    }
                ]
            };
        };
        PatternExplorer.controller = function (args) {
            return new PatternExplorer(args);
        };
        PatternExplorer.view = function (controller, args) {
            return controller.calculateView(args);
        };
        PatternExplorer.prototype.patternHasObservations = function (pattern) {
            if (!pattern)
                return false;
            if (!pattern.observationIDs)
                return false;
            if (pattern.observationIDs.length === 0)
                return false;
            var numRealObservations = 0;
            for (var _i = 0, _a = pattern.observationIDs; _i < _a.length; _i++) {
                var id = _a[_i];
                var accessor = new ObservationAccessor(id);
                if (accessor.observationHasTitleOrDescription())
                    numRealObservations++;
            }
            if (numRealObservations === 0)
                return false;
            return true;
        };
        //------------------------------------------------------------------------------------------------------------------------------------------
        // redrawing
        //------------------------------------------------------------------------------------------------------------------------------------------
        PatternExplorer.prototype.calculateView = function (args) {
            var _this = this;
            var panelBuilder = args.panelBuilder;
            var clientState = Globals.clientState();
            // Handling of caching of questions and stories
            var catalysisReportIdentifier = this.getCurrentCatalysisReportIdentifier(args);
            if (catalysisReportIdentifier !== this.catalysisReportIdentifier) {
                this.catalysisReportIdentifier = catalysisReportIdentifier;
                this.currentCatalysisReportChanged(this.catalysisReportIdentifier);
            }
            var parts;
            function isMissingQuestionsToInclude(questionsToInclude) {
                if (!questionsToInclude)
                    return true;
                for (var key in questionsToInclude) {
                    if (questionsToInclude[key])
                        return false;
                }
                return true;
            }
            function isMissingGraphTypesToCreate(graphTypesToCreate) {
                if (!graphTypesToCreate)
                    return true;
                for (var key in graphTypesToCreate) {
                    if (graphTypesToCreate[key])
                        return false;
                }
                return true;
            }
            var buildObservationsAndInterpretationsPanels = function () {
                var result = [];
                var remarkable = PatternExplorer.getOrSetWhetherPatternIsMarkedAsRemarkable(_this.project, _this.catalysisReportIdentifier, _this.currentPattern);
                var isRemarkable = remarkable === "yes";
                var hasAtLeastOneNonEmptyObservation = _this.patternHasObservations(_this.currentPattern);
                var hasEvenOneEmptyObservation = _this.observationAccessors.length > 0;
                // deal with legacy data in which the remarkable value is not set but there is an observation 
                if (!isRemarkable && hasAtLeastOneNonEmptyObservation)
                    isRemarkable = true;
                var remarkableItems = [];
                remarkableItems.push(m("span.narrafirma-mark-pattern-text", ["Is this pattern ", m("b", "remarkable"), "?"]));
                remarkableItems.push(m("button", { class: "narrafirma-mark-pattern-button",
                    onclick: _this.setRemarkableFlag.bind(_this, "yes"), disabled: remarkable === "yes" }, m("span.button-text ", "yes")));
                remarkableItems.push(m("button", { class: "narrafirma-mark-pattern-button",
                    onclick: _this.setRemarkableFlag.bind(_this, "maybe"), disabled: remarkable === "maybe" }, m("span.button-text ", "maybe")));
                remarkableItems.push(m("button", { class: "narrafirma-mark-pattern-button",
                    onclick: _this.setRemarkableFlag.bind(_this, "no"), disabled: remarkable === "no" }, m("span.button-text ", "no")));
                remarkableItems.push(m("button", { class: "narrafirma-mark-pattern-button",
                    onclick: _this.setRemarkableFlag.bind(_this, "redundant"), disabled: remarkable === "redundant" }, m("span.button-text ", "redundant")));
                remarkableItems.push(m("button", { class: "narrafirma-mark-pattern-button",
                    onclick: _this.setRemarkableFlag.bind(_this, ""), disabled: remarkable === undefined || remarkable === "" }, m("span.button-text ", "unmarked")));
                remarkableItems.push(m("button", {
                    disabled: !isRemarkable || (isRemarkable && hasEvenOneEmptyObservation),
                    onclick: _this.addObservationTabClick.bind(_this),
                }, m("span", { class: "buttonWithTextImage addButtonImage" }), "Add observation"));
                result.push(m("div", remarkableItems));
                if (isRemarkable) {
                    var tabs = [];
                    if (hasAtLeastOneNonEmptyObservation) {
                        for (var i = 0; i < _this.observationAccessors.length; i++) {
                            var tab = m("button", {
                                class: (i === _this.activeObservationTab) ? "narrafirma-tab-button-selected" : "narrafirma-tab-button",
                                onclick: _this.switchToObservationTabClick.bind(_this, i),
                                title: "Click to switch to another observation tab"
                            }, "" + (i + 1));
                            tabs.push(tab);
                        }
                        tabs.push(m("button", {
                            class: "narrafirma-tab-button",
                            disabled: remarkable !== "yes",
                            onclick: _this.addObservationTabClick.bind(_this),
                            title: "Click to add another observation to this pattern"
                        }, "+"));
                        tabs.push(m("button", {
                            class: "narrafirma-tab-button",
                            onclick: _this.deleteObservationTabClick.bind(_this),
                            title: "Click here to delete this observation (permanently)"
                        }, "-"));
                    }
                    var tabContents = [];
                    if (_this.activeObservationTab >= 0 && _this.activeObservationTab < _this.observationAccessors.length) {
                        var activeAccessor = _this.observationAccessors[_this.activeObservationTab];
                        clientState.observationAccessor(activeAccessor);
                        tabContents.push([
                            panelBuilder.buildPanel(_this.observationsPanelSpecification, {}),
                            activeAccessor.observationHasTitleOrDescription() ? panelBuilder.buildPanel(_this.interpretationsPanelSpecification, {}) : m("div"),
                        ]);
                    }
                    result.push(m(".narrafirma-tabs", m(".narrafirma-tabs-header", tabs), m(".narrafirma-tabs-body", tabContents)));
                }
                return result;
            };
            if (!this.catalysisReportIdentifier) {
                parts = [m("div.narrafirma-choose-catalysis-report", "Please select a catalysis report to work with.")];
            }
            else if (isMissingQuestionsToInclude(this.questionsToInclude)) {
                parts = [m("div.narrafirma-choose-questions-to-include", { style: "text-align: center; margin: 2em" }, "Nothing to see here! Please select some questions to include in the report (on the previous page).")];
            }
            else if (isMissingGraphTypesToCreate(this.graphTypesToCreate)) {
                parts = [m("div.narrafirma-choose-graph-types-to-include", { style: "text-align: center; margin: 2em" }, "Nothing to see here! Please select some graph types to include in the report (on the previous page).")];
            }
            else {
                var patternsAndStrengthsToDisplayAbovePatternsTable_1 = this.patternsAndStrengthsToDisplayAbovePatternsTable();
                var cancelButton_1 = m("button.narrafirma-statistics-cancel-button", {
                    onclick: function () {
                        _this.calculationsCanceled = true;
                        _this.progressMessage = "";
                    }
                }, "Cancel");
                var buildGridHeader = function () {
                    return m("div.patterns-grid-header", m("div#gridHeaderProgressMessage" + (_this.progressMessage ? ".pleaseWaitStatisticsOverlay" : ""), _this.progressMessage), _this.progressMessage ? cancelButton_1 : [], patternsAndStrengthsToDisplayAbovePatternsTable_1);
                };
                var buildExportButtonsPanel = function () {
                    return m("div.narrafirma-pattern-browser-exportbuttons", [
                        m("span", "Export all "),
                        m("button.narrafirma-pattern-browser-export", { onclick: function () { _this.exportAllPatternGraphs(); } }, "Graphs"),
                        m("button.narrafirma-pattern-browser-export", { onclick: function () { _this.exportAllPatternStatistics(); } }, "Statistics"),
                        m("button.narrafirma-pattern-browser-export", { onclick: function () { _this.exportAllCorrelations(); } }, "Correlations")
                    ]);
                };
                var activeAccessor = null;
                if (this.observationAccessors.length > this.activeObservationTab)
                    activeAccessor = this.observationAccessors[this.activeObservationTab];
                // this calculateView might have been called because another user changed something in the data
                if (clientState.redrawingDueToIncomingMessage()) {
                    this.patternsGrid.updateData();
                    // they may have added a new observation 
                    this.updatePatternObservationIDs(this.currentPattern);
                    this.updateObservationPanelForSelectedPattern();
                }
                var stories = this.modelForStoryGrid.storiesSelectedInGraph;
                if (this.currentPattern && (this.currentPattern.graphType === "data integrity" || this.currentPattern.graphType === "correlation map")) {
                    parts = [
                        buildExportButtonsPanel(),
                        buildGridHeader(),
                        this.patternsGrid.calculateView(args),
                        m("div.narrafirma-graph-results-panel", { config: this.insertGraphResultsPaneConfig.bind(this) }),
                        panelBuilder.buildPanel(this.thingsYouCanDoIfNoSelectionPanelSpecification, activeAccessor || this),
                        buildObservationsAndInterpretationsPanels(),
                    ];
                }
                else if (this.currentPattern && this.currentPattern.graphType === "texts") {
                    parts = [
                        buildExportButtonsPanel(),
                        buildGridHeader(),
                        this.patternsGrid.calculateView(args),
                        panelBuilder.buildPanel(this.textAnswersPanelSpecification, this),
                        buildObservationsAndInterpretationsPanels(),
                    ];
                }
                else if (this.currentPattern && this.currentPattern.graphType === "write-in texts") {
                    parts = [
                        buildExportButtonsPanel(),
                        buildGridHeader(),
                        this.patternsGrid.calculateView(args),
                        panelBuilder.buildPanel(this.writeInTextAnswersPanelSpecification, this),
                        buildObservationsAndInterpretationsPanels(),
                    ];
                }
                else {
                    var numStories = stories.length;
                    var storyOrStoriesWord = (numStories > 1) ? "stories" : "story";
                    var selectedStoriesText = numStories + " " + storyOrStoriesWord + " in selection - "
                        + this.nameForCurrentGraphSelection() + ". Click on a story to view it.";
                    parts = [
                        buildExportButtonsPanel(),
                        buildGridHeader(),
                        this.patternsGrid.calculateView(args),
                        this.currentPattern ?
                            [
                                m("div.narrafirma-graph-results-panel", { config: this.insertGraphResultsPaneConfig.bind(this) }),
                                this.graphHolder.currentGraph ? "" : m("div.narrafirma-pattern-browser-no-graph-message", "The number of stories for this pattern falls below the minimum count of " + this.graphHolder.minimumStoryCountRequiredForGraph
                                    + ", which you set on the Configure catalysis report page"
                                    + ". To display this graph, choose a lower minimum story count."),
                                (stories.length > 0) ?
                                    m("div.narrafirma-pattern-browser-selected-stories-header", selectedStoriesText) :
                                    m("div.narrafirma-pattern-browser-no-selection-tip", "Click and drag in the graph(s) above to select stories to view."),
                                (stories.length > 0) ? this.storyGrid.calculateView(args) : m("div"),
                                panelBuilder.buildPanel(this.thingsYouCanDoPanelSpecification, activeAccessor || this),
                                buildObservationsAndInterpretationsPanels(),
                            ] :
                            m("div.narrafirma-choose-pattern", "Please choose a pattern to view in the table above.")
                    ];
                }
            }
            return m("div.narrafirma-patterns-grid", parts);
        };
        PatternExplorer.prototype.setRemarkableFlag = function (newValue) {
            if (!this.currentPattern)
                return;
            var oldValue = PatternExplorer.getOrSetWhetherPatternIsMarkedAsRemarkable(this.project, this.catalysisReportIdentifier, this.currentPattern);
            PatternExplorer.getOrSetWhetherPatternIsMarkedAsRemarkable(this.project, this.catalysisReportIdentifier, this.currentPattern, newValue);
            if (oldValue !== newValue)
                this.updateGraphForNewPattern(this.currentPattern);
        };
        PatternExplorer.prototype.patternsAndStrengthsToDisplayAbovePatternsTable = function () {
            var _this = this;
            if (!this)
                return "";
            var result = "";
            var strengthCounts = { "3 (strong)": 0, "2 (medium)": 0, "1 (weak)": 0 };
            var numObservationsWithoutStrengths = 0;
            var numInterpretations = 0;
            var observationIDs = this.project.tripleStore.getListForSetIdentifier(this.catalysisReportObservationSetIdentifier);
            var nonBlankObservations = [];
            observationIDs.forEach(function (id) {
                var observation = _this.project.tripleStore.makeObject(id, true);
                if (observation && observation.observationTitle || observation.observationDescription)
                    nonBlankObservations.push(observation);
            });
            for (var i = 0; i < nonBlankObservations.length; i++) {
                if (nonBlankObservations[i].observationStrength) {
                    strengthCounts[nonBlankObservations[i].observationStrength] += 1;
                }
                else {
                    numObservationsWithoutStrengths += 1;
                }
                var interpretationIDs = this.project.tripleStore.getListForSetIdentifier(nonBlankObservations[i].observationInterpretations);
                numInterpretations += interpretationIDs.length;
            }
            result += this.modelForPatternsGrid.patterns.length + (this.modelForPatternsGrid.patterns.length !== 1 ? " patterns" : " pattern");
            if (Object.keys(strengthCounts).length) {
                result += ", " + nonBlankObservations.length + (nonBlankObservations.length !== 1 ? " observations" : " observation");
                result += " (by strength, ";
                var keyCount_1 = 0;
                Object.keys(strengthCounts).forEach(function (key) {
                    result += key.slice(0, 1) + ": " + strengthCounts[key];
                    if (keyCount_1 < 2)
                        result += "; ";
                    keyCount_1++;
                });
                result += "; none: " + numObservationsWithoutStrengths + "), ";
            }
            result += numInterpretations + (numInterpretations !== 1 ? " interpretations" : " interpretation");
            result += ". Click on a pattern to view it.";
            return m("div.narrafirma-catalysis-patterns-grid-label", result);
        };
        PatternExplorer.prototype.insertGraphResultsPaneConfig = function (element, isInitialized, context) {
            if (!isInitialized) {
                element.appendChild(this.graphHolder.graphResultsPane);
            }
        };
        PatternExplorer.prototype.exportAllPatternGraphs = function () {
            var patterns = this.modelForPatternsGrid.patterns;
            if (patterns.length > 100) {
                var response = confirm("You are exporting graphs from " + patterns.length
                    + " patterns, some of which could generate several graphs. "
                    + "This could take a long time and create a large zip file. Are you certain that you want to do this?");
                if (!response)
                    return;
            }
            // note that this code was brute-force copied and pasted from printing.ts
            // i had it there but calling PatternExplorer.makeGraph created a circular reference
            // it should probably be moved to its own file, but there are some differences, so maybe this is okay
            var progressModel = dialogSupport.openProgressDialog("Starting up...", "Generating graphs", "Cancel", dialogCancelled);
            var project = this.project;
            var reportID = this.catalysisReportIdentifier;
            var allStories = this.project.storiesForCatalysisReport(this.catalysisReportIdentifier);
            var catalysisReportName = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "catalysisReport_shortName");
            var options = [];
            options["outputGraphFormat"] = "PNG"; // hard coding this for now
            // these are the ones I think I must support
            options["lumpingCommands"] = project.lumpingCommandsForCatalysisReport(reportID);
            options["minimumStoryCountRequiredForGraph"] = project.tripleStore.queryLatestC(reportID, "minimumStoryCountRequiredForGraph") || Project.default_minimumStoryCountRequiredForGraph;
            options["numHistogramBins"] = project.tripleStore.queryLatestC(reportID, "numHistogramBins") || Project.default_numHistogramBins;
            options["numScatterDotOpacityLevels"] = project.tripleStore.queryLatestC(reportID, "numScatterDotOpacityLevels") || Project.default_numScatterDotOpacityLevels;
            options["scatterDotSize"] = project.tripleStore.queryLatestC(reportID, "scatterDotSize") || Project.default_scatterDotSize;
            options["correlationMapShape"] = project.tripleStore.queryLatestC(reportID, "correlationMapShape") || Project.default_correlationMapShape;
            options["correlationMapIncludeScaleEndLabels"] = project.tripleStore.queryLatestC(reportID, "correlationMapIncludeScaleEndLabels") || Project.default_correlationMapIncludeScaleEndLabels;
            options["correlationMapCircleDiameter"] = parseInt(project.tripleStore.queryLatestC(reportID, "correlationMapCircleDiameter")) || Project.default_correlationMapCircleDiameter;
            options["correlationLineChoice"] = project.tripleStore.queryLatestC(reportID, "correlationLineChoice") || Project.default_correlationLineChoice;
            options["customLabelLengthLimit"] = parseInt(project.tripleStore.queryLatestC(reportID, "customLabelLengthLimit") || Project.default_customLabelLengthLimit);
            options["hideNumbersOnContingencyGraphs"] = project.tripleStore.queryLatestC(reportID, "hideNumbersOnContingencyGraphs") || false;
            options["customGraphWidth"] = parseInt(project.tripleStore.queryLatestC(reportID, "customReportGraphWidth")) || Project.default_customReportGraphWidth;
            options["customGraphHeight"] = parseInt(project.tripleStore.queryLatestC(reportID, "customReportGraphHeight")) || Project.default_customReportGraphHeight;
            var zipFile = new jszip();
            var savedGraphCount = 0;
            var graphTypesThatDontGetPrinted = ["texts", "write-in texts"];
            function printGraphToZipFile(zipFile, graphHolder, graphNode, graphTitle, options) {
                var svgNode = graphNode.querySelector("svg");
                if (svgNode) {
                    // i am not using the svg option, but might as well keep it in case i want it later
                    if (options.outputGraphFormat === "SVG") {
                        var svgFileText = graphStyle.prepareSVGToSaveToFile(svgNode, options.customGraphCSS, graphHolder.outputFontModifierPercent);
                        zipFile.file(graphTitle + ".svg", svgFileText);
                        savedGraphCount++;
                    }
                    else if (options.outputGraphFormat === "PNG") {
                        // when using canvas.toBlob either the ZIP file or the PNG files come out corrupted
                        // found this method to fix it online and it works
                        var canvas = graphStyle.preparePNGToSaveToFile(svgNode, options.customGraphCSS, graphHolder.outputFontModifierPercent);
                        var dataURI = canvas.toDataURL("image/png");
                        var imageData = graphStyle.dataURItoBlob(dataURI);
                        zipFile.file(graphTitle + ".png", imageData, { binary: true });
                        savedGraphCount++;
                    }
                }
            }
            var patternIndex = 0;
            function printNextPattern() {
                function customGraphHolder(allStories, options) {
                    var graphHolder = {
                        // things that are not options
                        allStories: allStories,
                        graphResultsPane: charting.createGraphResultsPane("narrafirma-graph-results-pane chartEnclosure"),
                        // things that don't apply to this usage but should be set just in case
                        currentGraph: null,
                        currentSelectionExtentPercentages: null,
                        excludeStoryTooltips: true,
                        chartPanes: [],
                        minimumStoryCountRequiredForTest: 20,
                        showStatsPanelsInReport: false,
                        customStatsTextReplacements: null,
                        patternDisplayConfiguration: { hideNoAnswerValues: false, useLumpingCommands: true },
                        adjustedCSS: null,
                        graphTypesToCreate: {},
                        // things that should come from the report settings
                        lumpingCommands: options.lumpingCommands,
                        minimumStoryCountRequiredForGraph: options.minimumStoryCountRequiredForGraph,
                        numHistogramBins: options.numHistogramBins,
                        numScatterDotOpacityLevels: options.numScatterDotOpacityLevels,
                        scatterDotSize: options.scatterDotSize,
                        correlationMapShape: options.correlationMapShape,
                        correlationMapIncludeScaleEndLabels: options.correlationMapIncludeScaleEndLabels,
                        correlationMapCircleDiameter: options.correlationMapCircleDiameter,
                        correlationLineChoice: options.correlationLineChoice,
                        customLabelLengthLimit: options.customLabelLengthLimit,
                        hideNumbersOnContingencyGraphs: options.hideNumbersOnContingencyGraphs,
                        customGraphWidth: options.customGraphWidth,
                        customGraphHeight: options.customGraphHeight,
                        // things i want to set just for this output
                        outputGraphFormat: options.outputGraphFormat,
                        outputFontModifierPercent: 120,
                    };
                    return graphHolder;
                }
                function nicerGraphTypeName(name) {
                    var nicerGraphTypeNames = {
                        "data integrity": "data integrity graphs",
                        "bar": "bar charts",
                        "histogram": "histograms",
                        "multiple histogram": "histograms for choice subsets",
                        "scatter": "scatter plots",
                        "multiple scatter": "scatter plots for choice subsets",
                        "table": "contingency charts",
                        "contingency-histogram": "contingency charts with scale values",
                        "correlation map": "correlation maps"
                    };
                    return nicerGraphTypeNames[name] || name;
                }
                if (progressModel.cancelled) {
                    alert("Cancelled after working on " + (patternIndex + 1) + " pattern(s)");
                }
                else if (patternIndex >= patterns.length) {
                    progressModel.hideDialogMethod();
                    if (savedGraphCount > 0) {
                        var finishModel = dialogSupport.openFinishedDialog("Done creating zip file of " + savedGraphCount + " images; save it? (Note: saving the file might take a while.)", "Finished generating images", "Save", "Cancel", function (dialogConfiguration, hideDialogMethod) {
                            toaster.toast("Saving file, please wait...");
                            var fileName = catalysisReportName + " pattern graphs " + options["outputGraphFormat"] + ".zip";
                            zipFile.generateAsync({ type: "blob", platform: "UNIX", compression: "DEFLATE" }).then(function (blob) { saveAs(blob, fileName); });
                            hideDialogMethod();
                        });
                        finishModel.redraw();
                    }
                    else {
                        alert("No graphs were found with your current selection criteria. Try choosing different graph types.");
                    }
                    progressModel.redraw();
                }
                else {
                    var pattern = patterns[patternIndex];
                    if (pattern && graphTypesThatDontGetPrinted.indexOf(pattern.graphType) < 0) {
                        var graphTitle = pattern.patternName;
                        graphTitle = replaceAll(graphTitle, "/", " "); // jszip interprets a forward slash as a folder designation
                        graphTitle = nicerGraphTypeName(pattern.graphType) + "/" + graphTitle; // place files into folders by type
                        var graphHolder = customGraphHolder(allStories, options);
                        var selectionCallback = function () { return this; };
                        var graph = PatternExplorer.makeGraph(pattern, graphHolder, selectionCallback, !options["showStatsPanelsInReport"]);
                        if (graphHolder.chartPanes.length > 1) {
                            for (var graphIndex = 1; graphIndex < graphHolder.chartPanes.length; graphIndex++) {
                                var graphNode = graphHolder.chartPanes[graphIndex];
                                if (graphNode) {
                                    var choiceTitle = replaceAll(graph[graphIndex - 1].subgraphChoice, "/", " "); // subtract 1 because 1 is title pane
                                    var subGraphTitle = graphTitle + "/" + choiceTitle; // place subgraphs into folders
                                    printGraphToZipFile(zipFile, graphHolder, graphNode, subGraphTitle, options);
                                }
                            }
                        }
                        else {
                            var graphNode = graphHolder.graphResultsPane.firstChild;
                            if (graphNode)
                                printGraphToZipFile(zipFile, graphHolder, graphNode, graphTitle, options);
                        }
                    }
                    progressModel.progressText = progressText(patternIndex);
                    progressModel.redraw();
                    patternIndex++;
                    setTimeout(function () { printNextPattern(); }, 0);
                }
            }
            function progressText(patternIndex) {
                return "Pattern " + (patternIndex + 1) + " of " + patterns.length;
            }
            function dialogCancelled(dialogConfiguration, hideDialogMethod) {
                progressModel.cancelled = true;
                hideDialogMethod();
            }
            setTimeout(function () { printNextPattern(); }, 0);
        };
        PatternExplorer.prototype.exportAllPatternStatistics = function () {
            var progressModel = dialogSupport.openProgressDialog("Starting up...", "Generating statistics for export", "Cancel", dialogCancelled);
            var numPatternsWritten = 0;
            var patternIndex = 0;
            var delimiter = Globals.clientState().csvDelimiter();
            var headerLine = ["Number", "Pattern", "Graph type", "Summary", "Details", "Subset details"];
            var output = [];
            output = csvImportExport.addCSVOutputLine(output, headerLine, delimiter);
            var patterns = this.modelForPatternsGrid.patterns;
            var catalysisReportName = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "catalysisReport_shortName");
            var allStories = this.project.storiesForCatalysisReport(this.catalysisReportIdentifier);
            function printStatsForNextPattern() {
                if (progressModel.cancelled) {
                    alert("Cancelled after working on " + (patternIndex + 1) + " pattern(s)");
                }
                else if (patternIndex >= patterns.length) {
                    progressModel.hideDialogMethod();
                    if (numPatternsWritten > 0) {
                        var finishModel = dialogSupport.openFinishedDialog("Done creating CSV file of pattern statistics; save it?", "Finished generating CSV file", "Save", "Cancel", function (dialogConfiguration, hideDialogMethod) {
                            var fileName = catalysisReportName + " pattern statistics.csv";
                            var exportBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
                            saveAs(exportBlob, fileName);
                            hideDialogMethod();
                        });
                        finishModel.redraw();
                    }
                    else {
                        alert("No patterns were found with your current selection criteria. Try choosing different graph types.");
                    }
                    progressModel.redraw();
                }
                else {
                    var pattern = patterns[patternIndex];
                    if (pattern) {
                        var line = [];
                        line.push(patternIndex + 1);
                        line.push(pattern.patternName || "");
                        line.push(pattern.graphType || "");
                        line.push(pattern.statsSummary || "");
                        line.push(pattern.statsDetailed && pattern.statsDetailed.length > 0 ? pattern.statsDetailed.join("; ") : "");
                        if (pattern.allStatResults) {
                            for (var _i = 0, _a = Object.keys(pattern.allStatResults); _i < _a.length; _i++) {
                                var outerKey = _a[_i];
                                var resultDict = pattern.allStatResults[outerKey];
                                var thisResultText = outerKey + " | ";
                                for (var _b = 0, _c = Object.keys(resultDict); _b < _c.length; _b++) {
                                    var innerKey = _c[_b];
                                    thisResultText += " " + innerKey + ": " + resultDict[innerKey];
                                }
                                line.push(thisResultText);
                            }
                        }
                        output = csvImportExport.addCSVOutputLine(output, line, delimiter);
                    }
                    numPatternsWritten++;
                    progressModel.progressText = progressText(patternIndex);
                    progressModel.redraw();
                    patternIndex++;
                    setTimeout(function () { printStatsForNextPattern(); }, 0);
                }
            }
            function progressText(observationIndex) {
                return "Pattern " + (observationIndex + 1) + " of " + patterns.length;
            }
            function dialogCancelled(dialogConfiguration, hideDialogMethod) {
                progressModel.cancelled = true;
                hideDialogMethod();
            }
            setTimeout(function () { printStatsForNextPattern(); }, 0);
        };
        PatternExplorer.prototype.exportAllCorrelations = function () {
            var allStories = this.project.storiesForCatalysisReport(this.catalysisReportIdentifier);
            var lumpingCommands = this.project.lumpingCommandsForCatalysisReport(this.catalysisReportIdentifier);
            var minimumStoryCountRequiredForTest = this.graphHolder.minimumStoryCountRequiredForTest;
            var unansweredText = charting.customStatLabel("unanswered", this.graphHolder);
            var includeNAValues = false;
            var allQuestions = this.project.allQuestionsThatCouldBeGraphedForCatalysisReport(this.catalysisReportIdentifier, true);
            var scaleQuestions = allQuestions.filter(function (question) { if (question.displayType === "slider")
                return question; });
            var choiceQuestions = allQuestions.filter(function (question) { if (["select", "radiobuttons", "checkboxes"].indexOf(question.displayType) >= 0)
                return question; });
            var output = [];
            var delimiter = Globals.clientState().csvDelimiter();
            var explanation = ["Subset correlations: + = significant positive correlation (++ highly); - = significant negative correlation (-- highly); blank line or cell = no significant correlation"];
            output = csvImportExport.addCSVOutputLine(output, explanation, delimiter);
            var headerLine = ["Scale 1", "Scale 2", "Overall"];
            for (var i = 0; i < choiceQuestions.length; i++)
                headerLine.push(choiceQuestions[i].displayName);
            output = csvImportExport.addCSVOutputLine(output, headerLine, delimiter);
            var combosAlreadyHandled = [];
            for (var _i = 0, scaleQuestions_1 = scaleQuestions; _i < scaleQuestions_1.length; _i++) {
                var scaleQuestion1 = scaleQuestions_1[_i];
                for (var _a = 0, scaleQuestions_2 = scaleQuestions; _a < scaleQuestions_2.length; _a++) {
                    var scaleQuestion2 = scaleQuestions_2[_a];
                    if (scaleQuestion1 === scaleQuestion2)
                        continue;
                    var oneThenTwo = scaleQuestion1.displayName + " x " + scaleQuestion2.displayName;
                    var twoThenOne = scaleQuestion2.displayName + " x " + scaleQuestion1.displayName;
                    if (combosAlreadyHandled.indexOf(oneThenTwo) >= 0 || combosAlreadyHandled.indexOf(twoThenOne) >= 0)
                        continue;
                    combosAlreadyHandled.push(oneThenTwo);
                    var comboLine = [];
                    comboLine.push(scaleQuestion1.displayName);
                    comboLine.push(scaleQuestion2.displayName);
                    var overallStats = calculateStatistics.calculateStatisticsForScatterPlot(scaleQuestion1, scaleQuestion2, null, null, allStories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands);
                    var overallString = "";
                    if (overallStats.p < 0.01) {
                        overallString = overallStats.rho < 0 ? "--" : "++";
                    }
                    else if (overallStats.p < 0.05) {
                        overallString = overallStats.rho < 0 ? "-" : "+";
                    }
                    else {
                        overallString = "";
                    }
                    comboLine.push(overallString);
                    for (var _b = 0, choiceQuestions_1 = choiceQuestions; _b < choiceQuestions_1.length; _b++) {
                        var choiceQuestion = choiceQuestions_1[_b];
                        var optionsCell = [];
                        var noCorrs = [];
                        for (var _c = 0, _d = choiceQuestion.valueOptions; _c < _d.length; _c++) {
                            var option = _d[_c];
                            var optionStats = calculateStatistics.calculateStatisticsForScatterPlot(scaleQuestion1, scaleQuestion2, choiceQuestion, option, allStories, minimumStoryCountRequiredForTest, unansweredText, includeNAValues, lumpingCommands);
                            var corrString = "";
                            if (optionStats.p < 0.01) {
                                corrString = option + " " + (optionStats.rho < 0 ? "--" : "++");
                            }
                            else if (optionStats.p < 0.05) {
                                corrString = option + " " + (optionStats.rho < 0 ? "-" : "+");
                            }
                            else {
                                corrString = option + "";
                                noCorrs.push(option);
                            }
                            if (corrString)
                                optionsCell.push(corrString);
                        }
                        if (noCorrs.length === choiceQuestion.valueOptions.length) {
                            comboLine.push("");
                        }
                        else {
                            comboLine.push(optionsCell.join("\n"));
                        }
                    }
                    output = csvImportExport.addCSVOutputLine(output, comboLine, delimiter);
                }
            }
            var catalysisReportName = Globals.clientState().catalysisReportName();
            var fileName = catalysisReportName + " correlations.csv";
            var exportBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
            saveAs(exportBlob, fileName);
        };
        //------------------------------------------------------------------------------------------------------------------------------------------
        // updating data
        //------------------------------------------------------------------------------------------------------------------------------------------
        PatternExplorer.prototype.currentCatalysisReportChanged = function (catalysisReportIdentifier) {
            var _this = this;
            if (!catalysisReportIdentifier)
                return;
            // update options kept in this object
            this.graphTypesToCreate = this.project.tripleStore.queryLatestC(catalysisReportIdentifier, "graphTypesToCreate") || Project.default_graphTypesToCreate;
            this.graphMultiChoiceQuestionsAgainstThemselves = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "graphMultiChoiceQuestionsAgainstThemselves");
            this.hidePatternsWithoutStoryQuestions = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "hidePatternsWithoutStoryQuestions");
            this.hideStatsPanels = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "hideStatsPanelsOnExplorePatternsPage");
            this.catalysisReportObservationSetIdentifier = this.getObservationSetIdentifier(catalysisReportIdentifier);
            // update options kept in graph holder
            this.graphHolder.minimumStoryCountRequiredForTest = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "minimumSubsetSize") || Project.default_minimumStoryCountRequiredForTest;
            this.graphHolder.minimumStoryCountRequiredForGraph = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "minimumStoryCountRequiredForGraph") || Project.default_minimumStoryCountRequiredForGraph;
            this.graphHolder.numHistogramBins = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "numHistogramBins") || Project.default_numHistogramBins;
            this.graphHolder.numScatterDotOpacityLevels = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "numScatterDotOpacityLevels") || Project.default_numScatterDotOpacityLevels;
            this.graphHolder.scatterDotSize = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "scatterDotSize") || Project.default_scatterDotSize;
            this.graphHolder.correlationMapShape = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "correlationMapShape") || Project.default_correlationMapShape;
            this.graphHolder.correlationMapIncludeScaleEndLabels = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "correlationMapIncludeScaleEndLabels") || Project.default_correlationMapIncludeScaleEndLabels;
            this.graphHolder.correlationMapCircleDiameter = parseInt(this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "correlationMapCircleDiameter")) || Project.default_correlationMapCircleDiameter;
            this.graphHolder.correlationLineChoice = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "correlationLineChoice") || Project.default_correlationLineChoice;
            this.graphHolder.customLabelLengthLimit = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "customLabelLengthLimit") || Project.default_customLabelLengthLimit;
            this.graphHolder.customGraphWidth = parseInt(this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "customDisplayGraphWidth")) || Project.default_customDisplayGraphWidth;
            this.graphHolder.customGraphHeight = parseInt(this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "customDisplayGraphHeight")) || Project.default_customDisplayGraphHeight;
            this.graphHolder.customGraphPadding = parseInt(this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "customGraphPadding")) || Project.default_customGraphPadding;
            this.graphHolder.hideNumbersOnContingencyGraphs = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "hideNumbersOnContingencyGraphs");
            this.updateStyleSheetForCustomGraphCSS();
            // get stories 
            this.graphHolder.allStories = this.project.storiesForCatalysisReport(catalysisReportIdentifier);
            this.numStoryCollectionsIncludedInReport = this.project.numStoryCollectionsInCatalysisReport(catalysisReportIdentifier);
            // gather questions for patterns table
            var leadingStoryQuestions = questionnaireGeneration.getStoryNameAndTextQuestions();
            var elicitingQuestions = this.project.elicitingQuestionsForCatalysisReport(catalysisReportIdentifier);
            var numStoriesToldQuestions = this.project.numStoriesToldQuestionsForCatalysisReport(catalysisReportIdentifier);
            var storyLengthQuestions = this.project.storyLengthQuestionsForCatalysisReport(catalysisReportIdentifier);
            var collectionDateQuestions = this.project.collectionDateQuestionsForCatalysisReport(catalysisReportIdentifier);
            var languageQuestions = this.project.languageQuestionsForCatalysisReport(catalysisReportIdentifier);
            var storyQuestions = this.project.storyQuestionsForCatalysisReport(catalysisReportIdentifier);
            var participantQuestions = this.project.participantQuestionsForCatalysisReport(catalysisReportIdentifier);
            var annotationQuestions = questionnaireGeneration.convertEditorQuestions(this.project.collectAllAnnotationQuestions(), "A_");
            this.questions = [];
            this.questions = this.questions.concat(leadingStoryQuestions, elicitingQuestions, numStoriesToldQuestions, storyLengthQuestions, collectionDateQuestions, languageQuestions, storyQuestions, participantQuestions, annotationQuestions);
            this.questionsToInclude = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "questionsToInclude");
            this.graphHolder.lumpingCommands = this.project.lumpingCommandsForCatalysisReport(this.catalysisReportIdentifier);
            // adjust patterns grid for showing or hiding columns
            var columnIDsToShow = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "columnIDsToShowInPatternsTable");
            if (columnIDsToShow === undefined)
                columnIDsToShow = columnIDsToShowIfNoOptionsSaved;
            var allColumnIDs = Object.keys(columnIDsToDisplayNamesMap);
            this.patternsGridFieldSpecification.itemPanelSpecification.panelFields = [{ id: "id", displayName: "Index", valueOptions: [] }];
            allColumnIDs.forEach(function (columnID) {
                if (columnIDsToShow[columnID]) {
                    var columnSpec = { id: columnID, displayName: columnIDsToDisplayNamesMap[columnID], valueOptions: [] };
                    _this.patternsGridFieldSpecification.itemPanelSpecification.panelFields.push(columnSpec);
                }
            });
            this.patternsGrid.updateDisplayConfigurationAndData(this.patternsGridFieldSpecification);
            this.modelForPatternsGrid.patterns = this.buildPatternList();
            this.patternsGrid.updateData();
            this.storyGridFieldSpecification.itemPanelSpecification = makeItemPanelSpecificationForQuestions(this.questions);
            this.storyGrid.updateDisplayConfigurationAndData(this.storyGridFieldSpecification);
            this.updateGraphForNewPattern(null);
        };
        PatternExplorer.prototype.updateStyleSheetForCustomGraphCSS = function () {
            // save css in graphHolder to use for saving files to SVG/PNG
            this.graphHolder.customGraphCSS = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "catalysisReport_customGraphCSS");
            var styleSheetName = "customGraphStyleSheet";
            var oldStyleSheet = document.getElementById(styleSheetName);
            if (oldStyleSheet && oldStyleSheet.parentNode)
                oldStyleSheet.parentNode.removeChild(oldStyleSheet);
            if (this.graphHolder.customGraphCSS) {
                var newStyleSheet = document.createElement("style");
                newStyleSheet.setAttribute("id", styleSheetName);
                newStyleSheet.innerHTML = this.graphHolder.customGraphCSS;
                var script = document.querySelector("script");
                script.parentNode.insertBefore(newStyleSheet, script);
            }
        };
        // TODO: Similar to what is in add_graphBrowser
        PatternExplorer.prototype.getCurrentCatalysisReportIdentifier = function (args) {
            var catalysisReportShortName = valuePathResolver.newValuePathForFieldSpecification(args.model, args.fieldSpecification)();
            if (!catalysisReportShortName)
                return null;
            return this.project.findCatalysisReport(catalysisReportShortName);
        };
        //------------------------------------------------------------------------------------------------------------------------------------------
        // patterns table
        //------------------------------------------------------------------------------------------------------------------------------------------
        PatternExplorer.prototype.buildPatternList = function () {
            var _this = this;
            if (!this.questionsToInclude)
                return [];
            var project = this.project;
            var nominalQuestions = [];
            var scaleQuestions = [];
            var textQuestions = [];
            this.questions.forEach(function (question) {
                if (_this.questionsToInclude[question.id]) {
                    if (question.displayType === "slider") {
                        scaleQuestions.push(question);
                    }
                    else if (question.displayType === "text" || question.displayType === "textarea") {
                        textQuestions.push(question);
                    }
                    else if (nominalQuestionTypes.indexOf(question.displayType) !== -1) {
                        nominalQuestions.push(question);
                    }
                }
            });
            var result = this.buildOrCountPatternList(nominalQuestions, scaleQuestions, textQuestions, true);
            var self = this;
            var progressUpdater = {
                progressMessage: "Calculating statistics",
                redraw: function () {
                    self.progressMessage = progressUpdater.progressMessage;
                    // update progress message without using Mithril to avoid slowdown on this large page
                    var progressMessageSpan = document.getElementById("gridHeaderProgressMessage");
                    if (progressMessageSpan) {
                        progressMessageSpan.innerHTML = this.progressMessage;
                    }
                }
            };
            progressUpdater.redraw();
            var patternIndex = 0;
            var howOftenToUpdateProgressMessage = 20;
            var stories = this.graphHolder.allStories;
            var minimumStoryCountRequiredForTest = this.graphHolder.minimumStoryCountRequiredForTest;
            if (!this.calculationsCanceled) {
                setTimeout(function () { calculateStatsForNextPattern(); }, 1);
            }
            var calculateStatsForNextPattern = function () {
                if (patternIndex >= result.length) {
                    progressUpdater.progressMessage = "";
                    progressUpdater.redraw();
                    m.redraw();
                }
                else {
                    var hideNoAnswerValues = PatternExplorer.getOrSetWhetherNoAnswerValuesShouldBeHiddenForPattern(project, _this.catalysisReportIdentifier, result[patternIndex]);
                    var useLumpingCommands = PatternExplorer.getOrSetWhetherLumpingCommandsShouldBeUsedForPattern(project, _this.catalysisReportIdentifier, result[patternIndex]);
                    var lumpingCommands = {};
                    if (useLumpingCommands) {
                        lumpingCommands = project.lumpingCommandsForCatalysisReport(_this.catalysisReportIdentifier);
                    }
                    calculateStatistics.calculateStatisticsForPattern(result[patternIndex], stories, minimumStoryCountRequiredForTest, "No answer", !hideNoAnswerValues, lumpingCommands, progressUpdater, patternIndex, result.length, howOftenToUpdateProgressMessage);
                    patternIndex += 1;
                    if (!self.calculationsCanceled) {
                        setTimeout(function () { calculateStatsForNextPattern(); }, 1);
                    }
                }
            };
            return result;
        };
        PatternExplorer.prototype.hidePatternBecauseItDoesNotGoThroughTheStory = function (question1, question2, question3) {
            if (question3 === void 0) { question3 = null; }
            if (!this.hidePatternsWithoutStoryQuestions)
                return false;
            if (question3) {
                return (question1.id.indexOf("S_") < 0 && question2.id.indexOf("S_") < 0 && question3.id.indexOf("S_") < 0);
            }
            else {
                return (question1.id.indexOf("S_") < 0 && question2.id.indexOf("S_") < 0);
            }
        };
        PatternExplorer.prototype.buildOrCountPatternList = function (nominalQuestions, scaleQuestions, textQuestions, build) {
            var _this = this;
            var result = [];
            var graphCount = 0;
            function nextID() {
                return ("00000" + graphCount++).slice(-5);
            }
            // data integrity graphs
            if (this.graphTypesToCreate["data integrity graphs"]) {
                if (build) {
                    result.push(this.makePattern(nextID(), "data integrity", scaleQuestions, "All scale values"));
                    result.push(this.makePattern(nextID(), "data integrity", scaleQuestions, "Participant means"));
                    result.push(this.makePattern(nextID(), "data integrity", scaleQuestions, "Participant standard deviations"));
                    result.push(this.makePattern(nextID(), "data integrity", nominalQuestions, "Unanswered choice questions"));
                    result.push(this.makePattern(nextID(), "data integrity", scaleQuestions, "Unanswered scale questions"));
                }
                else {
                    graphCount += 5;
                }
            }
            // texts
            if (this.graphTypesToCreate["texts"]) {
                textQuestions.forEach(function (question) {
                    if (build) {
                        result.push(_this.makePattern(nextID(), "texts", [question], "Text answers"));
                    }
                    else {
                        graphCount++;
                    }
                });
            }
            // one choice question 
            if (this.graphTypesToCreate["bar graphs"]) {
                nominalQuestions.forEach(function (question1) {
                    if (build) {
                        result.push(_this.makePattern(nextID(), "bar", [question1], null));
                    }
                    else {
                        graphCount++;
                    }
                });
            }
            ;
            // one scale question
            if (this.graphTypesToCreate["histograms"]) {
                scaleQuestions.forEach(function (question1) {
                    if (build) {
                        result.push(_this.makePattern(nextID(), "histogram", [question1], null));
                    }
                    else {
                        graphCount++;
                    }
                });
            }
            ;
            // write-in texts
            if (this.graphTypesToCreate["write-in texts"]) {
                var allQuestionsWithAWriteInOption_1 = [];
                nominalQuestions.map(function (question) { if (question.writeInTextBoxLabel)
                    allQuestionsWithAWriteInOption_1.push(question); });
                scaleQuestions.map(function (question) { if (question.writeInTextBoxLabel)
                    allQuestionsWithAWriteInOption_1.push(question); });
                textQuestions.map(function (question) { if (question.writeInTextBoxLabel)
                    allQuestionsWithAWriteInOption_1.push(question); });
                allQuestionsWithAWriteInOption_1.forEach(function (question1) {
                    if (build) {
                        result.push(_this.makePattern(nextID(), "write-in texts", [question1], "Write-in texts"));
                    }
                    else {
                        graphCount++;
                    }
                });
            }
            ;
            // when creating question combinations, prevent mirror duplicates (axb, bxa) and self-matching questions (axa)
            // unless they want axa for multi-choice questions
            var usedQuestions;
            // two choice questions
            if (this.graphTypesToCreate["tables"]) {
                usedQuestions = [];
                nominalQuestions.forEach(function (question1) {
                    usedQuestions.push(question1);
                    nominalQuestions.forEach(function (question2) {
                        var okayToGraphQuestionAgainstItself = _this.graphMultiChoiceQuestionsAgainstThemselves
                            && question1.displayName === question2.displayName && question2.displayType === "checkboxes";
                        if (!okayToGraphQuestionAgainstItself && usedQuestions.indexOf(question2) !== -1)
                            return;
                        if (_this.hidePatternBecauseItDoesNotGoThroughTheStory(question1, question2))
                            return;
                        if (build) {
                            result.push(_this.makePattern(nextID(), "table", [question1, question2], null));
                        }
                        else {
                            graphCount++;
                        }
                    });
                });
            }
            ;
            // two scale questions
            if (this.graphTypesToCreate["scatterplots"]) {
                usedQuestions = [];
                scaleQuestions.forEach(function (question1) {
                    usedQuestions.push(question1);
                    scaleQuestions.forEach(function (question2) {
                        if (usedQuestions.indexOf(question2) !== -1)
                            return;
                        if (_this.hidePatternBecauseItDoesNotGoThroughTheStory(question1, question2))
                            return;
                        if (build) {
                            result.push(_this.makePattern(nextID(), "scatter", [question1, question2], null));
                        }
                        else {
                            graphCount++;
                        }
                    });
                });
            }
            ;
            // one scale question, one choice question
            if (this.graphTypesToCreate["multiple histograms"]) {
                scaleQuestions.forEach(function (question1) {
                    nominalQuestions.forEach(function (question2) {
                        if (_this.hidePatternBecauseItDoesNotGoThroughTheStory(question1, question2))
                            return;
                        if (build) {
                            result.push(_this.makePattern(nextID(), "multiple histogram", [question1, question2], null));
                        }
                        else {
                            graphCount++;
                        }
                    });
                });
            }
            ;
            // two choice questions, one scale question
            if (this.graphTypesToCreate["contingency-histogram tables"]) {
                usedQuestions = [];
                nominalQuestions.forEach(function (question1) {
                    usedQuestions.push(question1);
                    nominalQuestions.forEach(function (question2) {
                        var okayToGraphQuestionAgainstItself = _this.graphMultiChoiceQuestionsAgainstThemselves && question1.displayName === question2.displayName && question2.displayType === "checkboxes";
                        if (!okayToGraphQuestionAgainstItself && usedQuestions.indexOf(question2) !== -1)
                            return;
                        scaleQuestions.forEach(function (question3) {
                            if (_this.hidePatternBecauseItDoesNotGoThroughTheStory(question1, question2, question3))
                                return;
                            if (build) {
                                result.push(_this.makePattern(nextID(), "contingency-histogram", [question1, question2, question3], null));
                            }
                            else {
                                graphCount++;
                            }
                        });
                    });
                });
            }
            ;
            // two scale questions, one choice question
            if (this.graphTypesToCreate["multiple scatterplots"]) {
                usedQuestions = [];
                scaleQuestions.forEach(function (question1) {
                    usedQuestions.push(question1);
                    scaleQuestions.forEach(function (question2) {
                        if (usedQuestions.indexOf(question2) !== -1)
                            return;
                        nominalQuestions.forEach(function (question3) {
                            if (_this.hidePatternBecauseItDoesNotGoThroughTheStory(question1, question2, question3))
                                return;
                            if (build) {
                                result.push(_this.makePattern(nextID(), "multiple scatter", [question1, question2, question3], null));
                            }
                            else {
                                graphCount++;
                            }
                        });
                    });
                });
            }
            ;
            // all scale questions, all choice questions
            if (this.graphTypesToCreate["correlation maps"]) {
                if (scaleQuestions.length >= 3) {
                    result.push(this.makePattern(nextID(), "correlation map", scaleQuestions, "Correlation map"));
                    nominalQuestions.forEach(function (nominalQuestion) {
                        if (build) {
                            var aName = "Correlation map for " + nominalQuestion.displayName;
                            var questionList = [];
                            questionList.push(nominalQuestion); // choice question must be first in the list
                            questionList = questionList.concat(scaleQuestions);
                            result.push(_this.makePattern(nextID(), "correlation map", questionList, aName));
                        }
                        else {
                            graphCount++;
                        }
                    });
                }
            }
            if (build) {
                return result;
            }
            else {
                return [graphCount]; // so there is not a different return type
            }
        };
        //------------------------------------------------------------------------------------------------------------------------------------------
        // selected pattern 
        //------------------------------------------------------------------------------------------------------------------------------------------
        PatternExplorer.prototype.makePattern = function (id, graphType, questions, patternNameIfSpecialType) {
            var _this = this;
            var pattern;
            if (graphType == "data integrity") {
                pattern = { id: id, graphType: graphType, patternName: patternNameIfSpecialType,
                    questions: questions, q1DisplayName: "", q2DisplayName: "", q3DisplayName: "" };
            }
            else if (graphType == "correlation map") {
                pattern = { id: id, graphType: graphType, patternName: patternNameIfSpecialType,
                    questions: questions, q1DisplayName: "", q2DisplayName: "", q3DisplayName: "" };
            }
            else if (questions.length === 1) {
                pattern = { id: id, graphType: graphType, patternName: nameForQuestion(questions[0]),
                    questions: questions, q1DisplayName: questions[0].displayName, q2DisplayName: "", q3DisplayName: "" };
            }
            else if (questions.length === 2) {
                pattern = { id: id, graphType: graphType, patternName: nameForQuestion(questions[0]) + " x " + nameForQuestion(questions[1]),
                    questions: questions, q1DisplayName: questions[0].displayName, q2DisplayName: questions[1].displayName, q3DisplayName: "" };
            }
            else if (questions.length === 3) {
                pattern = { id: id, graphType: graphType, patternName: nameForQuestion(questions[0]) + " x " + nameForQuestion(questions[1]) + " + " + nameForQuestion(questions[2]),
                    questions: questions, q1DisplayName: questions[0].displayName, q2DisplayName: questions[1].displayName, q3DisplayName: questions[2].displayName };
            }
            else {
                console.log("makePattern: Unexpected number of questions", questions);
                throw new Error("makePattern: Unexpected number of questions: " + questions.length);
            }
            this.updatePatternObservationIDs(pattern);
            var observationTitleOrDescriptionAccessor = function () {
                return _this.getCombinedObservationsInfoForPattern(pattern, "observationTitle") || _this.getCombinedObservationsInfoForPattern(pattern, "observationDescription");
            };
            var strengthAccessor = function () {
                return _this.getCombinedObservationsInfoForPattern(pattern, "observationStrength") || "";
            };
            var interpretationsAccessor = function () {
                return _this.getCombinedObservationsInfoForPattern(pattern, "observationInterpretations") || "";
            };
            var remarkableAccessor = function () {
                var remarkable = PatternExplorer.getOrSetWhetherPatternIsMarkedAsRemarkable(_this.project, _this.catalysisReportIdentifier, pattern);
                return (remarkable === undefined)
                    ? (_this.patternHasObservations(pattern) ? "yes" : "")
                    : remarkable;
            };
            var noteAccessor = function () {
                return _this.getCombinedObservationsInfoForPattern(pattern, "observationNote") || "";
            };
            pattern.observation = observationTitleOrDescriptionAccessor; // circular reference
            pattern.strength = strengthAccessor;
            pattern.interpretations = interpretationsAccessor;
            pattern.remarkable = remarkableAccessor;
            pattern.note = noteAccessor;
            return pattern;
        };
        PatternExplorer.prototype.updatePatternObservationIDs = function (pattern) {
            if (!pattern)
                return;
            pattern.observationIDs = [];
            var index = 0;
            var observationID = "";
            while (observationID !== undefined) {
                observationID = findOrCreateObservationIDForPatternAndIndex(this.project, this.catalysisReportObservationSetIdentifier, pattern, index, false);
                if (observationID)
                    pattern.observationIDs.push(observationID);
                index++;
            }
        };
        PatternExplorer.prototype.patternSelected = function (selectedPattern) {
            this.activeObservationTab = 0;
            this.updateGraphForNewPattern(selectedPattern);
            this.currentPattern = selectedPattern;
            this.updateObservationPanelForSelectedPattern();
            this.modelForStoryGrid.storiesSelectedInGraph = [];
            this.storyGrid.updateData();
        };
        PatternExplorer.prototype.updateStoriesPane = function (stories) {
            this.modelForStoryGrid.storiesSelectedInGraph = stories;
            this.storyGrid.updateData();
        };
        PatternExplorer.prototype.updateObservationPanelForSelectedPattern = function () {
            var _this = this;
            if (!this.currentPattern)
                return;
            this.observationAccessors = [];
            this.currentPattern.observationIDs.forEach(function (id) {
                var newAccessor = new ObservationAccessor(id);
                _this.observationAccessors.push(newAccessor);
            });
        };
        PatternExplorer.prototype.getCombinedObservationsInfoForPattern = function (pattern, field) {
            var _this = this;
            var resultTexts = [];
            if (pattern && pattern.observationIDs && pattern.observationIDs.length > 0) {
                pattern.observationIDs.forEach(function (id) {
                    if (field === "observationInterpretations") {
                        var observation = _this.project.tripleStore.makeObject(id, true);
                        var interpretationIDs = _this.project.tripleStore.getListForSetIdentifier(observation.observationInterpretations);
                        var interpretationTexts_1 = [];
                        interpretationIDs.forEach(function (id) {
                            var interpretation = _this.project.tripleStore.makeObject(id, true);
                            if (interpretation)
                                interpretationTexts_1.push(interpretation.interpretation_name || interpretation.interpretation_text);
                        });
                        if (interpretationTexts_1.length)
                            resultTexts.push(interpretationTexts_1.join(" / "));
                    }
                    else {
                        var value = _this.project.tripleStore.queryLatestC(id, field);
                        if (value)
                            resultTexts.push(value);
                    }
                });
            }
            return resultTexts.join(" // ");
        };
        PatternExplorer.prototype.updateGraphForNewPattern = function (pattern) {
            // Remove old graph(s)
            while (this.graphHolder.chartPanes.length) {
                var chartPane = this.graphHolder.chartPanes.pop();
                this.graphHolder.graphResultsPane.removeChild(chartPane);
                // TODO: Do these need to be destroyed or freed somehow?
            }
            this.graphHolder.excludeStoryTooltips = false; // seems to stay set on
            // Need to remove the float end node, if any        
            while (this.graphHolder.graphResultsPane.firstChild) {
                this.graphHolder.graphResultsPane.removeChild(this.graphHolder.graphResultsPane.firstChild);
            }
            this.modelForStoryGrid.storiesSelectedInGraph = [];
            if (pattern === null) {
                return;
            }
            // tell grid to check to see if row is out of view - was causing problems if user scrolled with scroll bar then clicked in row
            this.patternsGrid.isNavigationalScrollingNeeded = "scrolled";
            var oldHideNoAnswerValuesChoice = this.graphHolder.patternDisplayConfiguration.hideNoAnswerValues;
            var newHideNoAnswerValuesChoice = PatternExplorer.getOrSetWhetherNoAnswerValuesShouldBeHiddenForPattern(this.project, this.catalysisReportIdentifier, pattern);
            this.graphHolder.patternDisplayConfiguration.hideNoAnswerValues = newHideNoAnswerValuesChoice;
            var oldUseLumpingCommandsChoice = this.graphHolder.patternDisplayConfiguration.useLumpingCommands;
            var newUseLumpingCommandsChoice = PatternExplorer.getOrSetWhetherLumpingCommandsShouldBeUsedForPattern(this.project, this.catalysisReportIdentifier, pattern);
            this.graphHolder.patternDisplayConfiguration.useLumpingCommands = newUseLumpingCommandsChoice;
            if (oldHideNoAnswerValuesChoice !== newHideNoAnswerValuesChoice || oldUseLumpingCommandsChoice !== newUseLumpingCommandsChoice) {
                var lumpingCommandsToUse = newUseLumpingCommandsChoice ? this.graphHolder.lumpingCommands : {};
                calculateStatistics.calculateStatisticsForPattern(pattern, this.graphHolder.allStories, this.graphHolder.minimumStoryCountRequiredForTest, "No answer", !newHideNoAnswerValuesChoice, lumpingCommandsToUse, null, 0, 0, 0);
            }
            this.graphHolder.statisticalInfo = "";
            this.graphHolder.currentGraph = PatternExplorer.makeGraph(pattern, this.graphHolder, this.updateStoriesPane.bind(this), this.hideStatsPanels);
            this.graphHolder.currentSelectionExtentPercentages = null;
            // TODO: Is this obsolete? this.graphHolder.currentSelectionSubgraph = null;
        };
        PatternExplorer.makeGraph = function (pattern, graphHolder, selectionCallback, hideStatsPanel) {
            if (hideStatsPanel === void 0) { hideStatsPanel = false; }
            var graphType = pattern.graphType;
            var q1 = pattern.questions[0];
            var q2 = pattern.questions[1];
            var q3 = pattern.questions[2];
            var newGraph = null;
            switch (graphType) {
                case "bar":
                    newGraph = charting.d3BarChartForQuestion(graphHolder, q1, selectionCallback, hideStatsPanel);
                    break;
                case "table":
                    newGraph = charting.d3ContingencyTable(graphHolder, q1, q2, null, selectionCallback, hideStatsPanel);
                    break;
                case "contingency-histogram":
                    newGraph = charting.d3ContingencyTable(graphHolder, q1, q2, q3, selectionCallback, hideStatsPanel);
                    break;
                case "histogram":
                    newGraph = charting.d3HistogramChartForQuestion(graphHolder, q1, null, null, selectionCallback, hideStatsPanel);
                    break;
                case "multiple histogram":
                    // Choice question needs to come before scale question in args
                    newGraph = charting.multipleHistograms(graphHolder, q2, q1, selectionCallback, hideStatsPanel);
                    break;
                case "scatter":
                    newGraph = charting.d3ScatterPlot(graphHolder, q1, q2, null, null, selectionCallback, hideStatsPanel);
                    break;
                case "multiple scatter":
                    newGraph = charting.multipleScatterPlot(graphHolder, q1, q2, q3, selectionCallback, hideStatsPanel);
                    break;
                case "correlation map":
                    newGraph = charting.d3CorrelationMapOrMaps(graphHolder, pattern.questions, hideStatsPanel);
                    break;
                case "data integrity":
                    if (pattern.patternName === "Unanswered choice questions" || pattern.patternName === "Unanswered scale questions") {
                        newGraph = charting.d3BarChartToShowUnansweredChoiceQuestions(graphHolder, pattern.questions, pattern.patternName);
                        break;
                    }
                    else {
                        if (pattern.patternName === "Participant means" || pattern.patternName === "Participant standard deviations") {
                            graphHolder.excludeStoryTooltips = true; // no stories to link tooltips to in these cases
                        }
                        newGraph = charting.d3HistogramChartForDataIntegrity(graphHolder, pattern.questions, pattern.patternName);
                        break;
                    }
                case "texts":
                    newGraph = null;
                    break;
                case "write-in texts":
                    newGraph = null;
                    break;
                default:
                    console.log("ERROR: Unexpected graph type");
                    alert("ERROR: Unexpected graph type");
                    break;
            }
            //console.log("newGraph", newGraph);
            return newGraph;
        };
        PatternExplorer.prototype.currentTextAnswers = function () {
            if (!this.catalysisReportObservationSetIdentifier)
                throw new Error("currentTextAnswers: this.catalysisReportObservationSetIdentifier is undefined");
            if (!this.currentPattern)
                return "";
            if (!this.currentPattern.questions[0])
                return "";
            if (!this.graphHolder.allStories)
                return "";
            var questionID = this.currentPattern.questions[0].id;
            var stories = this.graphHolder.allStories;
            var answers = {};
            var answerKeys = [];
            stories.forEach(function (story) {
                var text = story.fieldValue(questionID);
                if (text) {
                    if (!answers[text]) {
                        answers[text] = 0;
                        answerKeys.push(text);
                    }
                    answers[text] += 1;
                }
            });
            answerKeys.sort();
            var sortedAndFormattedAnswers = "";
            for (var i = 0; i < answerKeys.length; i++) {
                var answer = answerKeys[i];
                sortedAndFormattedAnswers += answer;
                if (answers[answer] > 1)
                    sortedAndFormattedAnswers += " (" + answers[answer] + ") ";
                if (i < answerKeys.length - 1)
                    sortedAndFormattedAnswers += "\n--------\n";
            }
            return sortedAndFormattedAnswers;
        };
        PatternExplorer.prototype.currentWriteInTextAnswers = function () {
            if (!this.catalysisReportObservationSetIdentifier)
                throw new Error("currentWriteInTextAnswers: this.catalysisReportObservationSetIdentifier is undefined");
            if (!this.currentPattern)
                return "";
            if (!this.currentPattern.questions[0])
                return "";
            if (!this.graphHolder.allStories)
                return "";
            var questionID = this.currentPattern.questions[0].id;
            var stories = this.graphHolder.allStories;
            var answers = {};
            var answerKeys = [];
            stories.forEach(function (story) {
                var writeInText = story.fieldValueWriteIn(questionID);
                if (writeInText) {
                    if (!answers[writeInText]) {
                        answers[writeInText] = 0;
                        answerKeys.push(writeInText);
                    }
                    answers[writeInText] += 1;
                }
            });
            answerKeys.sort();
            var sortedAndFormattedAnswers = "";
            for (var i = 0; i < answerKeys.length; i++) {
                var answer = answerKeys[i];
                sortedAndFormattedAnswers += answer;
                if (answers[answer] > 1)
                    sortedAndFormattedAnswers += " (" + answers[answer] + ") ";
                if (i < answerKeys.length - 1)
                    sortedAndFormattedAnswers += "\n--------\n";
            }
            return sortedAndFormattedAnswers;
        };
        //------------------------------------------------------------------------------------------------------------------------------------------
        // showing/doing things with selected stories in current graph (or just whole graph)
        //------------------------------------------------------------------------------------------------------------------------------------------
        PatternExplorer.prototype.doThingsWithSelectedStories = function () {
            var actionElement = document.getElementById("thingsYouCanDoPanel_actionRequested");
            var action = actionElement.value;
            switch (action) {
                case "Show survey questions for this pattern":
                    this.showSurveyQuestionsForPatternQuestions();
                    break;
                case "Show statistical results":
                    this.showStatisticalResultsForGraph();
                    break;
                case "Show selected stories in separate window for copying":
                    this.showAllStoriesSelectedInGraph();
                    break;
                case "Show random sample of 10 selected stories":
                    this.sampleStoriesSelectedInGraph(10);
                    break;
                case "Show random sample of 20 selected stories":
                    this.sampleStoriesSelectedInGraph(20);
                    break;
                case "Show random sample of 30 selected stories":
                    this.sampleStoriesSelectedInGraph(30);
                    break;
                case 'Toggle display of "No answer" values for this pattern':
                    this.toggleNoAnswerDisplayForPattern();
                    break;
                case 'Toggle display lumping for this pattern':
                    this.toggleUseLumpingCommandsForPattern();
                    break;
                case "Save current selection (will appear in text box below)":
                    this.saveGraphSelection();
                    break;
                case "Restore saved selection (position cursor in text box)":
                    this.restoreGraphSelection();
                    break;
                case "Save graph(s) as SVG file(s)":
                    this.saveGraphAsFile("SVG");
                    break;
                case "Save graph(s) as PNG file(s)":
                    this.saveGraphAsFile("PNG");
                    break;
                case "Save graph(s) as CSV file":
                    PatternExplorer.saveGraphAsCSV(this.currentPattern, this.graphHolder);
                    break;
                default:
                    alert("Please choose an action from the list before you click the button.");
                    break;
            }
        };
        PatternExplorer.prototype.toggleNoAnswerDisplayForPattern = function () {
            if (!this.currentPattern)
                return;
            var hideNoAnswerValues = PatternExplorer.getOrSetWhetherNoAnswerValuesShouldBeHiddenForPattern(this.project, this.catalysisReportIdentifier, this.currentPattern);
            var newValue = !hideNoAnswerValues;
            PatternExplorer.getOrSetWhetherNoAnswerValuesShouldBeHiddenForPattern(this.project, this.catalysisReportIdentifier, this.currentPattern, newValue);
            this.updateGraphForNewPattern(this.currentPattern);
        };
        PatternExplorer.prototype.toggleUseLumpingCommandsForPattern = function () {
            if (!this.currentPattern)
                return;
            var useLumpingCommands = PatternExplorer.getOrSetWhetherLumpingCommandsShouldBeUsedForPattern(this.project, this.catalysisReportIdentifier, this.currentPattern);
            var newValue = !useLumpingCommands;
            PatternExplorer.getOrSetWhetherLumpingCommandsShouldBeUsedForPattern(this.project, this.catalysisReportIdentifier, this.currentPattern, newValue);
            this.updateGraphForNewPattern(this.currentPattern);
        };
        PatternExplorer.prototype.saveGraphAsFile = function (fileTypeToSave) {
            if (!this.graphHolder || !this.graphHolder.graphResultsPane)
                return;
            var svgNodes = this.graphHolder.graphResultsPane.querySelectorAll("svg");
            var titleNode = this.graphHolder.graphResultsPane.querySelector(".narrafirma-graph-title");
            if (svgNodes.length == 0 || !titleNode)
                return;
            var patternTitle = titleNode.innerHTML;
            if (svgNodes.length == 1) {
                if (fileTypeToSave === "SVG") {
                    var svgFileText = graphStyle.prepareSVGToSaveToFile(svgNodes[0], this.graphHolder.customGraphCSS);
                    var svgFileBlob = new Blob([svgFileText], { type: "text/svg+xml;charset=utf-8" });
                    saveAs(svgFileBlob, patternTitle + ".svg", true); // true is to turn off 3-byte BOM (byte order mark) in UTF-8 encoding
                }
                else if (fileTypeToSave === "PNG") {
                    var canvas = graphStyle.preparePNGToSaveToFile(svgNodes[0], this.graphHolder.customGraphCSS);
                    canvas.toBlob(function (blob) {
                        saveAs(blob, patternTitle + ".png");
                    });
                }
            }
            else {
                var zipFile = new jszip();
                for (var i = 0; i < svgNodes.length; i++) {
                    var graphTitle = this.graphHolder.currentGraph[i].subgraphChoice;
                    graphTitle = replaceAll(graphTitle, "/", " "); // jszip interprets a forward slash as a folder designation 
                    if (fileTypeToSave === "SVG") {
                        var svgFileText = graphStyle.prepareSVGToSaveToFile(svgNodes[i], this.graphHolder.customGraphCSS);
                        zipFile.file(patternTitle + " " + graphTitle + ".svg", svgFileText);
                    }
                    else if (fileTypeToSave === "PNG") {
                        // when using canvas.toBlob either the ZIP file or the PNG files come out corrupted
                        // found this method to fix it online and it works
                        var canvas = graphStyle.preparePNGToSaveToFile(svgNodes[i], this.graphHolder.customGraphCSS);
                        var dataURI = canvas.toDataURL("image/png");
                        var imageData = graphStyle.dataURItoBlob(dataURI);
                        zipFile.file(patternTitle + " " + graphTitle + ".png", imageData, { binary: true });
                    }
                }
                zipFile.generateAsync({ type: "blob", platform: "UNIX", compression: "DEFLATE" })
                    .then(function (blob) {
                    saveAs(blob, patternTitle + " " + fileTypeToSave + ".zip");
                });
            }
        };
        PatternExplorer.saveGraphAsCSV = function (pattern, graphHolder, saveFile) {
            if (saveFile === void 0) { saveFile = true; }
            if (!pattern) {
                alert("Please choose a graph.");
                return;
            }
            var delimiter = Globals.clientState().csvDelimiter();
            var output = "";
            var niceGraphTypeName = "";
            var patternName = pattern.patternName;
            var dataKeys = Object.keys(graphHolder.dataForCSVExport);
            var optionsForFirstQuestion = [];
            var optionsForSecondQuestion = [];
            switch (pattern.graphType) {
                case "bar":
                    niceGraphTypeName = "Bar graph";
                    // {option: count}
                    dataKeys.forEach(function (key) {
                        output += key + delimiter + graphHolder.dataForCSVExport[key] + "\n";
                    });
                    break;
                case "table":
                    niceGraphTypeName = "Table";
                    // {option,option: count}
                    dataKeys.forEach(function (key) {
                        var parts = key.split(delimiter);
                        if (optionsForFirstQuestion.indexOf(parts[0]) < 0)
                            optionsForFirstQuestion.push(parts[0]);
                        if (optionsForSecondQuestion.indexOf(parts[1]) < 0)
                            optionsForSecondQuestion.push(parts[1]);
                    });
                    output += delimiter + optionsForFirstQuestion.join(delimiter) + "\n";
                    optionsForSecondQuestion.forEach(function (secondOption) {
                        output += secondOption + delimiter;
                        optionsForFirstQuestion.forEach(function (firstOption) {
                            output += graphHolder.dataForCSVExport[firstOption + delimiter + secondOption] + delimiter;
                        });
                        output += "\n";
                    });
                    break;
                case "contingency-histogram":
                    niceGraphTypeName = "Histogram table";
                    // {option x option: [mean, sd, skewness, kurtosis]}
                    output += delimiter + "mean" + delimiter + "sd" + delimiter + "skewness" + delimiter + "kurtosis" + delimiter + "values\n";
                    dataKeys.forEach(function (key) {
                        output += key + delimiter;
                        output += graphHolder.dataForCSVExport[key].join(delimiter) + "\n";
                    });
                    output = transposeCSVData(output, delimiter);
                    break;
                case "histogram":
                    niceGraphTypeName = "Histogram";
                    // {question name: bins and values}
                    dataKeys.forEach(function (key) {
                        output += graphHolder.dataForCSVExport[key].join("\n");
                    });
                    break;
                case "multiple histogram":
                    niceGraphTypeName = "Histogram set";
                    // {option: bins and values}
                    dataKeys.forEach(function (key) {
                        output += "\n" + key + "\n";
                        output += graphHolder.dataForCSVExport[key].join("\n") + "\n";
                    });
                    break;
                case "scatter":
                    niceGraphTypeName = "Scatter plot";
                    // {question name: array of xy pairs}
                    output += "x" + delimiter + "y\n";
                    Object.keys(graphHolder.dataForCSVExport).forEach(function (key) {
                        output += graphHolder.dataForCSVExport[key].join("\n");
                    });
                    break;
                case "multiple scatter":
                    niceGraphTypeName = "Scatter plot set";
                    // {option: array of xy pairs}
                    Object.keys(graphHolder.dataForCSVExport).forEach(function (key) {
                        output += "\n\n" + key + "\n";
                        output += "x" + delimiter + "y\n";
                        output += graphHolder.dataForCSVExport[key].join("\n");
                    });
                    break;
                case "data integrity":
                    if (["All scale values", "Participant means", "Participant standard deviations"].indexOf(patternName) >= 0) {
                        niceGraphTypeName = "Histogram";
                        // {data integrity type: bins and values}
                        dataKeys.forEach(function (key) {
                            output += graphHolder.dataForCSVExport[key].join("\n");
                        });
                    }
                    else if (["Unanswered choice questions", "Unanswered scale questions"].indexOf(patternName) >= 0) {
                        niceGraphTypeName = "Bar graph";
                        // {question name: count}
                        dataKeys.forEach(function (key) {
                            output += key + delimiter + graphHolder.dataForCSVExport[key] + "\n";
                        });
                    }
                    break;
                case "correlation map":
                    niceGraphTypeName = "Network map";
                    // {option: r,p,n}
                    dataKeys.forEach(function (key) {
                        output += "\n" + key + delimiter + "r" + delimiter + "p" + delimiter + "n\n";
                        output += graphHolder.dataForCSVExport[key].join("\n") + "\n";
                    });
                    break;
                default:
                    alert("No csv output has been implemented for the current graph selection.");
            }
            output = pattern.patternName + " (" + niceGraphTypeName + ")\n\n" + output;
            if (saveFile) {
                var exportBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
                saveAs(exportBlob, pattern.patternName + ".csv");
            }
            else {
                return output;
            }
        };
        PatternExplorer.prototype.showStatisticalResultsForGraph = function () {
            if (!this.currentPattern) {
                alert("Please choose a graph.");
                return;
            }
            if (!this.graphHolder.statisticalInfo) {
                alert("No statistical information is available for the current graph.");
                return;
            }
            var titleText = "Statistics for pattern: " + this.currentPattern.patternName;
            var text = titleText + (this.graphHolder.statisticalInfo.indexOf("\n\n") !== 0 ? "\n\n" : "") + this.graphHolder.statisticalInfo;
            dialogSupport.openTextEditorDialog(text, titleText, "Close", "Copy to Clipboard", this.closeCopyStoriesDialogClicked.bind(this), false, true);
        };
        PatternExplorer.prototype.showSurveyQuestionsForPatternQuestions = function () {
            if (!this.currentPattern) {
                alert("Please choose a graph.");
                return;
            }
            if (!this.currentPattern.questions) {
                alert("The current pattern has no questions.");
                return;
            }
            var titleText = "Questions for pattern: " + this.currentPattern.patternName;
            var typesToExplanationsDict = {
                "select": "single choice",
                "radiobuttons": "single choice",
                "boolean": "yes/no",
                "checkbox": "yes/no",
                "checkboxes": "multiple choice",
                "slider": "scale",
                "text": "text",
                "textarea": "text",
            };
            var text = "";
            for (var _i = 0, _a = this.currentPattern.questions; _i < _a.length; _i++) {
                var question = _a[_i];
                if (question.displayName && question.displayType && question.displayPrompt) {
                    text += question.displayName + " (" + typesToExplanationsDict[question.displayType] + "): " + question.displayPrompt + "\n";
                    if (question.valueOptions) {
                        text += "    " + question.valueOptions.join("\n    ") + "\n";
                    }
                    else if (question.displayType === "slider" && question.displayConfiguration.length > 1) {
                        text += "    " + question.displayConfiguration[0] + " ----- " + question.displayConfiguration[1] + "\n";
                    }
                    text += "\n";
                }
            }
            dialogSupport.openTextEditorDialog(text, titleText, "Close", "Copy to Clipboard", this.closeCopyStoriesDialogClicked.bind(this), false, true);
        };
        PatternExplorer.prototype.showAllStoriesSelectedInGraph = function () {
            var stories = this.modelForStoryGrid.storiesSelectedInGraph;
            if (!stories.length) {
                alert("Please select some stories in the graph.");
                return;
            }
            stories.sort(function (a, b) {
                if (a.indexInStoryCollection() < b.indexInStoryCollection())
                    return -1;
                if (a.indexInStoryCollection() > b.indexInStoryCollection())
                    return 1;
                return 0;
            });
            this.showStoriesInSeparateWindow(stories, "in graph selection", "Selected stories");
        };
        PatternExplorer.prototype.sample10StoriesSelectedInGraph = function () {
            this.sampleStoriesSelectedInGraph(10);
        };
        PatternExplorer.prototype.sample20StoriesSelectedInGraph = function () {
            this.sampleStoriesSelectedInGraph(20);
        };
        PatternExplorer.prototype.sample30StoriesSelectedInGraph = function () {
            this.sampleStoriesSelectedInGraph(30);
        };
        PatternExplorer.prototype.sampleStoriesSelectedInGraph = function (sampleSize) {
            var stories = this.modelForStoryGrid.storiesSelectedInGraph;
            if (!stories.length) {
                alert("Please select some stories to show.");
                return;
            }
            var sampledStories = [];
            if (stories.length <= sampleSize) {
                sampledStories = sampledStories.concat(stories);
            }
            else {
                var sampledStoryIDs = [];
                while (sampledStoryIDs.length < sampleSize) {
                    var randomIndex = Math.max(0, Math.min(stories.length - 1, Math.round(Math.random() * stories.length) - 1));
                    if (sampledStoryIDs.indexOf(randomIndex) < 0) {
                        sampledStoryIDs.push(randomIndex);
                    }
                }
                sampledStoryIDs.forEach(function (id) {
                    sampledStories.push(stories[id]);
                });
            }
            sampledStories.sort(function (a, b) {
                if (a.indexInStoryCollection() < b.indexInStoryCollection())
                    return -1;
                if (a.indexInStoryCollection() > b.indexInStoryCollection())
                    return 1;
                return 0;
            });
            this.showStoriesInSeparateWindow(sampledStories, "sampled from graph selection", "Sampled stories");
        };
        PatternExplorer.prototype.showStoriesInSeparateWindow = function (stories, sayAboutSelection, windowTitle) {
            var i;
            var text;
            var selectionName = this.nameForCurrentGraphSelection();
            var questionShortNames = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "questionShortNamesToShowForSelectedStories");
            if (questionShortNames === undefined) {
                questionShortNames = [];
            }
            else {
                if (typeof questionShortNames === "string") {
                    questionShortNames = questionShortNames.split("\n");
                }
            }
            var storyQuestions = this.project.storyQuestionsForCatalysisReport(this.catalysisReportIdentifier);
            var participantQuestions = this.project.participantQuestionsForCatalysisReport(this.catalysisReportIdentifier);
            var annotationQuestions = questionnaireGeneration.convertEditorQuestions(this.project.collectAllAnnotationQuestions(), "A_");
            var questionIDsToShowForSelectedStories = [];
            questionShortNames.forEach(function (shortName) {
                for (var i_1 = 0; i_1 < storyQuestions.length; i_1++) {
                    if (storyQuestions[i_1].id === "S_" + shortName) {
                        questionIDsToShowForSelectedStories.push("S_" + shortName);
                        break;
                    }
                }
                for (var i_2 = 0; i_2 < participantQuestions.length; i_2++) {
                    if (participantQuestions[i_2].id === "P_" + shortName) {
                        questionIDsToShowForSelectedStories.push("P_" + shortName);
                        break;
                    }
                }
                for (var i_3 = 0; i_3 < annotationQuestions.length; i_3++) {
                    if (annotationQuestions[i_3].id === "A_" + shortName) {
                        questionIDsToShowForSelectedStories.push("A_" + shortName);
                        break;
                    }
                }
            });
            function textWithAnswersToSelectedQuestions(story) {
                var questionAnswersToShow = [];
                questionIDsToShowForSelectedStories.forEach(function (fieldName) {
                    var answer = story.fieldValue(fieldName);
                    if (answer) {
                        if (typeof answer === "string") {
                            questionAnswersToShow.push(answer);
                        }
                        else if (typeof answer === "number") {
                            questionAnswersToShow.push(answer.toString());
                        }
                        else if (typeof answer === "object") {
                            Object.keys(answer).forEach(function (answerPart) { if (answer[answerPart])
                                questionAnswersToShow.push(answerPart); });
                        }
                    }
                });
                if (questionAnswersToShow.length) {
                    return " (" + questionAnswersToShow.join(", ") + ")";
                }
                return "";
            }
            // story names first
            text = "Names of stories (" + stories.length + ") " + sayAboutSelection + " - " + selectionName + "\n\n";
            for (var i_4 = 0; i_4 < stories.length; i_4++) {
                text += stories[i_4].indexInStoryCollection() + ". " + stories[i_4].storyName() + textWithAnswersToSelectedQuestions(stories[i_4]) + "\n";
            }
            // then full story texts
            text += "\nStories (" + stories.length + ") " + sayAboutSelection + " - " + selectionName + "\n";
            var header = "\n----------------------------------------------------------------------------------------------------\n";
            for (var i_5 = 0; i_5 < stories.length; i_5++) {
                text += "\n" + stories[i_5].indexInStoryCollection() + ". " + stories[i_5].storyName() + textWithAnswersToSelectedQuestions(stories[i_5]);
                if (this.numStoryCollectionsIncludedInReport > 1)
                    text += "\nStory collection: " + stories[i_5].storyCollectionIdentifier();
                text += header + stories[i_5].storyText() + "\n";
            }
            dialogSupport.openTextEditorDialog(text, windowTitle, "Close", "Copy to Clipboard", this.closeCopyStoriesDialogClicked.bind(this), false, true);
        };
        PatternExplorer.prototype.closeCopyStoriesDialogClicked = function (text, hideDialogMethod) {
            hideDialogMethod();
        };
        PatternExplorer.prototype.nameForCurrentGraphSelection = function () {
            var result = "";
            if (!this.currentPattern)
                return result;
            result += this.currentPattern.patternName;
            if (!this.graphHolder)
                return result;
            var selection = this.graphHolder.currentSelectionExtentPercentages;
            if (!selection)
                return result;
            switch (this.currentPattern.graphType) {
                case "bar":
                    result += ": " + selection.selectionCategories.join(", ");
                    break;
                case "table":
                    result += ": " + selection.selectionCategories.join(", ");
                    break;
                case "contingency-histogram":
                    result += ": " + selection.selectionCategories.join(", ");
                    break;
                case "histogram":
                    result += ": " + selection.selectionCategories.join(", ");
                    break;
                case "multiple histogram":
                    result += " [" + selection.subgraphChoice + "]: " + selection.selectionCategories.join(", ");
                    break;
                case "scatter":
                    result += ": " + selection.selectionCategories.join(", ");
                    break;
                case "multiple scatter":
                    result += " [" + selection.subgraphChoice + "]: " + selection.selectionCategories.join(", ");
                    break;
                default:
                    alert("NO name for current graph selection");
            }
            return result;
        };
        //------------------------------------------------------------------------------------------------------------------------------------------
        // saving and restoring graph selections
        //------------------------------------------------------------------------------------------------------------------------------------------
        PatternExplorer.prototype.saveGraphSelection = function () {
            if (this.activeObservationTab === undefined || this.activeObservationTab < 0 || !this.observationAccessors || this.activeObservationTab >= this.observationAccessors.length) {
                alert("Please create an observation in which to save your graph selection.");
                return;
            }
            var activeAccessor = this.observationAccessors[this.activeObservationTab];
            if (!this.graphHolder.currentGraph) {
                // TODO: Translated
                alert("Please select a pattern first.");
                return;
            }
            if (!this.graphHolder.currentSelectionExtentPercentages) {
                alert("Please make a selection in the graph first.");
                return;
            }
            if (this.scanForSelectionJSON()) {
                // TODO: Translate
                alert("This insertion would change a previously saved graph selection because your cursor is currently inside a curly-brackets reference.\nPlease click outside a reference.");
                return;
            }
            if (!this.currentPattern)
                return;
            // Find observation textarea and other needed data
            var textarea = document.getElementById("observationPanel_savedGraphSelections");
            var selection = this.graphHolder.currentSelectionExtentPercentages;
            var textToInsert = JSON.stringify(selection);
            // Replace the currently selected text in the textarea (or insert at caret if nothing selected)
            var selectionStart = textarea.selectionStart;
            var selectionEnd = textarea.selectionEnd;
            var oldText = activeAccessor.observationSavedGraphSelections();
            var newText = oldText.substring(0, selectionStart) + textToInsert + oldText.substring(selectionEnd);
            activeAccessor.observationSavedGraphSelections(newText);
            // Set the new value explicitly here rather than waiting for a Mithril redraw so that we can then select it
            textarea.value = newText;
            textarea.selectionStart = selectionStart;
            textarea.selectionEnd = selectionStart + textToInsert.length;
            textarea.focus();
        };
        PatternExplorer.prototype.scanForSelectionJSON = function (doFocus) {
            if (doFocus === void 0) { doFocus = false; }
            if (this.activeObservationTab === undefined || this.activeObservationTab < 0 || !this.observationAccessors || this.activeObservationTab >= this.observationAccessors.length)
                return;
            var activeAccessor = this.observationAccessors[this.activeObservationTab];
            var textarea = document.getElementById("observationPanel_savedGraphSelections");
            if (!this.currentPattern)
                return;
            var text = activeAccessor.observationSavedGraphSelections();
            if (doFocus)
                textarea.focus();
            var selectionStart = textarea.selectionStart;
            var selectionEnd = textarea.selectionEnd;
            // Find the text for a selection surrounding the current insertion point
            // This assumes there are not nested objects with nested braces
            var start;
            var end;
            // Special case of entire selection -- but could return more complex nested object...
            if (selectionStart !== selectionEnd) {
                if (text.charAt(selectionStart) === "{" && text.charAt(selectionEnd - 1) === "}") {
                    return text.substring(selectionStart, selectionEnd);
                }
            }
            for (start = selectionStart - 1; start >= 0; start--) {
                if (text.charAt(start) === "}")
                    return null;
                if (text.charAt(start) === "{")
                    break;
            }
            if (start < 0)
                return null;
            // Now find the end
            for (end = start; end < text.length; end++) {
                if (text.charAt(end) === "}")
                    break;
            }
            if (end >= text.length)
                return null;
            return text.substring(start, end + 1);
        };
        PatternExplorer.prototype.restoreGraphSelection = function () {
            if (!this.graphHolder.currentGraph) {
                // TODO: Translate
                alert("Please select a pattern first.");
                return;
            }
            // TODO: Need better approach to finding brush extent text and safely parsing it
            // Find observation textarea and other needed data
            // const selectedText = oldText.substring(selectionStart, selectionEnd);
            var selectedText = this.scanForSelectionJSON(true);
            if (!selectedText) {
                // TODO: Translate
                alert("To restore a graph selection, your cursor has to be inside the curly-brackets reference in a graph selections text box (which is part of an observation).\nClick inside the curly brackets, then try this again.");
                return;
            }
            var selection = null;
            try {
                selection = JSON.parse(selectedText);
            }
            catch (e) {
                console.log("JSON parse error", e);
            }
            if (!selection) {
                // TODO: Translate
                alert('The selected text was not a valid graph selection.\nTry clicking inside the curly brackets.');
                return;
            }
            var graph = this.graphHolder.currentGraph;
            if (_.isArray(graph)) {
                var optionText_1 = selection.subgraphChoice;
                if (!optionText_1) {
                    // TODO: Translate
                    alert("No choice of sub-graph was specified in in the stored graph selection.");
                    return;
                }
                optionText_1 = decodeCurlyBraces(optionText_1);
                var graphs = this.graphHolder.currentGraph;
                graphs.forEach(function (subgraph) {
                    if (subgraph.subgraphChoice === optionText_1) {
                        graph = subgraph;
                    }
                });
            }
            charting.restoreChartSelection(graph, selection);
        };
        //------------------------------------------------------------------------------------------------------------------------------------------
        // observations and interpretations
        //------------------------------------------------------------------------------------------------------------------------------------------
        // We don't make the set when the report is created; lazily make it if needed now
        PatternExplorer.prototype.getObservationSetIdentifier = function (catalysisReportIdentifier) {
            if (!catalysisReportIdentifier) {
                throw new Error("getObservationSetIdentifier: catalysisReportIdentifier is not defined");
            }
            var setIdentifier = this.project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_observations");
            if (!setIdentifier) {
                setIdentifier = generateRandomUuid("ObservationSet");
                this.project.tripleStore.addTriple(catalysisReportIdentifier, "catalysisReport_observations", setIdentifier);
            }
            return setIdentifier;
        };
        PatternExplorer.prototype.switchToObservationTabClick = function (tabIndex) {
            if (tabIndex !== undefined) {
                this.activeObservationTab = tabIndex;
            }
        };
        PatternExplorer.prototype.addObservationTabClick = function () {
            var newIndex = this.currentPattern.observationIDs.length || 0;
            var newObservationID = findOrCreateObservationIDForPatternAndIndex(this.project, this.catalysisReportObservationSetIdentifier, this.currentPattern, newIndex, true);
            this.currentPattern.observationIDs.push(newObservationID);
            this.activeObservationTab = newIndex;
            this.updateObservationPanelForSelectedPattern();
        };
        PatternExplorer.prototype.deleteObservationTabClick = function () {
            if (this.currentPattern && this.currentPattern.observationIDs && this.currentPattern.observationIDs[this.activeObservationTab]) {
                var observationIDToRemove = this.currentPattern.observationIDs[this.activeObservationTab];
                var observationToRemove = this.project.tripleStore.makeObject(observationIDToRemove, true);
                var interpretationIDsToRemove = this.project.tripleStore.getListForSetIdentifier(observationToRemove.observationInterpretations);
                if (observationIDToRemove) {
                    var message = 'Are you sure you want to delete the observation \n\n    ' + (observationToRemove.observationTitle || observationToRemove.observationDescription || "Untitled");
                    if (interpretationIDsToRemove && interpretationIDsToRemove.length > 0) {
                        message += '\n\nand the ' + interpretationIDsToRemove.length;
                        message += (interpretationIDsToRemove.length !== 1) ? " interpretations" : " interpretation";
                        message += ' connected to it? You cannot undo this action.';
                    }
                    else {
                        message += "?\n\nYou cannot undo this action.";
                    }
                    if (confirm(message)) {
                        // first, move down the saved index numbers of all observations ABOVE this one in the list for this pattern
                        // this has to be done because the index number is how the observation is looked up
                        // and if you didn't move everybody down to fill the gap, you would end up with (a) missing observations for indexes and (b) observations that are ignored
                        var indexToMoveDown = this.activeObservationTab + 1;
                        while (indexToMoveDown < this.currentPattern.observationIDs.length) {
                            var patternReference_1 = PatternExplorer.patternReferenceForPatternAndIndex(this.currentPattern, indexToMoveDown - 1);
                            this.project.tripleStore.addTriple(this.catalysisReportObservationSetIdentifier, patternReference_1, this.currentPattern.observationIDs[indexToMoveDown]);
                            indexToMoveDown++;
                        }
                        // now that everything has been moved down, remove the LAST index from the dataset by setting to null
                        var patternReference = PatternExplorer.patternReferenceForPatternAndIndex(this.currentPattern, this.currentPattern.observationIDs.length - 1);
                        this.project.tripleStore.addTriple(this.catalysisReportObservationSetIdentifier, patternReference, null);
                        // now remove the selected observation ID from the list for the current pattern
                        this.currentPattern.observationIDs.splice(this.activeObservationTab, 1);
                        // check to make sure the current tab is still within the list length
                        this.activeObservationTab = Math.min(this.currentPattern.observationIDs.length - 1, this.activeObservationTab);
                        // finally recreate the accessor objects
                        this.updateObservationPanelForSelectedPattern();
                    }
                }
            }
        };
        return PatternExplorer;
    }()); // end of PatternExplorer
    var ObservationAccessor = (function () {
        function ObservationAccessor(observationID) {
            this.observationID = observationID;
        }
        ObservationAccessor.prototype.getOrSetField = function (field, newValue) {
            if (newValue === void 0) { newValue = undefined; }
            var project = Globals.project();
            if (newValue === undefined) {
                var result = project.tripleStore.queryLatestC(this.observationID, field);
                if (result === undefined || result === null) {
                    result = "";
                }
                return result;
            }
            else {
                project.tripleStore.addTriple(this.observationID, field, newValue);
                return newValue;
            }
        };
        ObservationAccessor.prototype.observationHasTitleOrDescription = function () {
            return (this.getOrSetField("observationTitle") !== "") || (this.getOrSetField("observationDescription") !== "");
        };
        ObservationAccessor.prototype.observationDescription = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.getOrSetField("observationDescription", newValue);
        };
        ObservationAccessor.prototype.observationTitle = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.getOrSetField("observationTitle", newValue);
        };
        ObservationAccessor.prototype.observationStrength = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.getOrSetField("observationStrength", newValue);
        };
        ObservationAccessor.prototype.observationLinkingQuestion = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.getOrSetField("observationLinkingQuestion", newValue);
        };
        ObservationAccessor.prototype.observationExtraPatterns = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.getOrSetField("observationExtraPatterns", newValue);
        };
        ObservationAccessor.prototype.observationSavedGraphSelections = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.getOrSetField("observationSavedGraphSelections", newValue);
        };
        ObservationAccessor.prototype.observationNote = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.getOrSetField("observationNote", newValue);
        };
        ObservationAccessor.prototype.observationInterpretations = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.getOrSetField("observationInterpretations", newValue);
        };
        return ObservationAccessor;
    }());
    return PatternExplorer;
});

define('js/csvImportExport',["require", "exports", "d3", "./pointrel20150417/generateRandomUuid", "./questionnaireGeneration", "./surveyBuilderMithril", "./surveyCollection", "./surveyStorage", "./panelBuilder/dialogSupport", "./applicationWidgets/ClusteringDiagram", "./applicationWidgets/PatternExplorer", "./Globals", "mithril", "./panelBuilder/toaster", "FileSaver"], function (require, exports, d3, generateRandomUuid, questionnaireGeneration, surveyBuilderMithril, surveyCollection, surveyStorage, dialogSupport, ClusteringDiagram, PatternExplorer, Globals, m, toaster, saveAs) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    var writeInTag = "WriteInEntry_";
    var project;
    function initialize(theProject) {
        project = theProject;
    }
    exports.initialize = initialize;
    //------------------------------------------------------------------------------------------------------------------------------------------
    // string functions
    //------------------------------------------------------------------------------------------------------------------------------------------
    function replaceAll(str, find, replace) {
        return str.replace(new RegExp(find, 'g'), replace);
    }
    function stringUpTo(aString, upToWhat) {
        if (upToWhat !== "") {
            return aString.split(upToWhat)[0];
        }
        else {
            return aString;
        }
    }
    function stringBeyond(aString, beyondWhat) {
        if (beyondWhat !== "") {
            return aString.split(beyondWhat).pop();
        }
        else {
            return aString;
        }
    }
    function padLeadingZeros(num, size) {
        var result = num + "";
        while (result.length < size)
            result = "0" + result;
        return result;
    }
    function shortenTextIfNecessary(text) {
        if (!text || text.length < 50)
            return text;
        return text.slice(0, 50) + "...";
    }
    var observationNoteIdentifier = "[note]";
    function processCSVContents(contents, callbackForItem) {
        var delimiter = Globals.clientState().csvDelimiter();
        var csv = d3.dsv(delimiter, "text/plain");
        var rows = csv.parseRows(contents);
        var items = [];
        var header = null;
        for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            var row = rows[rowIndex];
            var rowIsEmpty = true;
            for (var i = 0; i < row.length; i++) {
                if (row[i] != "") {
                    rowIsEmpty = false;
                }
            }
            var rowIsCommentedOut = row[0].trim().charAt(0) === ";";
            if (rowIsEmpty || rowIsCommentedOut) {
                ;
            }
            else {
                if (!header) {
                    header = [];
                    var headerEnded = false;
                    for (var headerIndex = 0; headerIndex < row.length; headerIndex++) {
                        var headerCellValue = row[headerIndex];
                        if (headerCellValue) {
                            if (headerEnded) {
                                console.log("ERROR: header has empty field before end");
                                alert("ERROR: The column at index " + headerIndex + " in the data file has no header. There should be no empty column headers. ");
                            }
                            header.push(headerCellValue);
                        }
                        else {
                            headerEnded = true;
                        }
                    }
                }
                else {
                    var newItem = callbackForItem(header, row);
                    if (newItem)
                        items.push(newItem);
                }
            }
        }
        return { header: header, items: items };
    }
    function chooseCSVFileToImport(callback, saveStories, writeLog, questionnaire) {
        if (questionnaire === void 0) { questionnaire = null; }
        var cvsFileUploader = document.getElementById("csvFileLoader");
        cvsFileUploader.onchange = function () {
            var file = cvsFileUploader.files[0];
            if (!file) {
                return;
            }
            var reader = new FileReader();
            reader.onload = function (e) {
                var contents = e.target.result;
                callback(contents, saveStories, writeLog, questionnaire);
            };
            reader.readAsText(file);
        };
        cvsFileUploader.click();
    }
    //------------------------------------------------------------------------------------------------------------------------------------------
    // reading stories
    //------------------------------------------------------------------------------------------------------------------------------------------
    function processCSVContentsForStories(contents, saveStories, writeLog, questionnaire) {
        if (questionnaire === void 0) { questionnaire = null; }
        // set up log
        var logItems = [];
        var logQuestionAnswerCounts = {};
        function log(text) {
            if (writeLog) {
                if (logItems.indexOf(text) < 0) {
                    logItems.push(text);
                }
            }
        }
        function count(questionName, answerName) {
            if (!logQuestionAnswerCounts[questionName]) {
                logQuestionAnswerCounts[questionName] = {};
            }
            if (!logQuestionAnswerCounts[questionName][answerName]) {
                logQuestionAnswerCounts[questionName][answerName] = 0;
            }
            logQuestionAnswerCounts[questionName][answerName]++;
        }
        function getMultiChoiceDelimiter(questionnaire) {
            var result = "";
            if (questionnaire && questionnaire.import_multiChoiceDelimiter) {
                result = questionnaire.import_multiChoiceDelimiter;
            }
            else {
                var projectDelimiter = Globals.clientState().csvDelimiter();
                if (projectDelimiter) {
                    result = projectDelimiter;
                }
                else {
                    result = ",";
                }
            }
            if (result && result.toLowerCase() === "space")
                result = " ";
            return result;
        }
        var storyCollectionName;
        if (!questionnaire) {
            // check for story collection
            storyCollectionName = Globals.clientState().storyCollectionName();
            if (!storyCollectionName)
                alert("No story collection has been selected");
            // check for story form
            questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName, true);
        }
        if (!questionnaire)
            return;
        // start log
        if (storyCollectionName)
            log("INFO||Data check for story collection: " + storyCollectionName);
        log("INFO||Data column headers and cell values are only logged the FIRST time their unique value is encountered. Subsequent identical messages are suppressed. Text answers are not reported.");
        // set up progress bar
        var messageText = "";
        if (saveStories) {
            messageText = "Progress importing stories";
        }
        else {
            messageText = "Progress checking stories";
        }
        var progressModel = dialogSupport.openProgressDialog("Processing CSV file...", messageText, "Cancel", dialogCancelled);
        // set up check for story length (to exclude too-short stories)
        var canCheckStoryLength = true;
        var minWordsToIncludeStory = 0;
        if (questionnaire.import_minWordsToIncludeStory) {
            minWordsToIncludeStory = parseInt(questionnaire.import_minWordsToIncludeStory);
            if (isNaN(minWordsToIncludeStory)) {
                log("ERROR||Import option for minimum words to include a story (" + questionnaire.import_minWordsToIncludeStory + ") is not a number.");
                canCheckStoryLength = false;
            }
        }
        var rowNumber = 0;
        var numRowsSkipped = 0;
        // callback function to process file contents
        var headerAndItems = processCSVContents(contents, function (header, row) {
            rowNumber++;
            log("DEBUG||----- PROCESSING ROW " + rowNumber);
            var newItem = {};
            var saveStory = true;
            // get list of columns to append to story text (do not count as questions)
            var columnsToAppendToStoryText = [];
            if (questionnaire.import_columnsToAppendToStoryText) {
                columnsToAppendToStoryText = questionnaire.import_columnsToAppendToStoryText.split("\n");
            }
            // get list of things to write before appended texts
            var textsToWriteBeforeAppendedColumns = [];
            if (questionnaire.import_textsToWriteBeforeAppendedColumns) {
                if (typeof questionnaire.import_textsToWriteBeforeAppendedColumns === "string") {
                    textsToWriteBeforeAppendedColumns = questionnaire.import_textsToWriteBeforeAppendedColumns.split("\n");
                }
                else {
                    textsToWriteBeforeAppendedColumns = questionnaire.import_textsToWriteBeforeAppendedColumns;
                }
            }
            // get list of columns to ignore completely
            var columnsToIgnore = [];
            if (questionnaire.import_columnsToIgnore) {
                columnsToIgnore = questionnaire.import_columnsToIgnore.split("\n");
            }
            var _loop_1 = function (fieldIndex) {
                if (!saveStory) {
                    return "break";
                }
                // get cell value - but if row is shorter than header, don't assign any value
                var value = undefined;
                if (row[fieldIndex] != undefined) {
                    value = row[fieldIndex].trim(); // note the value is trimmed
                }
                // if there is nothing in the cell, record nothing
                if (value === undefined || value === "") {
                    return "continue";
                }
                var headerName = header[fieldIndex];
                // check to see if the header name is in the list of names to be changed because they conflict with other things (like yes/no answer formatting)
                // yes this is done for EVERY row instead of once for the header, which is slow
                // but since the function that reads the header is also used for reading story forms, i don't know HOW to do it only once
                if (questionnaire.import_stringsToRemoveFromHeaders) {
                    if (value != undefined && value !== "") {
                        var stringsToRemove = questionnaire.import_stringsToRemoveFromHeaders.split("\n");
                        if (stringsToRemove.length) {
                            for (var stringIndex = 0; stringIndex < stringsToRemove.length; stringIndex++) {
                                var stringToRemove = stringsToRemove[stringIndex];
                                if (headerName.indexOf(stringToRemove) >= 0) {
                                    headerName = replaceAll(headerName, stringsToRemove[stringIndex], "");
                                }
                            }
                        }
                    }
                }
                // column is story title
                if (headerName === questionnaire.import_storyTitleColumnName) {
                    if (value.toLowerCase() === "testing123") {
                        log('WARN||Row with story name "testing123" skipped.');
                        saveStory = false;
                        numRowsSkipped++;
                    }
                    else {
                        newItem["Story title"] = value;
                        //log("DEBUG||Story title: " + value);
                    }
                    // column is story text - check length if desired, and if too short, do not save story
                }
                else if (headerName === questionnaire.import_storyTextColumnName) {
                    var saveStoryText = false;
                    if (value === undefined || value === "") {
                        log("WARN||Row skipped because story text is empty.");
                        saveStory = false;
                        numRowsSkipped++;
                    }
                    else if (value.toLowerCase() === "testing123") {
                        log('WARN||Row ' + rowNumber + ' with story text "testing123" skipped.');
                        saveStory = false;
                        numRowsSkipped++;
                    }
                    else {
                        if (canCheckStoryLength && minWordsToIncludeStory > 0) {
                            var storyAsWords = value.split(" ");
                            if (storyAsWords.length < minWordsToIncludeStory) {
                                log("WARN||Row skipped because story text length (" + storyAsWords.length + ") is below minimum of " + minWordsToIncludeStory + "; text is: " + shortenTextIfNecessary(value));
                                saveStory = false;
                                numRowsSkipped++;
                            }
                            else {
                                saveStoryText = true;
                            }
                        }
                        else {
                            saveStoryText = true;
                        }
                    }
                    if (saveStory && saveStoryText) {
                        newItem["Story text"] = value;
                        //log("DEBUG||Story text (no word length check): " + shortenTextIfNecessary(value) + "...");
                    }
                    // column is story collection date - expected format: ISO 8601 (YYYY-MM-DD)
                }
                else if (headerName === questionnaire.import_storyCollectionDateColumnName) {
                    var saveDate = true;
                    if (value.length < 10) {
                        log("WARN||Story collection date (" + value + ") is too short; it should consist of at least ten characters (YYYY-MM-DD).");
                        saveDate = false;
                    }
                    var year = value.substr(0, 4);
                    if (isNaN(Number(year))) {
                        log("WARN||Story collection year (" + year + ") is not a number.");
                        saveDate = false;
                    }
                    var month = value.substr(5, 2);
                    if (isNaN(Number(month))) {
                        log("WARN||Story collection month (" + month + ") is not a number.");
                        saveDate = false;
                    }
                    var day = value.substr(8, 2);
                    if (isNaN(Number(day))) {
                        log("WARN||Story collection day of month (" + day + ") is not a number.");
                        saveDate = false;
                    }
                    if (saveDate) {
                        newItem["Collection date"] = value.substr(0, 10);
                    }
                    // column is story language (or language of form story was collected using, whichever the user wants it to be)
                }
                else if (headerName === questionnaire.import_storyFormLanguageColumnName) {
                    newItem["Language"] = value;
                    // column is one of additional text columns to be appended to story text (must be to the right of story text in data file)
                }
                else if (columnsToAppendToStoryText.indexOf(headerName) >= 0) {
                    var indexOfColumnInList = columnsToAppendToStoryText.indexOf(headerName);
                    var textBefore = " --- ";
                    if (textsToWriteBeforeAppendedColumns.length > indexOfColumnInList && textsToWriteBeforeAppendedColumns[indexOfColumnInList]) {
                        textBefore = textsToWriteBeforeAppendedColumns[indexOfColumnInList];
                    }
                    newItem["Story text"] = newItem["Story text"] + " " + textBefore + " " + value;
                    //log('DEBUG||Text for column [' + headerName + '] (' + shortenTextIfNecessary(value) + ') added to story text, with "' + textBefore + '" before it.');
                    // column is eliciting question chosen
                }
                else if (headerName === questionnaire.import_elicitingQuestionColumnName) {
                    var questionShortName = getElicitingQuestionDisplayNameForColumnName(value, questionnaire);
                    if (questionShortName) {
                        newItem["Eliciting question"] = questionShortName;
                        log("LOG||Eliciting question: " + questionShortName);
                    }
                    else {
                        var importNames_1 = [];
                        questionnaire.elicitingQuestions.forEach(function (question) {
                            importNames_1.push(question.importName);
                        });
                        log("ERROR||NO MATCHING ANSWER FOUND for eliciting question name [" + value + "] out of list [" + importNames_1.join(" | ") + "]");
                    }
                    // column is participant ID
                }
                else if (headerName === questionnaire.import_participantIDColumnName) {
                    newItem["Participant ID"] = value;
                    //log("DEBUG||Participant id: " + value);
                    // column is write-in answer 
                }
                else if (headerName.indexOf("WRITEIN_") == 0) {
                    var fieldName = stringBeyond(headerName, "WRITEIN_").trim();
                    var question = questionForHeaderFieldName(fieldName, fieldIndex, questionnaire, project);
                    if (question && question.writeInTextBoxLabel) {
                        newItem[writeInTag + question.displayName] = value;
                        log('LOG||Write-in answer for [' + question.displayName + ']: ' + value);
                    }
                }
                else {
                    // column is answer to question - get question name, and possibly answer name, from column header
                    var fieldName = "";
                    var answerName = "";
                    var separator = questionnaire.import_multiChoiceYesQASeparator;
                    if (separator != undefined && headerName.indexOf(separator) >= 0) {
                        if (separator.toLowerCase() === "space") {
                            separator = " ";
                        }
                        fieldName = stringUpTo(headerName, separator).trim();
                        answerName = stringBeyond(headerName, separator).trim();
                        answerName = stringUpTo(answerName, questionnaire.import_multiChoiceYesQAEnding);
                    }
                    else {
                        fieldName = headerName;
                        answerName = null;
                    }
                    // get question referred to by header name from story form
                    var question_1 = questionForHeaderFieldName(fieldName, fieldIndex, questionnaire, project);
                    if (question_1) {
                        var keepNonMatchingAnswers_1 = question_1.writeInTextBoxLabel && question_1.import_writeInTextsAreInSeparateColumn && question_1.import_writeInTextsAreInSeparateColumn === "no";
                        var questionName_1 = question_1.displayName;
                        var importValueType_1 = question_1.import_valueType;
                        log("LOG||Data column name: " + fieldName + " matched with question: " + questionName_1);
                        // simple data types, text is answer
                        if (["Single choice", "Radiobuttons", "Boolean", "Checkbox", "Text", "Textarea"].indexOf(importValueType_1) >= 0) {
                            var answerNameToUse = getDisplayAnswerNameForDataAnswerName(value, question_1);
                            if (answerNameToUse) {
                                if (["Text", "Textarea"].indexOf(importValueType_1) >= 0) {
                                    newItem[questionName_1] = answerNameToUse;
                                }
                                else {
                                    // if you want to set a value but the value has already been set (because of lumping),
                                    // it's okay to set it again, but you don't want to COUNT it twice, because the import counts will be too high
                                    // so for all data types, the count is only incremented the FIRST time the value is set for the story
                                    // the count must be incremented BEFORE the value is assigned, so you can tell if it has already been assigned
                                    if (!newItem[questionName_1])
                                        count(questionName_1, answerNameToUse);
                                    newItem[questionName_1] = answerNameToUse;
                                    log("LOG||Answer for " + questionName_1 + " (" + importValueType_1 + "): " + answerNameToUse);
                                }
                            }
                            else {
                                if (["Text", "Textarea"].indexOf(importValueType_1) < 0) {
                                    if (keepNonMatchingAnswers_1) {
                                        newItem[writeInTag + question_1.displayName] = value;
                                        log('LOG||Write-in answer for [' + question_1.displayName + ']: ' + value);
                                    }
                                    else {
                                        var listToShow = question_1.import_answerNames;
                                        if (!listToShow)
                                            listToShow = question_1.valueOptions;
                                        log("ERROR||Answer for " + questionName_1 + " (" + importValueType_1 + "): NO MATCHING ANSWER FOUND for answer name [" + value +
                                            "] out of list [" + listToShow.join(" | ") + "]");
                                    }
                                }
                            }
                            // Single choice indexed, text is number of choice in list
                        }
                        else if (importValueType_1 === "Single choice indexed") {
                            var valueAsInt = parseInt(value);
                            var valueAssigned = false;
                            if (!isNaN(valueAsInt)) {
                                for (var index = 0; index < question_1.valueOptions.length; index++) {
                                    if (valueAsInt - 1 === index) {
                                        if (!newItem[questionName_1])
                                            count(questionName_1, question_1.valueOptions[index]);
                                        newItem[questionName_1] = question_1.valueOptions[index];
                                        valueAssigned = true;
                                        log("LOG||Answer for " + questionName_1 + " (" + importValueType_1 + "): " + question_1.valueOptions[index] + "(" + valueAsInt + ")");
                                        break;
                                    }
                                }
                            }
                            if (!valueAssigned) {
                                if (keepNonMatchingAnswers_1) {
                                    newItem[writeInTag + question_1.displayName] = value;
                                    log('LOG||Write-in answer for [' + question_1.displayName + ']: ' + value);
                                }
                                else {
                                    log("ERROR||Answer for " + questionName_1 + " (" + importValueType_1 + "): NO MATCHING ANSWER FOUND for answer index: " + valueAsInt);
                                }
                            }
                            // Scale, text is scale value
                        }
                        else if (importValueType_1 === "Scale") {
                            // parseFloat does not take a locale parameter and cannot process a comma as the decimal delimiter
                            // so we should test for the presence of a comma, assuming that if it's present in a scale value
                            // it is meant to be a decimal delimiter 
                            var valueToConvert = value.replace(",", ".");
                            var valueAsFloat = parseFloat(valueToConvert);
                            if (isNaN(valueAsFloat)) {
                                if (keepNonMatchingAnswers_1) {
                                    newItem[writeInTag + question_1.displayName] = value;
                                    log('LOG||Write-in answer for [' + question_1.displayName + ']: ' + value);
                                }
                                else {
                                    log("ERROR||Answer for " + questionName_1 + " (" + importValueType_1 + "): Should be a number but is not.");
                                }
                            }
                            if (valueAsFloat % 1 !== 0) {
                                // we only want to give this error once per question, or the console will fill up with hundreds of these messages
                                // parseInt stops when it encounters anything but a digit, so the number will be truncated
                                log("ERROR||Answer for " + questionName_1 + " (" + importValueType_1 + "): Should be an integer but is not. It has been truncated.");
                            }
                            var valueAsInt = parseInt(value);
                            var adjustedValue = changeValueForCustomScaleValues(valueAsInt, question_1, questionnaire);
                            newItem[questionName_1] = adjustedValue;
                            var infoString = "LOG||Answer for " + questionName_1 + " (" + importValueType_1 + "): " + adjustedValue;
                            if (adjustedValue != valueAsInt) {
                                infoString += " (adjusted from " + valueAsInt + ")";
                            }
                            log(infoString);
                            count(questionName_1, adjustedValue);
                            // Multi-choice multi-column texts, text is one answer to add to list
                            // in case of lumping, dictionary entry will be set to true again
                        }
                        else if (importValueType_1 === "Multi-choice multi-column texts") {
                            var answerNameToUse = getDisplayAnswerNameForDataAnswerName(value, question_1);
                            if (answerNameToUse) {
                                if (!newItem[questionName_1])
                                    newItem[questionName_1] = {};
                                if (!newItem[questionName_1][answerNameToUse])
                                    count(questionName_1, answerNameToUse);
                                newItem[questionName_1][answerNameToUse] = true;
                                log("LOG||Answer for " + questionName_1 + " (" + importValueType_1 + "): " + answerNameToUse);
                            }
                            else {
                                if (keepNonMatchingAnswers_1) {
                                    newItem[writeInTag + question_1.displayName] = value;
                                    log('LOG||Write-in answer for [' + question_1.displayName + ']: ' + value);
                                }
                                else {
                                    var listToShow = question_1.import_answerNames;
                                    if (!listToShow)
                                        listToShow = question_1.valueOptions;
                                    log("ERROR||Answer for " + questionName_1 + " (" + importValueType_1 + "): NO MATCHING ANSWER FOUND for answer name [" + value +
                                        "] out of list [" + listToShow.join(" | ") + "]");
                                }
                            }
                            // Multi-choice multi-column yes/no, text is yes indicator (or something else), answer was in header
                            // in case of lumping, dictionary entry will be set to true again
                        }
                        else if (importValueType_1 === "Multi-choice multi-column yes/no") {
                            if (value === questionnaire.import_multiChoiceYesIndicator) {
                                if (!newItem[questionName_1])
                                    newItem[questionName_1] = {};
                                var answerNameToUse = getDisplayAnswerNameForDataAnswerName(answerName, question_1);
                                if (answerNameToUse) {
                                    if (!newItem[questionName_1][answerNameToUse])
                                        count(questionName_1, answerNameToUse);
                                    newItem[questionName_1][answerNameToUse] = true;
                                    log("LOG||Answer for " + questionName_1 + " (" + importValueType_1 + "): " + answerNameToUse);
                                }
                                else {
                                    if (keepNonMatchingAnswers_1) {
                                        newItem[writeInTag + question_1.displayName] = value;
                                        log('LOG||Write-in answer for [' + question_1.displayName + ']: ' + value);
                                    }
                                    else {
                                        var listToShow = question_1.import_answerNames;
                                        if (!listToShow)
                                            listToShow = question_1.valueOptions;
                                        log("ERROR||Answer for " + questionName_1 + " (" + importValueType_1 + "): NO MATCHING ANSWER FOUND for answer name [" + answerName +
                                            "] out of list [" + listToShow.join(" | ") + "]");
                                    }
                                }
                            }
                            // Multi-choice single-column delimited, text is whole list of answers
                            // in case of lumping, dictionary entry will be set to true again
                        }
                        else if (importValueType_1 === "Multi-choice single-column delimited") {
                            newItem[questionName_1] = {};
                            var delimiter = getMultiChoiceDelimiter(questionnaire);
                            var delimitedItems = value.split(delimiter);
                            delimitedItems.forEach(function (delimitedItem) {
                                var trimmedDelimitedItem = delimitedItem.trim();
                                if (trimmedDelimitedItem !== "") {
                                    var answerNameToUse = getDisplayAnswerNameForDataAnswerName(trimmedDelimitedItem, question_1);
                                    if (answerNameToUse) {
                                        if (!newItem[questionName_1][answerNameToUse])
                                            count(questionName_1, answerNameToUse);
                                        newItem[questionName_1][answerNameToUse] = true;
                                        log("LOG||Answer for " + questionName_1 + " (" + importValueType_1 + "): " + answerNameToUse);
                                    }
                                    else {
                                        if (keepNonMatchingAnswers_1) {
                                            newItem[writeInTag + question_1.displayName] = value;
                                            log('LOG||Write-in answer for [' + question_1.displayName + ']: ' + value);
                                        }
                                        else {
                                            var listToShow = question_1.import_answerNames;
                                            if (!listToShow)
                                                listToShow = question_1.valueOptions;
                                            log("ERROR||Answer for " + questionName_1 + " (" + importValueType_1 + "): NO MATCHING ANSWER FOUND for answer name [" + trimmedDelimitedItem +
                                                "] out of list " + listToShow.join(" | ") + "]");
                                        }
                                    }
                                }
                            });
                            // Multi-choice single-column delimited indexed, text is whole list of multi-choice answers, except they are numerical indexes to answers
                            // in case of lumping, dictionary entry will be set to true again
                        }
                        else if (importValueType_1 === "Multi-choice single-column delimited indexed") {
                            newItem[questionName_1] = {};
                            var delimiter = getMultiChoiceDelimiter(questionnaire);
                            var delimitedIndexTexts = value.split(delimiter);
                            delimitedIndexTexts.forEach(function (delimitedIndexText) {
                                var delimitedIndex = parseInt(delimitedIndexText);
                                var valueAssigned = false;
                                if (!isNaN(delimitedIndex)) {
                                    for (var index = 0; index < question_1.valueOptions.length; index++) {
                                        if (delimitedIndex - 1 === index) {
                                            var answerNameToUse = question_1.valueOptions[index];
                                            if (!newItem[questionName_1][answerNameToUse])
                                                count(questionName_1, answerNameToUse);
                                            newItem[questionName_1][answerNameToUse] = true;
                                            valueAssigned = true;
                                            log("LOG||Answer for " + questionName_1 + " (" + importValueType_1 + "): " + answerNameToUse);
                                            break;
                                        }
                                    }
                                }
                                if (!valueAssigned) {
                                    if (keepNonMatchingAnswers_1) {
                                        newItem[writeInTag + question_1.displayName] = value;
                                        log('LOG||Write-in answer for [' + question_1.displayName + ']: ' + value);
                                    }
                                    else {
                                        log("ERROR||Answer for " + questionName_1 + " (" + importValueType_1 + "): NO MATCHING ANSWER FOUND for answer index: " + delimitedIndex);
                                    }
                                }
                            });
                        }
                    }
                    else {
                        if (columnsToIgnore.indexOf(headerName) >= 0) {
                            log("LOG||Ignoring data column: " + fieldName);
                        }
                        else {
                            log("LOG||NO MATCHING QUESTION FOUND for data column name: " + fieldName);
                        }
                    }
                }
            };
            // read row by column
            for (var fieldIndex = 0; fieldIndex < header.length; fieldIndex++) {
                var state_1 = _loop_1(fieldIndex);
                if (state_1 === "break")
                    break;
            }
            if (saveStory) {
                return newItem;
            }
            else {
                return null;
            }
        });
        // warn user if problems with header
        // note that this is done after processing all the rows. I don't know how to change it given how processCSVContents works.
        // if I put it in the callback function the alert would be raised on every row
        // and I can't put it in the processCSVContents function because it's multiple purpose and also used for story forms
        var header = headerAndItems.header;
        if (!header) {
            alert("ERROR: No header line found in CSV data file.");
            progressModel.hideDialogMethod();
            progressModel.redraw();
            return;
        }
        if (!header.includes(questionnaire.import_storyTitleColumnName)) {
            if (questionnaire.import_storyTitleColumnName) {
                alert("ERROR: Data file header (first row) is missing an entry for the story title. It should have a header like this: " + questionnaire.import_storyTitleColumnName);
            }
            else {
                alert("ERROR: No story title header name is defined in the selected story form.");
            }
            progressModel.hideDialogMethod();
            progressModel.redraw();
            return;
        }
        else if (!header.includes(questionnaire.import_storyTextColumnName)) {
            if (questionnaire.import_storyTextColumnName) {
                alert("ERROR: Data file header (first row) is missing an entry for the story text. It should have a header like this: " + questionnaire.import_storyTextColumnName);
            }
            else {
                alert("ERROR: No story text header name is defined in the selected story form.");
            }
            progressModel.hideDialogMethod();
            progressModel.redraw();
            return;
        }
        //////////////////////////////////////// IF SAVING STORIES AND NOT WRITING LOG
        // convert arrays created while reading rows into proper stories (survey results)
        var items = headerAndItems.items;
        var surveyResults = [];
        var untitledCount = 0;
        var importedByUserIdentifier = project.userIdentifier.userIdentifier; // TODO: this is a kludgy way to get a string and seems brittle
        // group items by participant ID field, if entered
        var itemsByParticipantID = {};
        for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {
            var item = items[itemIndex];
            var participantID = item["Participant ID"] || generateRandomUuid("Participant");
            if (!itemsByParticipantID[participantID]) {
                itemsByParticipantID[participantID] = [];
            }
            itemsByParticipantID[participantID].push(item);
        }
        var totalStoryCount = 0;
        for (var participantIDIndex in itemsByParticipantID) {
            // TODO: Copied code from surveyBuilder module! Need a common function with surveyBuilder to make this!!!
            var newSurveyResult = {
                __type: "org.workingwithstories.QuestionnaireResponse",
                // TODO: Think about whether to include entire questionnaire or something else perhaps
                questionnaire: questionnaire,
                responseID: generateRandomUuid("QuestionnaireResponse"),
                stories: [],
                language: undefined,
                participantData: {
                    __type: "org.workingwithstories.ParticipantData",
                    participantID: participantIDIndex
                },
                // TODO: Should have timestamp in CSV file!!!
                timestampStart: "" + new Date().toISOString(),
                timestampEnd: "" + new Date().toISOString(),
                timeDuration_ms: 0,
                importedBy: importedByUserIdentifier // TODO: this is a kludgy way to get a string and seems brittle
            };
            for (var storyIndex in itemsByParticipantID[participantIDIndex]) {
                var storyItem = itemsByParticipantID[participantIDIndex][storyIndex];
                var elicitingQuestion = storyItem["Eliciting question"] || questionnaire.elicitingQuestions[0].id;
                var story = {
                    __type: "org.workingwithstories.Story",
                    // TODO: Can this "id" field be safely removed? id: generateRandomUuid("TODO:???"),
                    storyID: generateRandomUuid("Story"),
                    participantID: participantIDIndex,
                    elicitingQuestion: elicitingQuestion,
                    storyText: storyItem["Story text"],
                    storyName: storyItem["Story title"] || ("Untitled #" + padLeadingZeros(++untitledCount, 4)),
                    collectionDate: storyItem["Collection date"],
                    numStoriesTold: "" + itemsByParticipantID[participantIDIndex].length
                };
                for (var i = 0; i < questionnaire.storyQuestions.length; i++) {
                    var question = questionnaire.storyQuestions[i];
                    var value = storyItem[question.id.substring("S_".length)];
                    story[question.id] = value;
                    if (question.writeInTextBoxLabel) {
                        var writeInValue = storyItem[writeInTag + question.id.substring("S_".length)];
                        story[writeInTag + question.id] = writeInValue;
                    }
                }
                newSurveyResult.stories.push(story);
                newSurveyResult.language = storyItem["Language"];
                totalStoryCount += 1;
                for (var i = 0; i < questionnaire.participantQuestions.length; i++) {
                    var question = questionnaire.participantQuestions[i];
                    var value = storyItem[question.id.substring("P_".length)];
                    newSurveyResult.participantData[question.id] = value;
                    if (question.writeInTextBoxLabel) {
                        var writeInValue = storyItem[writeInTag + question.id.substring("P_".length)];
                        newSurveyResult.participantData[writeInTag + question.id] = writeInValue;
                    }
                }
            }
            surveyResults.push(newSurveyResult);
        }
        if (!surveyResults.length) {
            alert("ERROR: No stories to write.");
            progressModel.hideDialogMethod();
            progressModel.redraw();
            return;
        }
        function dialogCancelled(dialogConfiguration, hideDialogMethod) {
            progressModel.cancelled = true;
            hideDialogMethod();
        }
        var wizardPane = {
            forward: function () {
                console.log("survey sending success");
                if (progressModel.failed)
                    return;
                sendNextSurveyResult();
            },
            failed: function () {
                console.log("survey sending failed");
                if (progressModel.failed)
                    return;
                progressModel.failed = true;
                // TODO: Translate
                alert("Problem saving survey result; check the console for details.");
                progressModel.hideDialogMethod();
                progressModel.redraw();
            }
        };
        var totalSurveyCount = surveyResults.length;
        var surveyIndexToSend = 0;
        var numStoriesSentSoFar = 0;
        function sendNextSurveyResult() {
            if (progressModel.cancelled) {
                alert("Cancelled after sending " + numStoriesSentSoFar + " stories from " + surveyIndexToSend + " participants to server.");
            }
            else if (surveyIndexToSend >= surveyResults.length) {
                alert("Finished sending " + numStoriesSentSoFar + " stories from " + surveyIndexToSend + " participants to server.");
                progressModel.hideDialogMethod();
                progressModel.redraw();
            }
            else {
                var surveyResult = surveyResults[surveyIndexToSend++];
                // TODO: Translate
                numStoriesSentSoFar += surveyResult.stories.length;
                progressModel.progressText = "Sending " + numStoriesSentSoFar + "/" + totalStoryCount + " stories from " + surveyIndexToSend + "/" + totalSurveyCount + " participants to server";
                progressModel.redraw();
                surveyStorage.storeSurveyResult(project.pointrelClient, project.projectIdentifier, storyCollectionName, surveyResult, wizardPane);
            }
        }
        // Start sending survey results
        if (saveStories) {
            sendNextSurveyResult();
        }
        //////////////////////////////////////// IF WRITING LOG AND NOT SAVING STORIES
        // write accumulated log items to console
        if (writeLog) {
            var consoleMessageCounts_1 = { "INFO": 0, "WARN": 0, "LOG": 0, "DEBUG": 0, "ERROR": 0 };
            if (logItems.length > 0) {
                console.clear();
                logItems.forEach(function (item) {
                    var typeAndText = item.split("||");
                    var type = typeAndText[0];
                    var text = typeAndText[1];
                    if (type === "INFO") {
                        console.info(text);
                        consoleMessageCounts_1["INFO"]++;
                    }
                    else if (type === "WARN") {
                        console.warn(text);
                        consoleMessageCounts_1["WARN"]++;
                    }
                    else if (type === "LOG") {
                        console.log(text);
                        consoleMessageCounts_1["LOG"]++;
                    }
                    else if (type === "DEBUG") {
                        console.debug(text);
                        consoleMessageCounts_1["DEBUG"]++;
                    }
                    else if (type === "ERROR") {
                        console.error(text);
                        consoleMessageCounts_1["ERROR"]++;
                    }
                });
            }
            // write answer counts to bottom of console log
            var questionNames = Object.keys(logQuestionAnswerCounts);
            if (questionNames.length > 0) {
                console.info("---------- Answer counts");
                for (var questionIndex = 0; questionIndex < questionNames.length; questionIndex++) {
                    var questionName = questionNames[questionIndex];
                    var answerOutputText = "";
                    var answerInfo = logQuestionAnswerCounts[questionName];
                    var answerNames = Object.keys(answerInfo);
                    for (var answerIndex = 0; answerIndex < answerNames.length; answerIndex++) {
                        var answerName = answerNames[answerIndex];
                        answerOutputText += answerName + ": " + answerInfo[answerName];
                        if (answerIndex < answerNames.length - 1) {
                            answerOutputText += "; ";
                        }
                    }
                    console.info(questionName + ": " + answerOutputText);
                }
            }
            // tell user log is complete, remove progress bar
            alert("Finished checking " + totalStoryCount + " stories. "
                + numRowsSkipped + " rows skipped. Check browser console for these messages: "
                + consoleMessageCounts_1["DEBUG"] + " debug, "
                + consoleMessageCounts_1["LOG"] + " log, "
                + consoleMessageCounts_1["INFO"] + " info, "
                + consoleMessageCounts_1["WARN"] + " warning, "
                + consoleMessageCounts_1["ERROR"] + " error. ");
            progressModel.hideDialogMethod();
            progressModel.redraw();
        }
    }
    //------------------------------------------------------------------------------------------------------------------------------------------
    // support functions for reading stories
    //------------------------------------------------------------------------------------------------------------------------------------------
    function questionForHeaderFieldName(fieldName, fieldIndex, questionnaire, project) {
        if (!questionnaire)
            return null;
        if (!fieldName)
            return null;
        var matchingQuestion = null;
        for (var i = 0; i < questionnaire.storyQuestions.length; i++) {
            if (questionnaire.storyQuestions[i].import_columnName === fieldName) {
                matchingQuestion = questionnaire.storyQuestions[i];
                break;
            }
        }
        if (!matchingQuestion) {
            for (var i = 0; i < questionnaire.participantQuestions.length; i++) {
                if (questionnaire.participantQuestions[i].import_columnName === fieldName) {
                    matchingQuestion = questionnaire.participantQuestions[i];
                    break;
                }
            }
        }
        if (!matchingQuestion) {
            var leadingStoryQuestions = questionnaireGeneration.getLeadingStoryQuestions(questionnaire.elicitingQuestions);
            for (var i = 0; i < leadingStoryQuestions.length; i++) {
                if (leadingStoryQuestions[i].import_columnName === fieldName) {
                    matchingQuestion = leadingStoryQuestions[i];
                    break;
                }
            }
        }
        return matchingQuestion;
    }
    function getDisplayAnswerNameForDataAnswerName(value, question) {
        // the question MIGHT have import_answerNames, but it will ALWAYS have valueOptions
        if (!question.valueOptions || question.valueOptions.length < 1) {
            return value;
        }
        else {
            for (var i = 0; i < question.valueOptions.length; i++) {
                // first check to see if it matches the import option name
                if (question.import_answerNames && i < question.import_answerNames.length) {
                    if (value === question.import_answerNames[i]) {
                        return question.valueOptions[i];
                    }
                }
                if (value === question.valueOptions[i]) {
                    return question.valueOptions[i];
                }
            }
        }
        return null;
    }
    function getElicitingQuestionDisplayNameForColumnName(value, questionnaire) {
        for (var i = 0; i < questionnaire.elicitingQuestions.length; i++) {
            var question = questionnaire.elicitingQuestions[i];
            if (value === question.importName) {
                return question.id;
            }
        }
        return null;
    }
    function changeValueForCustomScaleValues(value, question, questionnaire) {
        if (question.displayType !== "slider")
            return null;
        var min = undefined;
        // the "" + is because apparently there are situations in which the scale value is an integer
        if (question.import_minScaleValue !== undefined && question.import_minScaleValue != "") {
            min = parseInt("" + question.import_minScaleValue);
        }
        else if (questionnaire.import_minScaleValue !== undefined && questionnaire.import_minScaleValue !== "") {
            min = parseInt("" + questionnaire.import_minScaleValue);
        }
        var max = undefined;
        if (question.import_maxScaleValue !== undefined && question.import_maxScaleValue != "") {
            max = parseInt("" + question.import_maxScaleValue);
        }
        else if (questionnaire.import_maxScaleValue != undefined && questionnaire.import_maxScaleValue != "") {
            max = parseInt("" + questionnaire.import_maxScaleValue);
        }
        if (min === undefined || isNaN(min) || max === undefined || isNaN(max) || min === max) {
            return value;
        }
        if (value <= min) {
            return 0;
        }
        else if (value >= max) {
            return 100;
        }
        else {
            var multiplier = 100 / (max - min);
            if (multiplier && multiplier > 0) {
                var adjustedValue = Math.round((value - min) * multiplier);
                if (adjustedValue > 100)
                    adjustedValue = 100;
                if (adjustedValue < 0)
                    adjustedValue = 0;
                return adjustedValue;
            }
        }
    }
    //------------------------------------------------------------------------------------------------------------------------------------------
    // reading annotations
    //------------------------------------------------------------------------------------------------------------------------------------------
    function processCSVContentsForAnnotations(contents, saveAnnotations, writeLog, questionnaire) {
        if (questionnaire === void 0) { questionnaire = null; }
        // set up log
        var logItems = [];
        var logQuestionAnswerCounts = {};
        function log(text) {
            if (writeLog) {
                if (logItems.indexOf(text) < 0) {
                    logItems.push(text);
                }
            }
        }
        function count(questionName, answerName) {
            if (!logQuestionAnswerCounts[questionName]) {
                logQuestionAnswerCounts[questionName] = {};
            }
            if (!logQuestionAnswerCounts[questionName][answerName]) {
                logQuestionAnswerCounts[questionName][answerName] = 0;
            }
            logQuestionAnswerCounts[questionName][answerName]++;
        }
        // check for a story collection, story form, and annotation questions
        var storyCollectionName = Globals.clientState().storyCollectionName();
        if (!storyCollectionName) {
            alert("Please select a story collection.");
            return;
        }
        if (!questionnaire) {
            questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName, true); // second param is alertIfProblem
            if (!questionnaire) {
                alert("The currently selected story collection has no associated story form.");
                return;
            }
        }
        var stories = surveyCollection.getStoriesForStoryCollection(storyCollectionName, true); // second param is includeIgnored
        if (stories.length < 1) {
            alert("The currently selected story collection has no stories in it.");
            return;
        }
        var annotationQuestions = questionnaireGeneration.convertEditorQuestions(project.collectAllAnnotationQuestions(), "A_");
        if (annotationQuestions.length < 1) {
            alert("The current project has no annotation questions.");
            return;
        }
        // start log
        log("INFO||Annotation import check for story collection: " + storyCollectionName);
        log("INFO||Data column headers and cell values are only logged the FIRST time their unique value is encountered. Subsequent identical messages are suppressed.");
        // set up progress bar
        var messageText = "";
        if (saveAnnotations) {
            messageText = "Progress importing annotations";
        }
        else {
            messageText = "Progress checking annotations";
        }
        var progressModel = dialogSupport.openProgressDialog("Processing CSV file...", messageText, "Cancel", dialogCancelled);
        var rowNumber = 0;
        // callback function to process file contents
        var headerAndItems = processCSVContents(contents, function (header, row) {
            rowNumber++;
            log("DEBUG||----- Processing row " + rowNumber);
            var storyToAnnotate = null;
            var annotationsForThisStory = {};
            // story name MUST be first cell in row, and story text MUST be second cell in row
            // this is because the match between row and story can depend on name, text, or both - so they must be read together
            var annotationStoryName = row[0];
            var annotationStoryText = row[1];
            var matchingStories = stories.filter(function (story) {
                return story.storyName() === annotationStoryName && story.storyText() === annotationStoryText;
            });
            var storyTextForMessage = (annotationStoryText.length > 100) ? annotationStoryText.slice(0, 100) + " ..." : annotationStoryText;
            if (matchingStories.length == 0) {
                log('WARN||No story matched the name "' + annotationStoryName + '" and text "' + storyTextForMessage + '".');
            }
            else if (matchingStories.length == 1) {
                storyToAnnotate = matchingStories[0];
                log('INFO||Matched annotation to story "' + annotationStoryName + '" with text "' + storyTextForMessage + '".');
            }
            else {
                log('WARN||Multiple stories match the name "' + annotationStoryName + '" and text "' + storyTextForMessage + '".');
            }
            if (!storyToAnnotate) {
                return null;
            }
            for (var fieldIndex = 2; fieldIndex < header.length; fieldIndex++) {
                var value = row[fieldIndex];
                if (value === undefined)
                    continue;
                value = value.trim();
                if (value === "")
                    continue;
                var headerName = header[fieldIndex];
                var question = null;
                for (var i = 0; i < annotationQuestions.length; i++) {
                    if (annotationQuestions[i].displayName === headerName) {
                        question = annotationQuestions[i];
                        break;
                    }
                }
                if (!question) {
                    log("LOG||NO MATCHING QUESTION FOUND for data column name: " + headerName);
                    continue;
                }
                var questionName = question.displayName;
                var questionType = question.displayType;
                log("LOG||Data column name: " + headerName + " matched with question: " + questionName);
                if (["text", "textarea"].indexOf(questionType) >= 0) {
                    annotationsForThisStory[questionName] = value;
                }
                else if (["boolean", "checkbox"].indexOf(questionType) >= 0) {
                    var trimmedValue = value.trim().toLowerCase();
                    if (trimmedValue === "yes" || trimmedValue === "true") {
                        annotationsForThisStory[questionName] = true;
                    }
                    else if (trimmedValue === "no" || trimmedValue === "false") {
                        annotationsForThisStory[questionName] = false;
                    }
                }
                else if (["select", "radiobuttons"].indexOf(questionType) >= 0) {
                    var answerNameToUse = getDisplayAnswerNameForDataAnswerName(value, question);
                    if (answerNameToUse) {
                        if (!annotationsForThisStory[questionName])
                            count(questionName, answerNameToUse);
                        annotationsForThisStory[questionName] = answerNameToUse;
                        log("LOG||Answer for " + questionName + " (" + questionType + "): " + answerNameToUse);
                    }
                    else {
                        var listToShow = question.import_answerNames;
                        if (!listToShow)
                            listToShow = question.valueOptions;
                        log("ERROR||Answer for " + questionName + " (" + questionType + "): NO MATCHING ANSWER FOUND for answer name [" + value +
                            "] out of list [" + listToShow.join(" | ") + "]");
                    }
                }
                else if (questionType === "slider") {
                    var valueAsFloat = parseFloat(value.replace(",", "."));
                    if (valueAsFloat % 1 !== 0)
                        log("ERROR||Answer for " + questionName + " (" + questionType + "): Should be an integer but is not. It has been truncated.");
                    var valueAsInt = parseInt(value);
                    var adjustedValue = changeValueForCustomScaleValues(valueAsInt, question, questionnaire);
                    annotationsForThisStory[questionName] = adjustedValue;
                    var infoString = "LOG||Answer for " + questionName + " (" + questionType + "): " + adjustedValue;
                    if (adjustedValue != valueAsInt)
                        infoString += " (adjusted from " + valueAsInt + ")";
                    log(infoString);
                    count(questionName, adjustedValue);
                }
                else if (questionType === "checkboxes") {
                    var answerNameToUse = getDisplayAnswerNameForDataAnswerName(value, question);
                    if (answerNameToUse) {
                        if (!annotationsForThisStory[questionName])
                            annotationsForThisStory[questionName] = {};
                        if (!annotationsForThisStory[questionName][answerNameToUse])
                            count(questionName, answerNameToUse);
                        annotationsForThisStory[questionName][answerNameToUse] = true;
                        log("LOG||Answer for " + questionName + " (" + questionType + "): " + answerNameToUse);
                    }
                    else {
                        var listToShow = question.import_answerNames;
                        if (!listToShow)
                            listToShow = question.valueOptions;
                        log("ERROR||Answer for " + questionName + " (" + questionType + "): NO MATCHING ANSWER FOUND for answer name [" + value +
                            "] out of list [" + listToShow.join(" | ") + "]");
                    }
                }
            }
            if (saveAnnotations) {
                return { story: storyToAnnotate, annotations: annotationsForThisStory };
            }
            else {
                return null;
            }
        });
        var header = headerAndItems.header;
        if (!header) {
            alert("ERROR: No header line found in CSV data file.");
            return;
        }
        var changes = [];
        if (saveAnnotations) {
            var items = headerAndItems.items;
            items.forEach(function (item) {
                var story = item.story;
                var annotations = item.annotations;
                var questionNames = Object.keys(annotations);
                questionNames.forEach(function (questionName) {
                    if (story.storyID() && questionName && (annotations[questionName] !== undefined)) {
                        changes.push({ id: story.storyID(), field: "A_" + questionName, value: annotations[questionName] });
                    }
                    else {
                        log('INFO||For the story "' + story.storyName() + '", there is no answer for the question "' + questionName + '".');
                    }
                });
            });
        }
        if (saveAnnotations && !changes.length) {
            alert("ERROR: No annotations to import.");
            progressModel.hideDialogMethod();
            progressModel.redraw();
            return;
        }
        function dialogCancelled(dialogConfiguration, hideDialogMethod) {
            progressModel.cancelled = true;
            hideDialogMethod();
        }
        var wizardPane = {
            forward: function () {
                console.log("annotation import success");
                if (progressModel.failed)
                    return;
                sendNextChange();
            },
            failed: function () {
                console.log("annotation import failed");
                if (progressModel.failed)
                    return;
                progressModel.failed = true;
                alert("Problem saving annotation; check the console for details.");
                progressModel.hideDialogMethod();
                progressModel.redraw();
            }
        };
        var totalChangeCount = changes.length;
        var changeIndexToSend = 0;
        var numChangesSentSoFar = 0;
        function sendNextChange() {
            if (progressModel.cancelled) {
                alert("Cancelled after sending " + numChangesSentSoFar + " annotations to server.");
            }
            else if (changeIndexToSend >= changes.length) {
                alert("Finished sending " + numChangesSentSoFar + " annotations to server.");
                progressModel.hideDialogMethod();
                progressModel.redraw();
            }
            else {
                var change = changes[changeIndexToSend++];
                numChangesSentSoFar++;
                progressModel.progressText = "Sending " + numChangesSentSoFar + "/" + totalChangeCount + " annotations to server";
                progressModel.redraw();
                var message = project.tripleStore.makeAddTripleMessage(change.id, change.field, change.value);
                project.pointrelClient.sendMessage(message, function (error, result) {
                    if (error) {
                        console.log("Problem saving annotation", error);
                        if (wizardPane && wizardPane.failed) {
                            wizardPane.failed();
                        }
                        else {
                            alert("Problem saving annotation; check the console for details.");
                        }
                        return;
                    }
                    console.log("Annotation stored");
                    if (wizardPane) {
                        wizardPane.forward();
                    }
                    else {
                        // TODO: Translate
                        alert("Annotations stored.");
                    }
                });
            }
        }
        // Start sending survey results
        if (saveAnnotations) {
            sendNextChange();
        }
        if (writeLog) {
            var consoleMessageCounts_2 = { "INFO": 0, "WARN": 0, "LOG": 0, "DEBUG": 0, "ERROR": 0 };
            if (logItems.length > 0) {
                console.clear();
                logItems.forEach(function (item) {
                    var typeAndText = item.split("||");
                    var type = typeAndText[0];
                    var text = typeAndText[1];
                    if (type === "INFO") {
                        console.info(text);
                        consoleMessageCounts_2["INFO"]++;
                    }
                    else if (type === "WARN") {
                        console.warn(text);
                        consoleMessageCounts_2["WARN"]++;
                    }
                    else if (type === "LOG") {
                        console.log(text);
                        consoleMessageCounts_2["LOG"]++;
                    }
                    else if (type === "DEBUG") {
                        console.debug(text);
                        consoleMessageCounts_2["DEBUG"]++;
                    }
                    else if (type === "ERROR") {
                        console.error(text);
                        consoleMessageCounts_2["ERROR"]++;
                    }
                });
            }
            // write answer counts to bottom of console log
            var questionNames = Object.keys(logQuestionAnswerCounts);
            if (questionNames.length > 0) {
                console.info("---------- Answer counts");
                for (var questionIndex = 0; questionIndex < questionNames.length; questionIndex++) {
                    var questionName = questionNames[questionIndex];
                    var answerOutputText = "";
                    var answerInfo = logQuestionAnswerCounts[questionName];
                    var answerNames = Object.keys(answerInfo);
                    for (var answerIndex = 0; answerIndex < answerNames.length; answerIndex++) {
                        var answerName = answerNames[answerIndex];
                        answerOutputText += answerName + ": " + answerInfo[answerName];
                        if (answerIndex < answerNames.length - 1) {
                            answerOutputText += "; ";
                        }
                    }
                    console.info(questionName + ": " + answerOutputText);
                }
            }
            // tell user log is complete
            alert("Finished checking " + rowNumber + " rows. Check browser console for these messages: "
                + consoleMessageCounts_2["DEBUG"] + " debug, "
                + consoleMessageCounts_2["LOG"] + " log, "
                + consoleMessageCounts_2["INFO"] + " info, "
                + consoleMessageCounts_2["WARN"] + " warning, "
                + consoleMessageCounts_2["ERROR"] + " error. ");
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // exporting annotations
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function exportAnnotationsForCurrentStoryCollectionToCSV() {
        var storyCollectionName = Globals.clientState().storyCollectionName();
        if (!storyCollectionName) {
            alert("Please select a story collection first.");
            return;
        }
        var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName);
        if (!questionnaire) {
            alert("The story collection has not been initialized with a story form: " + storyCollectionName);
            return;
        }
        var allStories = surveyCollection.getStoriesForStoryCollection(storyCollectionName, true);
        var header1 = [];
        var header2 = [];
        function header(contents, secondHeader) {
            if (secondHeader === void 0) { secondHeader = ""; }
            header1.push(contents);
            header2.push(secondHeader);
        }
        // Put initial header
        header("Story title", ";"); // use semicolon to make second line a comment
        header("Story text");
        function headersForQuestions(questions) {
            var _loop_2 = function (i) {
                var question = questions[i];
                if (["label", "header"].indexOf(question.displayType) >= 0)
                    return "break";
                if (question.valueOptions && question.displayType === "checkboxes") {
                    question.valueOptions.forEach(function (option) {
                        header(question.displayName, option);
                    });
                }
                else {
                    header(question.displayName);
                }
            };
            for (var i = 0; i < questions.length; i++) {
                var state_2 = _loop_2(i);
                if (state_2 === "break")
                    break;
            }
        }
        var annotationQuestions = project.collectAllAnnotationQuestions();
        var adjustedAnnotationQuestions = questionnaireGeneration.convertEditorQuestions(annotationQuestions, "A_");
        headersForQuestions(adjustedAnnotationQuestions);
        var output = "";
        var delimiter = Globals.clientState().csvDelimiter();
        function addOutputLine(line) { output = addCSVOutputLine(output, line, delimiter); }
        addOutputLine(header1);
        addOutputLine(header2);
        function dataForQuestions(questions, story, outputLine) {
            var _loop_3 = function (i) {
                var question = questions[i];
                if (["label", "header"].indexOf(question.displayType) >= 0)
                    return "break";
                var value = story.fieldValue(question.id);
                if (value === undefined || value === null)
                    value = "";
                if (question.valueOptions && question.displayType === "checkboxes") {
                    question.valueOptions.forEach(function (option) {
                        outputLine.push(value[option] ? option : "");
                    });
                }
                else {
                    outputLine.push(value);
                }
                if (question.writeInTextBoxLabel) {
                    var writeInValue = story.fieldValueWriteIn(question.id);
                    outputLine.push(writeInValue ? writeInValue : "");
                }
            };
            for (var i = 0; i < questions.length; i++) {
                var state_3 = _loop_3(i);
                if (state_3 === "break")
                    break;
            }
        }
        allStories.forEach(function (story) {
            var outputLine = [];
            outputLine.push(story.storyName());
            outputLine.push(story.storyText());
            dataForQuestions(adjustedAnnotationQuestions, story, outputLine);
            addOutputLine(outputLine);
        });
        var storyCollectionBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
        // TODO: This seems to clear the console in FireFox 40; why?
        saveAs(storyCollectionBlob, "export_annotations_" + storyCollectionName + ".csv");
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // reading story form
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function processCSVContentsForQuestionnaire(contents) {
        var headerAndItems = processCSVContents(contents, function (header, row) {
            var newItem = {};
            var lastFieldIndex;
            for (var fieldIndex = 0; fieldIndex < row.length; fieldIndex++) {
                var fieldName = header[fieldIndex];
                if (fieldName) {
                    lastFieldIndex = fieldIndex;
                }
                else {
                    fieldName = header[lastFieldIndex];
                }
                // TODO: Should the value really be trimmed?
                var value = row[fieldIndex].trim();
                if (fieldIndex < header.length - 1) {
                    newItem[fieldName] = value;
                }
                else {
                    // Handle multiple values for last header items
                    var list = newItem[fieldName];
                    if (!list) {
                        list = [];
                        newItem[fieldName] = list;
                    }
                    if (value)
                        list.push(value);
                }
            }
            return newItem;
        });
        var header = headerAndItems.header;
        if (!header) {
            alert("ERROR: No header line found in CSV file.");
            return false;
        }
        if (!(header.includes("Short name") && header.includes("Long name") && header.includes("Type") && header.includes("About") && header.includes("Answers"))) {
            alert("ERROR: Header is missing at least one required cell. It must have entries for Short name, Long name, Type, About, and Answers. (It should also have a Data column name header, but for legacy files Short name will be taken to mean the same thing.) The header row must be the first readable row in the CSV file.");
            return false;
        }
        var shortName = prompt("Please enter a short name for the new story form. (It must be unique within the project.)");
        if (!shortName)
            return;
        if (questionnaireGeneration.buildStoryForm(shortName)) {
            alert('A story form already exists with that name: "' + shortName + '"');
            return;
        }
        var storyFormListIdentifier = project.getFieldValue("project_storyForms");
        if (!storyFormListIdentifier) {
            storyFormListIdentifier = project.tripleStore.newIdForSet("StoryFormSet");
            project.setFieldValue("project_storyForms", storyFormListIdentifier);
        }
        var template = {};
        questionnaireGeneration.formFieldsInfo.forEach(function (fieldInfo) {
            if (fieldInfo.default) {
                template[fieldInfo.tripleStoreFieldID] = fieldInfo.default;
            }
            else {
                template[fieldInfo.tripleStoreFieldID] = "";
            }
        });
        template.id = generateRandomUuid("StoryForm");
        template.questionForm_shortName = shortName;
        template.questionForm_elicitingQuestions = project.tripleStore.newIdForSet("ElicitingQuestionChoiceSet");
        template.questionForm_storyQuestions = project.tripleStore.newIdForSet("StoryQuestionChoiceSet");
        template.questionForm_participantQuestions = project.tripleStore.newIdForSet("ParticipantQuestionChoiceSet");
        questionnaireGeneration.setDefaultImportFieldsForTemplate(template);
        var overrideOption = project.tripleStore.queryLatestC(project.projectIdentifier, "project_csvQuestionOverwriteOption");
        if (overrideOption === "always replace existing questions with matching questions from the CSV file") {
            overrideOption = "always";
        }
        else if (overrideOption === "always keep existing questions; ignore any matching questions in the CSV file") {
            overrideOption = "never";
        }
        else if (overrideOption === "show me the list of existing questions and ask if I still want to import the file") {
            overrideOption = "ask all";
        }
        else if (overrideOption === "ask me whether to replace each existing question") {
            overrideOption = "ask each";
        }
        else if (overrideOption === "stop the import if any existing questions are found") {
            overrideOption = "stop";
        }
        var storyQuestionsThatAlreadyExist = [];
        var participantQuestionsThatAlreadyExist = [];
        var items = headerAndItems.items;
        for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {
            var item = items[itemIndex];
            var about = item.About;
            var question = void 0;
            var existingQuestion = null;
            if (about === "story") {
                question = questionForItem(item, "storyQuestion");
                existingQuestion = existingQuestionThatMatchesNewQuestion(question, "storyQuestion");
                if (existingQuestion)
                    storyQuestionsThatAlreadyExist.push(existingQuestion);
            }
            else if (about === "participant") {
                question = questionForItem(item, "participantQuestion");
                existingQuestion = existingQuestionThatMatchesNewQuestion(question, "participantQuestion");
                if (existingQuestion)
                    participantQuestionsThatAlreadyExist.push(existingQuestion);
            }
        }
        if (storyQuestionsThatAlreadyExist.length || participantQuestionsThatAlreadyExist.length) {
            var message_1 = 'These questions already exist';
            switch (overrideOption) {
                case "always":
                    message_1 += " and are being overwritten.\n\n";
                    break;
                case "never":
                    message_1 += " and are being preserved. The questions with the same name in the CSV file are being ignored.\n\n";
                    break;
                case "ask all":
                case "ask each":
                case "stop":
                    message_1 += ":\n\n";
                    break;
                default:
                    throw Error("ERROR: No override option chosen.");
            }
            storyQuestionsThatAlreadyExist.forEach(function (question) { message_1 += "    " + question["storyQuestion_shortName"] + "\n"; });
            participantQuestionsThatAlreadyExist.forEach(function (question) { message_1 += "    " + question["participantQuestion_shortName"] + "\n"; });
            switch (overrideOption) {
                case "always":
                case "never":
                    alert(message_1);
                    break;
                case "ask all":
                    message_1 += "\nDo you want to overwrite them?";
                    if (confirm(message_1)) {
                        alert("Okay. The story form has been created, and the existing questions have been overwritten.");
                    }
                    else {
                        alert("Okay. No story form has been created. No questions have been imported.");
                        return;
                    }
                    break;
                case "ask each":
                    break;
                case "stop":
                    message_1 += "\nNo story form will be created.";
                    alert(message_1);
                    return;
                default:
                    throw Error("ERROR: No override option chosen.");
            }
        }
        project.tripleStore.makeNewSetItem(storyFormListIdentifier, "StoryForm", template);
        // For all items:
        //   Check if one with that name already exists
        //   if it does exist, ask if they want to overwrite it
        //   If does not exist, create it in the related set
        //   Add a reference to the question in the story form
        var questionTypeCounts = {};
        // in pre-1.2 files, headers for eliciting question, story title, story text, and participant ID were hard coded
        project.tripleStore.addTriple(template.id, "questionForm_import_elicitingQuestionColumnName", "Eliciting question");
        project.tripleStore.addTriple(template.id, "questionForm_import_storyTitleColumnName", "Story title");
        project.tripleStore.addTriple(template.id, "questionForm_import_storyTextColumnName", "Story text");
        project.tripleStore.addTriple(template.id, "questionForm_import_participantIDColumnName", "Participant ID");
        project.tripleStore.addTriple(template.id, "questionForm_import_storyCollectionDateColumnName", "Collection date");
        project.tripleStore.addTriple(template.id, "questionForm_import_storyFormLanguageColumnName", "Language");
        var _loop_4 = function (itemIndex) {
            var item = items[itemIndex];
            var about = item.About;
            var reference;
            var question = void 0;
            if (about === "story") {
                question = questionForItem(item, "storyQuestion");
                reference = ensureQuestionExists(question, "storyQuestion", overrideOption);
                addReferenceToList(template.questionForm_storyQuestions, reference, "storyQuestion", "StoryQuestionChoice");
            }
            else if (about === "participant") {
                question = questionForItem(item, "participantQuestion");
                reference = ensureQuestionExists(question, "participantQuestion", overrideOption);
                addReferenceToList(template.questionForm_participantQuestions, reference, "participantQuestion", "ParticipantQuestionChoice");
            }
            else if (about === "eliciting") {
                template.import_elicitingQuestionColumnName = item["Data column name"] || "Eliciting question";
                project.tripleStore.addTriple(template.id, "questionForm_import_elicitingQuestionColumnName", item["Data column name"] || "Eliciting question");
                template.import_elicitingQuestionGraphName = item["Short name"] || "Eliciting question";
                project.tripleStore.addTriple(template.id, "questionForm_import_elicitingQuestionGraphName", item["Short name"] || "Eliciting question");
                template.questionForm_chooseQuestionText = item["Long name"] || "Eliciting question";
                project.tripleStore.addTriple(template.id, "questionForm_chooseQuestionText", item["Long name"] || "Eliciting question");
                var answers = item["Answers"];
                answers.forEach(function (elicitingQuestionDefinition) {
                    if (!elicitingQuestionDefinition)
                        elicitingQuestionDefinition = "ERROR: Missing eliciting question text";
                    var sections = elicitingQuestionDefinition.split("|");
                    var dataColumnName = "";
                    var shortName = "";
                    var longName = "";
                    // If only one section, use it as import name, short name, AND text
                    // if two sections, use first as both import name and short name, use second as text
                    if (sections.length < 2) {
                        dataColumnName = sections[0];
                        shortName = sections[0];
                        longName = sections[0];
                        // if two sections, copy import name to short name, leaving text alone
                    }
                    else if (sections.length < 3) {
                        dataColumnName = sections[0];
                        shortName = sections[0];
                        longName = sections[1];
                        // if all three sections, correct order is import, short, long
                    }
                    else {
                        dataColumnName = sections[0];
                        shortName = sections[1];
                        longName = sections[2];
                    }
                    var elicitingQuestion = {
                        elicitingQuestion_dataColumnName: dataColumnName.trim(),
                        elicitingQuestion_shortName: shortName.trim(),
                        elicitingQuestion_text: longName.trim(),
                        elicitingQuestion_type: {}
                    };
                    reference = ensureQuestionExists(elicitingQuestion, "elicitingQuestion", "always");
                    addReferenceToList(template.questionForm_elicitingQuestions, reference, "elicitingQuestion", "ElicitingQuestionChoice");
                });
            }
            else if (about === "form") {
                var type_1 = item.Type;
                var text_1 = item.Answers[0];
                if (text_1 && text_1 != "") {
                    var fieldInfoFound_1 = false;
                    questionnaireGeneration.formFieldsInfo.forEach(function (fieldInfo) {
                        if (fieldInfo.exportImportID === type_1) {
                            fieldInfoFound_1 = true;
                            template[fieldInfo.tripleStoreFieldID] = text_1;
                            project.tripleStore.addTriple(template.id, fieldInfo.tripleStoreFieldID, text_1);
                        }
                    });
                    if (!fieldInfoFound_1) {
                        alert("ERROR: Unrecognized form field: " + type_1);
                    }
                }
            }
            else if (about === "import") {
                var type = item.Type;
                var text = item.Answers[0];
                if (text && text != "") {
                    if (type === "Scale range") {
                        var answers = item["Answers"];
                        var answerCount_1 = 0;
                        answers.forEach(function (textValue) {
                            var value = parseInt(textValue);
                            if (isNaN(value)) {
                                var word = "minimum";
                                if (answerCount_1 === 1)
                                    word = "maximum";
                                alert('The text you entered for the ' + word + ' scale value ("' + textValue + '") could not be converted to a number.');
                            }
                            if (answerCount_1 === 0) {
                                template.import_minScaleValue = value;
                                project.tripleStore.addTriple(template.id, "questionForm_import_minScaleValue", value);
                            }
                            else {
                                template.import_maxScaleValue = value;
                                project.tripleStore.addTriple(template.id, "questionForm_import_maxScaleValue", value);
                            }
                            answerCount_1 += 1;
                        });
                    }
                    else if (type === "Multi choice single column delimiter") {
                        template.import_multiChoiceDelimiter = text;
                        project.tripleStore.addTriple(template.id, "questionForm_import_multiChoiceDelimiter", text);
                    }
                    else if (type === "Yes no questions yes indicator") {
                        template.import_multiChoiceYesIndicator = text;
                        project.tripleStore.addTriple(template.id, "questionForm_import_multiChoiceYesIndicator", text);
                    }
                    else if (type === "Yes no questions Q-A separator") {
                        template.import_multiChoiceYesQASeparator = text;
                        project.tripleStore.addTriple(template.id, "questionForm_import_multiChoiceYesQASeparator", text);
                    }
                    else if (type === "Yes no questions Q-A ending") {
                        template.import_multiChoiceYesQAEnding = text;
                        project.tripleStore.addTriple(template.id, "questionForm_import_multiChoiceYesQAEnding", text);
                    }
                    else if (type === "Story title column name") {
                        template.import_storyTitleColumnName = text;
                        project.tripleStore.addTriple(template.id, "questionForm_import_storyTitleColumnName", text);
                    }
                    else if (type === "Story text column name") {
                        template.import_storyTextColumnName = text;
                        project.tripleStore.addTriple(template.id, "questionForm_import_storyTextColumnName", text);
                    }
                    else if (type === "Story collection date column name") {
                        template.import_storyCollectionDateColumnName = text;
                        project.tripleStore.addTriple(template.id, "questionForm_import_storyCollectionDateColumnName", text);
                    }
                    else if (type === "Language column name") {
                        template.import_storyFormLanguageColumnName = text;
                        project.tripleStore.addTriple(template.id, "questionForm_import_storyFormLanguageColumnName", text);
                    }
                    else if (type === "Participant ID column name") {
                        template.import_participantIDColumnName = text;
                        project.tripleStore.addTriple(template.id, "questionForm_import_participantIDColumnName", text);
                    }
                    else if (type === "Data columns to ignore") {
                        var answersAsLines = item["Answers"].join("\n");
                        template.import_columnsToIgnore = answersAsLines;
                        project.tripleStore.addTriple(template.id, "questionForm_import_columnsToIgnore", answersAsLines);
                    }
                    else if (type === "Data columns to append to story text") {
                        var columnsToAppend_1 = [];
                        var textsBeforeColumns_1 = [];
                        item["Answers"].forEach(function (answer) {
                            var sections = answer.split("|");
                            if (sections.length > 0) {
                                columnsToAppend_1.push(sections[0]);
                            }
                            if (sections.length > 1) {
                                textsBeforeColumns_1.push(sections[1]);
                            }
                        });
                        var columnsAsLines = columnsToAppend_1.join("\n");
                        template.import_columnsToAppendToStoryText = columnsAsLines;
                        project.tripleStore.addTriple(template.id, "questionForm_import_columnsToAppendToStoryText", columnsAsLines);
                        var textsAsLines = textsBeforeColumns_1.join("\n");
                        template.import_textsToWriteBeforeAppendedColumns = textsAsLines;
                        project.tripleStore.addTriple(template.id, "questionForm_import_textsToWriteBeforeAppendedColumns", textsBeforeColumns_1);
                    }
                    else if (type === "Minimum words to include story") {
                        var minWords = parseInt(text);
                        if (isNaN(minWords)) {
                            alert("The value you entered for the minimum words to include for a story (" + text + ") is not a number. It must be a number.");
                            template.import_minWordsToIncludeStory = "0";
                            project.tripleStore.addTriple(template.id, "questionForm_import_minWordsToIncludeStory", "0");
                        }
                        else {
                            template.import_minWordsToIncludeStory = text;
                            project.tripleStore.addTriple(template.id, "questionForm_import_minWordsToIncludeStory", text);
                        }
                    }
                    else if (type === "Texts to remove from column headers") {
                        var answersAsLines = item["Answers"].join("\n");
                        template.import_stringsToRemoveFromHeaders = answersAsLines;
                        project.tripleStore.addTriple(template.id, "questionForm_import_stringsToRemoveFromHeaders", answersAsLines);
                    }
                }
            }
            else if (about === "ignore") {
                // Ignore value so do nothing
            }
            else {
                console.log("Error: unexpected About type of ", about);
            }
        };
        for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {
            _loop_4(itemIndex);
        }
        m.redraw();
        toaster.toast("Finished reading story form: " + shortName);
        toaster.toast("Updating server in progress in background");
        function addReferenceToList(listIdentifier, reference, fieldName, className) {
            var order = questionTypeCounts[fieldName];
            if (!order) {
                order = 0;
            }
            order = order + 1;
            questionTypeCounts[fieldName] = order;
            var choice = { order: order };
            choice[fieldName] = reference;
            project.tripleStore.makeNewSetItem(listIdentifier, className, choice);
        }
    }
    //------------------------------------------------------------------------------------------------------------------------------------------
    // support functions for reading story form
    //------------------------------------------------------------------------------------------------------------------------------------------
    function ensureQuestionExists(question, questionCategory, overrideOption) {
        var matchingQuestion = existingQuestionThatMatchesNewQuestion(question, questionCategory);
        if (!matchingQuestion) {
            project.addQuestionForCategory(question, questionCategory);
            return question[questionCategory + "_shortName"];
        }
        else {
            switch (overrideOption) {
                case "always": // will fall through to next
                case "ask all":// if ask all, would not be here if they didn't say to override
                    project.deleteQuestionInCategory(matchingQuestion, questionCategory);
                    project.addQuestionForCategory(question, questionCategory);
                    return question[questionCategory + "_shortName"];
                case "ask each":
                    var message = 'A question with the name "' + matchingQuestion[questionCategory + "_shortName"]
                        + '" already exists. Do you want to overwrite it? Click OK to ovewrite the existing question. Click Cancel to keep the existing question.';
                    if (confirm(message)) {
                        project.deleteQuestionInCategory(matchingQuestion, questionCategory);
                        project.addQuestionForCategory(question, questionCategory);
                        return question[questionCategory + "_shortName"];
                    }
                    else {
                        return matchingQuestion[questionCategory + "_shortName"];
                    }
                case "never":
                    return matchingQuestion[questionCategory + "_shortName"];
                case "stop":
                    throw Error("ERROR: Should not be checking questions if user asked to stop importing.");
                default:
                    throw Error("ERROR: No override option chosen.");
            }
        }
    }
    function existingQuestionThatMatchesNewQuestion(question, questionCategory) {
        var idAccessor = questionCategory + "_shortName";
        var existingQuestionsInCategory = project.questionsForCategory(questionCategory);
        for (var i = 0; i < existingQuestionsInCategory.length; i++) {
            var existingQuestion = existingQuestionsInCategory[i];
            if (existingQuestion[idAccessor] === question[idAccessor]) {
                return existingQuestion;
            }
        }
        return null;
    }
    function questionForItem(item, questionCategory) {
        var valueType = "string";
        var questionType = "text";
        var valueOptions;
        var optionImageLinks;
        var import_answerNames;
        var import_minScaleValue = "";
        var import_maxScaleValue = "";
        var itemType = item["Type"].trim();
        var answers = item["Answers"];
        var maxNumAnswers = undefined;
        var writeInTextBoxLabel = "";
        var writeInTextsAreInSeparateColumn = "";
        var listBoxRows = undefined;
        var textBoxLength = undefined;
        var optionImagesWidth = undefined;
        var optionsString = item["Options"] || "";
        if (optionsString) {
            var optionParts = optionsString.split("|");
            optionParts.forEach(function (part) {
                if (part.indexOf("maxNumAnswers=") >= 0) {
                    maxNumAnswers = stringBeyond(part, "maxNumAnswers=");
                    if (maxNumAnswers && isNaN(maxNumAnswers)) {
                        alert('Import error: For the Multiple choice question "' + item["Short name"] + '," the maximum number of answers ("' + maxNumAnswers + '") is not a number.');
                        maxNumAnswers = "";
                    }
                }
                else if (part.indexOf("writeInTextBoxLabel=") >= 0) {
                    writeInTextBoxLabel = stringBeyond(part, "writeInTextBoxLabel=");
                }
                else if (part.indexOf("writeInTextsAreInSeparateColumn=") >= 0) {
                    writeInTextsAreInSeparateColumn = stringBeyond(part, "writeInTextsAreInSeparateColumn=").toLowerCase();
                    if (["yes", "no"].indexOf(writeInTextsAreInSeparateColumn) < 0) {
                        alert('Import error: For the question "' + item["Short name"] + '," the option writeInTextsAreInSeparateColumn ("' + writeInTextsAreInSeparateColumn + '") must have the value "yes" or "no."');
                        writeInTextsAreInSeparateColumn = "";
                    }
                }
                else if (part.indexOf("textBoxLength=") >= 0) {
                    textBoxLength = stringBeyond(part, "textBoxLength=");
                    if (textBoxLength && isNaN(textBoxLength)) {
                        alert('Import error: For the text question "' + item["Short name"] + '," the text box length ("' + textBoxLength + '") is not a number.');
                        textBoxLength = "";
                    }
                }
                else if (part.indexOf("listBoxRows=") >= 0) {
                    listBoxRows = stringBeyond(part, "listBoxRows=");
                    if (listBoxRows && isNaN(listBoxRows)) {
                        alert('Import error: For the Multiple choice question "' + item["Short name"] + '," the number of list box rows ("' + listBoxRows + '") is not a number.');
                        listBoxRows = "";
                    }
                }
                else if (part.indexOf("optionImagesWidth=") >= 0) {
                    optionImagesWidth = stringBeyond(part, "optionImagesWidth=");
                    if (optionImagesWidth && isNaN(optionImagesWidth)) {
                        alert('Import error: For the Multiple choice question "' + item["Short name"] + '," the option image width ("' + optionImagesWidth + '") is not a number.');
                        optionImagesWidth = "";
                    }
                }
            });
        }
        // legacy - old name for "Multi-choice multi-column texts" was "Multiple choice"
        if (itemType === "Multiple choice") {
            itemType = "Multi-choice multi-column texts";
        }
        if (["Single choice", "Single choice indexed"].indexOf(itemType) >= 0) {
            questionType = "select";
            var valueAndImportOptions = valueAndImportOptionsForAnswers(answers);
            valueOptions = valueAndImportOptions[0];
            import_answerNames = valueAndImportOptions[1];
            if (!answers || answers.length < 2) {
                alert('Import error: For the Single choice question "' + item["Short name"] + '", there must be at least two entries in the Answers columns.');
            }
        }
        else if (["Multi-choice multi-column texts", "Multi-choice multi-column yes/no", "Multi-choice single-column delimited", "Multi-choice single-column delimited indexed"].indexOf(itemType) >= 0) {
            questionType = "checkboxes";
            var valueAndImportOptions = valueAndImportOptionsForAnswers(answers);
            valueOptions = valueAndImportOptions[0];
            import_answerNames = valueAndImportOptions[1];
            optionImageLinks = valueAndImportOptions[2];
            if (!answers || answers.length < 2) {
                alert('Import error: For the Multiple choice question "' + item["Short name"] + '", there must be at least two entries in the Answers columns.');
            }
        }
        else if (itemType === "Radiobuttons") {
            questionType = "radiobuttons";
            var valueAndImportOptions = valueAndImportOptionsForAnswers(answers);
            valueOptions = valueAndImportOptions[0];
            import_answerNames = valueAndImportOptions[1];
            optionImageLinks = valueAndImportOptions[2];
            if (!answers || answers.length < 2) {
                alert('Import error: For the Radiobuttons question "' + item["Short name"] + '", there must be at least two entries in the Answers columns.');
            }
        }
        else if (itemType === "Boolean") {
            questionType = "boolean";
        }
        else if (itemType === "Checkbox") {
            questionType = "checkbox";
            valueOptions = answers;
        }
        else if (itemType === "Text") {
            questionType = "text";
        }
        else if (itemType === "Textarea") {
            questionType = "textarea";
        }
        else if (itemType === "Scale") {
            valueType = "number";
            questionType = "slider";
            if (!answers || answers.length < 2) {
                alert('Import error: For the Slider question "' + item["Short name"] + '", there must be two labels (for the left and right of the slider) in the Answers columns.');
                valueOptions = ["", ""]; // put in empty slider labels so that the graphs will at least draw 
            }
            else {
                valueOptions = [answers[0], answers[1]];
            }
            if (answers && answers.length > 2) {
                valueOptions.push(answers[2]); // this could be the "does not apply" label for the slider
            }
            if (answers && answers.length > 3) {
                var answerCount_2 = 0;
                var minAndMax = answers.slice(2);
                minAndMax.forEach(function (textValue) {
                    var value = parseInt(textValue);
                    if (isNaN(value)) {
                        var word = "minimum";
                        if (answerCount_2 === 1)
                            word = "maximum";
                        alert('The text you entered for the ' + word + ' scale value ("' + textValue + '") for the question "' + item["Short name"] + '" could not be converted to a number.');
                    }
                    if (answerCount_2 === 0) {
                        import_minScaleValue = textValue;
                    }
                    else {
                        import_maxScaleValue = textValue;
                    }
                    answerCount_2 += 1;
                });
            }
        }
        else {
            console.log("IMPORT ERROR: unsupported question type: ", itemType);
        }
        var question = {};
        question[questionCategory + "_type"] = questionType;
        question[questionCategory + "_shortName"] = item["Short name"];
        question[questionCategory + "_text"] = item["Long name"];
        if (valueOptions)
            question[questionCategory + "_options"] = valueOptions.join("\n");
        if (optionImageLinks)
            question[questionCategory + "_optionImageLinks"] = optionImageLinks.join("\n");
        if (maxNumAnswers)
            question[questionCategory + "_maxNumAnswers"] = maxNumAnswers;
        if (optionImagesWidth)
            question[questionCategory + "_optionImagesWidth"] = optionImagesWidth;
        if (listBoxRows)
            question[questionCategory + "_listBoxRows"] = listBoxRows;
        if (writeInTextBoxLabel)
            question[questionCategory + "_writeInTextBoxLabel"] = writeInTextBoxLabel;
        if (textBoxLength)
            question[questionCategory + "_textBoxLength"] = textBoxLength;
        question[questionCategory + "_import_columnName"] = item["Data column name"] || item["Short name"];
        question[questionCategory + "_import_valueType"] = itemType;
        question[questionCategory + "_import_writeInTextsAreInSeparateColumn"] = writeInTextsAreInSeparateColumn;
        question[questionCategory + "_import_minScaleValue"] = import_minScaleValue;
        question[questionCategory + "_import_maxScaleValue"] = import_maxScaleValue;
        if (import_answerNames)
            question[questionCategory + "_import_answerNames"] = import_answerNames.join("\n");
        return question;
    }
    function valueAndImportOptionsForAnswers(answers) {
        var valueOptions = [];
        var import_answerNames = [];
        var optionImageLinks = [];
        if (answers) {
            for (var i = 0; i < answers.length; i++) {
                var splitAnswersString = answers[i].split("|");
                if (splitAnswersString.length > 2) {
                    import_answerNames.push(splitAnswersString[0]);
                    valueOptions.push(splitAnswersString[1]);
                    optionImageLinks.push(splitAnswersString[2]);
                }
                else if (splitAnswersString.length > 1) {
                    import_answerNames.push(splitAnswersString[0]);
                    valueOptions.push(splitAnswersString[1]);
                }
                else {
                    valueOptions.push(answers[i]);
                    import_answerNames.push(answers[i]);
                }
            }
        }
        return [valueOptions, import_answerNames, optionImageLinks];
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // generating story form
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function autoFillStoryForm() {
        var questionnaireName = prompt("Please enter a short name for the new story form.");
        if (!questionnaireName)
            return;
        if (questionnaireGeneration.buildStoryForm(questionnaireName)) {
            alert('A story form already exists with that name: "' + questionnaireName + '"');
            return;
        }
        var storyFormListIdentifier = project.getFieldValue("project_storyForms");
        if (!storyFormListIdentifier) {
            storyFormListIdentifier = project.tripleStore.newIdForSet("StoryFormSet");
            project.setFieldValue("project_storyForms", storyFormListIdentifier);
        }
        var template = {
            id: generateRandomUuid("StoryForm"),
            questionForm_shortName: questionnaireName,
            questionForm_elicitingQuestions: project.tripleStore.newIdForSet("ElicitingQuestionChoiceSet"),
            questionForm_storyQuestions: project.tripleStore.newIdForSet("StoryQuestionChoiceSet"),
            questionForm_participantQuestions: project.tripleStore.newIdForSet("ParticipantQuestionChoiceSet")
        };
        project.tripleStore.makeNewSetItem(storyFormListIdentifier, "StoryForm", template);
        var questionTypeCounts = {};
        var question;
        var questionIndex;
        var elicitingQuestions = project.collectAllElicitingQuestions();
        for (questionIndex in elicitingQuestions) {
            question = elicitingQuestions[questionIndex];
            addReferenceToList(template.questionForm_elicitingQuestions, question.elicitingQuestion_shortName, "elicitingQuestion", "ElicitingQuestionChoice");
        }
        var storyQuestions = project.collectAllStoryQuestions();
        for (questionIndex in storyQuestions) {
            question = storyQuestions[questionIndex];
            addReferenceToList(template.questionForm_storyQuestions, question.storyQuestion_shortName, "storyQuestion", "StoryQuestionChoice");
        }
        var participantQuestions = project.collectAllParticipantQuestions();
        for (questionIndex in participantQuestions) {
            question = participantQuestions[questionIndex];
            addReferenceToList(template.questionForm_participantQuestions, question.participantQuestion_shortName, "participantQuestion", "ParticipantQuestionChoice");
        }
        m.redraw();
        toaster.toast("Finished generating story form \"" + questionnaireName + "\" from available questions.");
        function addReferenceToList(listIdentifier, reference, fieldName, className) {
            var order = questionTypeCounts[fieldName];
            if (!order) {
                order = 0;
            }
            order = order + 1;
            questionTypeCounts[fieldName] = order;
            var choice = {
                order: order
            };
            choice[fieldName] = reference;
            project.tripleStore.makeNewSetItem(listIdentifier, className, choice);
        }
    }
    exports.autoFillStoryForm = autoFillStoryForm;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // exporting story form
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function exportQuestionnaire(questionnaire) {
        if (questionnaire === void 0) { questionnaire = null; }
        var nameToSave = "";
        if (!questionnaire || typeof questionnaire === "string") {
            var storyCollectionName = Globals.clientState().storyCollectionName();
            if (!storyCollectionName) {
                alert("Please select a story collection first.");
                return;
            }
            nameToSave = storyCollectionName;
            questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName);
            if (!questionnaire) {
                alert("The story collection has not been initialized with a story form: " + storyCollectionName);
                return;
            }
        }
        else {
            nameToSave = questionnaire.shortName;
        }
        var output = "";
        var lineIndex = 1;
        var delimiter = Globals.clientState().csvDelimiter();
        function addOutputLine(line) { output = addCSVOutputLine(output, line, delimiter); }
        var header = ["Data column name", "Type", "About", "Short name", "Long name", "Options", "Answers"];
        addOutputLine(header);
        var elicitingLine = ["Eliciting question", "eliciting", "eliciting", "Eliciting question", "Eliciting question", ""];
        questionnaire.elicitingQuestions.forEach(function (elicitingQuestionSpecification) {
            elicitingLine.push(elicitingQuestionSpecification.id + "|" + elicitingQuestionSpecification.text);
        });
        addOutputLine(elicitingLine);
        function outputQuestions(questions, about) {
            var _loop_5 = function (i) {
                var outputLine = [];
                var question = questions[i];
                outputLine.push(question.displayName || ""); // short name is also data column name for export
                var questionType = exportQuestionTypeMap[question.displayType];
                if (!questionType) {
                    console.log("EXPORT ERROR: unsupported question type: ", question.displayType);
                    questionType = "UNSUPPORTED:" + question.displayType;
                }
                outputLine.push(questionType);
                outputLine.push(about);
                outputLine.push(question.displayName || "");
                outputLine.push(question.displayPrompt || "");
                var options = [];
                if (question.maxNumAnswers) {
                    options.push("maxNumAnswers=" + question.maxNumAnswers);
                }
                if (question.writeInTextBoxLabel) {
                    options.push("writeInTextBoxLabel=" + question.writeInTextBoxLabel);
                }
                if (question.listBoxRows) {
                    options.push("listBoxRows=" + question.listBoxRows);
                }
                if (question.textBoxLength) {
                    options.push("textBoxLength=" + question.textBoxLength);
                }
                if (question.optionImagesWidth) {
                    options.push("optionImagesWidth=" + question.optionImagesWidth);
                }
                outputLine.push(options.join("|"));
                if (question.displayType === "slider") {
                    if (question.displayConfiguration) {
                        if (question.displayConfiguration.length === 1) {
                            outputLine.push(question.displayConfiguration);
                        }
                        else if (question.displayConfiguration.length > 1) {
                            question.displayConfiguration.forEach(function (option) {
                                outputLine.push(option);
                            });
                        }
                    }
                }
                else {
                    if (question.valueOptions) {
                        question.valueOptions.forEach(function (option) {
                            outputLine.push(option);
                        });
                    }
                }
                addOutputLine(outputLine);
            };
            for (var i = 0; i < questions.length; i++) {
                _loop_5(i);
            }
        }
        outputQuestions(questionnaire.storyQuestions, "story");
        outputQuestions(questionnaire.participantQuestions, "participant");
        var annotationQuestions = project.collectAllAnnotationQuestions();
        var adjustedAnnotationQuestions = questionnaireGeneration.convertEditorQuestions(annotationQuestions, "A_");
        outputQuestions(adjustedAnnotationQuestions, "annotation");
        questionnaireGeneration.formFieldsInfo.forEach(function (fieldInfo) {
            if (fieldInfo.exportImportID) {
                addOutputLine(["", fieldInfo.exportImportID, "form", "", "", "", questionnaire[fieldInfo.objectFieldID] || ""]);
            }
        });
        // do not need to write "Scale range" because scale data was converted to 0-100 scale during import
        // do not need to write "Yes no questions Q-A separator" or "Yes no questions Q-A ending" or "Yes no questions yes indicator" or "Multi choice single column delimiter"
        // because only the original multi-choice format is used (Multi-choice multi-column texts) for which there are no import options
        // do not need to write "Story title column name" or "Story text column name" or "Eliciting question column name" or "Participant ID column name"
        // because the default (non specified) options will work for all of these things
        var questionnaireBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
        // TODO: This seems to clear the console in FireFox 40; why?
        saveAs(questionnaireBlob, "export_story_form_" + nameToSave + ".csv");
    }
    exports.exportQuestionnaire = exportQuestionnaire;
    var exportQuestionTypeMap = {
        "select": "Single choice",
        "slider": "Scale",
        "checkboxes": "Multi-choice multi-column texts",
        "radiobuttons": "Radiobuttons",
        "boolean": "Boolean",
        "checkbox": "Checkbox",
        "text": "Text",
        "textarea": "Textarea"
    };
    function addCSVOutputLine(output, line, delimiter) {
        var start = true;
        if (!delimiter)
            delimiter = ",";
        line.forEach(function (item) {
            var itemToSave = "";
            if (start) {
                start = false;
            }
            else {
                output += delimiter;
            }
            if (item === undefined) {
                itemToSave = "";
            }
            else if (typeof item == 'number') {
                itemToSave = "" + item;
            }
            else if (typeof item == "boolean") {
                itemToSave = item ? "true" : "false";
            }
            else {
                itemToSave = item;
            }
            if (itemToSave.indexOf(delimiter) !== -1) {
                itemToSave = itemToSave.replace(/"/g, '""');
                itemToSave = '"' + itemToSave + '"';
            }
            if (itemToSave.indexOf("\n") !== -1) {
                itemToSave = itemToSave.replace(/"/g, '""');
                itemToSave = '"' + itemToSave + '"';
            }
            output += itemToSave;
        });
        output += "\n";
        return output;
    }
    exports.addCSVOutputLine = addCSVOutputLine;
    function exportQuestionnaireForImport(questionnaire) {
        if (questionnaire === void 0) { questionnaire = null; }
        var nameToSave = "";
        if (!questionnaire || typeof questionnaire === "string") {
            var storyCollectionName = Globals.clientState().storyCollectionName();
            if (!storyCollectionName) {
                alert("Please select a story collection first.");
                return;
            }
            nameToSave = storyCollectionName;
            questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName);
            if (!questionnaire) {
                alert("The story collection has not been initialized with a story form: " + storyCollectionName);
                return;
            }
        }
        else {
            nameToSave = questionnaire.shortName;
        }
        var output = "";
        var lineIndex = 1;
        var delimiter = Globals.clientState().csvDelimiter();
        function addOutputLine(line) { output = addCSVOutputLine(output, line, delimiter); }
        var header = ["Data column name", "Type", "About", "Short name", "Long name", "Options", "Answers"];
        addOutputLine(header);
        if (questionnaire.import_elicitingQuestionColumnName) {
            var elicitingLine_1 = [
                questionnaire.import_elicitingQuestionColumnName, "eliciting", "eliciting",
                questionnaire.import_elicitingQuestionGraphName || "",
                questionnaire.chooseQuestionText,
                ""
            ]; // empty column for "Options" field
            questionnaire.elicitingQuestions.forEach(function (question) {
                elicitingLine_1.push(question.importName || question.id + "|" + question.id + "|" + question.text);
            });
            addOutputLine(elicitingLine_1);
        }
        function outputQuestions(questions, about) {
            var _loop_6 = function (i) {
                var outputLine = [];
                var question = questions[i];
                outputLine.push(question.import_columnName || "");
                outputLine.push(question.import_valueType || "");
                outputLine.push(about || "");
                outputLine.push(question.displayName || "");
                outputLine.push(question.displayPrompt || "");
                var questionOptions = [];
                if (question.maxNumAnswers) {
                    questionOptions.push("maxNumAnswers=" + question.maxNumAnswers);
                }
                if (question.writeInTextBoxLabel) {
                    questionOptions.push("writeInTextBoxLabel=" + question.writeInTextBoxLabel);
                }
                if (question.listBoxRows) {
                    questionOptions.push("listBoxRows=" + question.listBoxRows);
                }
                if (question.textBoxLength) {
                    questionOptions.push("textBoxLength=" + question.textBoxLength);
                }
                if (question.optionImagesWidth) {
                    questionOptions.push("optionImagesWidth=" + question.optionImagesWidth);
                }
                if (question.import_writeInTextsAreInSeparateColumn) {
                    questionOptions.push("writeInTextsAreInSeparateColumn=" + question.writeInTextsAreInSeparateColumn);
                }
                outputLine.push(questionOptions.join("|"));
                // answers
                if (question.displayType === "slider") {
                    if (question.displayConfiguration) {
                        if (question.displayConfiguration.length === 1) {
                            outputLine.push(question.displayConfiguration);
                        }
                        else if (question.displayConfiguration.length > 1) {
                            question.displayConfiguration.forEach(function (option) {
                                outputLine.push(option);
                            });
                        }
                        if (question.import_minScaleValue != undefined) {
                            outputLine.push("" + question.import_minScaleValue);
                        }
                        if (question.import_maxScaleValue != undefined) {
                            outputLine.push("" + question.import_maxScaleValue);
                        }
                    }
                }
                else {
                    if (question.valueOptions) {
                        for (var j = 0; j < question.valueOptions.length; j++) {
                            var cellValue = "";
                            if (question.import_answerNames && j < question.import_answerNames.length) {
                                cellValue += question.import_answerNames[j] + "|";
                            }
                            cellValue += question.valueOptions[j];
                            outputLine.push(cellValue);
                        }
                    }
                }
                addOutputLine(outputLine);
            };
            for (var i = 0; i < questions.length; i++) {
                _loop_6(i);
            }
        }
        outputQuestions(questionnaire.storyQuestions, "story");
        outputQuestions(questionnaire.participantQuestions, "participant");
        questionnaireGeneration.formFieldsInfo.forEach(function (fieldInfo) {
            if (fieldInfo.exportImportID && fieldInfo.objectFieldID && questionnaire[fieldInfo.objectFieldID]) {
                addOutputLine(["", fieldInfo.exportImportID, "form", "", "", "", questionnaire[fieldInfo.objectFieldID] || ""]);
            }
        });
        if (questionnaire.import_minScaleValue || questionnaire.import_maxScaleValue)
            addOutputLine(["", "Scale range", "import", "", "", "", "" + questionnaire.import_minScaleValue || "", "" + questionnaire.import_maxScaleValue || ""]);
        if (questionnaire.import_multiChoiceYesQASeparator)
            addOutputLine(["", "Yes no questions Q-A separator", "import", "", "", "", questionnaire.import_multiChoiceYesQASeparator || ""]);
        if (questionnaire.import_multiChoiceYesQAEnding)
            addOutputLine(["", "Yes no questions Q-A ending", "import", "", "", "", questionnaire.import_multiChoiceYesQAEnding || ""]);
        if (questionnaire.import_multiChoiceYesIndicator)
            addOutputLine(["", "Yes no questions yes indicator", "import", "", "", "", questionnaire.import_multiChoiceYesIndicator || ""]);
        if (questionnaire.import_multiChoiceDelimiter)
            addOutputLine(["", "Multi choice single column delimiter", "import", "", "", "", questionnaire.import_multiChoiceDelimiter || ""]);
        if (questionnaire.import_storyTitleColumnName)
            addOutputLine(["", "Story title column name", "import", "", "", "", questionnaire.import_storyTitleColumnName || ""]);
        if (questionnaire.import_storyTextColumnName)
            addOutputLine(["", "Story text column name", "import", "", "", "", questionnaire.import_storyTextColumnName || ""]);
        if (questionnaire.import_storyCollectionDateColumnName)
            addOutputLine(["", "Story text column name", "import", "", "", "", questionnaire.import_storyCollectionDateColumnName || ""]);
        if (questionnaire.import_participantIDColumnName)
            addOutputLine(["", "Participant ID column name", "import", "", "", "", questionnaire.import_participantIDColumnName || ""]);
        if (questionnaire.import_minWordsToIncludeStory)
            addOutputLine(["", "Minimum words to include story", "import", "", "", "", questionnaire.import_minWordsToIncludeStory || ""]);
        if (questionnaire.import_stringsToRemoveFromHeaders) {
            var textsToRemoveOutputLine_1 = ["", "Texts to remove from column headers", "import", "", "", ""];
            var textsList = questionnaire.import_stringsToRemoveFromHeaders.split("\n");
            if (textsList) {
                textsList.forEach(function (item) {
                    textsToRemoveOutputLine_1.push(item);
                });
            }
            addOutputLine(textsToRemoveOutputLine_1);
        }
        if (questionnaire.import_columnsToIgnore) {
            var columnsToIgnoreOutputLine_1 = ["", "Data columns to ignore", "import", "", "", ""];
            var columnList = questionnaire.import_columnsToIgnore.split("\n");
            if (columnList) {
                columnList.forEach(function (item) {
                    columnsToIgnoreOutputLine_1.push(item);
                });
            }
            addOutputLine(columnsToIgnoreOutputLine_1);
        }
        if (questionnaire.import_columnsToAppendToStoryText) {
            var columnsToAppendOutputLine = ["", "Data columns to append to story text", "import", "", "", ""];
            var columnsToAppend = questionnaire.import_columnsToAppendToStoryText.split("\n");
            if (columnsToAppend) {
                var textsBeforeColumns = [];
                if (questionnaire.import_textsToWriteBeforeAppendedColumns) {
                    if (typeof questionnaire.import_textsToWriteBeforeAppendedColumns === "string") {
                        textsBeforeColumns = questionnaire.import_textsToWriteBeforeAppendedColumns.split("\n");
                    }
                    else {
                        textsBeforeColumns = questionnaire.import_textsToWriteBeforeAppendedColumns;
                    }
                }
                for (var i = 0; i < columnsToAppend.length; i++) {
                    var textToWrite = columnsToAppend[i];
                    if (textsBeforeColumns) {
                        textToWrite += "|" + textsBeforeColumns[i];
                    }
                    columnsToAppendOutputLine.push(textToWrite);
                }
            }
            addOutputLine(columnsToAppendOutputLine);
        }
        var questionnaireBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
        // TODO: This seems to clear the console in FireFox 40; why?
        saveAs(questionnaireBlob, "export_story_form_for_import_" + nameToSave + ".csv");
    }
    exports.exportQuestionnaireForImport = exportQuestionnaireForImport;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // exporting and importing story form translation dictionaries
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function exportTranslationDictionary(questionnaire) {
        if (questionnaire === void 0) { questionnaire = null; }
        var nameToSave = "";
        if (!questionnaire || typeof questionnaire === "string") {
            var storyCollectionName = Globals.clientState().storyCollectionName();
            if (!storyCollectionName) {
                alert("Please select a story collection first.");
                return;
            }
            nameToSave = storyCollectionName;
            questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName);
            if (!questionnaire) {
                alert("The story collection has not been initialized with a story form: " + storyCollectionName);
                return;
            }
        }
        else {
            nameToSave = questionnaire.shortName;
        }
        if (!questionnaire.defaultLanguage) {
            alert("Please enter a default language before you export the translation dictionary.");
            return;
        }
        if (!questionnaire.languageChoiceQuestion_choices) {
            alert("Please enter some additional language names before you export the translation dictionary.");
            return;
        }
        var output = "";
        var lineIndex = 1;
        var delimiter = Globals.clientState().csvDelimiter();
        function addOutputLine(line) {
            output = addCSVOutputLine(output, line, delimiter);
        }
        function addOutputLineWithTranslations(text) {
            var parts = [];
            parts.push(lineIndex);
            parts.push(text || "");
            if (questionnaire.translationDictionary[text]) {
                additionalLanguages.forEach(function (language) { parts.push(questionnaire.translationDictionary[text][language] || ""); });
            }
            addOutputLine(parts);
            lineIndex++;
        }
        var header = ["Order in survey"];
        var additionalLanguages = questionnaire.languageChoiceQuestion_choices.split("\n").map(function (item) { return item.trim(); });
        header = header.concat(["Default language: " + questionnaire.defaultLanguage], additionalLanguages);
        addOutputLine(header);
        var instructionsLine = ["; Do not edit the default-language texts in this file. Only change the translated texts (to the right of the default-language texts)."];
        addOutputLine(instructionsLine);
        questionnaireGeneration.formFieldsInfo.forEach(function (fieldInfo) {
            if (fieldInfo.canBeTranslated) {
                addOutputLineWithTranslations(questionnaire[fieldInfo.objectFieldID] || surveyBuilderMithril.defaultFormTexts[fieldInfo.objectFieldID] || "");
            }
        });
        questionnaire.elicitingQuestions.forEach(function (elicitingQuestionSpecification) {
            addOutputLineWithTranslations(elicitingQuestionSpecification.text);
        });
        [questionnaire.storyQuestions, questionnaire.participantQuestions].forEach(function (questionList) {
            questionList.forEach(function (question) {
                addOutputLineWithTranslations(question.displayPrompt);
                if (question.displayType === "slider") {
                    question.displayConfiguration.forEach(function (option, index) { addOutputLineWithTranslations(option); });
                }
                else if (question.valueOptions) {
                    question.valueOptions.forEach(function (option, index) { addOutputLineWithTranslations(option); });
                }
            });
        });
        var questionnaireBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
        saveAs(questionnaireBlob, "export_translation_dictionary_" + nameToSave + ".csv");
    }
    exports.exportTranslationDictionary = exportTranslationDictionary;
    function processCSVContentsForTranslationDictionary(contents, saveStories, writeLog, questionnaire) {
        if (questionnaire === void 0) { questionnaire = null; }
        if (!questionnaire)
            return;
        var delimiter = Globals.clientState().csvDelimiter();
        var csv = d3.dsv(delimiter, "text/plain");
        var rows = csv.parseRows(contents);
        var dictionarySetID = project.tripleStore.queryLatestC(questionnaire.id, "questionForm_translationDictionary");
        if (!dictionarySetID) {
            dictionarySetID = project.tripleStore.newIdForSet("TranslationDictionarySet");
            project.tripleStore.addTriple(questionnaire.id, "questionForm_translationDictionary", dictionarySetID);
        }
        var alternativeLanguageNames = [];
        var numLanguageEntriesAdded = 0;
        var numNewDictionariesCreated = 0;
        var _loop_7 = function (rowIndex) {
            var row = rows[rowIndex];
            if (row.length < 3)
                return "continue";
            if (row[0][0] === ";")
                return "continue";
            if (row[0] === "")
                return "continue";
            if (rowIndex === 0) {
                // "Order" | Default language | Alternative language | Alternative language | Alternative language
                for (var columnIndex = 2; columnIndex < row.length; columnIndex++) {
                    alternativeLanguageNames.push(row[columnIndex]);
                }
            }
            else {
                // "Order" | Default language text | Alternative language text | Alternative language text | Alternative language text
                var defaultLanguageText_1 = row[1];
                if (defaultLanguageText_1) {
                    var _loop_8 = function (columnIndex) {
                        var value = row[columnIndex];
                        if (value) {
                            var languageName_1 = alternativeLanguageNames[columnIndex - 2];
                            var foundMatchingDictionary_1 = false;
                            var dictionaryIDs = project.tripleStore.getListForSetIdentifier(dictionarySetID);
                            dictionaryIDs.forEach(function (id) {
                                var storedDictionary = project.tripleStore.makeObject(id, true);
                                if (storedDictionary.defaultText === defaultLanguageText_1) {
                                    foundMatchingDictionary_1 = true;
                                    if (storedDictionary[languageName_1] !== value) {
                                        project.tripleStore.addTriple(id, languageName_1, value);
                                        numLanguageEntriesAdded++;
                                    }
                                }
                            });
                            if (!foundMatchingDictionary_1) {
                                var template = { "defaultText": defaultLanguageText_1 };
                                template[languageName_1] = value;
                                project.tripleStore.makeNewSetItem(dictionarySetID, "TranslationDictionary", template);
                                numNewDictionariesCreated++;
                            }
                        }
                    };
                    for (var columnIndex = 2; columnIndex < row.length; columnIndex++) {
                        _loop_8(columnIndex);
                    }
                }
            }
        };
        for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            _loop_7(rowIndex);
        }
        project.tripleStore.addTriple(questionnaire.id, "languageChoiceQuestion_choices", alternativeLanguageNames.join("\n"));
        var prompt;
        if (numLanguageEntriesAdded == 0 && numNewDictionariesCreated == 0) {
            prompt = "The imported translation dictionary matches the currently stored dictionary. No changes were made.";
        }
        else {
            prompt = "Import complete. New entries added: " + numNewDictionariesCreated + ". Language fields added or updated: " + numLanguageEntriesAdded + ".";
        }
        alert(prompt);
        m.redraw();
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // exporting stories
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function exportStoryCollection() {
        var storyCollectionName = Globals.clientState().storyCollectionName();
        if (!storyCollectionName) {
            alert("Please select a story collection first");
            return;
        }
        var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName);
        if (!questionnaire) {
            alert("The story collection has not been initialized with a story form: " + storyCollectionName);
            return;
        }
        var allStories = surveyCollection.getStoriesForStoryCollection(storyCollectionName, true);
        var header1 = [];
        var header2 = [];
        function header(contents, secondHeader) {
            if (secondHeader === void 0) { secondHeader = ""; }
            header1.push(contents);
            header2.push(secondHeader);
        }
        // Put initial header
        header("Story title", ";"); // use semicolon to make second line a comment
        header("Story text");
        header("Collection date");
        header("Language");
        header("Eliciting question");
        function headersForQuestions(questions) {
            var _loop_9 = function (i) {
                var question = questions[i];
                // TODO: Maybe should export ID instead? Or more header lines with ID and prompt?
                if (question.valueOptions && question.displayType === "checkboxes") {
                    question.valueOptions.forEach(function (option) {
                        header(question.displayName, option);
                    });
                }
                else {
                    header(question.displayName);
                }
                if (question.writeInTextBoxLabel) {
                    header("WRITEIN_" + question.displayName);
                }
            };
            for (var i = 0; i < questions.length; i++) {
                _loop_9(i);
            }
        }
        headersForQuestions(questionnaire.storyQuestions);
        headersForQuestions(questionnaire.participantQuestions);
        var annotationQuestions = project.collectAllAnnotationQuestions();
        var adjustedAnnotationQuestions = questionnaireGeneration.convertEditorQuestions(annotationQuestions, "A_");
        headersForQuestions(adjustedAnnotationQuestions);
        var output = "";
        var delimiter = Globals.clientState().csvDelimiter();
        function addOutputLine(line) { output = addCSVOutputLine(output, line, delimiter); }
        addOutputLine(header1);
        addOutputLine(header2);
        function dataForQuestions(questions, story, outputLine) {
            var _loop_10 = function (i) {
                var question = questions[i];
                var value = story.fieldValue(question.id);
                if (value === undefined || value === null)
                    value = "";
                if (question.valueOptions && question.displayType === "checkboxes") {
                    question.valueOptions.forEach(function (option) {
                        outputLine.push(value[option] ? option : "");
                    });
                }
                else {
                    // deal with pathological case where object data exists for select question (it should not)
                    // this could happen if user changed checkboxes question to select question after adding data
                    // there should be only one true value in the dictionary, so find it, then output that key
                    if (question.displayType === "select" && typeof value === "object") {
                        var keys = Object.keys(value);
                        for (var keyIndex = 0; keyIndex < keys.length; keyIndex++) {
                            var thisKey = keys[keyIndex];
                            var thisValue = value[thisKey];
                            if (thisValue) {
                                outputLine.push(thisKey);
                                console.log("WARNING: Found multi-choice answer for single-choice question. Writing first answer marked true.", value, question);
                                break;
                            }
                        }
                    }
                    else {
                        outputLine.push(value);
                    }
                }
                if (question.writeInTextBoxLabel) {
                    var writeInValue = story.fieldValueWriteIn(question.id);
                    outputLine.push(writeInValue ? writeInValue : "");
                }
            };
            for (var i = 0; i < questions.length; i++) {
                _loop_10(i);
            }
        }
        allStories.forEach(function (story) {
            var outputLine = [];
            outputLine.push(story.storyName());
            // if story text has newline or carriage return characters, enclose it in quotes
            var storyText = story.storyText();
            if (storyText.indexOf("\n") >= 0 || storyText.indexOf("\r") >= 0) {
                storyText = '"' + storyText + '"';
            }
            outputLine.push(storyText);
            outputLine.push(story.storyCollectionDate() || "");
            outputLine.push(story.storyLanguage() || "");
            outputLine.push(story.elicitingQuestion());
            dataForQuestions(questionnaire.storyQuestions, story, outputLine);
            dataForQuestions(questionnaire.participantQuestions, story, outputLine);
            dataForQuestions(adjustedAnnotationQuestions, story, outputLine);
            addOutputLine(outputLine);
        });
        var storyCollectionBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
        // TODO: This seems to clear the console in FireFox 40; why?
        saveAs(storyCollectionBlob, "export_story_collection_" + storyCollectionName + ".csv");
    }
    exports.exportStoryCollection = exportStoryCollection;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // exporting and importing catalysis elements
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function exportCatalysisReportElementsToCSV() {
        var output = "";
        var i = 0;
        var delimiter = Globals.clientState().csvDelimiter();
        function addOutputLine(line) { output = addCSVOutputLine(output, line, delimiter); }
        var catalysisReportName = Globals.clientState().catalysisReportName();
        var catalysisReportIdentifier = project.findCatalysisReport(catalysisReportName);
        var catalysisReportObservationSetIdentifier = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_observations");
        if (!catalysisReportObservationSetIdentifier) {
            console.log("catalysisReportObservationSetIdentifier not defined");
            return;
        }
        var observationIDs = project.tripleStore.getListForSetIdentifier(catalysisReportObservationSetIdentifier);
        addOutputLine(["; Export of catalysis elements for catalysis report " + catalysisReportName + " in project " + project.projectNameOrNickname()]);
        addOutputLine([""]);
        addOutputLine(["; Observation", "Name", "Description", "Strength", "Linking question", "Pattern", "Graph type", "Question 1", "Question 2", "Question 3", "Additional patterns", "X", "Y", "Interpretation name|description|idea|questions|x|y", "(repeat for each interpretation)"]);
        var perspectives = [];
        var clusteredInterpretations = [];
        var interpretationsClusteringDiagram = project.tripleStore.queryLatestC(catalysisReportIdentifier, "interpretationsClusteringDiagram");
        if (interpretationsClusteringDiagram)
            _a = ClusteringDiagram.calculateClusteringForDiagram(interpretationsClusteringDiagram), perspectives = _a[0], clusteredInterpretations = _a[1];
        var themes = [];
        var clusteredObservations = [];
        var observationsClusteringDiagram = project.tripleStore.queryLatestC(catalysisReportIdentifier, "observationsClusteringDiagram");
        if (observationsClusteringDiagram)
            _b = ClusteringDiagram.calculateClusteringForDiagram(observationsClusteringDiagram), themes = _b[0], clusteredObservations = _b[1];
        var _loop_11 = function (observationIndex) {
            var observationID = observationIDs[observationIndex];
            var observation = project.tripleStore.makeObject(observationID, true);
            if (observation.observationTitle || observation.observationDescription) {
                var observationLine_1 = [];
                observationLine_1.push("Observation");
                observationLine_1.push(observation.observationTitle || "");
                observationLine_1.push(observation.observationDescription || "");
                observationLine_1.push(observation.observationStrength || "");
                observationLine_1.push(observation.observationLinkingQuestion || "");
                observationLine_1.push(observation.pattern.patternName || "");
                observationLine_1.push(observation.pattern.graphType || "");
                if (observation.pattern.graphType === "data integrity") {
                    observationLine_1.push(observation.pattern.patternName || "");
                    observationLine_1.push("");
                    observationLine_1.push("");
                }
                else {
                    if (observation.pattern.questions.length === 1) {
                        observationLine_1.push(observation.pattern.questions[0].id);
                        observationLine_1.push("");
                        observationLine_1.push("");
                    }
                    else if (observation.pattern.questions.length === 2) {
                        observationLine_1.push(observation.pattern.questions[0].id);
                        observationLine_1.push(observation.pattern.questions[1].id);
                        observationLine_1.push("");
                    }
                    else if (observation.pattern.questions.length === 3) {
                        observationLine_1.push(observation.pattern.questions[0].id);
                        observationLine_1.push(observation.pattern.questions[1].id);
                        observationLine_1.push(observation.pattern.questions[2].id);
                    }
                }
                observationLine_1.push(observation.observationExtraPatterns || "");
                var foundClusteredObservation = null;
                for (var i_1 = 0; i_1 < clusteredObservations.length; i_1++) {
                    if (clusteredObservations[i_1].referenceUUID === observationID) {
                        foundClusteredObservation = clusteredObservations[i_1];
                        break;
                    }
                }
                if (foundClusteredObservation) {
                    observationLine_1.push(foundClusteredObservation.x);
                    observationLine_1.push(foundClusteredObservation.y);
                }
                else {
                    observationLine_1.push("");
                    observationLine_1.push("");
                }
                var interpretationsList = project.tripleStore.getListForSetIdentifier(observation.observationInterpretations);
                interpretationsList.forEach(function (interpretationID) {
                    var interpretation = project.tripleStore.makeObject(interpretationID, true);
                    if (interpretation.interpretation_name || interpretation.interpretation_text) {
                        var interpretationCell = [];
                        interpretationCell.push(interpretation.interpretation_name || "");
                        interpretationCell.push(interpretation.interpretation_text || "");
                        interpretationCell.push(interpretation.interpretation_idea || "");
                        interpretationCell.push(interpretation.interpretation_questions || "");
                        if (clusteredInterpretations.length) {
                            var foundClusteredInterpretation = null;
                            for (var i_2 = 0; i_2 < clusteredInterpretations.length; i_2++) {
                                if (clusteredInterpretations[i_2].referenceUUID === interpretationID) {
                                    foundClusteredInterpretation = clusteredInterpretations[i_2];
                                    break;
                                }
                            }
                            if (foundClusteredInterpretation) {
                                interpretationCell.push(foundClusteredInterpretation.x);
                                interpretationCell.push(foundClusteredInterpretation.y);
                            }
                        }
                        observationLine_1.push(interpretationCell.join("|"));
                    }
                });
                if (observation.observationNote)
                    observationLine_1.push(observationNoteIdentifier + observation.observationNote);
                addOutputLine(observationLine_1);
            }
        };
        for (var observationIndex = 0; observationIndex < observationIDs.length; observationIndex++) {
            _loop_11(observationIndex);
        }
        if (perspectives.length) {
            addOutputLine([""]);
            addOutputLine(["; Perspective", "Name", "Notes", "X", "Y", "Order"]);
            for (var i_3 = 0; i_3 < perspectives.length; i_3++) {
                var perspective = perspectives[i_3];
                addOutputLine(["Perspective", perspective.name || "", perspective.notes || "", perspective.x || "", perspective.y || "", perspective.order || ""]);
            }
        }
        if (themes.length) {
            addOutputLine([""]);
            addOutputLine(["; Theme", "Name", "Notes", "X", "Y", "Order"]);
            for (var i_4 = 0; i_4 < themes.length; i_4++) {
                var theme = themes[i_4];
                addOutputLine(["Theme", theme.name || "", theme.notes || "", theme.x || "", theme.y || "", theme.order || ""]);
            }
        }
        var exportBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
        saveAs(exportBlob, "Catalysis_report_elements_" + catalysisReportName + ".csv");
        var _a, _b;
    }
    exports.exportCatalysisReportElementsToCSV = exportCatalysisReportElementsToCSV;
    function processCSVContentsForCatalysisElements(contents) {
        // there is a general assumption here that the catalysis report is empty (so we do not need to look for existing items for any of these things)
        var numObservationsCreated = 0;
        var numInterpretationsCreated = 0;
        var numPerspectivesCreated = 0;
        var numThemesCreated = 0;
        var numObservationsAlreadyProcessedPerPattern = {};
        var catalysisReportIdentifier = Globals.clientState().catalysisReportIdentifier();
        var observationSetIdentifier = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_observations");
        if (!observationSetIdentifier) {
            observationSetIdentifier = generateRandomUuid("ObservationSet");
            project.tripleStore.addTriple(catalysisReportIdentifier, "catalysisReport_observations", observationSetIdentifier);
        }
        var allQuestions = project.allQuestionsThatCouldBeGraphedForCatalysisReport(catalysisReportIdentifier, false);
        var interpretationsClusteringDiagram = project.tripleStore.queryLatestC(catalysisReportIdentifier, "interpretationsClusteringDiagram");
        if (!interpretationsClusteringDiagram) {
            interpretationsClusteringDiagram = ClusteringDiagram.newDiagramModel();
        }
        var interpretationsClusteringDiagramChanged = false;
        var observationsClusteringDiagram = project.tripleStore.queryLatestC(catalysisReportIdentifier, "observationsClusteringDiagram");
        if (!observationsClusteringDiagram) {
            observationsClusteringDiagram = ClusteringDiagram.newDiagramModel();
        }
        var observationsClusteringDiagramChanged = false;
        var delimiter = Globals.clientState().csvDelimiter();
        var csv = d3.dsv(delimiter, "text/plain");
        var rows = csv.parseRows(contents);
        var _loop_12 = function (rowIndex) {
            var row = rows[rowIndex];
            if (row.length < 2)
                return "continue";
            if (row[0][0] === ";")
                return "continue";
            if (row[0] === "")
                return "continue";
            if (row[0] === "Observation") {
                // addOutputLine(["; Observation", "Name", "Description", "Strength", "Linking question", "Pattern", "Graph type", "Question 1", "Question 2", "Question 3", 
                // "Additional patterns", "X", "Y", "Interpretation name|description|idea|questions|x|y", "(repeat for each interpretation)"]);
                // optional note at the end, prefaced by observationNoteIdentifier
                var observationName = row[1];
                var observationDescription = row[2];
                var observationStrength_1 = row[3];
                var observationLinkingQuestion = row[4];
                var patternName = row[5];
                var graphType = row[6];
                var patternQuestionIDs = [];
                if (graphType === "data integrity") {
                    patternQuestionIDs = [patternName];
                }
                else {
                    if (row[7])
                        patternQuestionIDs.push(row[7]);
                    if (row[8])
                        patternQuestionIDs.push(row[8]);
                    if (row[9])
                        patternQuestionIDs.push(row[9]);
                }
                var observationExtraPatterns = row[10];
                var x = 100;
                if (row.length > 11) {
                    x = parseInt(row[11] || "");
                    if (isNaN(x))
                        x = 100;
                }
                var y = 100;
                if (row.length > 12) {
                    y = parseInt(row[12] || "");
                    if (isNaN(y))
                        y = 100;
                }
                var interpretationSpecs = [];
                var observationNote = null;
                if (row.length > 13) {
                    for (var colIndex = 13; colIndex < row.length; colIndex++) {
                        // the note field was added after this export format was designed
                        // i am writing out the note after the interpretations
                        // but the only way to test for it during import is to use an identifier
                        // to distinguish it from the interpretations
                        // hence I am testing for the prefix observationNoteIdentifier
                        if (row[colIndex].indexOf(observationNoteIdentifier) >= 0) {
                            observationNote = row[colIndex].substring(observationNoteIdentifier.length);
                        }
                        else {
                            interpretationSpecs.push(row[colIndex]);
                        }
                    }
                }
                var patternQuestions_1 = [];
                patternQuestionIDs.forEach(function (id) {
                    for (var questionIndex = 0; questionIndex < allQuestions.length; questionIndex++) {
                        if (allQuestions[questionIndex].id === id) {
                            patternQuestions_1.push(allQuestions[questionIndex]);
                        }
                    }
                });
                var patternQuestionsAsString = JSON.stringify(patternQuestions_1);
                if (numObservationsAlreadyProcessedPerPattern[patternQuestionsAsString] === undefined) {
                    numObservationsAlreadyProcessedPerPattern[patternQuestionsAsString] = 0;
                }
                var pattern = { graphType: graphType, patternName: patternName, questions: patternQuestions_1 };
                var patternReference = PatternExplorer.patternReferenceForPatternAndIndex(pattern, numObservationsAlreadyProcessedPerPattern[patternQuestionsAsString]);
                numObservationsAlreadyProcessedPerPattern[patternQuestionsAsString] += 1; // increment after saving, because first one saved should be index 0
                var observationIdentifier = generateRandomUuid("Observation");
                project.tripleStore.addTriple(observationSetIdentifier, patternReference, observationIdentifier);
                project.tripleStore.addTriple(observationIdentifier, "pattern", pattern);
                project.tripleStore.addTriple(observationIdentifier, "observationTitle", observationName);
                project.tripleStore.addTriple(observationIdentifier, "observationDescription", observationDescription);
                project.tripleStore.addTriple(observationIdentifier, "observationStrength", observationStrength_1);
                project.tripleStore.addTriple(observationIdentifier, "observationLinkingQuestion", observationLinkingQuestion);
                project.tripleStore.addTriple(observationIdentifier, "observationExtraPatterns", observationExtraPatterns);
                if (observationNote)
                    project.tripleStore.addTriple(observationIdentifier, "observationNote", observationNote);
                var newItem = ClusteringDiagram.addNewItemToDiagram(observationsClusteringDiagram, "item", observationName, observationDescription);
                newItem.x = x;
                newItem.y = y;
                ClusteringDiagram.setItemColorBasedOnStrength(newItem, observationStrength_1);
                observationsClusteringDiagramChanged = true;
                numObservationsCreated++;
                if (interpretationSpecs.length) {
                    var interpretationSetID_1 = project.tripleStore.queryLatestC(observationIdentifier, "observationInterpretations");
                    if (!interpretationSetID_1) {
                        interpretationSetID_1 = generateRandomUuid("InterpretationSet");
                        project.tripleStore.addTriple(observationIdentifier, "observationInterpretations", interpretationSetID_1);
                    }
                    interpretationSpecs.forEach(function (spec) {
                        var partsOfSpec = spec.split("|");
                        // "Interpretation name|description|idea|questions|x|y"
                        var name = partsOfSpec[0] || "";
                        var text = partsOfSpec[1] || "";
                        var idea = partsOfSpec[2] || "";
                        var questions = partsOfSpec[3] || "";
                        var x = 100;
                        if (partsOfSpec.length > 4) {
                            x = parseInt(partsOfSpec[4] || "");
                            if (isNaN(x))
                                x = 100;
                        }
                        var y = 100;
                        if (partsOfSpec.length > 5) {
                            y = parseInt(partsOfSpec[5] || "");
                            if (isNaN(y))
                                y = 100;
                        }
                        if (name && text) {
                            var template = {
                                id: generateRandomUuid("Interpretation"),
                                interpretation_name: name,
                                interpretation_text: text,
                                interpretation_idea: idea,
                                interpretation_questions: questions
                            };
                            project.tripleStore.makeNewSetItem(interpretationSetID_1, "Interpretation", template);
                            numInterpretationsCreated++;
                            var newItem_1 = ClusteringDiagram.addNewItemToDiagram(interpretationsClusteringDiagram, "item", name, text);
                            newItem_1.x = x;
                            newItem_1.y = y;
                            ClusteringDiagram.setItemColorBasedOnStrength(newItem_1, observationStrength_1);
                            interpretationsClusteringDiagramChanged = true;
                        }
                    });
                }
            }
            else if (row[0] === "Perspective") {
                // addOutputLine(["; Perspective", "Name", "Notes", "X", "Y", "Order"]);
                var name_1 = row[1];
                var notes = row[2];
                var x = 100;
                if (row.length > 3) {
                    x = parseInt(row[3] || "");
                    if (isNaN(x))
                        x = 100;
                }
                var y = 100;
                if (row.length > 4) {
                    y = parseInt(row[4] || "");
                    if (isNaN(y))
                        y = 100;
                }
                var order = 1;
                if (row.length > 5) {
                    order = parseInt(row[5] || "");
                    if (isNaN(order))
                        order = 1;
                }
                var newItem = ClusteringDiagram.addNewItemToDiagram(interpretationsClusteringDiagram, "cluster", name_1, notes);
                newItem.x = x;
                newItem.y = y;
                newItem.order = order;
                interpretationsClusteringDiagramChanged = true;
                numPerspectivesCreated++;
            }
            else if (row[0] === "Theme") {
                // addOutputLine(["; Theme", "Name", "Notes", "X", "Y", "Order"]);
                var name_2 = row[1];
                var notes = row[2];
                var x = 100;
                if (row.length > 3) {
                    x = parseInt(row[3] || "");
                    if (isNaN(x))
                        x = 100;
                }
                var y = 100;
                if (row.length > 4) {
                    y = parseInt(row[4] || "");
                    if (isNaN(y))
                        y = 100;
                }
                var order = 1;
                if (row.length > 5) {
                    order = parseInt(row[5] || "");
                    if (isNaN(order))
                        order = 1;
                }
                var newItem = ClusteringDiagram.addNewItemToDiagram(observationsClusteringDiagram, "cluster", name_2, notes);
                newItem.x = x;
                newItem.y = y;
                newItem.order = order;
                observationsClusteringDiagramChanged = true;
                numThemesCreated++;
            }
            else {
                alert('Unrecognized first cell in CSV row: "' + row[0] + '". The first cell in each row must be either "Observation", "Perspective", or "Theme". If this is a comment row, make sure the first character in the first cell is a semicolon.');
            }
        };
        for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            _loop_12(rowIndex);
        }
        if (interpretationsClusteringDiagramChanged) {
            project.tripleStore.addTriple(catalysisReportIdentifier, "interpretationsClusteringDiagram", interpretationsClusteringDiagram);
        }
        if (observationsClusteringDiagramChanged) {
            project.tripleStore.addTriple(catalysisReportIdentifier, "observationsClusteringDiagram", observationsClusteringDiagram);
        }
        var reportItems = [];
        reportItems.push(numObservationsCreated + (numObservationsCreated === 1 ? " observation" : " observations"));
        reportItems.push(numInterpretationsCreated + (numInterpretationsCreated === 1 ? " interpretation" : " interpretations"));
        reportItems.push(numPerspectivesCreated + (numPerspectivesCreated === 1 ? " perspective" : " perspectives"));
        reportItems.push(numThemesCreated + (numThemesCreated === 1 ? " theme" : " themes"));
        var reportText = "Successfully imported " + reportItems.join(", ") + ".";
        alert(reportText);
    }
    exports.processCSVContentsForCatalysisElements = processCSVContentsForCatalysisElements;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // exported functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function importCSVStories() {
        if (!Globals.clientState().storyCollectionName()) {
            // TODO: Translate
            return alert("You need to select a story collection before you can import stories.");
        }
        // save stories, do not write verbose log
        chooseCSVFileToImport(processCSVContentsForStories, true, false);
    }
    exports.importCSVStories = importCSVStories;
    function checkCSVStories() {
        if (!Globals.clientState().storyCollectionName()) {
            // TODO: Translate
            return alert("You need to select a story collection before you can check a story CSV file.");
        }
        // do not save stories, do write verbose log
        chooseCSVFileToImport(processCSVContentsForStories, false, true);
    }
    exports.checkCSVStories = checkCSVStories;
    function checkCSVStoriesWithStoryForm(questionnaire) {
        // do not save stories, do write verbose log
        chooseCSVFileToImport(processCSVContentsForStories, false, true, questionnaire);
    }
    exports.checkCSVStoriesWithStoryForm = checkCSVStoriesWithStoryForm;
    function importCSVQuestionnaire() {
        var overrideOption = project.tripleStore.queryLatestC(project.projectIdentifier, "project_csvQuestionOverwriteOption");
        if (!overrideOption) {
            alert("Please choose how you want to deal with existing questions while importing your CSV file.");
            return;
        }
        chooseCSVFileToImport(processCSVContentsForQuestionnaire, true, false);
    }
    exports.importCSVQuestionnaire = importCSVQuestionnaire;
    function importCSVAnnotations() {
        if (!Globals.clientState().storyCollectionName()) {
            // TODO: Translate
            return alert("You need to select a story collection before you can import annotations to it.");
        }
        // save stories, do not write verbose log
        chooseCSVFileToImport(processCSVContentsForAnnotations, true, false);
    }
    exports.importCSVAnnotations = importCSVAnnotations;
    function checkCSVAnnotations() {
        if (!Globals.clientState().storyCollectionName()) {
            // TODO: Translate
            return alert("You need to select a story collection before you can check a story CSV file.");
        }
        // do not save stories, do write verbose log
        chooseCSVFileToImport(processCSVContentsForAnnotations, false, true);
    }
    exports.checkCSVAnnotations = checkCSVAnnotations;
    function exportAnnotationsToCSV() {
        if (!Globals.clientState().storyCollectionName()) {
            // TODO: Translate
            return alert("You need to select a story collection before you can export annotations from it.");
        }
        exportAnnotationsForCurrentStoryCollectionToCSV();
    }
    exports.exportAnnotationsToCSV = exportAnnotationsToCSV;
    function importTranslationDictionary(questionnaire) {
        chooseCSVFileToImport(processCSVContentsForTranslationDictionary, true, false, questionnaire);
    }
    exports.importTranslationDictionary = importTranslationDictionary;
    function importCSVCatalysisElements() {
        if (!Globals.clientState().catalysisReportIdentifier()) {
            // TODO: Translate
            return alert("You need to select a catalysis report before you can import elements to it.");
        }
        var catalysisReportName = Globals.clientState().catalysisReportName();
        var message = 'You are about to import observations, interpretations, and perspectives into the current catalysis report, ' +
            catalysisReportName + '. You should only do this with an empty report. Are you sure you want to do this?';
        if (!confirm(message))
            return;
        chooseCSVFileToImport(processCSVContentsForCatalysisElements, false, false);
    }
    exports.importCSVCatalysisElements = importCSVCatalysisElements;
    function exportCatalysisReportElements() {
        if (!Globals.clientState().catalysisReportIdentifier()) {
            // TODO: Translate
            return alert("You need to select a catalysis report before you can export elements from it.");
        }
        exportCatalysisReportElementsToCSV();
    }
    exports.exportCatalysisReportElements = exportCatalysisReportElements;
});

define('js/navigationPane',["require", "exports", "mithril", "./PanelSetup", "./Globals"], function (require, exports, m, PanelSetup, Globals) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    var panelSpecificationCollection;
    var currentSectionID;
    var currentPageSpecification;
    var userIdentifier;
    var navigationController = null;
    /* jshint scripturl:true */
    var launchHelpCommand = "javascript:narrafirma_helpClicked()";
    var logoutCommand = "javascript:narrafirma_logoutClicked()";
    var loginCommand = "javascript:narrafirma_loginClicked()";
    var Navigation = {
        panelBuilder: null,
        controller: function (args) {
            this.pageID = null;
            this.pageSpecification = null;
            this.panelBuilder = Navigation.panelBuilder;
        },
        view: function (controller, args) {
            return m("div[id=narrafirma-navigation]", [
                m("span[id=narrafirma-name]", {
                    "class": Globals.clientState().serverStatus(),
                    "title": Globals.clientState().serverStatusText()
                }, "NarraFirma™"),
                //m("sup", {"class": "narrafirma-trademark"}, "TM"),
                //m("span[id=narrafirma-version]", "v" + versions.narrafirmaApplication),
                m("span[id=narrafirma-project-name]", Globals.project().projectNameOrNickname()),
                m("span[id=narrafirma-breadcrumbs]", buildBreadcrumbs(controller)),
                Globals.project().readOnly ? m("span[id=narrafirma-read-only]", { title: "You have read-only access to this project. You can make local changes, but they will not be saved to the server and will be lost when you reload the page." }, "Read only") : [],
                // These next links float right and so are added in reverse order
                userIdentifier === "anonymous" ?
                    m("a[id=narrafirma-login-link]", { href: loginCommand, title: "Log in (instead of being anonymous)" }, 'Log in') :
                    m("a[id=narrafirma-logout-link]", { href: logoutCommand, title: "Log out the current user" }, 'Log out (' + userIdentifier + ')'),
                m("a[id=narrafirma-help-link]", { href: launchHelpCommand, title: "Open online help for this page", "class": "narrafirma-help-link" }, m("span.button-text", "Help")),
                m("a[id=narrafirma-next-page]", { href: nextPageLink(), title: nextPageTitle(), "class": nextPageClass() }, m("span", { class: "buttonWithNoTextImage rightButtonImage" })),
                m("a[id=narrafirma-previous-page]", { href: previousPageLink(), title: previousPageTitle(), "class": previousPageClass() }, m("span", { class: "buttonWithNoTextImage leftButtonImage" }))
            ]);
        }
    };
    function previousPageTitle() {
        if (!currentPageSpecification || !currentPageSpecification.previousPageID)
            return "No previous page";
        var previousPage = panelSpecificationCollection.getPageSpecificationForPageID(currentPageSpecification.previousPageID);
        if (previousPage)
            return "Previous page (" + previousPage.displayName + ")";
        return "Previous page";
    }
    function previousPageClass() {
        if (!currentPageSpecification || !currentPageSpecification.previousPageID)
            return "narrafirma-link-disabled";
        return "narrafirma-link-enabled";
    }
    function previousPageLink() {
        if (!currentPageSpecification)
            return "#";
        return linkForPage(currentPageSpecification.previousPageID);
    }
    function nextPageTitle() {
        if (!currentPageSpecification || !currentPageSpecification.nextPageID)
            return "No next page";
        var nextPage = panelSpecificationCollection.getPageSpecificationForPageID(currentPageSpecification.nextPageID);
        if (nextPage)
            return "Next page (" + nextPage.displayName + ")";
        return "Next page";
    }
    function nextPageClass() {
        if (!currentPageSpecification || !currentPageSpecification.nextPageID)
            return "narrafirma-link-disabled";
        return "narrafirma-link-enabled";
    }
    function nextPageLink() {
        if (!currentPageSpecification)
            return "#";
        return linkForPage(currentPageSpecification.nextPageID);
    }
    function initializeNavigationPane(thePanelSpecificationCollection, theUserIdentifier, panelBuilder) {
        panelSpecificationCollection = thePanelSpecificationCollection;
        userIdentifier = theUserIdentifier;
        Navigation.panelBuilder = panelBuilder;
        navigationController = m.mount(document.getElementById("navigationDiv"), Navigation);
    }
    exports.initializeNavigationPane = initializeNavigationPane;
    function setCurrentPageSpecification(pageID, pageSpecification) {
        currentPageSpecification = pageSpecification;
        navigationController.pageID = pageID;
        navigationController.pageSpecification = pageSpecification;
    }
    exports.setCurrentPageSpecification = setCurrentPageSpecification;
    function buildBreadcrumbs(controller) {
        var pageID = controller.pageID;
        var pageSpecification = controller.pageSpecification;
        currentPageSpecification = pageSpecification;
        if (!pageSpecification)
            return ["Starting up..."];
        var breadcrumbs = [];
        if (pageID !== PanelSetup.startPage()) {
            breadcrumbs.push(htmlForBreadcrumb(PanelSetup.startPage(), "Home"));
            breadcrumbs.push(" > ");
            // TODO: Should lookup name of section
            if (!pageSpecification.isHeader) {
                var sectionPageSpecification = panelSpecificationCollection.getPageSpecificationForPageID("page_" + pageSpecification.section);
                if (sectionPageSpecification) {
                    breadcrumbs.push(htmlForBreadcrumb(sectionPageSpecification.id, sectionPageSpecification.displayName));
                    breadcrumbs.push(" > ");
                }
                else {
                    console.log("ERROR: could not find sectionPageSpecification for: ", pageSpecification.section, pageSpecification);
                }
            }
        }
        breadcrumbs.push(m("span", { id: "narrafirma-breadcrumb-current" }, pageSpecification.displayName));
        return breadcrumbs;
    }
    function linkForPage(pageIdentifier) {
        if (!pageIdentifier)
            return "javascript:void(0)";
        return "javascript:narrafirma_openPage(\'" + pageIdentifier + "\')";
    }
    function htmlForBreadcrumb(pageIdentifier, pageName) {
        return m("a", { href: linkForPage(pageIdentifier) }, pageName);
    }
    function getCurrentPageSpecification() {
        return currentPageSpecification;
    }
    exports.getCurrentPageSpecification = getCurrentPageSpecification;
});

define('js/pageDisplayer',["require", "exports", "./navigationPane", "mithril", "./PanelSetup"], function (require, exports, navigationPane, m, PanelSetup) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    // For tracking what page the application is on
    var currentPageID = null;
    var currentPageSpecification = null;
    var currentPage;
    var panelBuilder;
    var project;
    var clientState;
    function stringBeyond(aString, beyondWhat) {
        if (beyondWhat !== "") {
            return aString.split(beyondWhat).pop();
        }
        else {
            return aString;
        }
    }
    var PageDisplayer = {
        controller: function (args) {
            ;
        },
        view: function (controller, args) {
            var contentsDiv;
            // Setting the hash may trigger another call to the showPage function eventually, but as the new page will already be set, it should not loop further
            clientState.updateHashIfNeededForChangedClientState();
            if (!currentPageID) {
                contentsDiv = m("div", "Starting up...");
            }
            else {
                // Create the display widgets for this page
                try {
                    var parts = [];
                    var pageNameWithoutPrefix = stringBeyond(currentPageSpecification.id, "page_");
                    var isSectionPage = currentPageSpecification.section === pageNameWithoutPrefix;
                    if (currentPageSpecification.section === "dashboard" || currentPageSpecification.section === "administration")
                        isSectionPage = false;
                    if (isSectionPage) {
                        var sectionImageURL = "./images/section_" + currentPageSpecification.section + ".png";
                        var imagePart = m("img", {
                            class: "narrafirma-section-page-image",
                            alt: currentPageSpecification.section + " section image",
                            src: sectionImageURL
                        });
                        parts.push(imagePart);
                    }
                    else {
                        parts.push(m("div.narrafirma-page-name", currentPageSpecification.displayName));
                    }
                    parts.push(panelBuilder.buildPanel(currentPageID, project.projectIdentifier));
                    contentsDiv = m("div", { "class": "narrafirma-" + currentPageID }, parts);
                }
                catch (e) {
                    console.log("ERROR: When trying to view page", currentPageID, e);
                    // TODO: Translate
                    // alert("Something when wrong trying to create this page");
                    contentsDiv = m("div", "PROBLEM: Failed to view page: " + currentPageID);
                }
            }
            // for all of these optional displays
            // if nothing is stored for the option, show the thing (default to support for new user)
            // show or hide explanations of pages on section-dashboard pages
            var showPageExplanations = project.tripleStore.queryLatestC(project.projectIdentifier, "projectOptions_showPageExplanations");
            var explanationsExtraClass = (showPageExplanations === undefined || showPageExplanations === "yes") ? ".showPageExplanations" : "";
            // show or hide page category icons on section-dashboard pages
            var showPageCategoryIcons = project.tripleStore.queryLatestC(project.projectIdentifier, "projectOptions_showPageCategoryIcons");
            var iconsExtraClass = (showPageCategoryIcons === undefined || showPageCategoryIcons === "yes") ? ".showPageCategoryIcons" : "";
            // show or hide tips
            var showTips = project.tripleStore.queryLatestC(project.projectIdentifier, "projectOptions_showTips");
            var tipsExtraClass = (showTips === undefined || showTips === "yes") ? ".showTips" : "";
            // show or hide read-only warning
            var readOnlyWarningExtraClass = project.readOnly ? ".showReadOnlyWarning" : "";
            return m("div.pageContents" + explanationsExtraClass + iconsExtraClass + tipsExtraClass + readOnlyWarningExtraClass, { key: "pageContents" }, contentsDiv);
        }
    };
    // Call this once at the beginning of the application
    function configurePageDisplayer(thePanelBuilder, theProject, theClientState) {
        panelBuilder = thePanelBuilder;
        project = theProject;
        clientState = theClientState;
        m.mount(document.getElementById("pageDiv"), PageDisplayer);
    }
    exports.configurePageDisplayer = configurePageDisplayer;
    function showPage(pageID, forceRefresh, isRedrawAlreadyQueued) {
        if (forceRefresh === void 0) { forceRefresh = false; }
        if (isRedrawAlreadyQueued === void 0) { isRedrawAlreadyQueued = false; }
        if (!pageID)
            pageID = PanelSetup.startPage();
        if (currentPageID === pageID && !forceRefresh) {
            return;
        }
        var pageSpecification;
        try {
            pageSpecification = panelBuilder.getPageSpecificationForPageID(pageID);
        }
        catch (e) {
            console.log("Problem finding pageSpecification for", pageID);
        }
        var badPage = null;
        if (clientState.leavingPageCallback())
            clientState.leavingPageCallback()();
        // Assume that if we have a panel specification for a page that it is OK to go to it
        if (!pageSpecification || pageSpecification.displayType !== "page") {
            console.log("no such page", pageID);
            alert("No such page: " + pageID);
            badPage = pageID;
            // Put back the hash if there was a valid one there already
            if (currentPageID !== null && currentPageID !== pageID) {
                pageID = currentPageID;
            }
            else {
                pageID = PanelSetup.startPage();
            }
            // clientState.updateHashIfNeededForChangedClientState();
            try {
                pageSpecification = panelBuilder.getPageSpecificationForPageID(pageID);
            }
            catch (e) {
                console.log("Problem finding pageSpecification for", pageID);
            }
        }
        // Just going to assume we will be redrawing later via Mithril...
        // Make sure the hash is pointing to this page if this is not a forced refresh
        if (currentPageID !== pageID || badPage) {
            currentPageID = pageID;
            currentPageSpecification = pageSpecification;
            clientState.pageIdentifier(currentPageID);
        }
        navigationPane.setCurrentPageSpecification(pageID, pageSpecification);
        if (!isRedrawAlreadyQueued) {
            try {
                m.redraw();
            }
            catch (e) {
                console.log("ERROR: When trying to redraw page", currentPageID, e);
            }
        }
    }
    exports.showPage = showPage;
    function getCurrentPageID() {
        return currentPageID;
    }
    exports.getCurrentPageID = getCurrentPageID;
});

define('js/versions',["require", "exports"], function (require, exports) {
    "use strict";
    // Return current versions used by application  
    var versions = {
        narrafirmaApplication: "1.6.7",
        questionnaireContentType: "org.workingwithstories.NarraFirmaQuestionnaire",
        questionnaireContentVersion: "0.2.0",
        surveyResultContentType: "org.workingwithstories.NarraFirmaSurveyResult",
        surveyResultContentVersion: "0.2.0"
    };
    return versions;
});

define('js/printing',["require", "exports", "./surveyCollection", "./storyCardDisplay", "./graphStyle", "./Globals", "mithril", "./sanitizeHTML", "./applicationWidgets/ClusteringDiagram", "./applicationWidgets/PatternExplorer", "./Project", "./applicationWidgets/charting", "./panelBuilder/dialogSupport", "canvgModule", "./versions", "./panelBuilder/translate", "jszip", "FileSaver", "./csvImportExport"], function (require, exports, surveyCollection, storyCardDisplay, graphStyle, Globals, m, sanitizeHTML, ClusteringDiagram, PatternExplorer, Project, charting, dialogSupport, canvg, versions, translate, jszip, saveAs, csvImportExport) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    // html headers used in report
    // H1 - Report title
    // H2 - Perspective title
    // H3 - Observation title
    // H4 - Interpretation title
    // H5 - Graph title
    // H6 - Statistics
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // General string functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function replaceAll(str, find, replace) {
        return str.replace(new RegExp(find, 'g'), replace);
    }
    function replaceSpacesWithDashes(text) {
        if (text) {
            return replaceAll(text.trim(), " ", "-");
        }
        else {
            return "";
        }
    }
    function printHTML(htmlToPrint) {
        // Display HTML in a new window
        var w = window.open();
        if (w) {
            w.document.write(htmlToPrint);
            w.document.close();
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // General HTML printing functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function generateHTMLForPage(title, stylesheetReference, customCSS, vdom, message) {
        var output = "";
        output += "<!DOCTYPE html>\n";
        output += "<head>\n";
        output += "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n";
        output += '<meta charset="utf-8">';
        output += "<title>" + escapeHtml(title) + "</title>\n";
        if (stylesheetReference) {
            output += "<link rel=\"stylesheet\" href=\"" + stylesheetReference + "\">\n";
        }
        if (customCSS) {
            output += "<style>" + customCSS + "</style>";
        }
        output += "</head>\n\n";
        output += "<body>\n";
        if (vdom) {
            output += htmlForMithril(vdom);
        }
        else if (message) {
            output += message;
        }
        output += "\n</body>\n</html>";
        return output;
    }
    function htmlForMithril(vdom) {
        // Convert Mithril vdom objects to HTML
        var temporaryDiv = document.createElement('div');
        m.render(temporaryDiv, vdom);
        // add carriage returns to make html more readable (for people who want to mess with it by hand)
        var html = temporaryDiv.innerHTML;
        html = replaceAll(html, '<div class="storyCard">', '\n<div class="storyCard">');
        html = replaceAll(html, "<div", "\n<div");
        html = replaceAll(html, "<", "\n<");
        return html;
    }
    // escapeHtml from: http://shebang.brandonmintern.com/foolproof-html-escaping-in-javascript/
    function escapeHtml(str) {
        var div = document.createElement('div');
        div.appendChild(document.createTextNode(str));
        return div.innerHTML;
    }
    ;
    function repeatTags(count, tags) {
        var result = [];
        for (var i = 0; i < count; i++) {
            result.push(tags);
        }
        return result;
    }
    function printText(text) {
        try {
            var result = text;
            if (text) {
                result = replaceSimpleMarkupWithHTML(result);
                result = replaceAll(result, "\n", "\n<br>");
                result = sanitizeHTML.generateSanitizedHTMLForMithril(result);
            }
            else {
                result = "";
            }
            return result;
        }
        catch (error) {
            alert(error);
            return text;
        }
    }
    function replaceSimpleMarkupWithHTML(text) {
        var result = text;
        result = result.replace(/\*\*(.*?)\*\*/g, "<b>$1</b>");
        result = result.replace(/__(.*?)__/g, "<i>$1</i>");
        return result;
    }
    function printReturn() {
        return [
            m("br"),
            "\n"
        ];
    }
    function printReturnAndBlankLine() {
        return [
            printReturn(),
            printReturn()
        ];
    }
    function printCheckbox(text) {
        return m("div.narrafirma-survey-print-checkbox", [
            "[ ] ",
            printText(text),
            "\n"
        ]);
    }
    function printOption(text) {
        return m("div.narrafirma-survey-print-radiobutton", [
            "( ) ",
            printText(text),
            "\n"
        ]);
    }
    function printQuestionText(question, instructions) {
        if (instructions === void 0) { instructions = ""; }
        var questionTextForPrinting = printText(question.displayPrompt);
        if (question.displayType === "header") {
            questionTextForPrinting = m("b", questionTextForPrinting);
        }
        if (instructions)
            instructions = " (" + instructions + ")";
        return m("div.narrafirma-survey-print-question-text", [
            questionTextForPrinting,
            m("span.narrafirma-survey-print-instruction", instructions)
        ]);
    }
    function printWriteInText(question) {
        if (question.writeInTextBoxLabel) {
            var labelToPrint = question.writeInTextBoxLabel;
            if (labelToPrint.indexOf("**") >= 0) {
                labelToPrint = labelToPrint.replace("**", "");
            }
            return m("div.narrafirma-survey-print-question-write-in-line", labelToPrint + " ___________________________________");
        }
        else {
            return "";
        }
    }
    // TODO: Translate
    function printQuestion(question) {
        var result;
        switch (question.displayType) {
            case "boolean":
                result = [
                    printQuestionText(question, "Choose only one"),
                    printOption("yes"),
                    printOption("no")
                ];
                break;
            case "label":
                result = [
                    printQuestionText(question),
                ];
                break;
            case "header":
                result = [
                    printQuestionText(question),
                ];
                break;
            case "checkbox":
                result = [
                    printQuestionText(question),
                    printCheckbox("yes")
                ];
                break;
            case "checkboxes":
                result = [
                    printQuestionText(question, "Choose any combination"),
                    question.valueOptions.map(function (option, index) {
                        return printCheckbox(option);
                    })
                ];
                break;
            case "text":
                result = [
                    printQuestionText(question),
                    m("div.narrafirma-survey-print-blank-text-line", "_________________________________________________________________________")
                ];
                break;
            case "textarea":
                result = [
                    printQuestionText(question),
                    m("div.narrafirma-survey-print-textarea", printReturnAndBlankLine())
                ];
                break;
            case "select":
                result = [
                    printQuestionText(question, "Choose only one"),
                    question.valueOptions.map(function (option, index) {
                        return printOption(option);
                    })
                ];
                break;
            case "radiobuttons":
                result = [
                    printQuestionText(question, "Choose only one"),
                    question.valueOptions.map(function (option, index) {
                        return printOption(option);
                    })
                ];
                break;
            case "slider":
                result = [
                    printQuestionText(question, "Mark on the line"),
                    m("div.narrafirma-survey-print-slider", [
                        question.displayConfiguration[0],
                        " -------------------------------------------------- ",
                        question.displayConfiguration[1]
                    ])
                ];
                break;
        }
        result.push(printWriteInText(question));
        return result;
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Catalysis report - printing main report elements
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    var graphTypesThatDontGetPrinted = ["texts", "write-in texts"];
    function printCatalysisReport() {
        var project = Globals.project();
        var catalysisReportName = Globals.clientState().catalysisReportName();
        if (!catalysisReportName) {
            alert("Please choose a catalysis report to print.");
            return;
        }
        var catalysisReportIdentifier = project.findCatalysisReport(catalysisReportName);
        var reportType = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReportPrint_reportType");
        if (!reportType) {
            alert("Please choose what kind of report you want to print.");
            return;
        }
        var catalysisReportObservationSetIdentifier = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_observations");
        if (!catalysisReportObservationSetIdentifier) {
            console.log("catalysisReportObservationSetIdentifier not defined");
            return;
        }
        var strengthsChosen = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReportPrint_observationStrengths");
        if (!strengthsChosen) {
            alert("Please choose which observation strengths you want to print.");
            return;
        }
        var observationIDs = project.tripleStore.getListForSetIdentifier(catalysisReportObservationSetIdentifier);
        var allStories = project.storiesForCatalysisReport(catalysisReportIdentifier);
        var options = {};
        options["catalysisReportName"] = catalysisReportName;
        options["reportNotes"] = getAndCleanUserText(project, catalysisReportIdentifier, "catalysisReport_notes", "introduction");
        options["aboutReport"] = getAndCleanUserText(project, catalysisReportIdentifier, "catalysisReport_about", "about text");
        options["conclusion"] = getAndCleanUserText(project, catalysisReportIdentifier, "catalysisReport_conclusion", "conclusion");
        options["perspectiveLabel"] = getAndCleanUserText(project, catalysisReportIdentifier, "catalysisReport_perspectiveLabel", "perspective label");
        options["themeLabel"] = getAndCleanUserText(project, catalysisReportIdentifier, "catalysisReport_themeLabel", "theme label");
        options["interpretationLabel"] = getAndCleanUserText(project, catalysisReportIdentifier, "catalysisReport_interpretationLabel", "interpretation label");
        options["interpretationQuestionsLabel"] = getAndCleanUserText(project, catalysisReportIdentifier, "catalysisReport_interpretationQuestionsLabel", "interpretation questions label");
        options["interpretationIdeaLabel"] = getAndCleanUserText(project, catalysisReportIdentifier, "catalysisReport_interpretationIdeaLabel", "interpretation idea label");
        options["observationLabel"] = getAndCleanUserText(project, catalysisReportIdentifier, "catalysisReport_observationLabel", "observation label");
        options["customCSS"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_customCSS");
        options["customGraphCSS"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_customGraphCSS");
        options["lumpingCommands"] = project.lumpingCommandsForCatalysisReport(catalysisReportIdentifier);
        var statsTextReplacementsAsString = project.tripleStore.queryLatestC(catalysisReportIdentifier, "customStatsTextReplacements");
        var statsTextReplacements = {};
        if (statsTextReplacementsAsString) {
            var textReplacementLines = statsTextReplacementsAsString.split("\n");
            textReplacementLines.forEach(function (line) {
                var originalAndReplacement = line.split("=");
                if (originalAndReplacement.length > 1) {
                    statsTextReplacements[originalAndReplacement[0].trim()] = originalAndReplacement[1].trim();
                }
            });
        }
        options["customStatsTextReplacements"] = statsTextReplacements;
        options["minimumStoryCountRequiredForTest"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "minimumStoryCountRequiredForTest") || Project.default_minimumStoryCountRequiredForTest;
        options["minimumStoryCountRequiredForGraph"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "minimumStoryCountRequiredForGraph") || Project.default_minimumStoryCountRequiredForGraph;
        options["numHistogramBins"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "numHistogramBins") || Project.default_numHistogramBins;
        options["numScatterDotOpacityLevels"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "numScatterDotOpacityLevels") || Project.default_numScatterDotOpacityLevels;
        options["scatterDotSize"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "scatterDotSize") || Project.default_scatterDotSize;
        options["correlationMapShape"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "correlationMapShape") || Project.default_correlationMapShape;
        options["correlationMapIncludeScaleEndLabels"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "correlationMapIncludeScaleEndLabels") || Project.default_correlationMapIncludeScaleEndLabels;
        options["correlationMapCircleDiameter"] = parseInt(project.tripleStore.queryLatestC(catalysisReportIdentifier, "correlationMapCircleDiameter")) || Project.default_correlationMapCircleDiameter;
        options["correlationLineChoice"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "correlationLineChoice") || Project.default_correlationLineChoice;
        options["customLabelLengthLimit"] = parseInt(project.tripleStore.queryLatestC(catalysisReportIdentifier, "customLabelLengthLimit") || Project.default_customLabelLengthLimit);
        options["outputGraphFormat"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "outputGraphFormat") || "SVG";
        options["showStatsPanelsInReport"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "showStatsPanelsInReport") || false;
        options["printItemIndexNumbers"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "printItemIndexNumbers") || false;
        options["hideNumbersOnContingencyGraphs"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "hideNumbersOnContingencyGraphs") || false;
        options["useTableForInterpretationsFollowingObservation"] = project.tripleStore.queryLatestC(catalysisReportIdentifier, "useTableForInterpretationsFollowingObservation") || false;
        options["customGraphWidth"] = parseInt(project.tripleStore.queryLatestC(catalysisReportIdentifier, "customReportGraphWidth")) || Project.default_customReportGraphWidth;
        options["customGraphHeight"] = parseInt(project.tripleStore.queryLatestC(catalysisReportIdentifier, "customReportGraphHeight")) || Project.default_customReportGraphHeight;
        options["catalysisReportIdentifier"] = catalysisReportIdentifier;
        options["outputFontModifierPercent"] = parseInt(project.tripleStore.queryLatestC(catalysisReportIdentifier, "outputFontModifierPercent"));
        options["adjustedCSS"] = graphStyle.modifyFontSize(graphStyle.graphResultsPaneCSS(null), options["outputFontModifierPercent"]);
        var strengthsToInclude = [];
        var strengthTextsToReport = [];
        if (strengthsChosen["strong"] === true) {
            strengthsToInclude.push("3 (strong)");
            strengthTextsToReport.push("strong");
        }
        if (strengthsChosen["medium"] === true) {
            strengthsToInclude.push("2 (medium)");
            strengthTextsToReport.push("medium");
        }
        if (strengthsChosen["weak"] === true) {
            strengthsToInclude.push("1 (weak)");
            strengthTextsToReport.push("weak");
        }
        var includeObservationsWithoutStrengths = false;
        if (strengthsChosen["no strength value set"] === true) {
            includeObservationsWithoutStrengths = true;
            strengthTextsToReport.push("none");
        }
        options["strengthTextsToReport"] = strengthTextsToReport;
        var includeObservationsWithNoInterpretations = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReportPrint_includeObservationsWithNoInterpretations") || false;
        var observationIDsToInclude = [];
        observationIDs.forEach(function (id) {
            var observation = project.tripleStore.makeObject(id, true);
            if (!observation.observationTitle || !observation.observationTitle.trim()) {
                if (!observation.observationDescription || !observation.observationDescription.trim())
                    return;
            }
            if (observation.observationStrength) {
                if (strengthsToInclude.indexOf(observation.observationStrength) < 0)
                    return;
            }
            else {
                if (!includeObservationsWithoutStrengths)
                    return;
            }
            if (!includeObservationsWithNoInterpretations) {
                var interpretationsListIdentifier = project.tripleStore.queryLatestC(id, "observationInterpretations");
                var interpretationIDsForThisObservation = project.tripleStore.getListForSetIdentifier(interpretationsListIdentifier);
                if (!interpretationIDsForThisObservation || interpretationIDsForThisObservation.length == 0)
                    return;
            }
            observationIDsToInclude.push(id);
        });
        if (observationIDsToInclude.length === 0) {
            alert("No observations match your selection criteria. Try changing the observation strengths to include.");
            return;
        }
        if (reportType === "observations (disregarding any clustering)") {
            printCatalysisReportWithUnclusteredObservations(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDsToInclude, options);
        }
        else if (reportType === "observation graphs only") {
            printCatalysisReportWithObservationGraphsOnly(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDsToInclude, options);
        }
        else if (reportType === "observation and interpretation texts as csv") {
            printObservationsAndInterpretationsToCSV(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDsToInclude, options);
        }
        else if (reportType === "observation graph data as csv") {
            printCatalysisReportWithCSVOnly(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDsToInclude, options);
        }
        else if (reportType === "themes (clustered observations)") {
            printCatalysisReportWithClusteredObservations(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDsToInclude, options);
        }
        else if (reportType === "perspectives (clustered interpretations)") {
            printCatalysisReportWithClusteredInterpretations(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDsToInclude, options);
        }
        else {
            alert("The catalysis report type " + reportType + " was not recognized.");
        }
    }
    exports.printCatalysisReport = printCatalysisReport;
    function printCatalysisReportWithUnclusteredObservations(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDs, options) {
        var progressModel = dialogSupport.openProgressDialog("Starting up...", "Generating unclustered-observations catalysis report", "Cancel", dialogCancelled);
        var printItems = [];
        addPrintItemsForReportStart(printItems, project, catalysisReportName, catalysisReportIdentifier, allStories, options);
        var observationIndex = 0;
        function printNextObservation() {
            if (progressModel.cancelled) {
                alert("Cancelled after working on " + (observationIndex + 1) + " observation(s)");
            }
            else if (observationIndex >= observationIDs.length) {
                finishCatalysisReport(project, catalysisReportName, catalysisReportIdentifier, printItems, progressModel, options);
            }
            else {
                printItems.push(printObservation(observationIDs[observationIndex], observationIndex, -1, "", false, "neither", allStories, options));
                printItems.push(m(".narrafirma-catalysis-report-observations-only-page-break", ""));
                progressModel.progressText = progressText(observationIndex);
                progressModel.redraw();
                observationIndex++;
                setTimeout(function () { printNextObservation(); }, 0);
            }
        }
        function progressText(observationIndex) {
            return "Observation " + (observationIndex + 1) + " of " + observationIDs.length;
        }
        function dialogCancelled(dialogConfiguration, hideDialogMethod) {
            progressModel.cancelled = true;
            hideDialogMethod();
        }
        setTimeout(function () { printNextObservation(); }, 0);
    }
    function printCatalysisReportWithObservationGraphsOnly(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDs, options) {
        var progressModel = dialogSupport.openProgressDialog("Starting up...", "Generating observation graphs", "Cancel", dialogCancelled);
        var zipFile = new jszip();
        var savedGraphCount = 0;
        function printGraphToZipFile(zipFile, graphHolder, graphNode, graphTitle, options) {
            var svgNode = graphNode.querySelector("svg");
            if (svgNode) {
                if (options.outputGraphFormat === "SVG") {
                    var svgFileText = graphStyle.prepareSVGToSaveToFile(svgNode, options.customGraphCSS, graphHolder.outputFontModifierPercent);
                    zipFile.file(graphTitle + ".svg", svgFileText);
                    savedGraphCount++;
                }
                else if (options.outputGraphFormat === "PNG") {
                    // when using canvas.toBlob either the ZIP file or the PNG files come out corrupted
                    // found this method to fix it online and it works
                    var canvas = graphStyle.preparePNGToSaveToFile(svgNode, options.customGraphCSS, graphHolder.outputFontModifierPercent);
                    var dataURI = canvas.toDataURL("image/png");
                    var imageData = graphStyle.dataURItoBlob(dataURI);
                    zipFile.file(graphTitle + ".png", imageData, { binary: true });
                    savedGraphCount++;
                }
            }
        }
        var observationIndex = 0;
        function printNextObservation() {
            if (progressModel.cancelled) {
                alert("Cancelled after working on " + (observationIndex + 1) + " observation(s)");
            }
            else if (observationIndex >= observationIDs.length) {
                progressModel.hideDialogMethod();
                if (savedGraphCount > 0) {
                    var finishModel = dialogSupport.openFinishedDialog("Done creating zip file of images; save it?", "Finished generating images", "Save", "Cancel", function (dialogConfiguration, hideDialogMethod) {
                        var fileName = options.catalysisReportName + " observation graphs (" + options.strengthTextsToReport.join(" ") + ") " + options.outputGraphFormat + ".zip";
                        zipFile.generateAsync({ type: "blob", platform: "UNIX", compression: "DEFLATE" }).then(function (blob) { saveAs(blob, fileName); });
                        hideDialogMethod();
                    });
                    finishModel.redraw();
                }
                else {
                    alert("No graphs were found with your current selection criteria. Try choosing different observation strengths.");
                }
                progressModel.redraw();
            }
            else {
                var observation = project.tripleStore.makeObject(observationIDs[observationIndex]);
                if (observation && observation.pattern && graphTypesThatDontGetPrinted.indexOf(observation.pattern.graphType) < 0) {
                    var graphTitle = observation.pattern.patternName;
                    graphTitle = replaceAll(graphTitle, "/", " "); // jszip interprets a forward slash as a folder designation 
                    var graphHolder = initializedGraphHolder(allStories, options);
                    var hideNoAnswerValues = PatternExplorer.getOrSetWhetherNoAnswerValuesShouldBeHiddenForPattern(project, options.catalysisReportIdentifier, observation.pattern);
                    graphHolder.patternDisplayConfiguration.hideNoAnswerValues = hideNoAnswerValues;
                    var useLumpingCommands = PatternExplorer.getOrSetWhetherLumpingCommandsShouldBeUsedForPattern(project, options.catalysisReportIdentifier, observation.pattern);
                    graphHolder.patternDisplayConfiguration.useLumpingCommands = useLumpingCommands;
                    var selectionCallback = function () { return this; };
                    var graph = PatternExplorer.makeGraph(observation.pattern, graphHolder, selectionCallback, !options.showStatsPanelsInReport);
                    if (graphHolder.chartPanes.length > 1) {
                        for (var graphIndex = 1; graphIndex < graphHolder.chartPanes.length; graphIndex++) {
                            var graphNode = graphHolder.chartPanes[graphIndex];
                            if (graphNode) {
                                var subGraphTitle = graphTitle + " " + graph[graphIndex - 1].subgraphChoice; // subtract 1 because 1 is title pane
                                printGraphToZipFile(zipFile, graphHolder, graphNode, subGraphTitle, options);
                            }
                        }
                    }
                    else {
                        var graphNode = graphHolder.graphResultsPane.firstChild;
                        if (graphNode)
                            printGraphToZipFile(zipFile, graphHolder, graphNode, graphTitle, options);
                    }
                }
                progressModel.progressText = progressText(observationIndex);
                progressModel.redraw();
                observationIndex++;
                setTimeout(function () { printNextObservation(); }, 0);
            }
        }
        function progressText(observationIndex) {
            return "Observation " + (observationIndex + 1) + " of " + observationIDs.length;
        }
        function dialogCancelled(dialogConfiguration, hideDialogMethod) {
            progressModel.cancelled = true;
            hideDialogMethod();
        }
        setTimeout(function () { printNextObservation(); }, 0);
    }
    function printObservationsAndInterpretationsToCSV(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDs, options) {
        var progressModel = dialogSupport.openProgressDialog("Starting up...", "Generating observation graph data", "Cancel", dialogCancelled);
        var numObservationsWritten = 0;
        var observationIndex = 0;
        var delimiter = Globals.clientState().csvDelimiter();
        var headerLine = [
            "Number of observation", "Strength of observation", "Pattern observation is about", "Type of graph observation is about",
            "Name of observation", "Description of observation", "Question linking observation to interpretations",
            "Name of interpretation", "Description of interpretation", "Questions arising form interpretation", "Ideas related to interpretation"
        ];
        var output = [];
        output = csvImportExport.addCSVOutputLine(output, headerLine, delimiter);
        function printNextObservation() {
            if (progressModel.cancelled) {
                alert("Cancelled after working on " + (observationIndex + 1) + " observation(s)");
            }
            else if (observationIndex >= observationIDs.length) {
                progressModel.hideDialogMethod();
                if (numObservationsWritten > 0) {
                    var finishModel = dialogSupport.openFinishedDialog("Done creating CSV file of observation and interpretation texts; save it?", "Finished generating CSV file", "Save", "Cancel", function (dialogConfiguration, hideDialogMethod) {
                        var fileName = options.catalysisReportName + " observation texts (" + options.strengthTextsToReport.join(" ") + ").csv";
                        var exportBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
                        saveAs(exportBlob, fileName);
                        hideDialogMethod();
                    });
                    finishModel.redraw();
                }
                else {
                    alert("No observations were found with your current selection criteria. Try choosing different observation strengths.");
                }
                progressModel.redraw();
            }
            else {
                var observation = project.tripleStore.makeObject(observationIDs[observationIndex]);
                if (observation) {
                    var line = [];
                    line.push(observationIndex + 1);
                    line.push(observation.observationStrength || "");
                    line.push(observation.pattern.patternName || "");
                    line.push(observation.pattern.graphType || "");
                    line.push(observation.observationTitle || "");
                    line.push(observation.observationDescription || "");
                    line.push(observation.observationLinkingQuestion || "");
                    output = csvImportExport.addCSVOutputLine(output, line, delimiter);
                    var interpretationsListIdentifier = project.tripleStore.queryLatestC(observationIDs[observationIndex], "observationInterpretations");
                    var interpretationIDs = project.tripleStore.getListForSetIdentifier(interpretationsListIdentifier);
                    if (interpretationIDs && interpretationIDs.length > 0) {
                        for (var _i = 0, interpretationIDs_1 = interpretationIDs; _i < interpretationIDs_1.length; _i++) {
                            var id = interpretationIDs_1[_i];
                            var interpretation = project.tripleStore.makeObject(id, true);
                            if (interpretation) {
                                var line_1 = [];
                                line_1 = line_1.concat([observationIndex + 1, observation.observationStrength || "", "", "", "", "", ""]);
                                line_1.push(interpretation.interpretation_name || "");
                                line_1.push(interpretation.interpretation_text || "");
                                line_1.push(interpretation.interpretation_questions || "");
                                line_1.push(interpretation.interpretation_idea || "");
                                output = csvImportExport.addCSVOutputLine(output, line_1, delimiter);
                            }
                        }
                    }
                    numObservationsWritten++;
                    progressModel.progressText = progressText(observationIndex);
                    progressModel.redraw();
                    observationIndex++;
                    setTimeout(function () { printNextObservation(); }, 0);
                }
            }
        }
        function progressText(observationIndex) {
            return "Observation " + (observationIndex + 1) + " of " + observationIDs.length;
        }
        function dialogCancelled(dialogConfiguration, hideDialogMethod) {
            progressModel.cancelled = true;
            hideDialogMethod();
        }
        setTimeout(function () { printNextObservation(); }, 0);
    }
    function printCatalysisReportWithCSVOnly(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDs, options) {
        var progressModel = dialogSupport.openProgressDialog("Starting up...", "Generating observation graph data", "Cancel", dialogCancelled);
        var zipFile = new jszip();
        var savedGraphCount = 0;
        function saveCSVGraphToZipFile(zipFile, graphHolder, pattern) {
            var output = PatternExplorer.saveGraphAsCSV(pattern, graphHolder, false);
            var firstLineOfOutput = output.substr(0, output.indexOf("\n"));
            // add utf-8 BOM - https://github.com/Stuk/jszip/issues/368
            output = '\uFEFF' + output;
            zipFile.file(firstLineOfOutput + ".csv", output);
            savedGraphCount++;
        }
        var observationIndex = 0;
        function printNextObservation() {
            if (progressModel.cancelled) {
                alert("Cancelled after working on " + (observationIndex + 1) + " observation(s)");
            }
            else if (observationIndex >= observationIDs.length) {
                progressModel.hideDialogMethod();
                if (savedGraphCount > 0) {
                    var finishModel = dialogSupport.openFinishedDialog("Done creating zip file of graph data; save it?", "Finished generating graph data", "Save", "Cancel", function (dialogConfiguration, hideDialogMethod) {
                        var fileName = options.catalysisReportName + " graph data (" + options.strengthTextsToReport.join(" ") + ").zip";
                        zipFile.generateAsync({ type: "blob", platform: "UNIX", compression: "DEFLATE" }).then(function (blob) { saveAs(blob, fileName); });
                        hideDialogMethod();
                    });
                    finishModel.redraw();
                }
                else {
                    alert("No graphs were found with your current selection criteria. Try choosing different observation strengths.");
                }
                progressModel.redraw();
            }
            else {
                var observation = project.tripleStore.makeObject(observationIDs[observationIndex]);
                if (observation && observation.pattern && graphTypesThatDontGetPrinted.indexOf(observation.pattern.graphType) < 0) {
                    var graphTitle = observation.pattern.patternName;
                    graphTitle = replaceAll(graphTitle, "/", " "); // jszip interprets a forward slash as a folder designation 
                    var graphHolder = initializedGraphHolder(allStories, options);
                    var hideNoAnswerValues = PatternExplorer.getOrSetWhetherNoAnswerValuesShouldBeHiddenForPattern(project, options.catalysisReportIdentifier, observation.pattern);
                    graphHolder.patternDisplayConfiguration.hideNoAnswerValues = hideNoAnswerValues;
                    var useLumpingCommands = PatternExplorer.getOrSetWhetherLumpingCommandsShouldBeUsedForPattern(project, options.catalysisReportIdentifier, observation.pattern);
                    graphHolder.patternDisplayConfiguration.useLumpingCommands = useLumpingCommands;
                    var selectionCallback = function () { return this; };
                    var graph = PatternExplorer.makeGraph(observation.pattern, graphHolder, selectionCallback, !options.showStatsPanelsInReport);
                    if (graphHolder.chartPanes.length > 1) {
                        for (var graphIndex = 1; graphIndex < graphHolder.chartPanes.length; graphIndex++) {
                            var graphNode = graphHolder.chartPanes[graphIndex];
                            var subGraphTitle = graphTitle + " " + graph[graphIndex - 1].subgraphChoice; // subtract 1 because 1 is title pane
                            saveCSVGraphToZipFile(zipFile, graphHolder, observation.pattern);
                        }
                    }
                    else {
                        var graphNode = graphHolder.graphResultsPane.firstChild;
                        saveCSVGraphToZipFile(zipFile, graphHolder, observation.pattern);
                    }
                }
                progressModel.progressText = progressText(observationIndex);
                progressModel.redraw();
                observationIndex++;
                setTimeout(function () { printNextObservation(); }, 0);
            }
        }
        function progressText(observationIndex) {
            return "Observation " + (observationIndex + 1) + " of " + observationIDs.length;
        }
        function dialogCancelled(dialogConfiguration, hideDialogMethod) {
            progressModel.cancelled = true;
            hideDialogMethod();
        }
        setTimeout(function () { printNextObservation(); }, 0);
    }
    function printCatalysisReportWithClusteredObservations(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDs, options) {
        var clusteringDiagram = project.tripleStore.queryLatestC(catalysisReportIdentifier, "observationsClusteringDiagram");
        if (!clusteringDiagram) {
            alert("Please cluster observations before printing.");
            return;
        }
        var progressModel = dialogSupport.openProgressDialog("Starting up...", "Generating clustered-observations catalysis report", "Cancel", dialogCancelled);
        var printItems = [];
        addPrintItemsForReportStart(printItems, project, catalysisReportName, catalysisReportIdentifier, allStories, options);
        var clustersToPrint = clustersThatMatchObservationIDList(project, clusteringDiagram, "themes", observationIDs);
        clustersToPrint.sort(function (a, b) { return (a.order && b.order && a.order > b.order) ? 1 : -1; });
        var tocHeaderRaw = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_tocHeaderFirstLevel_observations");
        addPrintItemsForTOCLevelOne(printItems, tocHeaderRaw, clustersToPrint, "Themes", options);
        var clusterIndex = 0;
        var itemIndex = -1;
        function printNextObservation() {
            if (progressModel.cancelled) {
                alert("Cancelled after working on " + (clusterIndex + 1) + " theme(s)");
            }
            else if (clusterIndex >= clustersToPrint.length) {
                finishCatalysisReport(project, catalysisReportName, catalysisReportIdentifier, printItems, progressModel, options);
            }
            else {
                var cluster = clustersToPrint[clusterIndex];
                if (itemIndex < 0) {
                    var numItemsToPrintInThisCluster = numItemsOutOfListToPrint(cluster.items);
                    // theme name and notes
                    printItems.push(m("h2", { class: "narrafirma-catalysis-report-theme " + replaceSpacesWithDashes(cluster.name), id: "c_" + clusterIndex }, m("span.narrafirma-catalysis-report-theme-label", options.themeLabel), componentWithSequenceNumber(clusterIndex, -1, -1, options), printText(cluster.name)));
                    printItems.push(m("div.narrafirma-catalysis-report-theme-notes", printText(cluster.notes)));
                    // table of contents for theme
                    addPrintHeaderForTOCLevelTwo(printItems, project, catalysisReportIdentifier, "themes", "catalysisReport_tocHeaderSecondLevel_observations", "Observations in this theme (#):", numItemsToPrintInThisCluster);
                    var tocItemsForCluster = [];
                    for (var i = 0; i < cluster.items.length; i++) {
                        if (cluster.items[i].print) {
                            var idTag = "#c_" + clusterIndex + "_o_" + i;
                            var observation = project.tripleStore.makeObject(cluster.items[i].referenceUUID, true);
                            var sequenceText = options.printItemIndexNumbers ? (clusterIndex + 1).toString() + "." + (i + 1).toString() + ". " : "";
                            tocItemsForCluster.push(m("div", { "class": "narrafirma-catalysis-report-theme-link" }, [
                                m("span", { "class": "narrafirma-catalysis-report-observation-name" }, m("a", { "href": idTag }, sequenceText, printText(observation.observationTitle || observation.observationDescription)))
                            ]));
                        }
                    }
                    printItems.push(m("div", { "class": "narrafirma-catalysis-report-observation-links" }, tocItemsForCluster));
                    printItems.push(m("br"));
                    itemIndex++;
                }
                else if (itemIndex >= cluster.items.length) {
                    clusterIndex++;
                    itemIndex = -1;
                }
                else {
                    var item = cluster.items[itemIndex];
                    if (item.print) {
                        var idTag = "c_" + clusterIndex + "_o_" + itemIndex;
                        printItems.push(printObservation(item.referenceUUID, itemIndex, clusterIndex, idTag, true, "themes", allStories, options));
                        var interpretationsListIdentifier = project.tripleStore.queryLatestC(item.referenceUUID, "observationInterpretations");
                        var interpretationIDsForThisObservation = project.tripleStore.getListForSetIdentifier(interpretationsListIdentifier);
                        printItems.push(printListOfInterpretations(interpretationIDsForThisObservation, itemIndex, clusterIndex, idTag, options));
                        progressModel.progressText = progressText(clusterIndex, itemIndex);
                        progressModel.redraw();
                    }
                    itemIndex++;
                }
                setTimeout(function () { printNextObservation(); }, 0);
            }
        }
        function progressText(clusterIndex, observationIndex) {
            return "Theme " + (clusterIndex + 1) + " of " + clustersToPrint.length + ", observation " + (observationIndex + 1) + " of " + clustersToPrint[clusterIndex].items.length;
        }
        function dialogCancelled(dialogConfiguration, hideDialogMethod) {
            progressModel.cancelled = true;
            hideDialogMethod();
        }
        setTimeout(function () { printNextObservation(); }, 0);
    }
    function printCatalysisReportWithClusteredInterpretations(project, catalysisReportIdentifier, catalysisReportName, allStories, observationIDs, options) {
        var clusteringDiagram = project.tripleStore.queryLatestC(catalysisReportIdentifier, "interpretationsClusteringDiagram");
        if (!clusteringDiagram) {
            alert("Please cluster interpretations before printing.");
            return;
        }
        var progressModel = dialogSupport.openProgressDialog("Starting up...", "Generating clustered-interpretations catalysis report", "Cancel", dialogCancelled);
        function progressText(clusterIndex, itemIndex) {
            return "Perspective " + (clusterIndex + 1) + " of " + clustersToPrint.length + ", interpretation " + (itemIndex + 1) + " of " + clustersToPrint[clusterIndex].items.length;
        }
        function dialogCancelled(dialogConfiguration, hideDialogMethod) {
            progressModel.cancelled = true;
            hideDialogMethod();
        }
        var printItems = [];
        addPrintItemsForReportStart(printItems, project, catalysisReportName, catalysisReportIdentifier, allStories, options);
        var clustersToPrint = clustersThatMatchObservationIDList(project, clusteringDiagram, "perspectives", observationIDs);
        clustersToPrint.sort(function (a, b) { return (a.order && b.order && a.order > b.order) ? 1 : -1; });
        var tocHeaderRaw = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_tocHeaderFirstLevel");
        addPrintItemsForTOCLevelOne(printItems, tocHeaderRaw, clustersToPrint, "Perspectives", options);
        var clusterIndex = 0;
        var itemIndex = -1; // start before zero index to print TOC
        var observationsIDsForInterpretations = {};
        function printNextInterpretation() {
            if (progressModel.cancelled) {
                alert("Cancelled after working on " + (clusterIndex + 1) + " perspective(s)");
            }
            else if (clusterIndex >= clustersToPrint.length) {
                finishCatalysisReport(project, catalysisReportName, catalysisReportIdentifier, printItems, progressModel, options);
            }
            else {
                var cluster = clustersToPrint[clusterIndex];
                if (itemIndex < 0) {
                    var numItemsToPrintInThisCluster = numItemsOutOfListToPrint(cluster.items);
                    // perspective name and notes 
                    printItems.push(m("h2", { class: "narrafirma-catalysis-report-perspective " + replaceSpacesWithDashes(cluster.name), id: "c_" + clusterIndex }, m("span.narrafirma-catalysis-report-perspective-label", options.perspectiveLabel), componentWithSequenceNumber(clusterIndex, -1, -1, options), printText(cluster.name)));
                    printItems.push(m("div.narrafirma-catalysis-report-perspective-notes", printText(cluster.notes)));
                    // table of contents for perspective
                    addPrintHeaderForTOCLevelTwo(printItems, project, catalysisReportIdentifier, "perspectives", "catalysisReport_tocHeaderSecondLevel", "Interpretations and observations in this perspective (#):", numItemsToPrintInThisCluster);
                    var tocItemsForCluster = [];
                    for (var i = 0; i < cluster.items.length; i++) {
                        var item = cluster.items[i];
                        if (item.print) {
                            var interpretation = project.tripleStore.makeObject(item.referenceUUID, true);
                            if (interpretation) {
                                var observationIDsForThisInterpretation = makeObservationIDsListForInterpretation(project, observationIDs, item);
                                observationsIDsForInterpretations[item.uuid] = observationIDsForThisInterpretation[0]; // save to use later; only first observation in list matters
                                var observation = project.tripleStore.makeObject(observationsIDsForInterpretations[item.uuid]);
                                if (observation) {
                                    var tocItemsForOIPair = [];
                                    var sequenceText = options.printItemIndexNumbers ? (clusterIndex + 1).toString() + "." + (i + 1).toString() + ". " : "";
                                    var interpretationNameToPrint = sequenceText + interpretation.interpretation_name || interpretation.interpretation_text;
                                    tocItemsForOIPair.push(m("td", { "class": "narrafirma-catalysis-report-interpretation-links-table-td" }, m("a", { href: "#c_" + clusterIndex + "_i_" + i }, printText(interpretationNameToPrint))));
                                    var observationNameToPrint = sequenceText + observation.observationTitle || observation.observationDescription;
                                    tocItemsForOIPair.push(m("td", { "class": "narrafirma-catalysis-report-interpretation-links-table-td" }, m("a", { href: "#c_" + clusterIndex + "_i_" + i + "_o_0" }, printText(observationNameToPrint))));
                                    tocItemsForOIPair.push(m("td", { "class": "narrafirma-catalysis-report-interpretation-links-table-td" }, observation.observationStrength || ""));
                                    tocItemsForCluster.push(m("tr", { "class": "narrafirma-catalysis-report-interpretation-links-table-tr" }, tocItemsForOIPair));
                                }
                            }
                        }
                    }
                    tocItemsForCluster.sort(compareRowsInPerspectiveLinksTable);
                    printItems.push(m("table", { "class": "narrafirma-catalysis-report-interpretation-links-table" }, tocItemsForCluster));
                    printItems.push(m("br"));
                    itemIndex++;
                }
                else if (itemIndex >= cluster.items.length) {
                    clusterIndex++;
                    itemIndex = -1;
                }
                else {
                    var item = cluster.items[itemIndex];
                    if (item.print) {
                        var interpretation = project.tripleStore.makeObject(item.referenceUUID, true);
                        if (interpretation && (interpretation.interpretation_name || interpretation.interpretation_text)) {
                            var interpretationNameWithoutSpaces = replaceSpacesWithDashes(interpretation.interpretation_name || "");
                            var idTag = "c_" + clusterIndex + "_i_" + itemIndex;
                            var headerItems = [];
                            headerItems.push(m("span", { "class": "narrafirma-catalysis-report-interpretation-label " + interpretationNameWithoutSpaces }, printText(options.interpretationLabel)));
                            headerItems.push(componentWithSequenceNumber(clusterIndex, -1, itemIndex, options));
                            headerItems.push(printText(interpretation.interpretation_name || ""));
                            printItems.push(m("h4.narrafirma-catalysis-report-interpretation", { "id": idTag }, headerItems));
                            var linkingQuestion = project.tripleStore.queryLatestC(observationsIDsForInterpretations[item.uuid], "observationLinkingQuestion");
                            if (linkingQuestion) {
                                printItems.push(m("div.narrafirma-catalysis-report-observation-linking-question-by-perspective", printText(linkingQuestion)));
                            }
                            printItems.push(m("div.narrafirma-catalysis-report-interpretation-notes", printText(interpretation.interpretation_text)));
                            printInterpretationQuestionsAsHTMLList(printItems, interpretation.interpretation_questions, options);
                            if (interpretation.interpretation_idea) {
                                printItems.push(m("div.narrafirma-catalysis-report-interpretation-idea", options.interpretationIdeaLabel ? m("span.narrafirma-catalysis-report-interpretation-idea-label", printText(options.interpretationIdeaLabel)) : [], printText(interpretation.interpretation_idea)));
                            }
                            printItems.push(printObservation(observationsIDsForInterpretations[item.uuid], itemIndex, clusterIndex, idTag + "_o_0", false, "perspectives", allStories, options));
                            progressModel.progressText = progressText(clusterIndex, itemIndex);
                            progressModel.redraw();
                        }
                    }
                    itemIndex++;
                }
                setTimeout(function () { printNextInterpretation(); }, 0);
            }
        }
        setTimeout(function () { printNextInterpretation(); }, 0);
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Catalysis report - printing lists of observations or interpretations
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function printObservation(observationID, observationIndex, clusterIndex, idTagStart, printLinkingQuestion, themesOrPerspectives, allStories, options) {
        var project = Globals.project();
        var observation = project.tripleStore.makeObject(observationID);
        if (!observation)
            return [];
        var resultItems = [];
        var headerItems = [];
        headerItems.push(m("span", { "class": "narrafirma-catalysis-report-observation-label" }, printText(options.observationLabel)));
        headerItems.push(componentWithSequenceNumber(clusterIndex, -1, observationIndex, options));
        headerItems.push(m("span", { "class": "narrafirma-catalysis-report-observation-title" }, printText(observation.observationTitle || observation.observationDescription)));
        var strengthStringToPrint = observation.observationStrength ? " Strength: " + observation.observationStrength : "";
        headerItems.push(m("span", { "class": "narrafirma-catalysis-report-observation-strength" }, strengthStringToPrint));
        var idTagTouse = idTagStart;
        if (idTagTouse.indexOf("_o_") < 0)
            idTagTouse += "_o_" + observationIndex;
        resultItems.push(m("h3.narrafirma-catalysis-report-observation", { "id": idTagTouse }, headerItems));
        resultItems.push(m("div.narrafirma-catalysis-report-observation-description", printText(observation.observationDescription)));
        var selectionCallback;
        if (graphTypesThatDontGetPrinted.indexOf(observation.pattern.graphType) >= 0) {
            resultItems.push(printReturnAndBlankLine());
        }
        else {
            var pattern = observation.pattern;
            selectionCallback = function () { return this; };
            var graphHolder = initializedGraphHolder(allStories, options);
            var hideNoAnswerValues = PatternExplorer.getOrSetWhetherNoAnswerValuesShouldBeHiddenForPattern(project, options.catalysisReportIdentifier, pattern);
            graphHolder.patternDisplayConfiguration.hideNoAnswerValues = hideNoAnswerValues;
            var useLumpingCommands = PatternExplorer.getOrSetWhetherLumpingCommandsShouldBeUsedForPattern(project, options.catalysisReportIdentifier, pattern);
            graphHolder.patternDisplayConfiguration.useLumpingCommands = useLumpingCommands;
            var graph = PatternExplorer.makeGraph(pattern, graphHolder, selectionCallback, !options.showStatsPanelsInReport);
            if (graph)
                resultItems.push(printGraphWithGraphHolder(graphHolder, options.customGraphCSS));
        }
        if (observation.observationExtraPatterns) {
            var allQuestions_1 = project.allQuestionsThatCouldBeGraphedForCatalysisReport(options.catalysisReportIdentifier, true);
            // one pattern per line
            var patternTexts = observation.observationExtraPatterns.split("\n");
            patternTexts.forEach(function (patternText) {
                // the question short names MUST be in the order they are in the patterns table (because some of the graphs require a certain order)
                var questionNames = patternText.split('==');
                if (questionNames.length) {
                    // look up questions
                    var questions_1 = [];
                    questionNames.forEach(function (questionName) {
                        for (var i = 0; i < allQuestions_1.length; i++) {
                            if (allQuestions_1[i].displayName === questionName.trim()) {
                                questions_1.push(allQuestions_1[i]);
                            }
                        }
                    });
                    // generate graph
                    if (questions_1.length > 0) {
                        var graphType = graphTypeForListOfQuestions(questions_1);
                        var extraPattern = { "graphType": graphType, "questions": questions_1 };
                        var extraGraphHolder = initializedGraphHolder(allStories, options);
                        // the "show no answer values" option is whatever was set on the OTHER pattern that is being referenced here
                        var hideNoAnswerValues = PatternExplorer.getOrSetWhetherNoAnswerValuesShouldBeHiddenForPattern(project, options.catalysisReportIdentifier, extraPattern);
                        extraGraphHolder.patternDisplayConfiguration.hideNoAnswerValues = hideNoAnswerValues;
                        var useLumpingCommands = PatternExplorer.getOrSetWhetherLumpingCommandsShouldBeUsedForPattern(project, options.catalysisReportIdentifier, extraPattern);
                        extraGraphHolder.patternDisplayConfiguration.useLumpingCommands = useLumpingCommands;
                        var extraGraph = PatternExplorer.makeGraph(extraPattern, extraGraphHolder, selectionCallback, !options.showStatsPanelsInReport);
                        if (extraGraph)
                            resultItems.push(printGraphWithGraphHolder(extraGraphHolder, options.customGraphCSS));
                    }
                }
            });
        }
        if (printLinkingQuestion && observation.observationLinkingQuestion) {
            var linkingQuestionClass = "";
            if (themesOrPerspectives = "themes") {
                linkingQuestionClass = "div.narrafirma-catalysis-report-observation-linking-question-by-theme";
            }
            else {
                linkingQuestionClass = "div.narrafirma-catalysis-report-observation-linking-question-by-perspective";
            }
            resultItems.push(m(linkingQuestionClass, printText(observation.observationLinkingQuestion)));
        }
        return [resultItems];
    }
    function graphTypeForListOfQuestions(questions) {
        var result = "";
        if (questions.length === 1) {
            if (questions[0].displayType === "slider") {
                return "histogram"; // one scale
            }
            else {
                return "bar"; // one choice
            }
        }
        else if (questions.length === 2) {
            if (questions[0].displayType !== "slider" && questions[1].displayType !== "slider") {
                return "table";
            }
            else if (questions[0].displayType === "slider" && questions[1].displayType === "slider") {
                return "scatter";
            }
            else {
                return "multiple histogram";
            }
        }
        else if (questions.length === 3) {
            if (questions[0].displayType === "slider" && questions[1].displayType === "slider") {
                return "multiple scatter"; // two scales, one choice
            }
            else {
                return "contingency-histogram"; // two choices, one scale
            }
        }
    }
    function initializedGraphHolder(allStories, options) {
        var graphHolder = {
            graphResultsPane: charting.createGraphResultsPane("narrafirma-graph-results-pane chartEnclosure"),
            chartPanes: [],
            allStories: allStories,
            currentGraph: null,
            currentSelectionExtentPercentages: null,
            excludeStoryTooltips: true,
            minimumStoryCountRequiredForTest: options.minimumStoryCountRequiredForTest,
            minimumStoryCountRequiredForGraph: options.minimumStoryCountRequiredForGraph,
            numHistogramBins: options.numHistogramBins,
            numScatterDotOpacityLevels: options.numScatterDotOpacityLevels,
            scatterDotSize: options.scatterDotSize,
            correlationMapShape: options.correlationMapShape,
            correlationMapIncludeScaleEndLabels: options.correlationMapIncludeScaleEndLabels,
            correlationMapCircleDiameter: options.correlationMapCircleDiameter,
            correlationLineChoice: options.correlationLineChoice,
            customLabelLengthLimit: options.customLabelLengthLimit,
            hideNumbersOnContingencyGraphs: options.hideNumbersOnContingencyGraphs,
            outputGraphFormat: options.outputGraphFormat,
            outputFontModifierPercent: options.outputFontModifierPercent,
            showStatsPanelsInReport: options.showStatsPanelsInReport,
            customStatsTextReplacements: options.customStatsTextReplacements,
            customGraphWidth: options.customGraphWidth,
            customGraphHeight: options.customGraphHeight,
            patternDisplayConfiguration: { hideNoAnswerValues: false, useLumpingCommands: true },
            adjustedCSS: options.adjustedCSS,
            lumpingCommands: options.lumpingCommands,
            graphTypesToCreate: {}
        };
        return graphHolder;
    }
    function printListOfInterpretations(interpretationList, observationIndex, clusterIndex, idTagStart, options) {
        function printInterpretation(interpretation, index) {
            var headerItems = [];
            headerItems.push(m("span", { "class": "narrafirma-catalysis-report-interpretation-label" }, printText(options.interpretationLabel)));
            headerItems.push(componentWithSequenceNumber(clusterIndex, observationIndex, index, options));
            headerItems.push(m("span", { "class": "narrafirma-catalysis-report-observation-title" }, printText(interpretation.interpretation_name)));
            var resultItems = [];
            resultItems.push(m("h3.narrafirma-catalysis-report-interpretation", { "id": idTagStart + "_i_" + index }, headerItems));
            resultItems.push(m("div.narrafirma-catalysis-report-interpretation-notes", printText(interpretation.interpretation_text)));
            printInterpretationQuestionsAsHTMLList(resultItems, interpretation.interpretation_questions, options);
            if (interpretation.interpretation_idea) {
                resultItems.push(m("div.narrafirma-catalysis-report-interpretation-idea", options.interpretationIdeaLabel ? m("span.narrafirma-catalysis-report-interpretation-idea-label", printText(options.interpretationIdeaLabel)) : [], printText(interpretation.interpretation_idea)));
            }
            return resultItems;
        }
        var printAsTable = options.useTableForInterpretationsFollowingObservation;
        var result = [];
        var row = [];
        var project = Globals.project();
        interpretationList.forEach(function (id, index) {
            var item = project.tripleStore.makeObject(id, true);
            if (printAsTable) {
                row.push(m("td", m("div", { "class": "narrafirma-catalysis-report-list-table-td-div" }, printInterpretation(item, index))));
            }
            else {
                result.push(printInterpretation(item, index));
                result.push([printReturn()]);
            }
        });
        if (printAsTable)
            result.push(m("table", { "class": "narrafirma-catalysis-report-list-table" }, m("tr", row)));
        return result;
    }
    function printInterpretationQuestionsAsHTMLList(printItems, questionsText, options) {
        if (!questionsText)
            return;
        var html;
        var questionsAsList = questionsText.split("\n");
        if (questionsAsList.length > 1) {
            html = "<ul>";
            questionsAsList.forEach(function (item) { if (item)
                html += "<li>" + item + "</li>"; });
            html += "</ul>";
        }
        else {
            html = questionsText;
        }
        if (html) {
            printItems.push(m("div.narrafirma-catalysis-report-interpretation-questions", options.interpretationQuestionsLabel ? m("div.narrafirma-catalysis-report-interpretation-questions-label", printText(options.interpretationQuestionsLabel)) : [], printText(html)));
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Catalysis report - printing graphs
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function printGraphWithGraphHolder(graphHolder, customCSS) {
        // TODO: why are bar graphs and histograms drawn with a left axis color of #C26E00 when this never appears in the code? canvg thing?
        if (graphHolder.chartPanes.length > 1) {
            // multiple graphs
            var result = [];
            // Add the title
            result.push(m.trust(graphHolder.chartPanes[0].outerHTML));
            // Add the charts, in rows of three across
            // chartPanes starts at 1 because 0 is the title
            var numRowsToCreate = Math.floor((graphHolder.chartPanes.length - 1) / 3) + 1;
            var rows = [];
            for (var rowIndex = 0; rowIndex < numRowsToCreate; rowIndex++) {
                var columnsForThisRow = [];
                for (var colIndex = 0; colIndex < 3; colIndex++) {
                    var graphIndex = rowIndex * 3 + colIndex + 1;
                    if (graphIndex >= graphHolder.chartPanes.length)
                        break;
                    var graphPane = graphHolder.chartPanes[graphIndex];
                    var graph = printGraphWithGraphNode(graphPane, graphHolder, customCSS);
                    if (graph)
                        columnsForThisRow.push(m("td", graph));
                }
                rows.push(m("tr", columnsForThisRow));
            }
            result.push(m("table", { "class": "narrafirma-print-multiple-graphs" }, rows));
            // Add the overall statistics (for all panes)
            if (graphHolder.showStatsPanelsInReport) {
                var statisticsPanel = graphHolder.graphResultsPane.lastChild;
                result.push(m.trust(statisticsPanel.outerHTML));
            }
            return result;
        }
        else {
            var result = [];
            var graph = printGraphWithGraphNode(graphHolder.graphResultsPane.firstChild, graphHolder, customCSS);
            if (graph)
                result.push(graph);
            return result;
        }
    }
    function printGraphWithGraphNode(graphNode, graphHolder, customCSS) {
        var svgNode = graphNode.querySelector("svg");
        if (!svgNode)
            return null;
        svgNode.setAttribute("version", "1.1");
        svgNode.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        svgNode.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
        var titleNode = graphNode.querySelector(".narrafirma-graph-title");
        var statisticsNode = graphNode.querySelector(".narrafirma-statistics-panel");
        var styleNode = document.createElement("style");
        styleNode.setAttribute('type', 'text/css');
        var styleDefs = graphStyle.graphResultsPaneCSS(svgNode);
        styleDefs = graphStyle.modifyFontSize(styleDefs, graphHolder.outputFontModifierPercent);
        var styleNodeText = "<![CDATA[\n" + styleDefs + ((customCSS) ? customCSS : "") + "]]>";
        styleNode.innerHTML = styleNodeText;
        svgNode.insertBefore(styleNode, svgNode.firstChild);
        var result = [];
        if (titleNode)
            result.push(m.trust(titleNode.outerHTML));
        if (graphHolder.outputGraphFormat === "PNG") {
            var canvas = document.createElement("canvas");
            try {
                canvg(canvas, svgNode.outerHTML);
            }
            catch (error) {
                alert("Please check your custom CSS. It appears to be badly formed: " + error);
                return null;
            }
            var imgData = canvas.toDataURL("image/png");
            var imageForGraph = m("img", {
                class: "narrafirma-catalysis-report-graph",
                alt: "observation graph",
                src: imgData
            });
            result.push(m("div.narrafirma-graph-image", imageForGraph || []));
        }
        else if (graphHolder.outputGraphFormat === "SVG") {
            result.push(m("div.narrafirma-graph-image", m.trust(svgNode.outerHTML)));
        }
        else {
            throw Error("Unsupported graph type: " + graphHolder.outputGraphFormat);
        }
        if (graphHolder.showStatsPanelsInReport && statisticsNode) {
            result.push(m.trust(statisticsNode.outerHTML));
        }
        return result;
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Catalysis report - support functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function componentWithSequenceNumber(topLevelIndex, middleLevelIndex, bottomLevelIndex, options) {
        var result = null;
        if (options.printItemIndexNumbers) {
            var sequenceText = "";
            if (topLevelIndex >= 0)
                sequenceText += (topLevelIndex + 1).toString() + ".";
            if (middleLevelIndex >= 0)
                sequenceText += (middleLevelIndex + 1).toString() + ".";
            if (bottomLevelIndex >= 0)
                sequenceText += (bottomLevelIndex + 1).toString() + ".";
            sequenceText += " ";
            if (sequenceText)
                result = m("span", { class: "narrafirma-catalysis-report-sequence-number" }, sequenceText);
        }
        return result;
    }
    function numItemsOutOfListToPrint(items) {
        var result = 0;
        items.forEach(function (item) {
            if (item.print)
                result++;
        });
        return result;
    }
    function finishCatalysisReport(project, catalysisReportName, catalysisReportIdentifier, printItems, progressModel, options) {
        printItems.push(m("div.narrafirma-catalysis-report-conclusion", options["conclusion"]));
        progressModel.hideDialogMethod();
        // Trying to avoid popup warning if open window from timeout by using finish dialog button press to display results
        var finishModel = dialogSupport.openFinishedDialog("Done creating report; display it?", "Finished generating catalysis report", "Display", "Cancel", function (dialogConfiguration, hideDialogMethod) {
            var customCSS = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_customCSS");
            var htmlForPage = generateHTMLForPage(catalysisReportName, "css/standard.css", customCSS, printItems, null);
            printHTML(htmlForPage);
            hideDialogMethod();
            progressModel.redraw();
        });
        finishModel.redraw();
    }
    function clustersThatMatchObservationIDList(project, clusteringDiagram, perspectivesOrThemes, observationIDs) {
        var _a = ClusteringDiagram.calculateClusteringForDiagram(clusteringDiagram), clusters = _a[0], items = _a[1];
        var clustersToPrint = [];
        clusters.forEach(function (cluster) {
            if (cluster.hidden)
                return;
            cluster.items.forEach(function (item) {
                if (perspectivesOrThemes === "perspectives") {
                    if (item.hidden) {
                        item.print = false;
                    }
                    else {
                        // the item is an interpretation; find out if any of these observations are connected to it
                        var includedObservationIDsLinkedToThisInterpretation = makeObservationIDsListForInterpretation(project, observationIDs, item);
                        if (includedObservationIDsLinkedToThisInterpretation.length > 0) {
                            if (clustersToPrint.indexOf(cluster) < 0)
                                clustersToPrint.push(cluster);
                            item.print = true;
                        }
                        else {
                            item.print = false;
                        }
                    }
                }
                else if (perspectivesOrThemes === "themes") {
                    if (item.hidden) {
                        item.print = false;
                    }
                    else {
                        // the item is an observation; just check the id 
                        if (observationIDs.indexOf(item.referenceUUID) >= 0) {
                            if (clustersToPrint.indexOf(cluster) < 0)
                                clustersToPrint.push(cluster);
                            item.print = true;
                        }
                        else {
                            item.print = false;
                        }
                    }
                }
            });
        });
        return clustersToPrint;
    }
    function addPrintItemsForTOCLevelOne(printItems, tocHeaderRaw, clusters, clusterName, options) {
        if (!tocHeaderRaw)
            tocHeaderRaw = clusterName + " in this report (#):";
        var numberSignIndex = tocHeaderRaw.indexOf("#");
        if (numberSignIndex >= 0) {
            tocHeaderRaw = tocHeaderRaw.replace("#", clusters.length);
        }
        var tocHeader;
        try {
            tocHeader = sanitizeHTML.generateSanitizedHTMLForMithril(tocHeaderRaw);
        }
        catch (error) {
            alert("Problem in catalysis report contents header (first level): " + error);
        }
        printItems.push(m("div.narrafirma-catalysis-report-toc-link-header", tocHeader));
        for (var i = 0; i < clusters.length; i++) {
            var cluster = clusters[i];
            var sequenceText = options.printItemIndexNumbers ? (i + 1).toString() + ". " : "";
            printItems.push(m("div.narrafirma-catalysis-report-toc-link", m("a", { href: "#c_" + i }, sequenceText, printText(cluster.name))));
        }
    }
    function addPrintHeaderForTOCLevelTwo(printItems, project, catalysisReportIdentifier, reportType, headerID, defaultHeader, numItems) {
        var tocHeaderLevelTwoRaw = project.tripleStore.queryLatestC(catalysisReportIdentifier, headerID);
        if (!tocHeaderLevelTwoRaw)
            tocHeaderLevelTwoRaw = defaultHeader;
        var numberSignIndex = tocHeaderLevelTwoRaw.indexOf("#");
        if (numberSignIndex >= 0) {
            tocHeaderLevelTwoRaw = tocHeaderLevelTwoRaw.replace("#", numItems);
        }
        var tocHeaderLevelTwo;
        try {
            tocHeaderLevelTwo = sanitizeHTML.generateSanitizedHTMLForMithril(tocHeaderLevelTwoRaw);
        }
        catch (error) {
            alert("Problem in catalysis report contents header (second level): " + error);
        }
        var divClass;
        if (reportType === "themes") {
            divClass = "div.narrafirma-catalysis-report-theme-link-header";
        }
        else if (reportType === "perspectives") {
            divClass = "div.narrafirma-catalysis-report-perspective-link-header";
            printItems.push(m("br"));
        }
        printItems.push(m(divClass, tocHeaderLevelTwo));
    }
    function addPrintItemsForReportStart(printItems, project, catalysisReportName, catalysisReportIdentifier, allStories, options) {
        // title and report creation info
        printItems.push(m("h1.narrafirma-catalysis-report-title", printText(catalysisReportName)));
        var hideReportCreationInfo = project.tripleStore.queryLatestC(catalysisReportIdentifier, "hideReportCreationInfo");
        if (!hideReportCreationInfo) {
            printItems.push(m("div.narrafirma-catalysis-report-project-name-and-date", "This report for project " + project.projectNameOrNickname() + " was generated by NarraFirma " + versions.narrafirmaApplication + " on " + new Date().toString()));
        }
        // filter (if applicable)
        var filter = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_filter");
        if (filter)
            printItems.push(filterWarningForCatalysisReport(filter, allStories));
        // introduction and "about this report" section
        printItems.push(m("div.narrafirma-catalysis-report-intro-note", options["reportNotes"]));
        printItems.push(m("div.narrafirma-catalysis-report-about", options["aboutReport"]));
    }
    function getAndCleanUserText(project, catalysisReportIdentifier, id, errorMsg) {
        var textRaw = project.tripleStore.queryLatestC(catalysisReportIdentifier, id);
        var text;
        try {
            text = sanitizeHTML.generateSanitizedHTMLForMithril(textRaw);
        }
        catch (error) {
            alert("Problem in catalysis report " + errorMsg + ": " + error);
        }
        return text;
    }
    function filterWarningForCatalysisReport(filter, allStories) {
        var storyOrStoriesText = " stories";
        if (allStories.length == 1)
            storyOrStoriesText = " story";
        // TODO: translation
        var labelText = 'This report only pertains to stories that match the filter "' + filter + '" (' + allStories.length + storyOrStoriesText + ")";
        return m("div", { "class": "narrafirma-catalysis-report-filter-warning" }, sanitizeHTML.generateSanitizedHTMLForMithril(labelText));
    }
    function compareRowsInPerspectiveLinksTable(a, b) {
        var strengthStrings = ["1 (weak)", "2 (medium)", "3 (strong)"];
        var strengthInA = "";
        var strengthInB = "";
        // this will not work if strength is not in the third column of the table; need to change if change format of table
        if (a.children.length > 2 && a.children[2].children.length > 0) {
            strengthInA = a.children[2].children[0];
        }
        if (b.children.length > 2 && b.children[2].children.length > 0) {
            strengthInB = b.children[2].children[0];
        }
        if (strengthInA && strengthInB) {
            var indexOfA = strengthStrings.indexOf(strengthInA);
            var indexOfB = strengthStrings.indexOf(strengthInB);
            if (indexOfA > indexOfB) {
                return -1;
            }
            else if (indexOfB > indexOfA) {
                return 1;
            }
            else {
                return 0;
            }
        }
        else if (strengthInA) {
            return -1;
        }
        else if (strengthInB) {
            return 1;
        }
        else {
            return 0;
        }
    }
    function makeObservationIDsListForInterpretation(project, observationIDs, item) {
        var result = [];
        observationIDs.forEach(function (observationID) {
            var interpretationsListIdentifier = project.tripleStore.queryLatestC(observationID, "observationInterpretations");
            var interpretationsList = project.tripleStore.getListForSetIdentifier(interpretationsListIdentifier);
            interpretationsList.forEach(function (interpretationIdentifier) {
                var interpretation = project.tripleStore.makeObject(interpretationIdentifier, true);
                if (item.referenceUUID !== undefined) {
                    if (interpretationIdentifier === item.referenceUUID) {
                        result.push(observationID);
                    }
                }
                else {
                    if (interpretation.interpretation_name === item.name || interpretation.interpretation_text === item.text) {
                        item.referenceUUID = interpretationIdentifier;
                        result.push(observationID);
                    }
                }
            });
        });
        return result;
    }
    exports.makeObservationIDsListForInterpretation = makeObservationIDsListForInterpretation;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Printing story form
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function generateHTMLForQuestionnaire(questionnaire) {
        // TODO: Translate
        var vdom = m(".narrafirma-questionnaire-for-printing", [
            "\n",
            m("div.narrafirma-survey-print-title", printText(questionnaire.title)),
            m("div.narrafirma-survey-print-intro", printText(questionnaire.startText)),
            m("div.narrafirma-survey-print-please-select", printText(questionnaire.chooseQuestionText) || "Please choose a question to which you would like to respond."),
            questionnaire.elicitingQuestions.map(function (elicitingQuestion) {
                return printOption(elicitingQuestion.text);
            }),
            m("div.narrafirma-survey-print-enter-response", printText(questionnaire.enterStoryText) || "Please enter your response here."),
            m("div.narrafirma-survey-print-name-story", printText(questionnaire.nameStoryText) || "Please give your story a name."),
            questionnaire.storyQuestions.map(function (storyQuestion) {
                return printQuestion(storyQuestion);
            }),
            questionnaire.participantQuestions.length >= 1 ? m("div.narrafirma-survey-print-about-you-text", printText(questionnaire.aboutYouText || "About you")) : "",
            questionnaire.participantQuestions.map(function (participantQuestion) {
                return printQuestion(participantQuestion);
            }),
            m("div.narrafirma-survey-print-end-text", printText(questionnaire.endText || ""))
        ]);
        return generateHTMLForPage(questionnaire.title || "NarraFirma Story Form", "css/survey.css", questionnaire.customCSSForPrint, vdom, null);
    }
    function printStoryForm(model, fieldSpecification, value) {
        var storyCollectionName = Globals.clientState().storyCollectionName();
        if (!storyCollectionName) {
            // TODO: translate
            alert("Please select a story collection first.");
            return null;
        }
        var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName);
        if (!questionnaire)
            return;
        var output = generateHTMLForQuestionnaire(questionnaire);
        printHTML(output);
    }
    exports.printStoryForm = printStoryForm;
    function printPrivacyPolicy(model, fieldSpecification, value) {
        var project = Globals.project();
        if (!project)
            return;
        var vdom = m(".narrafirma-privacy-policy", [
            m("div.narrafirma-privacy-policy-header", project.projectNameOrNickname() + ": Privacy Policy"),
            m("div.narrafirma-privacy-policy-item", printText(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_collect"))),
            m("div.narrafirma-privacy-policy-item", printText(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_identification"))),
            m("div.narrafirma-privacy-policy-item", printText(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_nondisclosure"))),
            m("div.narrafirma-privacy-policy-item", printText(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_distribution"))),
            m("div.narrafirma-privacy-policy-item", printText(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_invitation"))),
            m("div.narrafirma-privacy-policy-item", printText(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_permission"))),
            m("div.narrafirma-privacy-policy-item", printText(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_review"))),
        ]);
        var output = generateHTMLForPage(project.projectNameOrNickname() + ": Privacy Policy", "css/survey.css", null, vdom, null);
        printHTML(output);
    }
    exports.printPrivacyPolicy = printPrivacyPolicy;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Printing story cards
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function printStoryCards() {
        var storyCollectionName = Globals.clientState().storyCollectionName();
        var storyCollectionIdentifier = Globals.clientState().storyCollectionIdentifier();
        if (!storyCollectionName) {
            alert("Please select a story collection for which to print story cards.");
            return;
        }
        var project = Globals.project();
        var filter = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_filter");
        var storiesForThisCollection = surveyCollection.getStoriesForStoryCollection(storyCollectionName);
        var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName);
        var filteredStories = null;
        if (filter) {
            filter = filter.trim();
            filteredStories = project.storiesForStoryCollectionWithFilter(storyCollectionIdentifier, storiesForThisCollection, questionnaire, filter, true);
        }
        else {
            filteredStories = storiesForThisCollection;
        }
        if (!filteredStories.length) {
            alert("There are no stories in the collection. Please add some stories before you print story cards.");
            return;
        }
        var questionsToInclude = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_questionsToInclude");
        var customCSS = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_customCSS");
        var beforeSliderCharacter = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_beforeSliderCharacter");
        var sliderButtonCharacter = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_sliderButtonCharacter");
        var afterSliderCharacter = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_afterSliderCharacter");
        var noAnswerSliderCharacter = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_noAnswerSliderCharacter");
        var order = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_order");
        var cutoff = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_storyTextCutoff");
        var cutoffMessage = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_storyTextCutoffMessage");
        var includeIndex = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_includeIndexInStoryCollection");
        var includeWriteInAnswers = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_includeWriteInTexts");
        var lumpingCommands = project.lumpingCommandsForStoryCollection(storyCollectionName);
        var sliderBucketCount = parseInt(project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_sliderBucketCount"));
        if (!sliderBucketCount)
            sliderBucketCount = 50;
        var numColumns = parseInt(project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_numColumns"));
        if (!numColumns)
            numColumns = 1;
        var hideNonSelectedAnswers = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_hideNonSelectedAnswers");
        var betweenAnswerText = project.tripleStore.queryLatestC(storyCollectionName, "printStoryCards_betweenAnswerText");
        var storyDivs = [];
        if (filter)
            storyDivs.push(m("div.storyCardFilterWarning", "Stories that match filter [" + filter + "] (" + filteredStories.length + ")"));
        var columnIndex = 1;
        var rowTRs = [];
        var columnTDs = [];
        for (var storyIndex = 0; storyIndex < filteredStories.length; storyIndex++) {
            var storyModel = filteredStories[storyIndex];
            var options = {
                storyTextAtTop: true,
                beforeSliderCharacter: beforeSliderCharacter,
                sliderButtonCharacter: sliderButtonCharacter,
                afterSliderCharacter: afterSliderCharacter,
                noAnswerSliderCharacter: noAnswerSliderCharacter,
                sliderBucketCount: sliderBucketCount,
                order: order,
                cutoff: cutoff,
                cutoffMessage: cutoffMessage,
                includeIndex: includeIndex,
                includeWriteInAnswers: includeWriteInAnswers,
                lumpingCommands: lumpingCommands,
                hrAtBottom: numColumns === 1,
                blankLineAfterStory: true,
                hideNonSelectedAnswers: hideNonSelectedAnswers,
                betweenAnswerText: betweenAnswerText
            };
            var storyContent = storyCardDisplay.generateStoryCardContent(storyModel, questionsToInclude, options);
            var storyDiv = m("div.storyCardForPrinting", storyContent);
            if (numColumns <= 1) {
                storyDivs.push(storyDiv);
            }
            else {
                if (columnIndex === 1)
                    columnTDs = [];
                columnTDs.push(m("td.narrafirma-story-card-for-printing-table", storyDiv));
                columnIndex++;
                if (columnIndex > numColumns) {
                    rowTRs.push(m("tr.narrafirma-story-card-for-printing-table", columnTDs));
                    columnIndex = 1;
                }
            }
        }
        if (numColumns && numColumns > 1) {
            storyDivs.push(m("table.narrafirma-story-card-for-printing-table", rowTRs));
        }
        var htmlForPage = generateHTMLForPage("Story cards for: " + storyCollectionName, "css/standard.css", customCSS, storyDivs, null);
        // carriage returns inside and between spans cause extra padding, which we don't want in this case
        htmlForPage = replaceAll(htmlForPage, "\n</span>", "</span>");
        htmlForPage = replaceAll(htmlForPage, "</span>\n<span>", "</span><span>");
        printHTML(htmlForPage);
    }
    exports.printStoryCards = printStoryCards;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Printing presentation outline
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function exportPresentationOutline() {
        var project = Globals.project();
        var presentationElementsList = project.getListForField("project_presentationElementsList");
        var printItems = [];
        var listDivs = [];
        presentationElementsList.forEach(function (id, index) {
            var item = project.tripleStore.makeObject(id, true);
            // pull out name of element and write it first as a header
            var fieldNames = Object.keys(item);
            var header = "";
            for (var i = 0; i < fieldNames.length; i++) {
                if (fieldNames[i] === "projectPresentationElement_name") {
                    header = item[fieldNames[i]];
                    break;
                }
            }
            if (header)
                listDivs.push(m("div.narrafirma-presentation-line", [m("h2.narrafirma-presentation-element-name", header)]));
            var itemDivs = [];
            for (var _i = 0, fieldNames_1 = fieldNames; _i < fieldNames_1.length; _i++) {
                var fieldName = fieldNames_1[_i];
                if (fieldName === "projectPresentationElement_name")
                    continue;
                var fieldSpecification = Globals.panelSpecificationCollection().getFieldSpecificationForFieldID(fieldName);
                var shortName = fieldSpecification ? fieldSpecification.displayName : "Problem with: " + fieldName;
                itemDivs.push(m("div.narrafirma-presentation-line", [
                    m("span.narrafirma-presentation-item-name", shortName + ": "),
                    m("span.narrafirma-presentation-item-value", item[fieldName])
                ]));
            }
            ;
            listDivs.push(itemDivs);
            listDivs.push([printReturn()]);
        });
        printItems.push(listDivs);
        printItems.push(m("div.narrafirma-presentation-timestamp", "Presentation Outline generated " + new Date()));
        var htmlForPage = generateHTMLForPage("Presentation Outline", "css/standard.css", null, printItems, null);
        printHTML(htmlForPage);
    }
    exports.exportPresentationOutline = exportPresentationOutline;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Printing session agendas
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function exportCollectionSessionAgenda(itemID) {
        var project = Globals.project();
        var collectionSessionAgenda = project.tripleStore.makeObject(itemID, true);
        var activitiesListID = collectionSessionAgenda["collectionSessionPlan_activitiesList"];
        var activitiesList = project.tripleStore.getListForSetIdentifier(activitiesListID);
        var printItems = [];
        printItems.push([printAgendaItem(collectionSessionAgenda, { collectionSessionPlan_activitiesList: true })]);
        activitiesList.sort(function (a, b) {
            var aObject = project.tripleStore.makeObject(a, true);
            var bObject = project.tripleStore.makeObject(b, true);
            return (aObject.order < bObject.order) ? -1 : 1;
        });
        printItems.push(m("div.narrafirma-session-activities-intro", "Session activities"));
        printItems.push(printActivitiesList(activitiesList, {}));
        printItems.push(m("div.narrafirma-session-timestamp", "Story collection session agenda generated " + new Date()));
        var htmlForPage = generateHTMLForPage("Story collection session agenda", "css/standard.css", null, printItems, null);
        printHTML(htmlForPage);
    }
    exports.exportCollectionSessionAgenda = exportCollectionSessionAgenda;
    function printSensemakingSessionAgenda(itemID) {
        var project = Globals.project();
        var sensemakingSessionAgenda = project.tripleStore.makeObject(itemID, true);
        var activitiesListID = sensemakingSessionAgenda["sensemakingSessionPlan_activitiesList"];
        var activitiesList = project.tripleStore.getListForSetIdentifier(activitiesListID);
        var printItems = [];
        printItems.push([printAgendaItem(sensemakingSessionAgenda, { sensemakingSessionPlan_activitiesList: true })]);
        activitiesList.sort(function (a, b) {
            var aObject = project.tripleStore.makeObject(a, true);
            var bObject = project.tripleStore.makeObject(b, true);
            return (aObject.order < bObject.order) ? -1 : 1;
        });
        printItems.push(m("div.narrafirma-session-activities-intro", "Session activities"));
        printItems.push(printActivitiesList(activitiesList, {}));
        printItems.push(m("div.narrafirma-session-timestamp", "Sensemaking session agenda generated " + new Date()));
        var htmlForPage = generateHTMLForPage("Sensemaking session agenda", "css/standard.css", null, printItems, null);
        printHTML(htmlForPage);
    }
    exports.printSensemakingSessionAgenda = printSensemakingSessionAgenda;
    function printActivitiesList(list, fieldsToIgnore) {
        var result = [];
        var row = [];
        var project = Globals.project();
        list.forEach(function (id, index) {
            var item = project.tripleStore.makeObject(id, true);
            result.push(printAgendaItem(item, fieldsToIgnore));
        });
        return result;
    }
    function printAgendaItem(item, fieldsToIgnore) {
        var result = [];
        // pull out name of session or activity and write it first as a header
        var sessionHeaderFieldNames = ["collectionSessionPlan_name", "sensemakingSessionPlan_name"];
        var activityHeaderFieldNames = ["collectionSessionActivity_name", "sensemakingSessionPlan_activity_name"];
        var fieldNames = Object.keys(item);
        var headerFieldName = "";
        var header = "";
        var isActivity = false;
        for (var i = 0; i < fieldNames.length; i++) {
            if (sessionHeaderFieldNames.indexOf(fieldNames[i]) >= 0 || activityHeaderFieldNames.indexOf(fieldNames[i]) >= 0) {
                headerFieldName = fieldNames[i];
                header = item[headerFieldName];
                if (activityHeaderFieldNames.indexOf(headerFieldName) >= 0)
                    isActivity = true;
                break;
            }
        }
        if (header) {
            if (isActivity) {
                result.push(m("div.narrafirma-session-line", [m("h2.narrafirma-session-activity-name", header)]));
            }
            else {
                result.push(m("div.narrafirma-session-line", [m("h1.narrafirma-session-name", header)]));
            }
        }
        // now write rest of fields
        for (var _i = 0, fieldNames_2 = fieldNames; _i < fieldNames_2.length; _i++) {
            var fieldName = fieldNames_2[_i];
            if (fieldName === headerFieldName)
                continue;
            if (fieldsToIgnore[fieldName])
                continue;
            var fieldSpecification = Globals.panelSpecificationCollection().getFieldSpecificationForFieldID(fieldName);
            var shortName = fieldSpecification ? fieldSpecification.displayName : "Problem with: " + fieldName;
            var fieldValue = item[fieldName];
            result.push(m("div.narrafirma-session-line", [m("span.narrafirma-session-item-name", shortName + ": "), m("span.narrafirma-session-item-value", fieldValue)]));
        }
        ;
        if (isActivity) {
            return [m("div.narrafirma-session-activity-frame", result)];
        }
        else {
            return result;
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Printing project report
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function cssForProjectReport() {
        var result = "div {\n        margin: 0.5em 0 0.5em 0;\n        padding: 0.2em 0 0.2em 0;\n    }\n    \n    .narrafirma-report-title {\n        font-size: 2em;\n    }\n     \n     .narrafirma-report-intro {\n         font-size: 0.9em;\n     }\n     \n     .narrafirma-report-headerpagename {\n         font-size: 1.5em;\n         font-weight: bold;\n         background-color: lightgray;\n         padding: 0.5em;\n     }\n    \n     .narrafirma-report-pagename {\n         font-size: 1.3em;\n         font-weight: bold;\n         border-bottom: 1px solid gray;\n     }\n    \n     .narrafirma-report-header {\n        font-size: 1.2em;\n        font-weight: bold;\n     }\n    \n     .narrafirma-report-label {\n        font-size: 1em;\n     }\n    \n     .narrafirma-report-question-prompt {\n        font-size: 1em;\n     }\n    \n     .narrafirma-report-question-answer {\n         margin-left: 2em;\n         border: 1px solid lightgray;\n         padding-left: 0.5em;\n     }\n    \n     .narrafirma-report-grid-item {\n        margin-left: 2em;\n        border: 2px solid lightgray;\n        padding: 0.5em;\n    }\n    \n    .narrafirma-report-grid-item-name {\n        background-color: #eeeeee;\n        padding: 0.5em;\n    }\n         \n    .narrafirma-report-clusteringdiagram, .narrafirma-report-observationlist, .narrafirma-report-project-story {\n        margin-left: 2em;\n        border: 1px solid lightgray;\n        padding-left: 0.6em;\n     }\n     ";
        return result;
    }
    function printPartsForField(displayType, value) {
        var parts = [];
        if (typeof value === "object") {
            if (displayType === "checkboxes") {
                var options = Object.keys(value);
                parts.push("<div class=\"narrafirma-report-question-answer\">");
                options.forEach(function (option) {
                    if (option)
                        parts.push(option + "<br/>");
                });
                parts.push("</div>");
            }
        }
        else {
            if (typeof value === "string")
                value = replaceAll(value, "\n", "<br/>");
            parts.push("<div class=\"narrafirma-report-question-answer\">" + value + "</div>");
        }
        return parts;
    }
    function printPartsForGrid(field, panelSpecificationCollection, tripleStore, parentID, displayTypesNotToShow) {
        var parts = [];
        var gridHasUserContent = false;
        var gridPanel = panelSpecificationCollection.getPanelSpecificationForPanelID(field.displayConfiguration);
        if (gridPanel) {
            parts.push("<div class=\"narrafirma-report-question-prompt\">" + field.displayPrompt + "</div>");
            var singularGridItemName_1 = "";
            var lastThreeChars = field.displayName.slice(-3);
            if (lastThreeChars === "ies") {
                singularGridItemName_1 = field.displayName.slice(0, -3) + "y";
            }
            else {
                singularGridItemName_1 = field.displayName.slice(0, -1);
            }
            var setIdentifier = tripleStore.queryLatestC(parentID, field.id);
            var itemIDs = tripleStore.getListForSetIdentifier(setIdentifier);
            var items_1 = [];
            itemIDs.forEach(function (itemID) {
                var item = tripleStore.makeObject(itemID);
                item.itemID = itemID;
                if (item)
                    items_1.push(item);
            });
            items_1 = items_1.sort(function (a, b) { return (a.order > b.order) ? 1 : -1; });
            var itemCount_1 = 1;
            items_1.forEach(function (item) {
                parts.push("<div class=\"narrafirma-report-grid-item\">");
                parts.push("<div class=\"narrafirma-report-grid-item-name\">" + singularGridItemName_1 + " " + itemCount_1 + "</div>");
                gridPanel.panelFields.forEach(function (gridField) {
                    if (displayTypesNotToShow.indexOf(gridField.displayType) >= 0)
                        return;
                    if (gridField.displayType === "grid") {
                        var gridParts = printPartsForGrid(gridField, panelSpecificationCollection, tripleStore, item.itemID, displayTypesNotToShow);
                        if (gridParts)
                            parts = parts.concat(gridParts);
                    }
                    else {
                        var value = item[gridField.id];
                        if (value) {
                            parts.push("<div class=\"narrafirma-report-question-prompt\">" + gridField.displayPrompt + "</div>");
                            var fieldParts = printPartsForField(gridField.displayType, value);
                            if (fieldParts) {
                                parts = parts.concat(fieldParts);
                                gridHasUserContent = true;
                            }
                        }
                    }
                });
                parts.push("</div>");
                itemCount_1++;
            });
        }
        if (gridHasUserContent) {
            return parts;
        }
        else {
            return null;
        }
    }
    function printObservationsInProjectReport(page, project, tripleStore, catalysisReportIdentifier) {
        var parts = [];
        var observationsHaveUserContent = false;
        var observationSetIdentifier = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_observations");
        if (observationSetIdentifier) {
            var observations = project.tripleStore.queryAllLatestBCForA(observationSetIdentifier);
            parts.push("<div class=\"narrafirma-report-observationlist\">");
            for (var key in observations) {
                var observationIdentifier = observations[key];
                var observation = tripleStore.makeObject(observationIdentifier);
                if (observation.observationTitle || observation.observationDescription) {
                    parts.push("<p><b>" + observation.pattern.patternName + ": " + observation.observationTitle + "</b> " + observation.observationDescription + "</p>");
                    var interpretationsSetIdentifier = project.tripleStore.queryLatestC(observationIdentifier, "observationInterpretations");
                    if (interpretationsSetIdentifier) {
                        var interpretations = project.tripleStore.getListForSetIdentifier(interpretationsSetIdentifier);
                        parts.push("<ul>");
                        for (var key_1 in interpretations) {
                            var interpretationIdentifier = interpretations[key_1];
                            var interpretation = tripleStore.makeObject(interpretationIdentifier);
                            var printText_1 = "<li><b>" + interpretation.interpretation_name + "</b> " + interpretation.interpretation_text;
                            if (interpretation.interpretation_questions)
                                printText_1 += interpretation.interpretation_questions;
                            if (interpretation.interpretation_idea)
                                printText_1 += " <i>" + interpretation.interpretation_idea + "</i>";
                            parts.push(printText_1 + "</li>");
                            observationsHaveUserContent = true;
                        }
                        parts.push("</ul>");
                    }
                }
            }
            parts.push("</div>");
        }
        if (observationsHaveUserContent) {
            return parts;
        }
        else {
            return null;
        }
    }
    function printClusteringDiagram(field, tripleStore, lookupID) {
        var parts = [];
        var diagramHasUserContent = false;
        parts.push("<div class=\"narrafirma-report-question-prompt\">" + field.displayPrompt + "</div>");
        parts.push("<div class=\"narrafirma-report-clusteringdiagram\">");
        var data = tripleStore.queryLatestC(lookupID, field.id);
        if (data !== undefined) {
            var items = [];
            var clusters = [];
            _a = ClusteringDiagram.calculateClusteringForDiagram(data), clusters = _a[0], items = _a[1];
            clusters.forEach(function (cluster) {
                parts.push("<p><b>" + cluster.name + "</b> " + cluster.notes + "</p><ul>");
                cluster.items.forEach(function (item) {
                    parts.push("<li><i>" + item.name + "</i> " + item.notes + "</li>");
                    diagramHasUserContent = true;
                });
                parts.push("</ul>");
            });
        }
        parts.push("</div>");
        if (diagramHasUserContent) {
            return parts;
        }
        else {
            return null;
        }
        var _a;
    }
    function printQuizScoreResult(field, tripleStore, lookupID, panelSpecificationCollection) {
        var total = 0;
        for (var i = 0; i < field.displayConfiguration.length; i++) {
            var questionAnswer = tripleStore.queryLatestC(lookupID, field.displayConfiguration[i]);
            var answerWeight = 0;
            var index = 0;
            if (questionAnswer) {
                var choices = panelSpecificationCollection.getFieldSpecificationForFieldID(field.displayConfiguration[i]).valueOptions;
                index = choices.indexOf(questionAnswer);
                if (index === choices.length - 1) {
                    answerWeight = 0;
                }
                else {
                    answerWeight = index;
                }
                if (answerWeight < 0)
                    answerWeight = 0;
                total += answerWeight;
            }
        }
        var possibleTotal = field.displayConfiguration.length * 3;
        var percent = Math.round(100 * total / possibleTotal);
        var template = translate("#calculate_quizScoreResult_template", "{{total}} of {{possibleTotal}} ({{percent}}%)");
        var scoreResult = template.replace("{{total}}", total).replace("{{possibleTotal}}", possibleTotal).replace("{{percent}}", "" + percent);
        return scoreResult;
    }
    function printPage(page, project, tripleStore, catalysisReportIdentifier, storyCollectionName, storyCollectionIdentifier, displayTypesNotToShow, panelSpecificationCollection) {
        var pageHasUserContent = false;
        var parts = [];
        page.panelFields.forEach(function (field) {
            if (displayTypesNotToShow.indexOf(field.displayType) >= 0)
                return;
            var displayTypeToUse = field.displayType;
            if (["catalysisReportGraphTypesChooser", "catalysisReportQuestionChooser", "printStoryCardsQuestionChooser"].indexOf(field.displayType) >= 0)
                displayTypeToUse = "checkboxes";
            var lookupID = project.projectIdentifier;
            if (field.valuePath) {
                if (field.valuePath.indexOf("catalysisReportIdentifier") >= 0) {
                    lookupID = catalysisReportIdentifier;
                }
                else if (field.valuePath.indexOf("storyCollectionName") >= 0) {
                    lookupID = storyCollectionName;
                }
                else if (field.valuePath.indexOf("storyCollectionIdentifier") >= 0) {
                    lookupID = storyCollectionIdentifier;
                }
            }
            if (displayTypeToUse === "grid") {
                var gridParts = printPartsForGrid(field, panelSpecificationCollection, tripleStore, lookupID, displayTypesNotToShow);
                if (gridParts) {
                    parts = parts.concat(gridParts);
                    pageHasUserContent = true;
                }
            }
            else if (displayTypeToUse === "clusteringDiagram") {
                var diagramParts = printClusteringDiagram(field, tripleStore, lookupID);
                if (diagramParts) {
                    parts = parts.concat(diagramParts);
                    pageHasUserContent = true;
                }
            }
            else if (displayTypeToUse === "storiesList") {
                parts.push('<div class=\"narrafirma-report-question-prompt\">' + field.displayPrompt + "</div>");
                var projectStoryIdentifiers = project.getListForField("project_projectStoriesList");
                projectStoryIdentifiers.forEach(function (projectStoryIdentifier) {
                    var projectStory = project.tripleStore.makeObject(projectStoryIdentifier);
                    parts.push("<div class=\"narrafirma-report-project-story\"><i>" + projectStory.projectStory_name + "</i> " + projectStory.projectStory_text + "</div>");
                    pageHasUserContent = true;
                });
            }
            else if (displayTypeToUse === "quizScoreResult") {
                var scoreResult = printQuizScoreResult(field, tripleStore, lookupID, panelSpecificationCollection);
                parts.push("<p><b>" + field.displayPrompt + "</b> " + scoreResult + "</p>");
            }
            else if (displayTypeToUse === "header") {
                parts.push("<div class=\"narrafirma-report-header\">" + field.displayPrompt + "</div>");
            }
            else if (displayTypeToUse === "label") {
                if (field.id !== "configureCatalysisReport_promptToSelectCatalysisReportForInterpretations" && field.id !== "promptToSelectCatalysisReportForInterpretations") {
                    // skip those two prompting fields; they are messages to the user that only appear sometimes
                    parts.push("<div class=\"narrafirma-report-label\">" + field.displayPrompt + "</div>");
                }
            }
            else {
                var data = tripleStore.queryLatestC(lookupID, field.id);
                if (data !== undefined) {
                    parts.push('<div class=\"narrafirma-report-question-prompt\">' + field.displayPrompt + "</div>");
                    var fieldParts = printPartsForField(displayTypeToUse, data);
                    parts = parts.concat(fieldParts);
                    pageHasUserContent = true;
                }
                else {
                    // there are some cases where the field id does not match the value path
                    // in these cases the value path is the correct lookup id, so we need to get it from there
                    // but we can't always get it from the value path, because sometimes there isn't one
                    if (field.valuePath) {
                        var lastSlash = field.valuePath.lastIndexOf("/");
                        var fieldIDFromValuePath = field.valuePath.substring(lastSlash + 1);
                        var data_1 = tripleStore.queryLatestC(lookupID, fieldIDFromValuePath);
                        if (data_1 !== undefined) {
                            parts.push('<div class=\"narrafirma-report-question-prompt\">' + field.displayPrompt + "</div>");
                            var fieldParts = printPartsForField(displayTypeToUse, data_1);
                            parts = parts.concat(fieldParts);
                            pageHasUserContent = true;
                        }
                    }
                }
            }
        });
        // must print observations separately because they are not linked to the page specification structure
        // want this to print after the label that describes it
        if (page.displayName === "Explore patterns" && catalysisReportIdentifier) {
            var observationParts = printObservationsInProjectReport(page, project, tripleStore, catalysisReportIdentifier);
            if (observationParts) {
                parts = parts.concat(observationParts);
                pageHasUserContent = true;
            }
        }
        if (pageHasUserContent) {
            return parts;
        }
        else {
            return null;
        }
    }
    function printProjectReport() {
        var parts = [];
        var project = Globals.project();
        var tripleStore = project.tripleStore;
        var clientState = Globals.clientState();
        var panelSpecificationCollection = Globals.panelSpecificationCollection();
        var allPages = panelSpecificationCollection.buildListOfPages();
        var displayTypesNotToShow = ["button", "html", "recommendationTable", "templateList", "storyBrowser", "storyAnnotationBrowser", "graphBrowser", "functionResult"];
        var pagesNeverToPrint = ["page_startStoryCollection", "page_printQuestionForms", "page_enterStories", "page_importExportStories", "page_removeData", "page_reviewIncomingStories", "page_browseGraphs",
            "page_stopStoryCollection", "page_startCatalysisReport", "page_printCatalysisReport"];
        parts.push("<div class=\"narrafirma-report-title\">Project Report for " + project.projectNameOrNickname() + "</div>");
        parts.push("<div class=\"narrafirma-report-intro\">Generated by NarraFirma " + versions.narrafirmaApplication + " on " + new Date().toString() + ".</div>");
        allPages.forEach(function (page) {
            if (page.section === "dashboard" || page.section === "administration")
                return;
            if (pagesNeverToPrint.indexOf(page.id) >= 0)
                return;
            if (page.isHeader) {
                parts.push("<div class=\"narrafirma-report-headerpagename\">" + page.displayName + "</div>");
            }
            if (["page_configureCatalysisReport", "page_explorePatterns", "page_clusterInterpretations"].indexOf(page.id) >= 0) {
                var catalysisReports = tripleStore.queryLatestC(project.projectIdentifier, "project_catalysisReports");
                if (catalysisReports) {
                    var catalysisReportIdentifiers = tripleStore.getListForSetIdentifier(catalysisReports);
                    for (var i = 0; i < catalysisReportIdentifiers.length; i++) {
                        var reportShortName = tripleStore.queryLatestC(catalysisReportIdentifiers[i], "catalysisReport_shortName");
                        var pageParts = printPage(page, project, tripleStore, catalysisReportIdentifiers[i], null, null, displayTypesNotToShow, panelSpecificationCollection);
                        if (pageParts) {
                            parts.push("<div class=\"narrafirma-report-grid-item\">");
                            parts.push("<div class=\"narrafirma-report-grid-item-name\">Catalysis report: " + reportShortName + "</div>");
                            parts = parts.concat(pageParts);
                            parts.push("</div>");
                        }
                    }
                }
            }
            else if (page.id === "page_printStoryCards") {
                var storyCollections = tripleStore.queryLatestC(project.projectIdentifier, "project_storyCollections");
                if (storyCollections) {
                    var storyCollectionIdentifiers = tripleStore.getListForSetIdentifier(storyCollections);
                    for (var i = 0; i < storyCollectionIdentifiers.length; i++) {
                        var collectionShortName = tripleStore.queryLatestC(storyCollectionIdentifiers[i], "storyCollection_shortName");
                        var pageParts = printPage(page, project, tripleStore, null, collectionShortName, storyCollectionIdentifiers[i], displayTypesNotToShow, panelSpecificationCollection);
                        if (pageParts) {
                            parts.push("<div class=\"narrafirma-report-grid-item\">");
                            parts.push("<div class=\"narrafirma-report-grid-item-name\">Story collection: " + collectionShortName + "</div>");
                            parts = parts.concat(pageParts);
                            parts.push("</div>");
                        }
                    }
                }
            }
            else {
                var pageParts = printPage(page, project, tripleStore, null, null, null, displayTypesNotToShow, panelSpecificationCollection);
                if (pageParts) {
                    parts.push("<div class=\"narrafirma-report-pagename\">" + page.displayName + "</div>");
                    parts = parts.concat(pageParts);
                }
            }
        });
        var html = generateHTMLForPage("Report - " + project.projectNameOrNickname(), null, cssForProjectReport(), null, parts.join("\n"));
        printHTML(html);
    }
    exports.printProjectReport = printProjectReport;
});

define('js/projectImportExport',["require", "exports", "./panelBuilder/toaster", "./Globals", "./panelBuilder/dialogSupport", "./surveyStorage", "FileSaver"], function (require, exports, toaster, Globals, dialogSupport, surveyStorage, saveAs) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    var allMessagesExportType = "NarraFirma_allMessages";
    var allMessagesExportFormat = "0.1.0";
    var currentProjectStateExportType = "NarraFirma_currentProjectState";
    var currentProjectStateExportFormat = "0.1.1";
    // ----------------------------------------------------------------------------------------------------
    // IMPORT
    // ----------------------------------------------------------------------------------------------------
    function importProject() {
        var project = Globals.project();
        var tripleStore = project.tripleStore;
        if (!project.currentUserHasAdminAccess) {
            alert("You must have administrative permission to import into the project.");
            return;
        }
        // valueOptions: ["project snapshot (with or without stories)", "project history with stories"],
        var importType = tripleStore.queryLatestC(project.projectIdentifier, "importExport_importType");
        if (!importType) {
            alert("Please choose a type of file to import.");
            return;
        }
        // warn user if there are things in the project
        var lookIn = ["project_elicitingQuestionsList", "project_storyQuestionsList", "project_participantQuestionsList",
            "project_annotationQuestionsList", "project_storyForms", "project_storyCollections", "project_catalysisReports",];
        var sayAbout = ["eliciting questions", "questions about stories", "questions about participants",
            "annotation questions", "story forms", "story collections", "catalysis reports"];
        var foundItemsIn = [];
        for (var i = 0; i < lookIn.length; i++) {
            var ids = Globals.project().getListForField(lookIn[i]);
            if (ids && ids.length) {
                foundItemsIn.push(sayAbout[i]);
            }
        }
        console.log("foundItemsIn", foundItemsIn);
        var importWhat;
        if (importType === "project history with stories") {
            importWhat = "a project history";
        }
        else {
            importWhat = "a project snapshot";
        }
        var confirmText = "";
        if (foundItemsIn.length) {
            confirmText = "Are you ABSOLUTELY sure you want to import " + importWhat + "?\n\nThis should only be done with an empty project, " +
                "and there are \n\n    " + foundItemsIn.join("\n    ") + "\n\n in this project.";
        }
        else {
            confirmText = "Are you sure you want to import " + importWhat + "? (This should only be done with an empty project.)";
        }
        if (!confirm(confirmText))
            return;
        if (importType === "project history with stories") {
            importEntireProject();
        }
        else {
            importProjectCurrentState();
        }
    }
    exports.importProject = importProject;
    function importEntireProject() {
        var project = Globals.project();
        console.log("importEntireProject");
        chooseProjectFileToImport(function (contents) {
            var importObject = JSON.parse(contents);
            // importObject.messages.forEach((message) => {
            //    // if (message._topicIdentifier === "surveyResults")
            //    console.log("message", message._topicIdentifier);
            //});
            // TODO: Similar to what is in csvImportExport -- could any duplication be refactored out?
            if (importObject.exportType !== allMessagesExportType) {
                alert('Wrong export file type; expected exportType of "' + allMessagesExportType + '" but found: "' + importObject.exportType + '"');
                return;
            }
            if (importObject.exportFormat > allMessagesExportFormat) {
                if (!confirm("The file has an export format of: " + importObject.exportFormat + " which is later than this application's of: " + allMessagesExportFormat + "\nTry importing anyway (not recommended)?")) {
                    return;
                }
            }
            var progressModel = dialogSupport.openProgressDialog("Importing project messages...", "Progress importing project messsages", "Cancel", dialogCancelled);
            function dialogCancelled(dialogConfiguration, hideDialogMethod) {
                progressModel.cancelled = true;
                hideDialogMethod();
            }
            var messageIndexToSend = 0;
            function sendNextMessage() {
                if (progressModel.cancelled) {
                    alert("Cancelled after importing " + messageIndexToSend + " messages");
                }
                else if (messageIndexToSend >= importObject.messages.length) {
                    alert("Finished importing " + importObject.messages.length + " messages.");
                    progressModel.hideDialogMethod();
                    progressModel.redraw();
                }
                else {
                    var message_1 = importObject.messages[messageIndexToSend++];
                    // Rewrite project references in triples, but not in survey results
                    // TODO: The message trace is no longer valid if do rewrite
                    if (message_1.change && message_1.change.triple && message_1.change.triple.a === importObject.projectIdentifier) {
                        message_1.change.triple.a = project.projectIdentifier;
                    }
                    if (message_1.change && message_1.change.projectIdentifier === importObject.projectIdentifier) {
                        message_1.change.projectIdentifier = project.projectIdentifier;
                    }
                    // TODO: Translate
                    progressModel.progressText = "Importing " + messageIndexToSend + " of " + importObject.messages.length + " messages";
                    progressModel.redraw();
                    setTimeout(function () { project.pointrelClient.sendMessage(message_1, sendNextMessage); }, 0);
                }
            }
            // Start sending project messages
            sendNextMessage();
        });
    }
    exports.importEntireProject = importEntireProject;
    function importProjectCurrentState() {
        var project = Globals.project();
        console.log("importProjectCurrentState");
        chooseProjectFileToImport(function (contents) {
            var importObject = JSON.parse(contents);
            // TODO: Similar to what is in csvImportExport -- could any duplication be refactored out?
            if (importObject.exportType !== currentProjectStateExportType) {
                alert('Wrong export file type; expected exportType of "' + currentProjectStateExportType + '" but found: "' + importObject.exportType + '"');
                return;
            }
            if (importObject.exportFormat > currentProjectStateExportFormat) {
                if (!confirm("The file has an export format of: " + importObject.exportFormat + " which is later than this application's of: " + allMessagesExportFormat + "\nTry importing anyway (not recommended)?")) {
                    return;
                }
            }
            var progressModel = dialogSupport.openProgressDialog("Importing current project state...", "Progress importing current project state", "Cancel", dialogCancelled);
            function dialogCancelled(dialogConfiguration, hideDialogMethod) {
                progressModel.cancelled = true;
                hideDialogMethod();
            }
            var messagesToSend = [];
            // Prepare triples for adding
            var aKeys = Object.keys(importObject.projectCurrentState);
            for (var aKeyIndex = 0; aKeyIndex < aKeys.length; aKeyIndex++) {
                var aKey = aKeys[aKeyIndex];
                var aKeyObject = JSON.parse(aKey);
                var aObject = importObject.projectCurrentState[aKey];
                // Rewrite project references in triples
                if (aKeyObject === importObject.projectIdentifier) {
                    aKeyObject = project.projectIdentifier;
                }
                var bKeys = Object.keys(aObject);
                for (var bKeyIndex = 0; bKeyIndex < bKeys.length; bKeyIndex++) {
                    var bKey = bKeys[bKeyIndex];
                    var bKeyObject = JSON.parse(bKey);
                    var cValue = aObject[bKey];
                    messagesToSend.push([aKeyObject, bKeyObject, cValue]);
                }
            }
            // Prepare activeQuestionnaires for adding
            if (importObject.activeQuestionnaires) {
                var questionnaireMessage = project.pointrelClient.createChangeMessage("questionnaires", "questionnairesMessage", importObject.activeQuestionnaires, null);
                messagesToSend.push(questionnaireMessage);
            }
            // Prepare surveyResults for adding
            if (importObject.storyCollections) {
                var _loop_1 = function (storyCollectionName) {
                    var surveyResults = importObject.storyCollections[storyCollectionName];
                    surveyResults.forEach(function (surveyResult) {
                        //const questionnaireMessage = project.pointrelClient.createChangeMessage("questionnaires", "questionnairesMessage", importObject.activeQuestionnaires, null);
                        var surveyResultMessage = surveyStorage.makeSurveyResultMessage(project.pointrelClient, project.projectIdentifier, storyCollectionName, surveyResult);
                        messagesToSend.push(surveyResultMessage);
                    });
                };
                for (var storyCollectionName in importObject.storyCollections) {
                    _loop_1(storyCollectionName);
                }
            }
            var messagesSentCount = 0;
            function sendNextMessage() {
                if (progressModel.cancelled) {
                    alert("Cancelled after adding " + messagesSentCount + " project messages.");
                }
                else if (messagesSentCount >= messagesToSend.length) {
                    alert("Successfully imported " + messagesSentCount + " project messages.");
                    progressModel.hideDialogMethod();
                    progressModel.redraw();
                }
                else {
                    var message_2 = messagesToSend[messagesSentCount++];
                    var triple_1 = null;
                    if (Array.isArray(message_2)) {
                        triple_1 = message_2;
                    }
                    // TODO: Translate
                    progressModel.progressText = "Sending " + messagesSentCount + " of " + messagesToSend.length + " messages";
                    progressModel.redraw();
                    setTimeout(function () {
                        if (triple_1) {
                            project.tripleStore.addTriple(triple_1[0], triple_1[1], triple_1[2], sendNextMessage);
                        }
                        else {
                            project.pointrelClient.sendMessage(message_2, sendNextMessage);
                        }
                    }, 0);
                }
            }
            // Start sending project messages
            sendNextMessage();
        });
    }
    exports.importProjectCurrentState = importProjectCurrentState;
    function chooseProjectFileToImport(callback) {
        var projectFileUploader = document.getElementById("projectFileUploader");
        projectFileUploader.onchange = function () {
            var file = projectFileUploader.files[0];
            if (!file) {
                return;
            }
            var reader = new FileReader();
            reader.onload = function (e) {
                var contents = e.target.result;
                callback(contents);
            };
            reader.readAsText(file);
        };
        projectFileUploader.click();
    }
    // ----------------------------------------------------------------------------------------------------
    // RESET
    // ----------------------------------------------------------------------------------------------------
    function resetProject() {
        var project = Globals.project();
        if (!project.currentUserHasAdminAccess) {
            alert("You must have administrative permission to reset the project.");
            return;
        }
        if (confirm("Are you sure you want to reset this project? This action cannot be undone. Make sure you have a project snapshot file ready to restore the project afterwards.")) {
            var journalIdentifier_1 = project.journalIdentifier;
            project.pointrelClient.resetJournal(journalIdentifier_1, function (error, response) {
                if (error || !response.success) {
                    console.log("Error resetting project", journalIdentifier_1, error, response);
                    var message = "error";
                    if (response)
                        message = response.description;
                    if (error)
                        message = error.description;
                    if (error && typeof error.error === "string")
                        message += "\n" + error.error.split("\n")[0];
                    toaster.toast("Error resetting project: " + journalIdentifier_1 + " :: " + message);
                }
                else {
                    console.log("Successfully reset project", journalIdentifier_1, response);
                    // Need to call redraw as event changing data was triggered by network
                    alert("The project " + project.projectNameAndNickname() + " was successfully reset and is now empty.");
                    location.reload();
                }
            });
        }
    }
    exports.resetProject = resetProject;
    function listOfRemovedStoryCollections() {
        var result = [];
        var project = Globals.project();
        var storyCollectionsIDsInUse = project.getListForField("project_storyCollections");
        var storyCollectionNamesInUse = [];
        for (var i = 0; i < storyCollectionsIDsInUse.length; i++) {
            storyCollectionNamesInUse.push(project.tripleStore.queryLatestC(storyCollectionsIDsInUse[i], "storyCollection_shortName"));
        }
        var storyCollectionNamesAndCounts = {};
        project.pointrelClient.filterMessages(function (message) {
            if (message._topicIdentifier === "surveyResults") {
                var id = message.change.storyCollectionIdentifier;
                if (!storyCollectionNamesAndCounts[id]) {
                    storyCollectionNamesAndCounts[id] = 0;
                }
                storyCollectionNamesAndCounts[id] += 1;
            }
        });
        var keys = Object.keys(storyCollectionNamesAndCounts);
        for (var i = 0; i < keys.length; i++) {
            var collectionName = keys[i];
            if (storyCollectionNamesInUse.indexOf(collectionName) < 0 && result.indexOf(collectionName) < 0) {
                result.push(collectionName + ": " + storyCollectionNamesAndCounts[collectionName] + " stories");
            }
        }
        return result;
    }
    exports.listOfRemovedStoryCollections = listOfRemovedStoryCollections;
    // ----------------------------------------------------------------------------------------------------
    // EXPORT
    // ----------------------------------------------------------------------------------------------------
    function exportProject() {
        var project = Globals.project();
        var tripleStore = project.tripleStore;
        // valueOptions: ["project snapshot without stories", "project snapshot with stories", "project history with stories"],
        var exportType = tripleStore.queryLatestC(project.projectIdentifier, "importExport_exportType");
        if (exportType === "project history with stories") {
            exportEntireProject();
        }
        else if (exportType === "project snapshot with stories") {
            exportProjectCurrentState(true);
        }
        else if (exportType === "project snapshot without stories") {
            exportProjectCurrentState(false);
        }
        else {
            alert("Please choose a type of file to export.");
        }
    }
    exports.exportProject = exportProject;
    function exportEntireProject() {
        if (!confirm("Are you sure you want to export a project history with stories?"))
            return;
        var project = Globals.project();
        // const json = JSON.stringify(project.tripleStore.tripleMessages, null, 4);
        var exportObject = {
            projectIdentifier: project.projectIdentifier,
            timestamp: new Date().toISOString(),
            exportType: allMessagesExportType,
            exportFormat: allMessagesExportFormat,
            userIdentifier: project.pointrelClient.userIdentifier,
            messages: project.pointrelClient.messagesSortedByReceivedTimeArray
        };
        var json = JSON.stringify(exportObject, null, 4);
        // const printItems = m("pre", json);
        // const htmlForPage = generateHTMLForPage("NarraFirma project export for " + project.projectIdentifier + " on " + new Date().toISOString(), null, printItems);
        // printHTML(htmlForPage);
        var questionnaireBlob = new Blob([json], { type: "application/json;charset=utf-8" });
        saveAs(questionnaireBlob, exportObject.projectIdentifier + " with history exported at " + exportObject.timestamp + ".json");
    }
    exports.exportEntireProject = exportEntireProject;
    function exportProjectCurrentState(includeSurveyResults) {
        // TODO: Translate
        var promptMessage = includeSurveyResults ?
            "Are you sure you want to export a project snapshot with stories?" :
            "Are you sure you want to export a project snapshot WITHOUT stories? No stories will be saved.";
        if (!confirm(promptMessage))
            return;
        var project = Globals.project();
        var tripleStore = project.tripleStore;
        var projectCurrentState = {};
        var aKeys = Object.keys(tripleStore.indexABC);
        aKeys.sort();
        for (var aKeyIndex = 0; aKeyIndex < aKeys.length; aKeyIndex++) {
            var aKey = aKeys[aKeyIndex];
            var aObject = tripleStore.indexABC[aKey];
            var bResult = {};
            projectCurrentState[aKey] = bResult;
            var bKeys = Object.keys(aObject);
            bKeys.sort();
            for (var bKeyIndex = 0; bKeyIndex < bKeys.length; bKeyIndex++) {
                var bKey = bKeys[bKeyIndex];
                bResult[bKey] = aObject[bKey].latestC;
            }
        }
        var activeQuestionnaires = null;
        var storyCollections = null;
        if (includeSurveyResults) {
            var questionnaireMessages = project.pointrelClient.filterMessages(function (message) {
                return message._topicIdentifier === "questionnaires";
            });
            if (questionnaireMessages.length)
                activeQuestionnaires = questionnaireMessages[questionnaireMessages.length - 1].change;
            var storyCollectionIDsInUse = project.getListForField("project_storyCollections");
            var storyCollectionNamesInuse_1 = [];
            storyCollectionIDsInUse.forEach(function (id) {
                var aName = tripleStore.queryLatestC(id, "storyCollection_shortName");
                storyCollectionNamesInuse_1.push(aName);
            });
            var surveyResultMessages = project.pointrelClient.filterMessages(function (message) {
                var result = false;
                if (message._topicIdentifier === "surveyResults") {
                    // message.change.storyCollectionIdentifier is the story collection name
                    if (storyCollectionNamesInuse_1.indexOf(message.change.storyCollectionIdentifier) >= 0) {
                        result = true;
                    }
                    else {
                        result = false;
                    }
                }
                return result;
            });
            storyCollections = {};
            surveyResultMessages.forEach(function (message) {
                var storyCollectionName = message.change.storyCollectionIdentifier;
                var storyCollection = storyCollections[storyCollectionName];
                if (!storyCollection) {
                    storyCollection = [];
                    storyCollections[storyCollectionName] = storyCollection;
                }
                storyCollection.push(message.change.surveyResult);
            });
        }
        var exportObject = {
            projectIdentifier: project.projectIdentifier,
            timestamp: new Date().toISOString(),
            exportType: currentProjectStateExportType,
            exportFormat: currentProjectStateExportFormat,
            userIdentifier: project.pointrelClient.userIdentifier,
            projectCurrentState: projectCurrentState,
            activeQuestionnaires: activeQuestionnaires,
            storyCollections: storyCollections
        };
        var json = JSON.stringify(exportObject, null, 4);
        var questionnaireBlob = new Blob([json], { type: "application/json;charset=utf-8" });
        var withOrWithoutStories = includeSurveyResults ? "with stories" : "without stories";
        saveAs(questionnaireBlob, exportObject.projectIdentifier + " current state " + withOrWithoutStories + " exported at " + exportObject.timestamp + ".json");
    }
});

define('js/manageStoryCollection',["require", "exports", "./panelBuilder/dialogSupport", "./questionnaireGeneration", "./surveyCollection"], function (require, exports, dialogSupport, questionnaireGeneration, surveyCollection) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    var project;
    var clientState;
    // Call this to set up the project or other needed data
    function initialize(theProject, theClientState) {
        project = theProject;
        clientState = theClientState;
    }
    exports.initialize = initialize;
    function createNewStoryCollection() {
        function constructStoryCollectionDialog() {
            var storyFormNamesList = project.listOfAllStoryFormNames();
            console.log("storyFormNamesList", storyFormNamesList);
            var options = [];
            for (var index in storyFormNamesList) {
                options.push(m("option", { value: storyFormNamesList[index], selected: undefined }, storyFormNamesList[index]));
            }
            return m("div", [m("div.narrafirma-create-collection-name-prompt", "Enter a name for the new story collection."),
                m("div.narrafirma-create-collection-input-name-div", m('input[type=text]', {
                    id: "storyCollection_shortName",
                    class: "narrafirma-create-collection-input-name",
                    value: newCollectionName,
                    onchange: function (event) {
                        if (allCollectionNames.length && allCollectionNames.indexOf(event.target.value) >= 0) {
                            alert("That name is already in use. Please enter a different name.");
                            event.target.value = "";
                        }
                        else {
                            newCollectionName = event.target.value;
                        }
                    }
                })),
                m("div.narrafirma-create-collection-form-prompt", "Choose a story form to associate with the collection."),
                m("div.narrafirma-create-collection-choose-form", [m('label', { for: "storyForms", class: "narrafirma-create-collection-choose-form-label" }, "Story form"),
                    m("select", {
                        id: "storyForms",
                        class: "narrafirma-create-collection-choose-form-select",
                        value: "",
                        onchange: function (event) {
                            newCollectionStoryFormName = event.target.value;
                        }
                    }, options),
                ]),
            ]);
        }
        var newCollectionName = "";
        var allCollectionNames = project.listOfAllStoryCollectionNames();
        var newCollectionStoryFormName = "";
        var dialogConfiguration = {
            dialogModel: null,
            dialogTitle: "Create New Story Collection",
            dialogEntryText: "",
            dialogClass: undefined,
            dialogConstructionFunction: constructStoryCollectionDialog,
            dialogOKButtonLabel: "Create Story Collection",
            dialogCancelButtonLabel: "Cancel",
            dialogOKCallback: function (dialogConfiguration, hideDialogMethod) {
                if (newCollectionName && newCollectionStoryFormName) {
                    var confirmationPrompt = 'Please confirm that you want to create a story collection called "' + newCollectionName
                        + '" using the story form called "' + newCollectionStoryFormName + '."';
                    if (confirm(confirmationPrompt)) {
                        var template = {};
                        template["storyCollection_shortName"] = newCollectionName;
                        template["storyCollection_questionnaireIdentifier"] = newCollectionStoryFormName;
                        var setIdentifier = project.tripleStore.queryLatestC(project.projectIdentifier, "project_storyCollections");
                        if (!setIdentifier) {
                            setIdentifier = project.tripleStore.newIdForSet("StoryCollectionSet");
                            project.tripleStore.addTriple(project.projectIdentifier, "project_storyCollections", setIdentifier);
                        }
                        var newCollectionID = project.tripleStore.makeNewSetItem(setIdentifier, "StoryCollection", template);
                        project.tripleStore.addTriple(newCollectionID, "id", newCollectionID);
                        var questionnaire = questionnaireGeneration.buildStoryForm(newCollectionStoryFormName);
                        if (!questionnaire) {
                            alert('The selected story form (' + newCollectionStoryFormName + ") was not found.");
                            return;
                        }
                        project.tripleStore.addTriple(newCollectionID, "questionnaire", questionnaire);
                    }
                    else {
                        return;
                    }
                }
                else {
                    if (!newCollectionName) {
                        alert("Please enter a name for the story collection.");
                    }
                    else if (!newCollectionStoryFormName) {
                        alert("Please choose a story form to associate with the new story collection.");
                    }
                    return;
                }
                hideDialogMethod();
            }
        };
        return dialogSupport.openDialog(dialogConfiguration);
    }
    exports.createNewStoryCollection = createNewStoryCollection;
    function questionsOnlyInFirstList(listOne, listTwo, idField) {
        var result = [];
        for (var _i = 0, listOne_1 = listOne; _i < listOne_1.length; _i++) {
            var itemOne = listOne_1[_i];
            var foundItemOneInListTwo = false;
            for (var _a = 0, listTwo_1 = listTwo; _a < listTwo_1.length; _a++) {
                var itemTwo = listTwo_1[_a];
                if (itemTwo[idField] === itemOne[idField]) {
                    foundItemOneInListTwo = true;
                    break;
                }
            }
            if (!foundItemOneInListTwo) {
                result.push(itemOne);
            }
        }
        return result;
    }
    function questionsInBothLists(listOne, listTwo, idField) {
        var result = [];
        for (var _i = 0, listOne_2 = listOne; _i < listOne_2.length; _i++) {
            var itemOne = listOne_2[_i];
            for (var _a = 0, listTwo_2 = listTwo; _a < listTwo_2.length; _a++) {
                var itemTwo = listTwo_2[_a];
                if (itemTwo[idField] === itemOne[idField]) {
                    result.push(itemOne);
                }
            }
        }
        return result;
    }
    function questionForID(list, idField, idValue) {
        var result = null;
        for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
            var item = list_1[_i];
            if (item[idField] == idValue) {
                result = item;
            }
        }
        return result;
    }
    function displayQuestionIDs(list, idField) {
        var ids = [];
        for (var _i = 0, list_2 = list; _i < list_2.length; _i++) {
            var item = list_2[_i];
            ids.push(item[idField].replace("S_", "").replace("P_", ""));
        }
        return ids.join(", ");
    }
    function displayQuestionName(id) {
        return id.replace("S_", "").replace("P_", "");
    }
    function updateQuestionnaireForStoryCollection(storyCollectionIdentifier) {
        updateOrCheckQuestionnaireForStoryCollection(storyCollectionIdentifier, true);
    }
    exports.updateQuestionnaireForStoryCollection = updateQuestionnaireForStoryCollection;
    function checkStoryFormsForDataConflicts(storyCollectionIdentifier) {
        updateOrCheckQuestionnaireForStoryCollection(storyCollectionIdentifier, false);
    }
    exports.checkStoryFormsForDataConflicts = checkStoryFormsForDataConflicts;
    function updateOrCheckQuestionnaireForStoryCollection(storyCollectionIdentifier, actuallyCopy) {
        if (actuallyCopy === void 0) { actuallyCopy = false; }
        function numStoriesWithDataForQuestionID(question, stories) {
            var storiesWithThisQuestion = [];
            for (var _i = 0, stories_1 = stories; _i < stories_1.length; _i++) {
                var story = stories_1[_i];
                var value = story.fieldValue(question.id);
                // value could be string, number, or dictionary
                if (typeof value === "string" || typeof value === "number") {
                    if (value !== undefined && value !== null && value !== "") {
                        storiesWithThisQuestion.push(story);
                    }
                }
                else {
                    // for dictionary, cannot just check if it exists; must also check if there are any true values 
                    // because if a respondent checks then unchecks a value, the dictionary persists
                    if (value !== undefined && value !== null) {
                        var keys = Object.keys(value);
                        var hasTrueEntry = false;
                        for (var _a = 0, keys_1 = keys; _a < keys_1.length; _a++) {
                            var key = keys_1[_a];
                            if (value[key] === true) {
                                hasTrueEntry = true;
                            }
                        }
                        if (hasTrueEntry) {
                            storiesWithThisQuestion.push(story);
                        }
                    }
                }
            }
            return storiesWithThisQuestion.length;
        }
        function messageForTypeMismatch(snapshotQuestion, currentQuestion, name, stories) {
            var result = "";
            var snapshotType = snapshotQuestion.displayType;
            var currentType = currentQuestion.displayType;
            if (snapshotType != currentType) {
                var okay = false;
                okay = okay || (snapshotType == "label" && currentType == "header");
                okay = okay || (snapshotType == "header" && currentType == "label");
                okay = okay || (snapshotType == "text" && currentType == "textarea");
                okay = okay || (snapshotType == "textarea" && currentType == "text");
                okay = okay || (snapshotType == "select" && currentType == "radiobuttons");
                okay = okay || (snapshotType == "radiobuttons" && currentType == "select");
                okay = okay || (snapshotType == "boolean" && currentType == "checkbox");
                okay = okay || (snapshotType == "checkbox" && currentType == "boolean");
                if (!okay) {
                    var numStoriesWithDataForQuestion = numStoriesWithDataForQuestionID(snapshotQuestion, stories);
                    var storiesHave = (numStoriesWithDataForQuestion !== 1) ? " stories have" : " story has";
                    if (numStoriesWithDataForQuestion > 0) {
                        result += 'For the question:\n  - ' + name
                            + '\nthe snapshot version has the type:\n  - ' + snapshotType
                            + '\nand the current version has the type\n  - ' + currentType;
                        result += "\nThese question types are incompatible, and "
                            + numStoriesWithDataForQuestion + storiesHave + " data for the snapshot version.";
                    }
                }
            }
            return result;
        }
        function messageForAnswerListMismatch(snapshotQuestion, currentQuestion, name, stories) {
            var result = "";
            var snapshotAnswers = snapshotQuestion.valueOptions;
            var currentAnswers = currentQuestion.valueOptions;
            if (JSON.stringify(snapshotAnswers) != JSON.stringify(currentAnswers)) {
                var matchingAnswers = [];
                var answersOnlyInSnapshot = [];
                for (var _i = 0, snapshotAnswers_1 = snapshotAnswers; _i < snapshotAnswers_1.length; _i++) {
                    var snapshotAnswer = snapshotAnswers_1[_i];
                    for (var _a = 0, currentAnswers_1 = currentAnswers; _a < currentAnswers_1.length; _a++) {
                        var currentAnswer = currentAnswers_1[_a];
                        if (currentAnswer === snapshotAnswer) {
                            matchingAnswers.push(snapshotAnswer);
                        }
                    }
                    if (matchingAnswers.indexOf(snapshotAnswer) < 0) {
                        answersOnlyInSnapshot.push(snapshotAnswer);
                    }
                }
                if (answersOnlyInSnapshot.length > 0) {
                    var answerCountsOnlyInSnapshot_1 = {};
                    var totalNumAnswers = 0;
                    for (var _b = 0, answersOnlyInSnapshot_1 = answersOnlyInSnapshot; _b < answersOnlyInSnapshot_1.length; _b++) {
                        var sAnswer = answersOnlyInSnapshot_1[_b];
                        var numStoriesWithSAnswer = 0;
                        for (var _c = 0, stories_2 = stories; _c < stories_2.length; _c++) {
                            var story = stories_2[_c];
                            var value = story.fieldValue(snapshotQuestion.id);
                            var match = false;
                            if (typeof value === "string" || typeof value === "number") {
                                match = value == sAnswer;
                            }
                            else {
                                match = value.hasOwnProperty(sAnswer);
                            }
                            if (match) {
                                numStoriesWithSAnswer++;
                            }
                        }
                        answerCountsOnlyInSnapshot_1[sAnswer] = numStoriesWithSAnswer;
                        totalNumAnswers += numStoriesWithSAnswer;
                    }
                    if (totalNumAnswers > 0) {
                        result += 'For the question "' + name + '" the answers:\n  - ' + answersOnlyInSnapshot.join("\n  - ")
                            + '\nappear in the snapshot version, do not appear in the current version, and are connected to stories.\n';
                        var storyCountMessages_1 = [];
                        Object.keys(answerCountsOnlyInSnapshot_1).forEach(function (anAnswer) {
                            storyCountMessages_1.push('   - the answer "' + anAnswer + '" appears in ' + answerCountsOnlyInSnapshot_1[anAnswer]
                                + (answerCountsOnlyInSnapshot_1[anAnswer] > 1) ? " stories." : " story.");
                        });
                        result += storyCountMessages_1.join("\n");
                    }
                }
            }
            return result;
        }
        function checkTwoQuestionsForTypeAndListMismatches(snapshotQuestion, currentQuestion, stories) {
            var result = "";
            var typeMismatchMessage = messageForTypeMismatch(snapshotQuestion, currentQuestion, displayQuestionName(snapshotQuestion.id), stories);
            if (typeMismatchMessage) {
                result += typeMismatchMessage;
            }
            else {
                var typesWithValueOptions = ["select", "radiobuttons", "checkboxes"];
                if (typesWithValueOptions.indexOf(snapshotQuestion.displayType) >= 0) {
                    result += messageForAnswerListMismatch(snapshotQuestion, currentQuestion, displayQuestionName(snapshotQuestion.id), stories);
                }
            }
            return result;
        }
        function constructResultDialog(startText, noticeText, problemsText, endText, snapshot) {
            var snapshotText = JSON.stringify(snapshot, null, "\t");
            var currentText = JSON.stringify(current, null, "\t");
            return m("div", [
                m("div.narrafirma-update-story-form-start", startText),
                noticeText ? m("div.narrafirma-update-story-form-notice", noticeText) : "",
                problemsText ? m("pre.narrafirma-update-story-form-problems", problemsText) : "",
                problemsText ? m("button.narrafirma-update-story-form-copy-button", { onclick: function (event) {
                        var textareas = document.getElementsByClassName("narrafirma-update-story-form-problems");
                        if (textareas.length > 0)
                            window.navigator['clipboard'].writeText(textareas[0].innerHTML);
                    } }, "Copy") : m("div"),
                m("div.narrafirma-update-story-form-end", endText),
                m("div.narrafirma-update-story-form-type-label", "The snapshot version saved in the story collection"),
                m("pre.narrafirma-update-story-form-snapshot", snapshotText),
                m("button.narrafirma-update-story-form-copy-button", { onclick: function (event) {
                        var textareas = document.getElementsByClassName("narrafirma-update-story-form-snapshot");
                        if (textareas.length > 0)
                            window.navigator['clipboard'].writeText(textareas[0].innerHTML);
                    } }, "Copy"),
                m("div.narrafirma-update-story-form-type-label", "The current version"),
                m("pre.narrafirma-update-story-form-current", currentText),
                m("button.narrafirma-update-story-form-copy-button", { onclick: function (event) {
                        var textareas = document.getElementsByClassName("narrafirma-update-story-form-current");
                        if (textareas.length > 0)
                            window.navigator['clipboard'].writeText(textareas[0].innerHTML);
                    } }, "Copy"),
            ]);
        }
        function doCopy(activeOnWeb, override) {
            var prompt = "";
            if (!override)
                prompt += 'No data conflicts were found. ';
            prompt += "Please confirm that you want to update the snapshot story form associated with the story collection "
                + storyCollectionName + '" so that it matches the current version.';
            if (!confirm(prompt)) {
                return;
            }
            var copyOfSnapshotBeforeChange = snapshot;
            var updateResult = setQuestionnaireForStoryCollection(storyCollectionIdentifier);
            if (!updateResult) {
                alert("Problem: Could not build story form.");
                return;
            }
            var activeNotice = activeOnWeb ?
                "This story collection is currently accepting stories over the internet. "
                    + "When you are ready to make these changes live, deactivate the collection's web form. "
                    + "Then, when you activate the form again, it will pick up your changes." : null;
            var dialogConfiguration = {
                dialogTitle: "Update successful",
                dialogConstructionFunction: function () {
                    return constructResultDialog("The snapshot version of the story form was successfully updated.", activeNotice, null, "Here are the two versions of the story form as they were before the update (now they are identical).", copyOfSnapshotBeforeChange);
                },
                dialogOKCallback: function (dialogConfiguration, hideDialogMethod) { hideDialogMethod(); }
            };
            return dialogSupport.openDialog(dialogConfiguration);
        }
        if (!storyCollectionIdentifier) {
            alert("Problem: No story collection identifier.");
            return;
        }
        var storyCollectionName = project.tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_shortName");
        if (!storyCollectionName) {
            alert("Problem: No story collection name.");
            return;
        }
        var storyCollection = project.tripleStore.makeObject(storyCollectionIdentifier, true);
        var activeOnWeb = project.tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_activeOnWeb");
        var snapshot = storyCollection.questionnaire;
        var linkedStoryFormName = project.tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_questionnaireIdentifier");
        var linkedStoryFormID = project.findStoryFormID(linkedStoryFormName);
        var current = questionnaireGeneration.buildStoryFormUsingTripleStoreID(linkedStoryFormID, linkedStoryFormName);
        var stories = surveyCollection.getStoriesForStoryCollection(storyCollectionName);
        if (stories.length === 0) {
            if (actuallyCopy) {
                doCopy(activeOnWeb, false);
                return;
            }
            else {
                alert("This story collection has no stories in it, so you can update the story form without creating any data conflicts.");
                return;
            }
        }
        var indent = "  - ";
        var problemTexts = [];
        // for eliciting questions, just look for questions (with data) that are missing in the current version
        // this could happen because questions were removed, but it could also happen if question short names were changed
        var eqInSnapshotOnly = questionsOnlyInFirstList(snapshot.elicitingQuestions, current.elicitingQuestions, "id");
        if (eqInSnapshotOnly.length > 0) {
            var eqInSnapshotOnlyWithStoryData = [];
            for (var _i = 0, eqInSnapshotOnly_1 = eqInSnapshotOnly; _i < eqInSnapshotOnly_1.length; _i++) {
                var eq = eqInSnapshotOnly_1[_i];
                var storiesWithThisQuestion = [];
                for (var _a = 0, stories_3 = stories; _a < stories_3.length; _a++) {
                    var story = stories_3[_a];
                    var value = story.fieldValue("elicitingQuestion");
                    if (value && value === eq["id"]) {
                        storiesWithThisQuestion.push(story);
                    }
                }
                if (storiesWithThisQuestion.length > 0) {
                    eqInSnapshotOnlyWithStoryData.push(eq);
                }
            }
            if (eqInSnapshotOnlyWithStoryData.length > 0) {
                var text = "The eliciting questions in this list:\n" + indent + displayQuestionIDs(eqInSnapshotOnlyWithStoryData, "id")
                    + "\nare:\n" + indent + "in the snapshot version of the form\n"
                    + indent + "not in the current version of the form\n"
                    + indent + "connected to at least one story";
                problemTexts.push(text);
            }
        }
        // for story and participant questions, also need to check for type mismatches and answer list mismatches
        for (var _b = 0, _c = ["story", "participant"]; _b < _c.length; _b++) {
            var qType = _c[_b];
            var qInSnapshotOnly = questionsOnlyInFirstList(snapshot[qType + "Questions"], current[qType + "Questions"], "id");
            if (qInSnapshotOnly.length > 0) {
                var qInSnapshotOnlyWithStoryData = [];
                for (var _d = 0, qInSnapshotOnly_1 = qInSnapshotOnly; _d < qInSnapshotOnly_1.length; _d++) {
                    var question = qInSnapshotOnly_1[_d];
                    var storiesWithDataForThisQuestion = numStoriesWithDataForQuestionID(question, stories);
                    if (storiesWithDataForThisQuestion > 0) {
                        qInSnapshotOnlyWithStoryData.push(question);
                    }
                }
                if (qInSnapshotOnlyWithStoryData.length > 0) {
                    var text = "The " + qType + " questions in this list:\n" + indent + displayQuestionIDs(qInSnapshotOnlyWithStoryData, "id")
                        + "\nare:\n" + indent + "in the snapshot version of the form\n"
                        + indent + "not in the current version of the form\n"
                        + indent + "answered for at least one story";
                    problemTexts.push(text);
                }
            }
            var qInBothLists = questionsInBothLists(snapshot[qType + "Questions"], current[qType + "Questions"], "id");
            for (var _e = 0, qInBothLists_1 = qInBothLists; _e < qInBothLists_1.length; _e++) {
                var question = qInBothLists_1[_e];
                var snapshotQuestion = questionForID(snapshot[qType + "Questions"], "id", question.id);
                var currentQuestion = questionForID(current[qType + "Questions"], "id", question.id);
                var problemText = checkTwoQuestionsForTypeAndListMismatches(snapshotQuestion, currentQuestion, stories);
                if (problemText.length > 0) {
                    problemTexts.push(problemText);
                }
            }
        }
        if (problemTexts.length === 0) {
            if (actuallyCopy) {
                doCopy(activeOnWeb, false);
            }
            else {
                var dialogConfiguration = {
                    dialogTitle: "No data conflicts found",
                    dialogConstructionFunction: function () {
                        return constructResultDialog("No data conflicts were found. You can safely update this story form.", null, null, "For your reference, here are the two story forms in detail.", snapshot);
                    },
                    dialogOKCallback: function (dialogConfiguration, hideDialogMethod) { hideDialogMethod(); }
                };
                return dialogSupport.openDialog(dialogConfiguration);
            }
        }
        else {
            var allProblemsText_1 = "";
            for (var i = 0; i < problemTexts.length; i++) {
                allProblemsText_1 += i + 1 + ". " + problemTexts[i] + "\n\n";
            }
            if (actuallyCopy) {
                var dialogConfiguration = {
                    dialogTitle: "There are data conflicts",
                    dialogConstructionFunction: function () {
                        return constructResultDialog("The snapshot story form should not be updated because of the following issues.", null, allProblemsText_1, "Here are the two story forms in detail.", snapshot);
                    },
                    dialogOKButtonLabel: "Override (Update anyway)",
                    dialogOKCallback: function (dialogConfiguration, hideDialogMethod) { hideDialogMethod(); doCopy(activeOnWeb, true); },
                    dialogCancelButtonLabel: actuallyCopy ? "Cancel" : "Close"
                };
                return dialogSupport.openDialog(dialogConfiguration);
            }
            else {
                var dialogConfiguration = {
                    dialogTitle: "There are data conflicts",
                    dialogConstructionFunction: function () {
                        return constructResultDialog("The snapshot story form should not be updated because of the following issues.", null, allProblemsText_1, "Here are the two story forms in detail.", snapshot);
                    },
                    dialogCloseCallback: function (dialogConfiguration, hideDialogMethod) { hideDialogMethod(); }
                };
                return dialogSupport.openDialog(dialogConfiguration);
            }
        }
    }
    function setQuestionnaireForStoryCollection(storyCollectionIdentifier) {
        if (!storyCollectionIdentifier)
            return false;
        var questionnaireName = project.tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_questionnaireIdentifier");
        var questionnaire = questionnaireGeneration.buildStoryForm(questionnaireName);
        if (!questionnaire)
            return false;
        project.tripleStore.addTriple(storyCollectionIdentifier, "questionnaire", questionnaire);
        return true;
    }
});

define('js/buttonActions',["require", "exports", "./panelBuilder/browser", "./csvImportExport", "./panelBuilder/dialogSupport", "./navigationPane", "./pageDisplayer", "./questionnaireGeneration", "./surveyBuilderMithril", "./surveyCollection", "./surveyStorage", "./panelBuilder/translate", "./panelBuilder/toaster", "./printing", "./projectImportExport", "./applicationWidgets/ClusteringDiagram", "./manageStoryCollection"], function (require, exports, browser, csvImportExport, dialogSupport, navigationPane, pageDisplayer, questionnaireGeneration, surveyBuilder, surveyCollection, surveyStorage, translate, toaster, printing, projectImportExport, ClusteringDiagram, manageStoryCollection) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    var project;
    var clientState;
    // Call this to set up the project or other needed data
    function initialize(theProject, theClientState) {
        project = theProject;
        clientState = theClientState;
    }
    exports.initialize = initialize;
    function helpButtonClicked() {
        var pageSpecification = navigationPane.getCurrentPageSpecification();
        if (!pageSpecification) {
            console.log("no pageSpecification for current page");
            return;
        }
        var helpURL = 'help/' + pageSpecification.section + "/help_" + pageSpecification.id + '.html';
        browser.launchApplication(helpURL, 'help');
    }
    exports.helpButtonClicked = helpButtonClicked;
    function showImportGuide() {
        var helpURL = 'help/collection/help_page_importGuide.html';
        browser.launchApplication(helpURL, 'help');
    }
    exports.showImportGuide = showImportGuide;
    function showHelpOnUpdatingStoryFormsInCollections() {
        var helpURL = 'help/collection/help_page_startStoryCollection.html#whatYouCanChange';
        browser.launchApplication(helpURL, 'help');
    }
    exports.showHelpOnUpdatingStoryFormsInCollections = showHelpOnUpdatingStoryFormsInCollections;
    function checkForValidationErrors() {
        var thereAreValidationErrors = false;
        var gridCloseButtons = document.getElementsByClassName("narrafirma-griditempanel-close-button");
        if (gridCloseButtons.length > 0) {
            for (var i = 0; i < gridCloseButtons.length; i++) {
                var button = gridCloseButtons[i];
                var event_1 = button["onclick"];
                if (typeof event_1 == "function") {
                    thereAreValidationErrors = thereAreValidationErrors || event_1.call(button);
                }
            }
        }
        return thereAreValidationErrors;
    }
    exports.checkForValidationErrors = checkForValidationErrors;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // overall - links
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function logoutButtonClicked() {
        if (checkForValidationErrors())
            return;
        if (confirm("Are you sure you want to log out?")) {
            var isWordPressAJAX = !!window["ajaxurl"];
            if (isWordPressAJAX) {
                window.location.href = window.location.href.split("wp-content")[0] + "wp-login.php?action=logout";
            }
            else {
                window.location.href = "/logout";
            }
        }
    }
    exports.logoutButtonClicked = logoutButtonClicked;
    function loginButtonClicked() {
        // TODO: Warn if have any read-only changes that would be lost
        var isWordPressAJAX = !!window["ajaxurl"];
        if (isWordPressAJAX) {
            window.location.href = window.location.href.split("wp-content")[0] + "wp-login.php?action=login";
        }
        else {
            window.location.href = "/login";
        }
    }
    exports.loginButtonClicked = loginButtonClicked;
    function guiOpenSection(model, fieldSpecification, value) {
        if (checkForValidationErrors())
            return;
        var section = fieldSpecification.displayConfiguration.section;
        // Don't queue an extra redraw as one is already queued since this code get called by a button press
        var isRedrawAlreadyQueued = true;
        pageDisplayer.showPage(section, false, isRedrawAlreadyQueued);
        // document.body.scrollTop = 0;
        // document.documentElement.scrollTop = 0;
        window.scrollTo(0, 0);
    }
    exports.guiOpenSection = guiOpenSection;
    function showOrHideAdvancedOptions() {
        clientState.showAdvancedOptions(!clientState.showAdvancedOptions());
    }
    exports.showOrHideAdvancedOptions = showOrHideAdvancedOptions;
    function showOrHideImportOptions() {
        clientState.showImportOptions(!clientState.showImportOptions());
    }
    exports.showOrHideImportOptions = showOrHideImportOptions;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // overall - clustering diagram
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function copyClusteringDiagramElements(fromDiagramField, fromType, toDiagramField, toType) {
        var fromDiagram = project.getFieldValue(fromDiagramField);
        if (!fromDiagram || !fromDiagram.items.length)
            return;
        var toDiagram = project.getFieldValue(toDiagramField) || ClusteringDiagram.newDiagramModel();
        var addedItemCount = 0;
        fromDiagram.items.forEach(function (item) {
            if (item.type === fromType) {
                if (!isNamedItemInDiagram(toDiagram, item.name, toType)) {
                    ClusteringDiagram.addNewItemToDiagram(toDiagram, toType, item.name, item.notes);
                    addedItemCount++;
                }
            }
        });
        if (addedItemCount) {
            toaster.toast("Updating clustering surface");
            project.setFieldValue(toDiagramField, toDiagram);
        }
        else {
            toaster.toast("No changes were needed to clustering surface");
        }
    }
    function copyPlanningStoriesToClusteringDiagram(model) {
        var list = project.getListForField("project_projectStoriesList");
        var toDiagramField = "project_storyElements_answersClusteringDiagram";
        var toDiagram = project.getFieldValue(toDiagramField) || ClusteringDiagram.newDiagramModel();
        var addedItemCount = 0;
        list.forEach(function (projectStoryIdentifier) {
            var projectStory = project.tripleStore.makeObject(projectStoryIdentifier);
            var storyName = projectStory.projectStory_name;
            var storyText = projectStory.projectStory_text;
            if (!isNamedItemInDiagram(toDiagram, storyName, "cluster")) {
                ClusteringDiagram.addNewItemToDiagram(toDiagram, "cluster", storyName, storyText);
                addedItemCount++;
            }
        });
        if (addedItemCount) {
            toaster.toast("Updating clustering surface");
            project.setFieldValue(toDiagramField, toDiagram);
        }
        else {
            toaster.toast("No changes were needed to clustering surface");
        }
    }
    exports.copyPlanningStoriesToClusteringDiagram = copyPlanningStoriesToClusteringDiagram;
    function isNamedItemInDiagram(diagram, name, itemType) {
        if (itemType === void 0) { itemType = null; }
        // Array.some returns true or false depending on whether there is soem item that tests true 
        return diagram.items.some(function (item) {
            if (!itemType || item.type === itemType) {
                if (item.name === name) {
                    return true;
                }
            }
            return false;
        });
    }
    function copyAnswersToClusteringDiagram(model) {
        copyClusteringDiagramElements("project_storyElements_answersClusteringDiagram", "item", "project_storyElements_answerClustersClusteringDiagram", "item");
    }
    exports.copyAnswersToClusteringDiagram = copyAnswersToClusteringDiagram;
    function copyAnswerClustersToClusteringDiagram(model) {
        copyClusteringDiagramElements("project_storyElements_answerClustersClusteringDiagram", "cluster", "project_storyElements_attributesClusteringDiagram", "cluster");
    }
    exports.copyAnswerClustersToClusteringDiagram = copyAnswerClustersToClusteringDiagram;
    function copyAttributesToClusteringDiagram(model) {
        copyClusteringDiagramElements("project_storyElements_attributesClusteringDiagram", "item", "project_storyElements_attributeClustersClusteringDiagram", "item");
    }
    exports.copyAttributesToClusteringDiagram = copyAttributesToClusteringDiagram;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // planning
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function copyDraftPNIQuestionVersionsIntoAnswers_Basic() {
        var finalQuestionIDs = [
            "project_pniQuestions_goal_final",
            "project_pniQuestions_relationships_final",
            "project_pniQuestions_focus_final",
            "project_pniQuestions_range_final",
            "project_pniQuestions_scope_final",
            "project_pniQuestions_emphasis_final"
        ];
        var copiedAnswersCount = 0;
        for (var index in finalQuestionIDs) {
            var finalQuestionID = finalQuestionIDs[index];
            var draftQuestionID = finalQuestionID.replace("_final", "_draft");
            var finalValue = project.tripleStore.queryLatestC(project.projectIdentifier, finalQuestionID);
            if (!finalValue) {
                var draftValue = project.tripleStore.queryLatestC(project.projectIdentifier, draftQuestionID);
                if (draftValue) {
                    project.tripleStore.addTriple(project.projectIdentifier, finalQuestionID, draftValue);
                    copiedAnswersCount++;
                }
            }
        }
        return copiedAnswersCount;
    }
    function copyDraftPNIQuestionVersionsIntoAnswers() {
        var copiedAnswersCount = copyDraftPNIQuestionVersionsIntoAnswers_Basic();
        var template = translate("#copyDraftPNIQuestion_template", "Copied {{copiedAnswersCount}} answers.\n\n(Note that blank draft answers are not copied, and non-blank final answers are not replaced.)");
        var message = template.replace("{{copiedAnswersCount}}", copiedAnswersCount);
        alert(message);
    }
    exports.copyDraftPNIQuestionVersionsIntoAnswers = copyDraftPNIQuestionVersionsIntoAnswers;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // collection
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Caller should call wizard.forward() on successful save to see the last page, and provide a retry message otherwise
    // Caller may also want to call (the returned) surveyDialog.hide() to close the window, or let the user do it.
    function openMithrilSurveyDialog(questionnaire, callback, previewModeTitleText) {
        if (previewModeTitleText === void 0) { previewModeTitleText = null; }
        var surveyViewFunction = surveyBuilder.buildSurveyForm(null, questionnaire, callback, { previewMode: !!previewModeTitleText, ignoreTitleChange: true, dataEntry: true });
        var dialogConfiguration = {
            dialogModel: null,
            dialogTitle: "Enter Story" + (previewModeTitleText || ""),
            dialogClass: undefined,
            dialogConstructionFunction: surveyViewFunction,
            dialogOKButtonLabel: "Close",
            dialogOKCallback: function (dialogConfiguration, hideDialogMethod) { hideDialogMethod(); }
        };
        return dialogSupport.openDialog(dialogConfiguration);
    }
    function openSurveyDialog() {
        var storyCollectionName = clientState.storyCollectionName();
        if (!storyCollectionName) {
            // TODO: translate
            alert("Please select a story collection first.");
            return null;
        }
        var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName, true);
        if (!questionnaire)
            return;
        var surveyDialog = openMithrilSurveyDialog(questionnaire, finished);
        function finished(status, surveyResult, wizardPane) {
            console.log("surveyResult", status, surveyResult);
            if (status === "submitted") {
                surveyStorage.storeSurveyResult(project.pointrelClient, project.projectIdentifier, storyCollectionName, surveyResult, wizardPane);
            }
        }
    }
    function copyStoryFormURL() {
        alert("Story form URL is: " + "http://localhost:8080/survey.html");
    }
    exports.copyStoryFormURL = copyStoryFormURL;
    function previewQuestionForm(model, fieldSpecification) {
        var questionnaire = questionnaireGeneration.buildStoryFormUsingTripleStoreID(model, "");
        window["narraFirma_previewQuestionnaire"] = questionnaire;
        var w = window.open("survey.html#preview=" + (new Date().toISOString()), "_blank");
    }
    exports.previewQuestionForm = previewQuestionForm;
    function checkCSVDataFileWhileEditingStoryForm(model, fieldSpecification) {
        var questionnaire = questionnaireGeneration.buildStoryFormUsingTripleStoreID(model, "");
        csvImportExport.checkCSVStoriesWithStoryForm(questionnaire);
    }
    exports.checkCSVDataFileWhileEditingStoryForm = checkCSVDataFileWhileEditingStoryForm;
    function exportStoryFormWhileEditingIt_NativeFormat(model, fieldSpecification) {
        var questionnaire = questionnaireGeneration.buildStoryFormUsingTripleStoreID(model, "");
        csvImportExport.exportQuestionnaire(questionnaire);
    }
    exports.exportStoryFormWhileEditingIt_NativeFormat = exportStoryFormWhileEditingIt_NativeFormat;
    function exportStoryFormWhileEditingIt_ExternalFormat(model, fieldSpecification) {
        var questionnaire = questionnaireGeneration.buildStoryFormUsingTripleStoreID(model, "");
        csvImportExport.exportQuestionnaireForImport(questionnaire);
    }
    exports.exportStoryFormWhileEditingIt_ExternalFormat = exportStoryFormWhileEditingIt_ExternalFormat;
    function itemTypeForItemID(itemID) {
        // item types whose short names are required, for lookup:
        // eliciting, story, participant, and annotation questions
        // story forms
        // story collections
        // catalysis reports
        var itemType = null;
        if (itemID.indexOf("ElicitingQuestion") >= 0) {
            itemType = "elicitingQuestion";
        }
        else if (itemID.indexOf("StoryQuestion") >= 0) {
            itemType = "storyQuestion";
        }
        else if (itemID.indexOf("ParticipantQuestion") >= 0) {
            itemType = "participantQuestion";
        }
        else if (itemID.indexOf("AnnotationQuestion") >= 0) {
            itemType = "annotationQuestion";
        }
        else if (itemID.indexOf("StoryForm") >= 0) {
            itemType = "questionForm";
        }
        else if (itemID.indexOf("CatalysisReport") >= 0) {
            itemType = "catalysisReport";
        }
        else if (itemID.indexOf("StoryCollection") >= 0) {
            itemType = "storyCollection";
        }
        else {
            var message = "Error: Unsupported short-name validation check for item: " + itemID;
            alert(message);
            console.log(message);
        }
        return itemType;
    }
    function checkThatItemHasShortName(itemID) {
        if (!itemID)
            return false;
        var item = project.tripleStore.makeObject(itemID, true);
        if (!item)
            return false;
        var itemType = itemTypeForItemID(itemID);
        var shortNameKey = itemType + "_shortName";
        return item[shortNameKey] && item[shortNameKey].length > 0;
    }
    exports.checkThatItemHasShortName = checkThatItemHasShortName;
    function checkThatItemHasShortNameWithNoForwardSlashInIt(itemID) {
        if (!itemID)
            return false;
        var item = project.tripleStore.makeObject(itemID, true);
        if (!item)
            return false;
        var itemType = itemTypeForItemID(itemID);
        var shortNameKey = itemType + "_shortName";
        return item[shortNameKey] && item[shortNameKey].length > 0 && item[shortNameKey].indexOf("/") < 0;
    }
    exports.checkThatItemHasShortNameWithNoForwardSlashInIt = checkThatItemHasShortNameWithNoForwardSlashInIt;
    function checkThatQuestionHasType(itemID) {
        if (!itemID)
            return false;
        var item = project.tripleStore.makeObject(itemID, true);
        if (!item)
            return false;
        // item types where question types are required, for lookup:
        // story, participant, and annotation questions 
        var itemType = null;
        if (itemID.indexOf("StoryQuestion") >= 0) {
            itemType = "storyQuestion";
        }
        else if (itemID.indexOf("ParticipantQuestion") >= 0) {
            itemType = "participantQuestion";
        }
        else if (itemID.indexOf("AnnotationQuestion") >= 0) {
            itemType = "annotationQuestion";
        }
        else if (itemID.indexOf("ElicitingQuestion") >= 0) {
            return true; // eliciting question types are not required
        }
        else {
            var message = "Error: Unsupported question type validation check for item: " + itemID;
            alert(message);
            console.log(message);
        }
        var questionType = item[itemType + "_type"];
        return (questionType && questionType.length > 0);
    }
    exports.checkThatQuestionHasType = checkThatQuestionHasType;
    function questionTypeForID(itemID) {
        if (itemID.indexOf("StoryQuestion") >= 0) {
            return "storyQuestion";
        }
        else if (itemID.indexOf("ParticipantQuestion") >= 0) {
            return "participantQuestion";
        }
        else {
            var message = "Error: Unsupported options list validation check for item: " + itemID;
            alert(message);
            console.log(message);
            return null;
        }
    }
    function checkThatItemHasOptionListIfRequired(itemID) {
        if (!itemID)
            return false;
        var item = project.tripleStore.makeObject(itemID, true);
        if (!item)
            return false;
        var itemType = questionTypeForID(itemID);
        if (!itemType)
            return false;
        var questionType = item[itemType + "_type"];
        if (!questionType)
            return false;
        if (["radiobuttons", "select", "checkboxes"].indexOf(questionType) < 0)
            return true;
        var questionOptionsString = item[itemType + "_options"];
        if (questionOptionsString) {
            var questionOptionsList = item[itemType + "_options"].split("\n");
            return (questionOptionsList.length > 1);
        }
        else {
            return false;
        }
    }
    exports.checkThatItemHasOptionListIfRequired = checkThatItemHasOptionListIfRequired;
    function checkThatItemOptionsHaveNoLeadingOrTrailingWhiteSpaceCharacters(itemID) {
        if (!itemID)
            return false;
        var item = project.tripleStore.makeObject(itemID, true);
        if (!item)
            return true; // in this case, if they have entered nothing, it is not wrong 
        var itemType = questionTypeForID(itemID);
        if (!itemType)
            return false;
        var questionType = item[itemType + "_type"];
        if (!questionType)
            return false;
        if (["radiobuttons", "select", "checkboxes"].indexOf(questionType) < 0)
            return true;
        var questionOptionsString = item[itemType + "_options"];
        if (questionOptionsString) {
            var questionOptionsList = item[itemType + "_options"].split("\n");
            var trimmedQuestionOptionsList = questionOptionsList.map(function (item) { return item.trim(); });
            return (questionOptionsList.join("\n") === trimmedQuestionOptionsList.join("\n"));
        }
        else {
            return true; // in this case, if they have entered nothing, it is not wrong 
        }
    }
    exports.checkThatItemOptionsHaveNoLeadingOrTrailingWhiteSpaceCharacters = checkThatItemOptionsHaveNoLeadingOrTrailingWhiteSpaceCharacters;
    function showStoryAsJSONData(model, fieldSpecification) {
        // don't show questionnaire 
        function replacer(key, value) {
            if (key === "questionnaire") {
                return undefined;
            }
            return value;
        }
        var text = JSON.stringify(model, replacer, 4); // 4 is the number of pretty-print nesting indentation spaces
        dialogSupport.openTextEditorDialog(text, "Story", "Close", "Copy to Clipboard", closeShowDialogClicked, false, true);
    }
    exports.showStoryAsJSONData = showStoryAsJSONData;
    function closeShowDialogClicked(text, hideDialogMethod) {
        hideDialogMethod();
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // catalysis
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function copyInterpretationsToClusteringDiagram() {
        var shortName = clientState.catalysisReportName();
        if (!shortName) {
            alert("Please pick a catalysis report to work with.");
            return;
        }
        var catalysisReportIdentifier = project.findCatalysisReport(shortName);
        if (!catalysisReportIdentifier) {
            alert("Problem finding catalysis report identifier.");
            return;
        }
        var allInterpretations = [];
        var observationSetIdentifier = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_observations");
        if (!observationSetIdentifier) {
            alert("No observations have been made on the Explore Patterns page.");
            return;
        }
        var observationIDs = project.tripleStore.getListForSetIdentifier(observationSetIdentifier);
        var observations = project.tripleStore.queryAllLatestBCForA(observationSetIdentifier);
        for (var key in observations) {
            var observationIdentifier = observations[key];
            var interpretationsSetIdentifier = project.tripleStore.queryLatestC(observationIdentifier, "observationInterpretations");
            if (interpretationsSetIdentifier) {
                var interpretations = project.tripleStore.getListForSetIdentifier(interpretationsSetIdentifier);
                for (var i = 0; i < interpretations.length; i++) {
                    var interpretationIdentifier = interpretations[i];
                    var interpretationName = project.tripleStore.queryLatestC(interpretationIdentifier, "interpretation_name");
                    var interpretationText = project.tripleStore.queryLatestC(interpretationIdentifier, "interpretation_text");
                    if (interpretationName) {
                        allInterpretations.push({
                            "type": "Interpretation",
                            id: interpretationIdentifier,
                            name: interpretationName,
                            text: interpretationText
                        });
                    }
                }
            }
        }
        if (allInterpretations.length === 0) {
            alert("No interpretations have been found for this catalysis report.");
            return;
        }
        var clusteringDiagram = project.tripleStore.queryLatestC(catalysisReportIdentifier, "interpretationsClusteringDiagram");
        if (!clusteringDiagram) {
            clusteringDiagram = ClusteringDiagram.newDiagramModel();
        }
        function findUUIDForInterpretationName(name) {
            for (var index = 0; index < allInterpretations.length; index++) {
                var interpretation = allInterpretations[index];
                if (interpretation.name === name) {
                    return interpretation.id;
                }
            }
            return null;
        }
        function findObservationForInterpretation(observationIDs, id, name) {
            for (var i = 0; i < observationIDs.length; i++) {
                var observationID = observationIDs[i];
                var interpretationsListIdentifier = project.tripleStore.queryLatestC(observationID, "observationInterpretations");
                var interpretationsList = project.tripleStore.getListForSetIdentifier(interpretationsListIdentifier);
                for (var j = 0; j < interpretationsList.length; j++) {
                    if (id) {
                        if (interpretationsList[j] === id) {
                            return observationID;
                        }
                    }
                    else {
                        var interpretation = project.tripleStore.makeObject(interpretationsList[j], true);
                        if (name === interpretation.interpretation_name) {
                            return observationID;
                        }
                    }
                }
            }
            return null;
        }
        // Make sure every item has a referenceUUID linking it to an interpretation
        var existingReferenceUUIDs = {};
        clusteringDiagram.items.forEach(function (item) {
            if (item.type === "item" && !item.referenceUUID) {
                // If no referenceUUID already set, find interpretation based on name
                var uuid = findUUIDForInterpretationName(item.name);
                // Only allow one item to link to an interpretation
                // if there are two items with the same name, only the first one
                // will be mapped to the correct interpretation
                // the second one will be left unconnected to anything
                if (!uuid) {
                    console.log("No UUID found for intepretation name", item.name);
                }
                else {
                    if (existingReferenceUUIDs[uuid]) {
                        console.log("Two interpretations with same name", item.name, uuid);
                    }
                    else {
                        item.referenceUUID = uuid;
                    }
                }
            }
            existingReferenceUUIDs[item.referenceUUID] = true;
        });
        // Update name and notes on existing items
        var updatedItemCount = 0;
        clusteringDiagram.items.forEach(function (item) {
            if (item.type === "item") {
                if (item.referenceUUID) {
                    var itemChanged = false;
                    var newName = project.tripleStore.queryLatestC(item.referenceUUID, "interpretation_name") || "";
                    var newNotes = project.tripleStore.queryLatestC(item.referenceUUID, "interpretation_text") || "";
                    var observationID = findObservationForInterpretation(observationIDs, item.referenceUUID, item.name);
                    var newStrength = null;
                    var newNotesExtra = null;
                    if (observationID) {
                        newStrength = project.tripleStore.queryLatestC(observationID, "observationStrength") || "";
                        var observationTitle = project.tripleStore.queryLatestC(observationID, "observationTitle");
                        var observationDescription = project.tripleStore.queryLatestC(observationID, "observationDescription");
                        var shortenedDescription = observationDescription.slice(0, 200);
                        if (shortenedDescription.length < observationDescription.length)
                            shortenedDescription += " ...";
                        newNotesExtra = observationTitle + " -- " + shortenedDescription;
                    }
                    // if they filled in only name or text, use it for both
                    if (newName === "" || newName === "Deleted interpretation") {
                        newName = newNotes;
                    }
                    else if (newNotes === "" || newNotes === "Deleted interpretation") {
                        newNotes = newName;
                        itemChanged = true;
                    }
                    // update clustering item for change to interpretation and/or observation
                    if (newName !== item.name) {
                        item.name = newName;
                        itemChanged = true;
                    }
                    if (newNotes !== item.notes) {
                        item.notes = newNotes;
                    }
                    if (item.strength === undefined || item.bodyColor === undefined || newStrength != item.strength) {
                        item.strength = newStrength;
                        itemChanged = true;
                    }
                    // recalculate item color even if strength is unchanged, because unassigned-strength color was changed in NF 1.5.2
                    // in older versions the color was too dark (not enough contrast)
                    ClusteringDiagram.setItemColorBasedOnStrength(item, item.strength);
                    if (item.notesExtra === undefined || newNotesExtra === null || newNotesExtra != item.notesExtra) {
                        item.notesExtra = newNotesExtra;
                        itemChanged = true;
                    }
                    if (itemChanged)
                        updatedItemCount++;
                }
            }
        });
        // add items for interpretations not represented in the space
        var addedItemCount = 0;
        allInterpretations.forEach(function (interpretation) {
            if (!existingReferenceUUIDs[interpretation.id]) {
                // check that this interpretation is attached to an observation; if not, it should not be added to the diagram
                var observationID = findObservationForInterpretation(observationIDs, interpretation.id, interpretation.name);
                if (observationID) {
                    // if the user creates an observation and adds interpretations to it,
                    // and then deletes the name and text of the observation, 
                    // the observation will still exist in the system,
                    // and the interpretations will still exist, and they will still link to the observation,
                    // but they should be hidden from the clustering diagram and the report.
                    var observationName = project.tripleStore.queryLatestC(observationID, "observationTitle");
                    var observationDescription = project.tripleStore.queryLatestC(observationID, "observationDescription");
                    var observationStrength = project.tripleStore.queryLatestC(observationID, "observationStrength");
                    if (observationName || observationDescription) {
                        addedItemCount++;
                        var item = ClusteringDiagram.addNewItemToDiagram(clusteringDiagram, "item", interpretation.name, interpretation.text);
                        item.referenceUUID = interpretation.id;
                        item.strength = observationStrength;
                        ClusteringDiagram.setItemColorBasedOnStrength(item, observationStrength);
                    }
                }
            }
        });
        project.tripleStore.addTriple(catalysisReportIdentifier, "interpretationsClusteringDiagram", clusteringDiagram);
        if (addedItemCount === 0 && updatedItemCount === 0) {
            toaster.toast("The clustering space is up to date.");
        }
        else {
            toaster.toast("Added " + addedItemCount + " interpretations and updated " + updatedItemCount + " interpretations in the clustering surface.");
        }
    }
    exports.copyInterpretationsToClusteringDiagram = copyInterpretationsToClusteringDiagram;
    function copyObservationsToClusteringDiagram() {
        var shortName = clientState.catalysisReportName();
        if (!shortName) {
            alert("Please pick a catalysis report to work with.");
            return;
        }
        var catalysisReportIdentifier = project.findCatalysisReport(shortName);
        if (!catalysisReportIdentifier) {
            alert("Problem finding catalysis report identifier.");
            return;
        }
        var observationSetIdentifier = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_observations");
        if (!observationSetIdentifier) {
            alert("No observations have been made on the Explore Patterns page.");
            return;
        }
        var observationIDs = project.tripleStore.getListForSetIdentifier(observationSetIdentifier);
        if (observationIDs.length === 0) {
            alert("No observations have been found for this catalysis report.");
            return;
        }
        var clusteringDiagram = project.tripleStore.queryLatestC(catalysisReportIdentifier, "observationsClusteringDiagram");
        if (!clusteringDiagram) {
            clusteringDiagram = ClusteringDiagram.newDiagramModel();
        }
        // Update name and description and strength on existing items
        var existingReferenceUUIDs = {};
        var updatedItemCount = 0;
        clusteringDiagram.items.forEach(function (item) {
            if (item.type === "item") {
                if (item.referenceUUID) {
                    var itemChanged = false;
                    existingReferenceUUIDs[item.referenceUUID] = item;
                    var newName = project.tripleStore.queryLatestC(item.referenceUUID, "observationTitle") || "";
                    var newNotes = project.tripleStore.queryLatestC(item.referenceUUID, "observationDescription") || "";
                    var newStrength = project.tripleStore.queryLatestC(item.referenceUUID, "observationStrength") || "";
                    // if they filled only one in, use it for both
                    if (newName === "" || newName === "Deleted observation") {
                        newName = newNotes;
                    }
                    else if (newNotes === "" || newNotes === "Deleted observation") {
                        newNotes = newName;
                    }
                    // update clustering item for change to observation
                    if (newName !== item.name) {
                        item.name = newName;
                        itemChanged = true;
                    }
                    if (newNotes !== item.notes) {
                        item.notes = newNotes;
                        itemChanged = true;
                    }
                    if (item.strength === undefined || item.bodyColor === undefined || newStrength != item.strength) {
                        item.strength = newStrength;
                        itemChanged = true;
                    }
                    // recalculate item color even if strength is unchanged, because unassigned-strength color was changed in NF 1.5.2
                    // in older versions the color was too dark (not enough contrast)
                    ClusteringDiagram.setItemColorBasedOnStrength(item, item.strength);
                    if (itemChanged)
                        updatedItemCount++;
                }
            }
        });
        // add items for observations not represented in the space
        var addedItemCount = 0;
        observationIDs.forEach(function (id) {
            if (!existingReferenceUUIDs[id]) {
                var observationName = project.tripleStore.queryLatestC(id, "observationTitle");
                var observationDescription = project.tripleStore.queryLatestC(id, "observationDescription");
                var observationStrength = project.tripleStore.queryLatestC(id, "observationStrength") || "";
                if (observationName || observationDescription) {
                    addedItemCount++;
                    var item = ClusteringDiagram.addNewItemToDiagram(clusteringDiagram, "item", observationName, observationDescription);
                    item.referenceUUID = id;
                    item.strength = observationStrength;
                    ClusteringDiagram.setItemColorBasedOnStrength(item, observationStrength);
                }
            }
        });
        project.tripleStore.addTriple(catalysisReportIdentifier, "observationsClusteringDiagram", clusteringDiagram);
        if (addedItemCount === 0 && updatedItemCount === 0) {
            toaster.toast("The observations clustering diagram is up to date.");
        }
        else {
            project.tripleStore.addTriple(catalysisReportIdentifier, "observationsClusteringDiagram", clusteringDiagram);
            toaster.toast("Added " + addedItemCount + " observations and updated " + updatedItemCount + " observations in the clustering surface.");
        }
    }
    exports.copyObservationsToClusteringDiagram = copyObservationsToClusteringDiagram;
    function copyPrivacyPolicy() {
        var items = [];
        if (!project)
            return;
        var title = project.projectNameOrNickname() + ": Privacy Policy";
        items.push(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_collect"));
        items.push(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_identification"));
        items.push(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_nondisclosure"));
        items.push(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_distribution"));
        items.push(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_invitation"));
        items.push(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_permission"));
        items.push(project.tripleStore.queryLatestC(project.projectIdentifier, "project_privacyPolicy_review"));
        var result = items.join('\n\n');
        dialogSupport.openTextEditorDialog(result, title, "Close", "Copy to Clipboard", closeShowDialogClicked, false, true);
    }
    exports.copyPrivacyPolicy = copyPrivacyPolicy;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // project administration
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function showListOfRemovedStoryCollections() {
        var removedCollections = projectImportExport.listOfRemovedStoryCollections();
        var message = "";
        if (!removedCollections.length) {
            message = "There are no stories in the project connected to deleted story collections.";
        }
        else {
            message = "These story collections have been removed from the project, but ";
            message += "the stories associated with them have not been removed. ";
            message += "You can access any of these collections ";
            message += "by creating a new story collection with the same name.\n\n";
            for (var i = 0; i < removedCollections.length; i++) {
                message += removedCollections[i] + "\n";
            }
        }
        alert(message);
    }
    exports.showListOfRemovedStoryCollections = showListOfRemovedStoryCollections;
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // button actions in other places
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    exports.createNewStoryCollection = manageStoryCollection.createNewStoryCollection;
    exports.updateQuestionnaireForStoryCollection = manageStoryCollection.updateQuestionnaireForStoryCollection;
    exports.checkStoryFormsForDataConflicts = manageStoryCollection.checkStoryFormsForDataConflicts;
    exports.enterSurveyResult = openSurveyDialog;
    exports.toggleWebActivationOfSurvey = surveyCollection.toggleWebActivationOfSurvey;
    exports.storyCollectionStop = surveyCollection.storyCollectionStop;
    exports.importCSVQuestionnaire = csvImportExport.importCSVQuestionnaire;
    exports.importCSVStories = csvImportExport.importCSVStories;
    exports.checkCSVStories = csvImportExport.checkCSVStories;
    exports.exportQuestionnaire = csvImportExport.exportQuestionnaire;
    exports.exportQuestionnaireForImport = csvImportExport.exportQuestionnaireForImport;
    exports.exportStoryCollection = csvImportExport.exportStoryCollection;
    exports.autoFillStoryForm = csvImportExport.autoFillStoryForm;
    exports.exportAnnotationsToCSV = csvImportExport.exportAnnotationsToCSV;
    exports.checkCSVAnnotations = csvImportExport.checkCSVAnnotations;
    exports.importCSVAnnotations = csvImportExport.importCSVAnnotations;
    exports.exportProject = projectImportExport.exportProject;
    exports.importProject = projectImportExport.importProject;
    exports.resetProject = projectImportExport.resetProject;
    exports.exportEntireProject = projectImportExport.exportEntireProject;
    exports.showStoryAsJSON = showStoryAsJSONData;
    exports.printStoryForm = printing.printStoryForm;
    exports.printPrivacyPolicy = printing.printPrivacyPolicy;
    exports.printStoryCards = printing.printStoryCards;
    exports.printCatalysisReport = printing.printCatalysisReport;
    exports.importCatalysisReportElements = csvImportExport.importCSVCatalysisElements;
    exports.exportCatalysisReportElements = csvImportExport.exportCatalysisReportElements;
    exports.exportPresentationOutline = printing.exportPresentationOutline;
    exports.exportCollectionSessionAgenda = printing.exportCollectionSessionAgenda;
    exports.printSensemakingSessionAgenda = printing.printSensemakingSessionAgenda;
    exports.printProjectReport = printing.printProjectReport;
});

define('js/applicationWidgets/add_catalysisReportQuestionChooser',["require", "exports", "mithril", "../panelBuilder/valuePathResolver", "../Globals", "../questionnaireGeneration"], function (require, exports, m, valuePathResolver, Globals, questionnaireGeneration) {
    "use strict";
    "use strict";
    function add_catalysisReportQuestionChooser(panelBuilder, model, fieldSpecification) {
        var project = Globals.project();
        var catalysisReportIdentifier = Globals.clientState().catalysisReportIdentifier();
        if (!catalysisReportIdentifier)
            return m("div", "Please select a catalysis report");
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var storageFunction = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var allStories = project.storiesForCatalysisReport(catalysisReportIdentifier, true);
        var allStoryQuestions = project.storyQuestionsForCatalysisReport(catalysisReportIdentifier);
        var elicitingQuestions = project.elicitingQuestionsForCatalysisReport(catalysisReportIdentifier);
        var allParticipantQuestions = project.participantQuestionsForCatalysisReport(catalysisReportIdentifier);
        // annotation questions are not per questionnaire but global to the project (which is maybe not good?)
        // because annotation questions are global, they are not in the form the other questions are in (which are in the questionnaire)
        // so they must be converted
        var allAnnotationQuestions = questionnaireGeneration.convertEditorQuestions(project.collectAllAnnotationQuestions(), "A_");
        // show questions by type
        var nominalQuestionTypes = ["select", "boolean", "checkbox", "checkboxes", "radiobuttons"];
        var storyRatioQuestions = [];
        var storyTextQuestions = [];
        var storyNominalQuestions = [];
        allStoryQuestions.forEach(function (question) {
            if (question.displayType === "slider") {
                storyRatioQuestions.push(question);
            }
            else if (question.displayType === "text" || question.displayType === "textarea") {
                storyTextQuestions.push(question);
            }
            else if (nominalQuestionTypes.indexOf(question.displayType) !== -1) {
                storyNominalQuestions.push(question);
            }
        });
        var participantRatioQuestions = [];
        var participantTextQuestions = [];
        var participantNominalQuestions = [];
        allParticipantQuestions.forEach(function (question) {
            if (question.displayType === "slider") {
                participantRatioQuestions.push(question);
            }
            else if (question.displayType === "text" || question.displayType === "textarea") {
                participantTextQuestions.push(question);
            }
            else if (nominalQuestionTypes.indexOf(question.displayType) !== -1) {
                participantNominalQuestions.push(question);
            }
        });
        function isChecked(shortName, value) {
            if (value === void 0) { value = undefined; }
            var map = storageFunction() || {};
            if (map === undefined) {
                return false;
            }
            if (value === undefined) {
                return !!map[shortName];
            }
            map[shortName] = !!value;
            storageFunction(map);
        }
        function increment(theObject, fieldName) {
            var count = theObject[fieldName] || 0;
            count++;
            theObject[fieldName] = count;
        }
        function bin(value) {
            var bin = Math.floor(value / 10);
            var high = bin * 10 + 9;
            if (bin >= 9) {
                bin = 9;
                high = 100;
            }
            var low = bin * 10;
            return "" + low + " - " + high;
        }
        function countAnswers(id, questionType) {
            var answerCounts = {};
            var answeredQuestionsCount = 0;
            var naCount = 0;
            allStories.forEach(function (story) {
                var value = story.fieldValue(id);
                if (questionType == "boolean") {
                    if (value) {
                        increment(answerCounts, "yes");
                    }
                    else {
                        increment(answerCounts, "no");
                    }
                    answeredQuestionsCount++;
                }
                else if (questionType == "checkbox") {
                    if (value) {
                        increment(answerCounts, "true");
                    }
                    else {
                        increment(answerCounts, "false");
                    }
                    answeredQuestionsCount++;
                }
                else if (value !== undefined && value !== null && value !== {} && value !== "") {
                    answeredQuestionsCount++;
                    if (questionType === "slider") {
                        // Bin the sliders
                        increment(answerCounts, bin(value));
                    }
                    else if (typeof value === "string" || typeof value === "number") {
                        increment(answerCounts, value);
                    }
                    else {
                        for (var key in value) {
                            if (value[key]) {
                                increment(answerCounts, key);
                            }
                        }
                    }
                }
                else {
                    naCount++;
                }
            });
            if (naCount)
                answerCounts["{N/A}"] = naCount;
            var sortedAnswerCounts = {};
            Object.keys(answerCounts).sort().forEach(function (key) {
                sortedAnswerCounts[key] = answerCounts[key];
            });
            return {
                answeredQuestionsCount: answeredQuestionsCount,
                answerCounts: sortedAnswerCounts
            };
        }
        function buildQuestionCheckbox(shortName, questionType, questionCategory) {
            var id = questionCategory + shortName;
            // now including text questions
            if (questionType === "label" || (questionType === "header"))
                return [];
            // if (questionType === "textarea" || (questionCategory !== "A_" && questionType === "text")) return [];
            var counts = countAnswers(id, questionType);
            var answersHover = shortName + " (" + questionType + ") has " + counts.answeredQuestionsCount + " answers:\n" + JSON.stringify(counts.answerCounts, null, 2);
            return m("div", { title: answersHover }, [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, shortName),
                m("br")
                /*
                "^--- ",
                counts.answeredQuestionsCount,
                " answers: ",
                JSON.stringify(counts.answerCounts, null, 2),
                m("br"),
                m("br")
                */
            ]);
        }
        function buildQuestionCheckboxSpecialForElicitingQuestion() {
            var id = "elicitingQuestion";
            var counts = countAnswers(id, "select");
            var answersHover = id + " has " + counts.answeredQuestionsCount + " answers:\n" + JSON.stringify(counts.answerCounts, null, 2);
            return m("div", { title: answersHover }, [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, "Eliciting question"),
                m("br")
            ]);
        }
        function buildQuestionCheckboxSpecialForNumStoriesTold() {
            var id = "numStoriesTold";
            var counts = countAnswers(id, "select");
            var answersHover = id + " has " + counts.answeredQuestionsCount + " answers:\n" + JSON.stringify(counts.answerCounts, null, 2);
            return m("div", { title: answersHover }, [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, "Number of stories told"),
                m("br")
            ]);
        }
        function buildQuestionCheckboxSpecialForStoryLength() {
            var id = "storyLength";
            return m("div", [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, "Story length"),
                m("br")
            ]);
        }
        function buildQuestionCheckboxSpecialForCollectionDate() {
            var id = "collectionDate";
            return m("div", [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, "Collection date"),
                m("br")
            ]);
        }
        function buildQuestionCheckboxSpecialForLanguage() {
            var id = "language";
            return m("div", [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, "Language"),
                m("br")
            ]);
        }
        function selectElements(displayTypes) {
            if (displayTypes === void 0) { displayTypes = null; }
            var map = {};
            if (elicitingQuestions) {
                elicitingQuestions.forEach(function (question) {
                    if (!displayTypes)
                        map["elicitingQuestion"] = true;
                });
            }
            allStoryQuestions.forEach(function (question) {
                if (!displayTypes || displayTypes.indexOf(question.displayType) >= 0)
                    map["S_" + question.displayName] = true;
            });
            allParticipantQuestions.forEach(function (question) {
                if (!displayTypes || displayTypes.indexOf(question.displayType) >= 0)
                    map["P_" + question.displayName] = true;
            });
            allAnnotationQuestions.forEach(function (question) {
                if (!displayTypes || displayTypes.indexOf(question.displayType) >= 0)
                    map["A_" + question.displayName] = true;
            });
            if (!displayTypes)
                map["numStoriesTold"] = true;
            if (!displayTypes)
                map["storyLength"] = true;
            if (!displayTypes)
                map["collectionDate"] = true;
            if (!displayTypes)
                map["language"] = true;
            storageFunction(map);
        }
        function selectAll() {
            selectElements();
        }
        function selectAllScaleQuestions() {
            selectElements(["slider"]);
        }
        function selectAllChoiceQuestions() {
            selectElements(["select", "radiobuttons", "checkboxes"]);
        }
        function selectAllTextQuestions() {
            selectElements(["text", "textarea"]);
        }
        function selectAllAdditionalQuestions() {
            var map = {};
            map["elicitingQuestion"] = true;
            map["numStoriesTold"] = true;
            map["storyLength"] = true;
            map["collectionDate"] = true;
            map["language"] = true;
            storageFunction(map);
        }
        function selectAllStoryQuestions() {
            var map = {};
            allStoryQuestions.forEach(function (question) {
                map["S_" + question.displayName] = true;
            });
            storageFunction(map);
        }
        function selectAllParticipantQuestions() {
            var map = {};
            allParticipantQuestions.forEach(function (question) {
                map["P_" + question.displayName] = true;
            });
            storageFunction(map);
        }
        function selectAllAnnotationQuestions() {
            var map = {};
            allAnnotationQuestions.forEach(function (question) {
                map["A_" + question.displayName] = true;
            });
            storageFunction(map);
        }
        function clearAll() {
            storageFunction({});
        }
        function numBoxesChecked() {
            var map = storageFunction();
            var result = 0;
            if (map) {
                Object.keys(map).forEach(function (item) {
                    if (map[item])
                        result++;
                });
            }
            return result;
        }
        // TODO: Translate
        var firstColumn = [];
        firstColumn.push(m("b", "Story questions"));
        firstColumn.push(m("br"));
        firstColumn.push(m("br"));
        firstColumn.push(m("i", "Scales"));
        firstColumn.push(m("fieldset", storyRatioQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "S_"); })));
        firstColumn.push(storyRatioQuestions.length ? [] : [m("i", " - none"), m("br")]);
        firstColumn.push(m("br"));
        firstColumn.push(m("i", "Choices"));
        firstColumn.push(m("fieldset", storyNominalQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "S_"); })));
        firstColumn.push(storyNominalQuestions.length ? [] : [m("i", " - none"), m("br")]);
        firstColumn.push(m("br"));
        firstColumn.push(m("i", "Texts"));
        firstColumn.push(m("fieldset", storyTextQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "S_"); })));
        firstColumn.push(storyTextQuestions.length ? [] : [m("i", " - none"), m("br")]);
        var firstColumnTD = m("td", { "class": "narrafirma-questions-chooser-table-td" }, firstColumn);
        var secondColumn = [];
        secondColumn.push(m("b", "Participant questions"));
        secondColumn.push(m("br"));
        secondColumn.push(m("br"));
        secondColumn.push(m("i", "Scales"));
        secondColumn.push(m("fieldset", participantRatioQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "P_"); })));
        secondColumn.push(participantRatioQuestions.length ? [] : [m("i", " - none"), m("br")]);
        secondColumn.push(m("br"));
        secondColumn.push(m("i", "Choices"));
        secondColumn.push(m("fieldset", participantNominalQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "P_"); })));
        secondColumn.push(participantNominalQuestions.length ? [] : [m("i", " - none"), m("br")]);
        secondColumn.push(m("br"));
        secondColumn.push(m("i", "Texts"));
        secondColumn.push(m("fieldset", participantTextQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "P_"); })));
        secondColumn.push(participantTextQuestions.length ? [] : [m("i", " - none"), m("br")]);
        var secondColumnTD = m("td", { "class": "narrafirma-questions-chooser-table-td" }, secondColumn);
        var thirdColumn = [];
        thirdColumn.push(m("b", "Annotation questions"));
        thirdColumn.push(m("br"));
        thirdColumn.push(m("br"));
        thirdColumn.push(m("fieldset", allAnnotationQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "A_"); })));
        thirdColumn.push(allAnnotationQuestions.length ? [] : [m("i", " - none"), m("br")]);
        thirdColumn.push(m("br"));
        thirdColumn.push(m("b", "Additional information"));
        thirdColumn.push(m("br"));
        thirdColumn.push(m("br"));
        if (elicitingQuestions)
            thirdColumn.push(m("fieldset", elicitingQuestions.map(function (question) { return buildQuestionCheckboxSpecialForElicitingQuestion(); })));
        thirdColumn.push(m("fieldset", [
            buildQuestionCheckboxSpecialForNumStoriesTold(),
            buildQuestionCheckboxSpecialForStoryLength(),
            buildQuestionCheckboxSpecialForCollectionDate(),
            buildQuestionCheckboxSpecialForLanguage()
        ]));
        var thirdColumnTD = m("td", { "class": "narrafirma-questions-chooser-table-td" }, thirdColumn);
        var table = m("table", { "class": "narrafirma-questions-chooser-table" }, m("tr", [firstColumnTD, secondColumnTD, thirdColumnTD]));
        return m("div.questionExternal", [prompt,
            m("div", table),
            m("span[style=margin-left: 0.5em]", "Select questions:"),
            m("button", { onclick: selectAll }, "All"),
            m("button", { onclick: selectAllStoryQuestions }, "Story"),
            m("button", { onclick: selectAllParticipantQuestions }, "Participant"),
            m("button", { onclick: selectAllAnnotationQuestions }, "Annotation"),
            m("button", { onclick: selectAllScaleQuestions }, "Scale"),
            m("button", { onclick: selectAllChoiceQuestions }, "Choice"),
            m("button", { onclick: selectAllTextQuestions }, "Text"),
            m("button", { onclick: selectAllAdditionalQuestions }, "Additional"),
            m("button", { onclick: clearAll }, "None"),
            m("br"),
            m("br"),
            m("div[style=margin-left:0.5em]", ["" + numBoxesChecked() + " questions selected; " + allStories.length + " stories"]),
            m("br")
        ]);
    }
    return add_catalysisReportQuestionChooser;
});

define('js/applicationWidgets/add_printStoryCardsQuestionChooser',["require", "exports", "mithril", "../panelBuilder/valuePathResolver", "../Globals", "../questionnaireGeneration"], function (require, exports, m, valuePathResolver, Globals, questionnaireGeneration) {
    "use strict";
    "use strict";
    // TODO: This code is redundant with code from add_catalysisReportQuestionChooser - needs to be merged
    function add_printStoryCardsQuestionChooser(panelBuilder, model, fieldSpecification) {
        var project = Globals.project();
        var storyCollectionName = Globals.clientState().storyCollectionName();
        if (!storyCollectionName)
            return m("div", "Please select a story collection.");
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var storageFunction = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var allStoryQuestions = project.storyQuestionsForStoryCollection(storyCollectionName);
        var elicitingQuestions = [project.elicitingQuestionForStoryCollection(storyCollectionName)];
        var allParticipantQuestions = project.participantQuestionsForStoryCollection(storyCollectionName);
        var allAnnotationQuestions = questionnaireGeneration.convertEditorQuestions(project.collectAllAnnotationQuestions(), "A_");
        function isChecked(shortName, value) {
            if (value === void 0) { value = undefined; }
            var map = storageFunction() || {};
            if (value === undefined) {
                return !!map[shortName];
            }
            map[shortName] = !!value;
            storageFunction(map);
        }
        function buildQuestionCheckbox(shortName, questionType, questionCategory) {
            var id = questionCategory + shortName;
            if (questionType === "label" || (questionType === "header"))
                return [];
            return m("div", [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, shortName),
                m("br")
            ]);
        }
        function buildQuestionCheckboxSpecialForElicitingQuestion() {
            var id = "elicitingQuestion";
            return m("div", [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, "Eliciting question"),
                m("br")
            ]);
        }
        function buildQuestionCheckboxSpecialForNumStoriesTold() {
            var id = "numStoriesTold";
            return m("div", [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, "Number of stories told"),
                m("br")
            ]);
        }
        function buildQuestionCheckboxSpecialForStoryLength() {
            var id = "storyLength";
            return m("div", [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, "Story length"),
                m("br")
            ]);
        }
        function buildQuestionCheckboxSpecialForStoryCollectionDate() {
            var id = "collectionDate";
            return m("div", [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, "Collection date"),
                m("br")
            ]);
        }
        function buildQuestionCheckboxSpecialForLanguage() {
            var id = "language";
            return m("div", [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, "Language"),
                m("br")
            ]);
        }
        function selectElements(displayTypes) {
            if (displayTypes === void 0) { displayTypes = null; }
            var map = {};
            if (elicitingQuestions) {
                elicitingQuestions.forEach(function (question) {
                    if (!displayTypes)
                        map["elicitingQuestion"] = true;
                });
            }
            allStoryQuestions.forEach(function (question) {
                if (!displayTypes || displayTypes.indexOf(question.displayType) >= 0)
                    map["S_" + question.displayName] = true;
            });
            allParticipantQuestions.forEach(function (question) {
                if (!displayTypes || displayTypes.indexOf(question.displayType) >= 0)
                    map["P_" + question.displayName] = true;
            });
            allAnnotationQuestions.forEach(function (question) {
                if (!displayTypes || displayTypes.indexOf(question.displayType) >= 0)
                    map["A_" + question.displayName] = true;
            });
            if (!displayTypes)
                map["numStoriesTold"] = true;
            if (!displayTypes)
                map["storyLength"] = true;
            if (!displayTypes)
                map["collectionDate"] = true;
            if (!displayTypes)
                map["language"] = true;
            storageFunction(map);
        }
        function selectAll() {
            selectElements();
        }
        function selectAllScaleQuestions() {
            selectElements(["slider"]);
        }
        function selectAllChoiceQuestions() {
            selectElements(["select", "radiobuttons", "checkboxes"]);
        }
        function selectAllTextQuestions() {
            selectElements(["text", "textarea"]);
        }
        function selectAllAdditionalQuestions() {
            var map = {};
            map["elicitingQuestion"] = true;
            map["numStoriesTold"] = true;
            map["storyLength"] = true;
            map["collectionDate"] = true;
            map["language"] = true;
            storageFunction(map);
        }
        function selectAllStoryQuestions() {
            var map = {};
            allStoryQuestions.forEach(function (question) {
                map["S_" + question.displayName] = true;
            });
            storageFunction(map);
        }
        function selectAllParticipantQuestions() {
            var map = {};
            allParticipantQuestions.forEach(function (question) {
                map["P_" + question.displayName] = true;
            });
            storageFunction(map);
        }
        function selectAllAnnotationQuestions() {
            var map = {};
            allAnnotationQuestions.forEach(function (question) {
                map["A_" + question.displayName] = true;
            });
            storageFunction(map);
        }
        function clearAll() {
            storageFunction({});
        }
        // TODO: Translate
        // show questions by type
        var nominalQuestionTypes = ["select", "boolean", "checkbox", "checkboxes", "radiobuttons"];
        var storyRatioQuestions = [];
        var storyTextQuestions = [];
        var storyNominalQuestions = [];
        allStoryQuestions.forEach(function (question) {
            if (question.displayType === "slider") {
                storyRatioQuestions.push(question);
            }
            else if (question.displayType === "text" || question.displayType === "textarea") {
                storyTextQuestions.push(question);
            }
            else if (nominalQuestionTypes.indexOf(question.displayType) !== -1) {
                storyNominalQuestions.push(question);
            }
        });
        var participantRatioQuestions = [];
        var participantTextQuestions = [];
        var participantNominalQuestions = [];
        allParticipantQuestions.forEach(function (question) {
            if (question.displayType === "slider") {
                participantRatioQuestions.push(question);
            }
            else if (question.displayType === "text" || question.displayType === "textarea") {
                participantTextQuestions.push(question);
            }
            else if (nominalQuestionTypes.indexOf(question.displayType) !== -1) {
                participantNominalQuestions.push(question);
            }
        });
        var firstColumn = [];
        firstColumn.push(m("b", "Story questions"));
        firstColumn.push(m("br"));
        firstColumn.push(m("br"));
        firstColumn.push(m("i", "Scales"));
        firstColumn.push(m("fieldset", storyRatioQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "S_"); })));
        firstColumn.push(storyRatioQuestions.length ? [] : [m("i", " - none"), m("br")]);
        firstColumn.push(m("br"));
        firstColumn.push(m("i", "Choices"));
        firstColumn.push(m("fieldset", storyNominalQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "S_"); })));
        firstColumn.push(storyNominalQuestions.length ? [] : [m("i", " - none"), m("br")]);
        firstColumn.push(m("br"));
        firstColumn.push(m("i", "Texts"));
        firstColumn.push(m("fieldset", storyTextQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "S_"); })));
        firstColumn.push(storyTextQuestions.length ? [] : [m("i", " - none"), m("br")]);
        var firstColumnTD = m("td", { "class": "narrafirma-questions-chooser-table-td" }, firstColumn);
        var secondColumn = [];
        secondColumn.push(m("b", "Participant questions"));
        secondColumn.push(m("br"));
        secondColumn.push(m("br"));
        secondColumn.push(m("i", "Scales"));
        secondColumn.push(m("fieldset", participantRatioQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "P_"); })));
        secondColumn.push(participantRatioQuestions.length ? [] : [m("i", " - none"), m("br")]);
        secondColumn.push(m("br"));
        secondColumn.push(m("i", "Choices"));
        secondColumn.push(m("fieldset", participantNominalQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "P_"); })));
        secondColumn.push(participantNominalQuestions.length ? [] : [m("i", " - none"), m("br")]);
        secondColumn.push(m("br"));
        secondColumn.push(m("i", "Texts"));
        secondColumn.push(m("fieldset", participantTextQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "P_"); })));
        secondColumn.push(participantTextQuestions.length ? [] : [m("i", " - none"), m("br")]);
        var secondColumnTD = m("td", { "class": "narrafirma-questions-chooser-table-td" }, secondColumn);
        var thirdColumn = [];
        thirdColumn.push(m("b", "Annotation questions"));
        thirdColumn.push(m("br"));
        thirdColumn.push(m("br"));
        thirdColumn.push(m("fieldset", allAnnotationQuestions.map(function (question) { return buildQuestionCheckbox(question.displayName, question.displayType, "A_"); })));
        thirdColumn.push(allAnnotationQuestions.length ? [] : [m("i", " - none"), m("br")]);
        thirdColumn.push(m("br"));
        thirdColumn.push(m("b", "Additional information"));
        thirdColumn.push(m("br"));
        thirdColumn.push(m("br"));
        if (elicitingQuestions)
            thirdColumn.push(m("fieldset", elicitingQuestions.map(function (question) { return buildQuestionCheckboxSpecialForElicitingQuestion(); })));
        thirdColumn.push(m("fieldset", [
            buildQuestionCheckboxSpecialForNumStoriesTold(),
            buildQuestionCheckboxSpecialForStoryLength(),
            buildQuestionCheckboxSpecialForStoryCollectionDate(),
            buildQuestionCheckboxSpecialForLanguage()
        ]));
        var thirdColumnTD = m("td", { "class": "narrafirma-questions-chooser-table-td" }, thirdColumn);
        var table = m("table", { "class": "narrafirma-questions-chooser-table" }, m("tr", [firstColumnTD, secondColumnTD, thirdColumnTD]));
        return m("div.questionExternal", [prompt,
            m("div", table),
            m("span[style=margin-left: 0.5em]", "Select questions:"),
            m("button", { onclick: selectAll }, "All"),
            m("button", { onclick: selectAllStoryQuestions }, "Story"),
            m("button", { onclick: selectAllParticipantQuestions }, "Participant"),
            m("button", { onclick: selectAllAnnotationQuestions }, "Annotation"),
            m("button", { onclick: selectAllScaleQuestions }, "Scale"),
            m("button", { onclick: selectAllChoiceQuestions }, "Choice"),
            m("button", { onclick: selectAllTextQuestions }, "Text"),
            m("button", { onclick: selectAllAdditionalQuestions }, "Additional"),
            m("button", { onclick: clearAll }, "None"),
            m("br"),
        ]);
    }
    return add_printStoryCardsQuestionChooser;
});

define('js/applicationWidgets/add_questionTypeChooser',["require", "exports", "mithril", "../panelBuilder/valuePathResolver", "../Globals"], function (require, exports, m, valuePathResolver, Globals) {
    "use strict";
    "use strict";
    function add_questionTypeChooser(panelBuilder, model, fieldSpecification) {
        var project = Globals.project();
        //const questionCategory = fieldSpecification.displayConfiguration;
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var storageFunction = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var allQuestionTypes = ["label", "header", "boolean", "checkbox", "select", "radiobuttons", "slider", "checkboxes", "text", "textarea"];
        var columnNames = ["No answers", "Yes/no answer", "One answer", "Multiple answers", "Text answer"];
        var questionTypesInTableColumns = [
            ["label", "header"],
            ["boolean", "checkbox"],
            ["radiobuttons", "select", "slider"],
            ["checkboxes"],
            ["text", "textarea"]
        ];
        function isChecked(shortName, value) {
            if (value === void 0) { value = undefined; }
            if (value === undefined) {
                return (storageFunction() === shortName);
            }
            else if (value) {
                storageFunction(shortName);
            }
        }
        function buildChoiceRadioButton(aName, id) {
            var disabled = panelBuilder.readOnly;
            return m("div.narrafirma-question-types-chooser-table-div", { disabled: disabled }, [
                m("input[type=radio]", { id: id, checked: isChecked(id), disabled: disabled, onchange: function (event) { isChecked(id, event.target.checked); } }),
                m(isChecked(id) ? "label.narrafirma-question-types-chooser-table-label-checked" : "label.narrafirma-question-types-chooser-table-label-unchecked", { for: id }, m("span", [
                    m("span", aName),
                    m("br"),
                    m("img", {
                        src: 'help/collection/questionTypeThumbnail_' + id + '.png',
                        class: isChecked(id) ? (disabled ? "narrafirma-question-type-thumbnail-checked-disabled" : "narrafirma-question-type-thumbnail-checked") : "narrafirma-question-type-thumbnail-unchecked",
                        width: "90px"
                    }),
                ])),
            ]);
        }
        var columnTDs = [];
        var _loop_1 = function (i) {
            var column = [];
            column.push(m("div.narrafirma-question-types-chooser-table-header", columnNames[i]));
            column.push(m("br"));
            questionTypesInTableColumns[i].forEach(function (questionType) {
                var radioButton = buildChoiceRadioButton(questionType, questionType);
                column.push(radioButton);
            });
            columnTDs.push(m("td", { "class": "narrafirma-question-types-chooser-table-td" }, m("fieldset", column)));
        };
        for (var i = 0; i < columnNames.length; i++) {
            _loop_1(i);
        }
        // TODO: Translate
        return m("div.questionExternal", [
            prompt, [m("table", { "class": "narrafirma-question-types-chooser-table" }, m("tr", columnTDs))],
        ]);
    }
    return add_questionTypeChooser;
});

define('js/panelBuilder/standardWidgets',["require", "exports", "mithril", "./valuePathResolver", "./translate", "../Globals", "lodash", "../sanitizeHTML"], function (require, exports, m, valuePathResolver, translate, Globals, _, sanitizeHTML) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    function getIdForText(text) {
        return text.replaceAll(" ", "_");
    }
    var clientState = Globals.clientState();
    function closeCopyCollisionTextDialogClicked(text, hideDialogMethod) {
        hideDialogMethod();
    }
    function optionsForSelect(panelBuilder, model, fieldSpecification, currentValue, addNoSelectionOption) {
        var specifiedChoices = fieldSpecification.valueOptions;
        var choices = specifiedChoices;
        if (_.isString(specifiedChoices)) {
            choices = valuePathResolver.newValuePath(model, specifiedChoices)();
            if (_.isString(choices)) {
                // Build choices by making items using tripleStore set
                var choiceItems = [];
                var choiceSet = Globals.project().tripleStore.getListForSetIdentifier(choices);
                for (var i = 0; i < choiceSet.length; i++) {
                    var choiceIdentifier = choiceSet[i];
                    var item = Globals.project().tripleStore.makeObject(choiceIdentifier, true);
                    choiceItems.push(item);
                }
                choices = choiceItems;
            }
        }
        if (!choices) {
            console.log("No choices or options defined for select", fieldSpecification.id);
            return [];
        }
        var isValueInChoices = false;
        var options = [];
        // '-- select --'
        if (addNoSelectionOption)
            options.push({ name: translate("#selection_has_not_been_made|(no selection)"), value: "", selected: !currentValue });
        choices.forEach(function (each) {
            var label;
            var value;
            var selected;
            if (_.isString(each)) {
                label = translate(fieldSpecification.id + "::selection:" + each, each);
                options.push({ name: label, value: each });
                if (currentValue === each)
                    isValueInChoices = true;
            }
            else {
                // TODO: Maybe bug in dojo select that it does not handle values that are not strings
                // http://stackoverflow.com/questions/16205699/programatically-change-selected-option-of-a-dojo-form-select-that-is-populated-b
                if (fieldSpecification.valueOptionsSubfield) {
                    if (each[fieldSpecification.valueOptionsSubfield]) {
                        value = each[fieldSpecification.valueOptionsSubfield];
                    }
                    else {
                        value = "Unnamed " + fieldSpecification.displayName + " (Warning: Cannot be accessed without a name.)";
                    }
                }
                else {
                    value = each.value;
                }
                if (fieldSpecification.displayDataOptionField) {
                    label = each[fieldSpecification.displayDataOptionField];
                }
                else {
                    label = value;
                }
                label = translate(fieldSpecification.id + "::selection:" + label, label);
                if (currentValue === value) {
                    selected = true;
                    isValueInChoices = true;
                }
                else {
                    selected = undefined;
                }
                options.push({ name: label, value: value, selected: selected });
            }
        });
        // return isValueInChoices || (currentValue === null || currentValue === undefined || currentValue === "");
        return options;
    }
    var displayTypesWithoutValues = {
        label: true,
        header: true
    };
    function setSliderValueWithPopup(value, sliderValueOptions) {
        var newValueText = prompt("Type a new value", value);
        var newValue = parseInt(newValueText);
        if (newValue && newValue >= 0 && newValue <= 100) {
            sliderValueOptions.value = newValue;
            return "" + newValue;
        }
        else {
            return "";
        }
    }
    function standardConfigMethod(valueProperty, element, isInitialized) {
        var value = valueProperty();
        if (value === undefined)
            return;
        // nf_lastRetrievedValue is for "keeping a separate "work-in-progress" state property and another "real" property on the side"
        // https://github.com/MithrilJS/mithril.js/issues/1087
        if (!isInitialized) {
            element.value = value;
            element.nf_lastRetrievedValue = value;
            return;
        }
        if (value === element.value)
            return;
        if (element.type !== "text" && element.type !== "textarea") {
            element.value = value;
            return;
        }
        if (element !== document.activeElement) {
            element.value = value;
            return;
        }
        if (element.value === undefined || element.value === "") {
            element.value = value;
            return;
        }
        if (element.nf_lastRetrievedValue === value)
            return;
        var prompt = "Collision alert!\n\nAnother user has changed this field to [ " + value + " ]. Do you want to override their entry?";
        if (confirm(prompt)) {
            valueProperty(element.value);
            element.nf_lastRetrievedValue = element.value;
        }
        else {
            element.value = value;
            element.nf_lastRetrievedValue = value;
        }
    }
    exports.standardConfigMethod = standardConfigMethod;
    function displayQuestion(panelBuilder, model, fieldSpecification) {
        var fieldID = fieldSpecification.id;
        var displayType = fieldSpecification.displayType;
        var questionLabel = panelBuilder.buildQuestionLabel(fieldSpecification);
        var valueProperty = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var value;
        if (!displayTypesWithoutValues[displayType]) {
            value = valueProperty();
        }
        if (value === undefined)
            value = "";
        var isAnnotationQuestion = fieldSpecification.id.indexOf("A_") >= 0;
        var useNormalDivs = typeof fieldSpecification.displayWithoutQuestionDivs === "undefined" || !fieldSpecification.displayWithoutQuestionDivs;
        var displayReadOnly = fieldSpecification.displayReadOnly;
        if (typeof fieldSpecification.displayReadOnly === "function") {
            displayReadOnly = fieldSpecification.displayReadOnly(panelBuilder, model);
        }
        var readOnly = panelBuilder.readOnly || displayReadOnly || (fieldSpecification.valueImmutable && value) || undefined;
        var disabled = readOnly || undefined;
        var parts = [];
        function standardChangeMethod(event, value) {
            if (event)
                value = event.target.value;
            valueProperty(value);
            if (event)
                event.target.nf_lastRetrievedValue = event.target.value;
        }
        var standardValueOptions = {
            id: getIdForText(fieldID),
            // switched from value to config to avoid clearing field when other user enters different data
            // this only works with mithril 0.2.x, must change it when we upgrade to a newer version of mithril
            // value: value,
            config: function (element, isInitialized) { return standardConfigMethod(valueProperty, element, isInitialized); },
            onchange: standardChangeMethod,
            readOnly: readOnly,
            disabled: disabled
        };
        ///////////////////////////////////////////////////////////////////// text /////////////////////////////////////////////////////////////////////
        function displayTextQuestion() {
            questionLabel[0].attrs["for"] = getIdForText(fieldID);
            questionLabel[0].tag = "label";
            var className = "narrafirma-textbox";
            if (fieldSpecification.required) {
                className += "-required";
            }
            var lengthAsNumber = Number(fieldSpecification.displayConfiguration);
            if (!isNaN(lengthAsNumber)) {
                standardValueOptions["style"] = "width: " + lengthAsNumber + "%";
            }
            return [m("input[class=" + className + "]", standardValueOptions), m("br")];
        }
        ///////////////////////////////////////////////////////////////////// textarea /////////////////////////////////////////////////////////////////////
        function displayTextareaQuestion() {
            questionLabel[0].attrs["for"] = getIdForText(fieldID);
            questionLabel[0].tag = "label";
            return [m("textarea[class=narrafirma-textbox]", standardValueOptions), m("br")];
        }
        ///////////////////////////////////////////////////////////////////// one checkbox /////////////////////////////////////////////////////////////////////
        function displayCheckboxQuestion() {
            questionLabel[0].attrs["for"] = getIdForText(fieldID);
            questionLabel[0].tag = "label";
            return [
                m("input[type=checkbox]", {
                    id: getIdForText(fieldID),
                    disabled: disabled,
                    checked: value,
                    onchange: function (event) { standardChangeMethod(null, event.target.checked); }
                }),
                m("label", { "for": getIdForText(fieldID) }, fieldSpecification.displayConfiguration || ""),
                m("br")
            ];
        }
        ///////////////////////////////////////////////////////////////////// set of checkboxes /////////////////////////////////////////////////////////////////////
        function displayCheckboxesQuestion() {
            function disableUncheckedBoxesIfReachedMaxNumAnswers(checkBoxIDs) {
                var numOptionsChecked = 0;
                checkBoxIDs.map(function (anOptionID, index) {
                    if (document.querySelector('#' + anOptionID + ':checked'))
                        numOptionsChecked++;
                });
                var disableUncheckedBoxes = (numOptionsChecked >= fieldSpecification.maxNumAnswers);
                checkBoxIDs.map(function (anOptionID, index) {
                    var element = document.querySelector('#' + anOptionID);
                    if (element && !element.checked) {
                        element.disabled = disableUncheckedBoxes;
                        var label = document.querySelector('label[for="' + anOptionID + '"]');
                        if (label)
                            label.setAttribute("style", "opacity: " + (disableUncheckedBoxes ? "0.5" : "1.0"));
                    }
                });
            }
            delete questionLabel[0].attrs["for"];
            if (!value) {
                value = {};
                standardChangeMethod(null, value);
                // this else is here because of a bug (fixed) in the survey code that caused checkbox answers
                // to be stored as strings instead of dictionaries
                // this will convert the string to a dictionary without losing the (one) value that was set
            }
            else if (typeof (value) === "string") {
                var option = value;
                value = {};
                value[option] = true;
                standardChangeMethod(null, value);
            }
            var checkBoxIDsForThisQuestion = [];
            if (fieldSpecification.maxNumAnswers) {
                fieldSpecification.valueOptions.map(function (option, index) {
                    var optionID = getIdForText(fieldID + "_" + option);
                    checkBoxIDsForThisQuestion.push(optionID);
                });
            }
            if (!fieldSpecification.valueOptions || fieldSpecification.valueOptions.length < 1) {
                if (!isAnnotationQuestion) {
                    return [m("p", "Survey error: No options were created for this question.")];
                }
            }
            var questionParts = [
                fieldSpecification.valueOptions.map(function (option, index) {
                    var optionName = (typeof option === "string") ? option : option.name;
                    var optionValue = (typeof option === "string") ? option : option.value;
                    var optionID = getIdForText(fieldID + "_" + option);
                    return [
                        m("input[type=checkbox]", {
                            id: optionID,
                            checked: !!value[optionValue],
                            onchange: function (event) {
                                value[optionValue] = event.target.checked;
                                standardChangeMethod(null, value);
                                if (fieldSpecification.maxNumAnswers) {
                                    disableUncheckedBoxesIfReachedMaxNumAnswers(checkBoxIDsForThisQuestion);
                                }
                            }
                        }),
                        m("label", { "for": optionID }, sanitizeHTML.generateSmallerSetOfSanitizedHTMLForMithril(optionName)),
                        m("br")
                    ];
                })
            ];
            questionParts.unshift(m("legend", questionLabel[0]));
            questionLabel = [];
            return questionParts;
        }
        ///////////////////////////////////////////////////////////////////// radio buttons /////////////////////////////////////////////////////////////////////
        function displayRadioButtonsQuestion() {
            delete questionLabel[0].attrs["for"];
            var questionParts = [
                fieldSpecification.valueOptions.map(function (option, index) {
                    var optionID = getIdForText(fieldID + "_" + option);
                    return [
                        m("input[type=radio]", {
                            id: optionID,
                            value: option,
                            name: fieldSpecification.id,
                            disabled: disabled,
                            checked: value === option,
                            onchange: standardChangeMethod.bind(null, null, option)
                        }),
                        m("label", { "for": optionID }, sanitizeHTML.generateSmallerSetOfSanitizedHTMLForMithril(option)),
                        m("br")
                    ];
                })
            ];
            questionParts.unshift(m("legend", questionLabel[0]));
            questionLabel = [];
            return questionParts;
        }
        ///////////////////////////////////////////////////////////////////// boolean /////////////////////////////////////////////////////////////////////
        function displayBooleanQuestion() {
            delete questionLabel[0].attrs["for"];
            var questionParts = [
                m("input[type=radio]", {
                    id: getIdForText(fieldID + "_yes"),
                    value: true,
                    name: fieldSpecification.id,
                    disabled: disabled,
                    checked: value === true,
                    onchange: standardChangeMethod.bind(null, null, true)
                }),
                m("label", { "for": getIdForText(fieldID + "_yes") }, "yes"),
                m("br"),
                m("input[type=radio]", {
                    id: getIdForText(fieldID + "_no"),
                    value: false,
                    name: fieldSpecification.id,
                    disabled: disabled,
                    checked: value === false,
                    onchange: standardChangeMethod.bind(null, null, false)
                }),
                m("label", { "for": getIdForText(fieldID + "_no") }, "no"),
                m("br")
            ];
            questionParts.unshift(m("legend", questionLabel[0]));
            questionLabel = [];
            return questionParts;
        }
        ///////////////////////////////////////////////////////////////////// select /////////////////////////////////////////////////////////////////////
        function displaySelectQuestion() {
            questionLabel[0].attrs["for"] = getIdForText(fieldID);
            questionLabel[0].tag = "label";
            var selectOptionsRaw = optionsForSelect(panelBuilder, model, fieldSpecification, value, !fieldSpecification.displayConfiguration);
            var selectOptions = selectOptionsRaw.map(function (option, index) {
                var optionOptions = { value: option.value, selected: undefined };
                if (option.selected)
                    optionOptions.selected = 'selected';
                return m("option", optionOptions, option.name);
            });
            var sizeAsNumber = Number(fieldSpecification.displayConfiguration);
            if (!isNaN(sizeAsNumber))
                standardValueOptions["size"] = sizeAsNumber;
            return [m("select", standardValueOptions, selectOptions), (fieldSpecification.displayWithoutQuestionDivs || isAnnotationQuestion) ? "" : m("br")];
        }
        ///////////////////////////////////////////////////////////////////// slider /////////////////////////////////////////////////////////////////////
        function displaySliderQuestion() {
            function isEmpty(value) {
                return value === undefined || value === null || value === "";
            }
            questionLabel[0].attrs["for"] = getIdForText(fieldID);
            questionLabel[0].tag = "label";
            var checkboxID = getIdForText(fieldID) + "_doesNotApply";
            var sliderValueOptions = { value: value, id: getIdForText(fieldID), onchange: standardChangeMethod, readOnly: readOnly, disabled: disabled, min: 0, max: 100, step: 1 };
            var leftSideText = "";
            var rightSideText = "";
            var doesNotApplyText = "Does not apply";
            if (fieldSpecification.displayConfiguration) {
                if (fieldSpecification.displayConfiguration.length > 1) {
                    leftSideText = fieldSpecification.displayConfiguration[0];
                    rightSideText = fieldSpecification.displayConfiguration[1];
                }
                if (fieldSpecification.displayConfiguration.length > 2) {
                    if (fieldSpecification.displayConfiguration[2])
                        doesNotApplyText = fieldSpecification.displayConfiguration[2];
                }
            }
            // Could suggest 0-100 to support <IE10 that don't have range input -- or could do polyfill
            // if (fieldSpecification.displayPrompt) questionLabel[0].children = fieldSpecification.displayPrompt + " (0-100)";
            var questionParts = [
                m("span", { "class": "narrafirma-slider-low-arrow" }, "◀"),
                m("span", { "class": "narrafirma-slider-low" }, leftSideText),
                m('span', { "class": "narrafirma-slider" }, m('input[type="range"]', sliderValueOptions)),
                m('span', { "class": "narrafirma-slider-high" }, rightSideText),
                m('span', { "class": "narrafirma-slider-high-arrow" }, "▶"),
                m("span", { "class": "narrafirma-slider-value", "tabindex": "0",
                    onclick: function (event) {
                        var newValue = setSliderValueWithPopup(value, sliderValueOptions);
                        if (newValue)
                            valueProperty(newValue);
                    },
                    onkeypress: function (event) {
                        if (event.keyCode == 13) {
                            var newValue = setSliderValueWithPopup(value, sliderValueOptions);
                            if (newValue)
                                valueProperty(newValue);
                        }
                    },
                }, value),
                m("br"),
                m('input[type="checkbox"]', {
                    "class": "narrafirma-slider-does-not-apply",
                    id: checkboxID,
                    checked: isEmpty(sliderValueOptions.value),
                    onclick: function (event) {
                        if (event.target.checked) {
                            valueProperty("");
                        }
                        else {
                            valueProperty("50");
                        }
                    }
                }),
                m("label", { "for": checkboxID }, doesNotApplyText)
            ];
            return questionParts;
        }
        function addAnnotationAnswer(event) {
            var newAnswer = prompt('Type a new answer to add to the list of available answers for the annotation question "' + fieldSpecification.displayName + '."');
            if (newAnswer) {
                fieldSpecification.valueOptions.push(newAnswer);
                Globals.project().addOptionToAnnotationChoiceQuestion(fieldSpecification.id, newAnswer);
                m.redraw();
            }
        }
        ///////////////////////////////////////////////////////////////////// now call the methods ///////////////////////////////////////////////////////////////
        if (displayType === "label") {
            // Nothing to do
        }
        else if (displayType === "header") {
            // Nothing to do; bolding done using style
        }
        else if (displayType === "text") {
            parts = displayTextQuestion();
        }
        else if (displayType === "textarea") {
            parts = displayTextareaQuestion();
        }
        else if (displayType === "checkbox") {
            parts = displayCheckboxQuestion();
        }
        else if (displayType === "checkboxes") {
            parts = [m("fieldset", displayCheckboxesQuestion())];
            if (isAnnotationQuestion)
                parts.push(m("button.narrafirma-add-annotation-choice", { style: "margin-left: 1.5em", onclick: addAnnotationAnswer }, m("span", { class: "buttonWithTextImage addButtonImage" }), "Add New Answer"));
        }
        else if (displayType === "radiobuttons") {
            parts = [m("fieldset", displayRadioButtonsQuestion())];
            if (isAnnotationQuestion)
                parts.push(m("button.narrafirma-add-annotation-choice", { style: "margin-left: 1.5em", onclick: addAnnotationAnswer }, m("span", { class: "buttonWithTextImage addButtonImage" }), "Add New Answer"));
        }
        else if (displayType === "boolean") {
            parts = [m("fieldset", displayBooleanQuestion())];
        }
        else if (displayType === "select") {
            parts = displaySelectQuestion();
            if (isAnnotationQuestion)
                parts.push(m("button.narrafirma-add-annotation-choice", { onclick: addAnnotationAnswer }, m("span", { class: "buttonWithTextImage addButtonImage" }), "Add New Answer"));
        }
        else if (displayType === "slider") {
            parts = displaySliderQuestion();
        }
        else {
            parts = [
                m("span", { style: { "font-weight": "bold" } }, "UNFINISHED: " + fieldSpecification.displayType),
                m("br")
            ];
        }
        if (parts.length && useNormalDivs) {
            parts = m("div", { "class": "questionInternal narrafirma-question-type-" + displayType }, parts);
        }
        if (questionLabel) {
            parts = questionLabel.concat(parts);
        }
        var classString = "questionExternal";
        if (isAnnotationQuestion)
            classString += "-annotation";
        classString += " narrafirma-question-type-" + displayType;
        if (readOnly)
            classString += " read-only";
        if (fieldSpecification.displayClass) {
            classString += " " + fieldSpecification.displayClass;
        }
        if (useNormalDivs) {
            return m("div", { key: fieldID, "class": classString }, parts);
        }
        else {
            return parts;
        }
    }
    exports.displayQuestion = displayQuestion;
});

define('js/applicationWidgets/add_translationDictionaryEditorPanel',["require", "exports", "mithril", "../sanitizeHTML", "../Globals", "../questionnaireGeneration", "../csvImportExport", "../panelBuilder/dialogSupport", "../panelBuilder/standardWidgets"], function (require, exports, m, sanitizeHTML, Globals, questionnaireGeneration, csvImportExport, dialogSupport, standardWidgets) {
    "use strict";
    "use strict";
    function add_translationDictionaryEditorPanel(panelBuilder, model, fieldSpecification) {
        var project = Globals.project();
        var translateableTexts = [];
        var keysOfTranslationDictionary = [];
        var orphanedTexts = [];
        var additionalLanguages = [];
        var dictionarySetID = undefined;
        var dictionaryIDs = [];
        // deal with cases where necessary things are not available or set
        var storyFormID = Globals.clientState().storyFormIdentifier();
        if (!storyFormID)
            return m("div.questionExternal", sanitizeHTML.generateSanitizedHTMLForMithril("Please choose a story form to translate."));
        var storyForm = questionnaireGeneration.buildStoryFormUsingTripleStoreID(storyFormID, "");
        if (!storyForm)
            return m("div.questionExternal", sanitizeHTML.generateSanitizedHTMLForMithril("ERROR: Could not find story form " + storyFormID));
        if (!storyForm.defaultLanguage)
            return m("div.questionExternal", sanitizeHTML.generateSanitizedHTMLForMithril("Please enter a default language."));
        if (!storyForm.languageChoiceQuestion_choices)
            return m("div.questionExternal", sanitizeHTML.generateSanitizedHTMLForMithril("Please enter at least one additional language."));
        // set up data to be used in display
        storyForm = questionnaireGeneration.buildStoryFormUsingTripleStoreID(storyFormID, "");
        translateableTexts = questionnaireGeneration.translateableTextsInStoryForm(storyForm);
        keysOfTranslationDictionary = Object.keys(storyForm.translationDictionary);
        additionalLanguages = storyForm.languageChoiceQuestion_choices.split("\n").map(function (item) { return item.trim(); });
        dictionarySetID = project.tripleStore.queryLatestC(storyFormID, "questionForm_translationDictionary");
        if (!dictionarySetID) {
            dictionarySetID = project.tripleStore.newIdForSet("TranslationDictionarySet");
            project.tripleStore.addTriple(storyFormID, "questionForm_translationDictionary", dictionarySetID);
        }
        dictionaryIDs = project.tripleStore.getListForSetIdentifier(dictionarySetID);
        removeEmptyOrphans();
        var textBoxIDs = [];
        // tell user counts of things
        var totalNumEntries = 0;
        var numEntriesByLanguage = {};
        additionalLanguages.forEach(function (language) { numEntriesByLanguage[language] = 0; });
        keysOfTranslationDictionary.forEach(function (key) {
            additionalLanguages.forEach(function (language) {
                if (storyForm.translationDictionary[key][language]) {
                    numEntriesByLanguage[language]++;
                    totalNumEntries++;
                }
            });
        });
        var questionPrompt = "Texts to translate: " + translateableTexts.length + ".";
        questionPrompt += " Translated texts: " + totalNumEntries + ". ";
        additionalLanguages.forEach(function (language, index) { questionPrompt += language + ": " + numEntriesByLanguage[language] + ". "; });
        if (orphanedTexts.length)
            questionPrompt += " Orphaned translations (not found in story form or questions): " + orphanedTexts.length + ".";
        // lookup functions
        function dictionaryForText(text, dictionaryIDs) {
            for (var i = 0; i < dictionaryIDs.length; i++) {
                var id = dictionaryIDs[i];
                var storedDictionary = project.tripleStore.makeObject(id, true);
                if (storedDictionary.defaultText === text) {
                    storedDictionary.id = id;
                    return storedDictionary;
                }
            }
            return null;
        }
        function dictionaryHasAtLeastOneTranslatedText(dict, additionalLanguages) {
            for (var i = 0; i < additionalLanguages.length; i++) {
                var language = additionalLanguages[i];
                if (dict.hasOwnProperty(language) && dict[language] !== "") {
                    return true;
                }
            }
            return false;
        }
        function removeEmptyOrphans() {
            // remove newly orphaned translations that have no alternative-language texts
            // the user will not benefit from seeing them
            orphanedTexts = questionnaireGeneration.orphanedTranslationsForStoryForm(storyForm);
            var idsToRemove = [];
            var keysToRemove = [];
            orphanedTexts.forEach(function (text) {
                var storedDictionary = dictionaryForText(text, dictionaryIDs);
                if (storedDictionary && !dictionaryHasAtLeastOneTranslatedText(storedDictionary, additionalLanguages)) {
                    idsToRemove.push(storedDictionary.id);
                    keysToRemove.push(storedDictionary.id);
                }
            });
            if (idsToRemove.length > 0) {
                idsToRemove.forEach(function (id) { project.tripleStore.deleteSetItem(dictionarySetID, id); });
                keysToRemove.forEach(function (key) { delete storyForm.translationDictionary[key]; });
                dictionaryIDs = project.tripleStore.getListForSetIdentifier(dictionarySetID);
                keysOfTranslationDictionary = Object.keys(storyForm.translationDictionary);
                orphanedTexts = questionnaireGeneration.orphanedTranslationsForStoryForm(storyForm);
            }
        }
        // button functions
        var thingsYouCanDo = [
            "-- select -- ",
            "Create or update translation dictionary",
            "Delete translation dictionary",
            "Show orphaned translations",
            "Remove orphaned translations",
            "Import translations from CSV",
            "Export translations to CSV",
            "Show all translations",
            "Preview story form"
        ];
        var thingsYouCanDoSelectOptions = [];
        thingsYouCanDo.forEach(function (thing, index) {
            thingsYouCanDoSelectOptions.push(m("option", { value: thing, selected: undefined }, thing));
        });
        function doThings() {
            var thingsYouCanDoElement = document.getElementById("thingsYouCanDo_actionRequested");
            var thing = thingsYouCanDoElement.value;
            switch (thing) {
                case "Create or update translation dictionary":
                    createOrUpdateTranslationDictionary();
                    break;
                case "Delete translation dictionary":
                    resetTranslationDictionary();
                    break;
                case "Show orphaned translations":
                    showOrphanedTranslations();
                    break;
                case "Remove orphaned translations":
                    removeOrphanedTranslations();
                    break;
                case "Import translations from CSV":
                    importTranslationDictionary();
                    break;
                case "Export translations to CSV":
                    exportTranslationDictionary();
                    break;
                case "Show all translations":
                    showAllTranslations();
                    break;
                case "Preview story form":
                    previewStoryForm();
                    break;
                default:
                    alert("Please choose an action from the list before you click the button.");
                    break;
            }
        }
        function createOrUpdateTranslationDictionary() {
            var numNewDictionariesCreated = 0;
            translateableTexts.forEach(function (text) {
                var storedDictionary = dictionaryForText(text, dictionaryIDs);
                if (!storedDictionary) {
                    project.tripleStore.makeNewSetItem(dictionarySetID, "TranslationDictionary", { "defaultText": text });
                    numNewDictionariesCreated++;
                }
            });
            if (numNewDictionariesCreated == 0) {
                alert("The translation dictionary matches the story form.");
            }
            else {
                alert("The translation dictionary was updated. New entries added: " + numNewDictionariesCreated + ".");
            }
        }
        function exportTranslationDictionary() {
            csvImportExport.exportTranslationDictionary(storyForm);
        }
        function importTranslationDictionary() {
            csvImportExport.importTranslationDictionary(storyForm);
        }
        function showOrphanedTranslations() {
            if (!orphanedTexts.length) {
                alert("This story form has no orphaned translations.");
                return;
            }
            var showParts = [];
            showParts.push('These "orphaned" translations are in the translation dictionary, but not in the questions or story form.\n');
            orphanedTexts.forEach(function (key) {
                if (storyForm.translationDictionary.hasOwnProperty(key)) {
                    showParts.push(key);
                    var languagesWritten_1 = 0;
                    Object.keys(storyForm.translationDictionary[key]).forEach(function (innerKey) {
                        if (["defaultText", "id"].indexOf(innerKey) < 0) {
                            if (storyForm.translationDictionary[key][innerKey]) {
                                languagesWritten_1++;
                                showParts.push("    " + innerKey + ": " + storyForm.translationDictionary[key][innerKey]);
                            }
                        }
                    });
                    if (!languagesWritten_1)
                        showParts.push("    (no translations)");
                }
            });
            dialogSupport.openTextEditorDialog(showParts.join("\n"), "Orphaned translations", "Close", "Copy to Clipboard", closeShowDialogClicked, false, true);
        }
        function showAllTranslations() {
            var showParts = [];
            keysOfTranslationDictionary.forEach(function (key) {
                showParts.push(key);
                var languagesWritten = 0;
                Object.keys(storyForm.translationDictionary[key]).forEach(function (innerKey) {
                    if (["defaultText", "id"].indexOf(innerKey) < 0) {
                        if (storyForm.translationDictionary[key][innerKey]) {
                            languagesWritten++;
                            showParts.push("    " + innerKey + ": " + storyForm.translationDictionary[key][innerKey]);
                        }
                    }
                });
                if (!languagesWritten)
                    showParts.push("    (no translations)");
            });
            dialogSupport.openTextEditorDialog(showParts.join("\n"), "All translations", "Close", "Copy to Clipboard", closeShowDialogClicked, false, true);
        }
        function closeShowDialogClicked(text, hideDialogMethod) {
            hideDialogMethod();
        }
        function removeOrphanedTranslations() {
            if (!orphanedTexts.length) {
                alert("This story form has no orphaned translations.");
                return;
            }
            var atLeastOneSetItemHasBeenRemoved = false;
            orphanedTexts.forEach(function (text) {
                dictionaryIDs.forEach(function (id) {
                    var storedDictionary = project.tripleStore.makeObject(id, true);
                    if (storedDictionary.defaultText === text) {
                        atLeastOneSetItemHasBeenRemoved = true;
                        project.tripleStore.deleteSetItem(dictionarySetID, id);
                    }
                });
            });
            if (atLeastOneSetItemHasBeenRemoved) {
                dictionaryIDs = project.tripleStore.getListForSetIdentifier(dictionarySetID);
            }
            alert(orphanedTexts.length + " orphaned translations have been removed from the story form.");
        }
        function resetTranslationDictionary() {
            if (confirm("Are you certain that you want to remove the entire translation dictionary for this story form?")) {
                project.tripleStore.addTriple(storyFormID, "questionForm_translationDictionary", null);
                m.redraw();
            }
        }
        function previewStoryForm() {
            window["narraFirma_previewQuestionnaire"] = storyForm;
            var w = window.open("survey.html#preview=" + (new Date().toISOString()), "_blank");
        }
        function getOrSetDictValue(id, dict, language, value) {
            if (value === undefined) {
                return dict[language] || "";
            }
            else {
                changeTranslationForID(id, value);
            }
        }
        function htmlPartsForDictionary(text, dict) {
            if (!dict)
                return [];
            var partsForThisText = [];
            var explanationHTML = undefined;
            var explanation = questionnaireGeneration.explanationForFormFieldOrQuestion(storyForm, text);
            if (explanation) {
                explanationHTML = m("span.narrafirma-translation-explanation", explanation);
            }
            partsForThisText.push(m("div.narrafirma-text-to-be-translated", [text, explanationHTML || ""]));
            var dictionaryTable = [];
            additionalLanguages.forEach(function (language) {
                var partsForThisLanguage = [];
                partsForThisLanguage.push(m("td.narrafirma-translation-language", language));
                var inputID = text + "::" + language;
                var inputClass = "input[type=text].narrafirma-translation-textbox";
                if (text.length >= 200) {
                    inputClass = "textarea.narrafirma-translation-textbox";
                }
                partsForThisLanguage.push(m("td.narrafirma-translation-textbox", m(inputClass, {
                    id: inputID,
                    // switched from value to config to avoid clearing field when other user enters different data
                    // value: dict[language] || "",
                    config: standardWidgets.standardConfigMethod.bind(null, function (value) { return getOrSetDictValue(inputID, dict, language, value); }),
                    onchange: changeTranslationForEvent
                })));
                textBoxIDs.push(inputID);
                dictionaryTable.push(m("tr"), partsForThisLanguage);
            });
            partsForThisText.push(m("table.narrafirma-translation-dictionary", dictionaryTable));
            return m("div.questionExternal", partsForThisText);
        }
        function changeTranslationForEvent(event) {
            changeTranslationForID(event.target.id, event.target.value);
            if (event)
                event.target.nf_lastRetrievedValue = event.target.value;
        }
        function changeTranslationForID(id, value) {
            if (!id)
                return;
            var textAndLanguage = id.split("::");
            if (textAndLanguage.length < 2)
                return;
            var text = textAndLanguage[0];
            var language = textAndLanguage[1];
            var foundMatchingDictionary = undefined;
            dictionaryIDs.forEach(function (id) {
                var storedDictionary = project.tripleStore.makeObject(id, true);
                if (storedDictionary.defaultText === text) {
                    if (!storedDictionary.hasOwnProperty(language) || storedDictionary[language] !== value) {
                        project.tripleStore.addTriple(id, language, value);
                    }
                    return;
                }
            });
        }
        var parts = [];
        parts.push(m("select", { id: "thingsYouCanDo_actionRequested", style: "margin-left: 0.5em;" }, thingsYouCanDoSelectOptions));
        parts.push(m("button", { id: "thingsYouCanDo_button", onclick: doThings }, m("span", { class: "buttonWithTextImage doItButtonImage" }), "Do it"));
        if (keysOfTranslationDictionary.length > 0) {
            var instructionsPrompt = "Enter translations for each text in the story form, as shown below. (Don't translate the explanations in italics.) \n            If you have made changes to your questions or story form, choose \"Create or update translation dictionary,\" then click \"Do it.\"";
            parts.push(m("div.narrafirma-translation-prompt", instructionsPrompt));
            var sections = [
                "Starting out",
                "Choosing a story-eliciting question",
                "Eliciting questions",
                "Writing and naming a story",
                "Answering questions about the story",
                "Story questions",
                "Telling another story",
                "Answering questions about the participant",
                "Participant questions",
                "Finishing the form"
            ];
            sections.forEach(function (section) {
                var textsForThisSection = questionnaireGeneration.translateableTextsInStoryForm(storyForm, section);
                if (textsForThisSection.length) {
                    if (["Eliciting questions", "Story questions", "Participant questions"].indexOf(section) < 0) {
                        parts.push(m("div", { class: "questionExternal narrafirma-question-type-header", style: "padding: 0.5em 0 0.5em 0.5em" }, section));
                    }
                    textsForThisSection.forEach(function (text) {
                        if (keysOfTranslationDictionary.indexOf(text) >= 0) {
                            parts.push(htmlPartsForDictionary(text, storyForm.translationDictionary[text]));
                        }
                    });
                }
            });
        }
        return [m("div.narrafirma-translation-prompt", sanitizeHTML.generateSanitizedHTMLForMithril(questionPrompt)), parts];
    }
    return add_translationDictionaryEditorPanel;
});

define('js/applicationWidgets/add_choiceQuestionAnswersManagementPanel',["require", "exports", "mithril", "../sanitizeHTML", "../Globals"], function (require, exports, m, sanitizeHTML, Globals) {
    "use strict";
    "use strict";
    var answersWithOpenChangePanels = [];
    function add_choiceQuestionAnswersManagementPanel(panelBuilder, model, fieldSpecification) {
        var question = Globals.project().tripleStore.makeObject(model, true);
        if (!question)
            return m("div.questionExternal", sanitizeHTML.generateSanitizedHTMLForMithril("ERROR: Could not find question " + model));
        if (["select", "radiobuttons", "checkboxes"].indexOf(question.annotationQuestion_type) < 0) {
            return null;
        }
        var project = Globals.project();
        var allStories = project.allStoriesInProject();
        function storyCountForAnswer(answer) {
            var result = 0;
            allStories.forEach(function (story) {
                var value = story.fieldValue("A_" + question.annotationQuestion_shortName);
                if (typeof value == "string") {
                    if (value === answer)
                        result++;
                }
                else {
                    if (value.hasOwnProperty(answer) && value[answer])
                        result++;
                }
            });
            return result;
        }
        function showChangeAnswerPanel(answer) {
            if (answersWithOpenChangePanels.indexOf(answer) < 0)
                answersWithOpenChangePanels.push(answer);
        }
        function hideChangeAnswerPanel(answer) {
            var answerIndex = answersWithOpenChangePanels.indexOf(answer);
            if (answerIndex >= 0) {
                answersWithOpenChangePanels.splice(answerIndex, 1);
            }
        }
        function moveAnswerUpOrDown(answer, upOrDown) {
            var answers = [];
            if (question.annotationQuestion_options) {
                answers = question.annotationQuestion_options.split("\n");
            }
            var answerIndex = answers.indexOf(answer);
            if (answerIndex >= 0) {
                answers.splice(answerIndex, 1);
                if (upOrDown === "up") {
                    if (answerIndex + 1 > answers.length) {
                        answers.unshift(answer);
                    }
                    else {
                        answers.splice(answerIndex + 1, 0, answer);
                    }
                }
                else if (upOrDown === "down") {
                    if (answerIndex - 1 < 0) {
                        answers.push(answer);
                    }
                    else {
                        answers.splice(answerIndex - 1, 0, answer);
                    }
                }
            }
            question.annotationQuestion_options = answers.join("\n");
            project.tripleStore.addTriple(model, "annotationQuestion_options", question.annotationQuestion_options);
        }
        function moveAnswerUp(answer) {
            // down on the screen is up in the list!
            moveAnswerUpOrDown(answer, "down");
        }
        function moveAnswerDown(answer) {
            // down on the screen is up in the list!
            moveAnswerUpOrDown(answer, "up");
        }
        function changeAnswer(answer, inputID) {
            var questionID = "A_" + question.annotationQuestion_shortName;
            var element = document.getElementById(inputID);
            if (element) {
                var newAnswer = element.value;
                if (newAnswer && newAnswer != answer) {
                    var storyCount = storyCountForAnswer(answer);
                    var storyCountText = (storyCount == 1) ? " story" : " stories";
                    var prompt_1 = 'You are about to change the answer "' + answer + '" to "' + newAnswer
                        + '" in the question "' + question.annotationQuestion_shortName;
                    if (storyCount > 0) {
                        prompt_1 += '" - and in ' + storyCount + storyCountText + ".";
                    }
                    else {
                        prompt_1 += '."';
                    }
                    prompt_1 += "\n\nThis action CANNOT be undone. Are you ABSOLUTELY CERTAIN you want to rename this answer?";
                    if (confirm(prompt_1)) {
                        changeAnswerInData(questionID, answer, newAnswer);
                        hideChangeAnswerPanel(answer);
                    }
                }
            }
        }
        function cancelChangingAnswer(answer) {
            hideChangeAnswerPanel(answer);
        }
        function removeAnswer(answer) {
            var questionID = "A_" + question.annotationQuestion_shortName;
            var storyCount = storyCountForAnswer(answer);
            var storyCountText = (storyCount == 1) ? " story" : " stories";
            var prompt = 'You are about to remove the answer "' + answer + '" from the question "'
                + question.annotationQuestion_shortName;
            if (storyCount > 0) {
                prompt += '" - and from ' + storyCount + storyCountText + ".";
            }
            else {
                prompt += '."';
            }
            prompt += "\n\n You CANNOT undo this. Are you SURE you want to remove this answer?";
            if (confirm(prompt)) {
                changeAnswerInData(questionID, answer, null);
            }
        }
        function changeAnswerInData(questionID, answer, newAnswer) {
            allStories.forEach(function (story) {
                var value = story.fieldValue(questionID);
                if (value) {
                    if (typeof value == "string") {
                        if (value === answer) {
                            project.tripleStore.addTriple(story.storyID(), questionID, newAnswer);
                        }
                    }
                    else {
                        if (value.hasOwnProperty(answer)) {
                            delete value[answer];
                            if (newAnswer)
                                value[newAnswer] = true;
                            project.tripleStore.addTriple(story.storyID(), questionID, value);
                        }
                    }
                }
            });
            var answers = [];
            if (question.annotationQuestion_options) {
                answers = question.annotationQuestion_options.split("\n");
            }
            var answerIndex = answers.indexOf(answer);
            if (answerIndex >= 0) {
                answers.splice(answerIndex, 1);
            }
            if (newAnswer) {
                if (answers.indexOf(newAnswer) < 0) {
                    answers.push(newAnswer);
                }
            }
            question.annotationQuestion_options = answers.join("\n");
            project.tripleStore.addTriple(model, "annotationQuestion_options", question.annotationQuestion_options);
        }
        function addAnswer() {
            var newAnswer = prompt('Type a new answer to add to the list of available answers for the annotation question "' + question.annotationQuestion_shortName + '."');
            if (newAnswer) {
                var answers_1 = [];
                if (question.annotationQuestion_options) {
                    answers_1 = question.annotationQuestion_options.split("\n");
                }
                if (answers_1.indexOf(newAnswer) < 0) {
                    answers_1.push(newAnswer);
                    question.annotationQuestion_options = answers_1.join("\n");
                    project.tripleStore.addTriple(model, "annotationQuestion_options", question.annotationQuestion_options);
                }
            }
        }
        var questionPrompt = "These are the <strong>answers</strong> you have entered for this question.\n        <em>Changing an answer here will change it in this question and in your stories.</em>";
        var parts = [];
        var answers = [];
        if (question.annotationQuestion_options) {
            answers = question.annotationQuestion_options.split("\n");
        }
        if (answers.length > 0) {
            answers.map(function (answer, index) {
                var partsForThisAnswer = [];
                var storyCount = storyCountForAnswer(answer);
                var storyCountText = (storyCount == 1) ? " story" : " stories";
                partsForThisAnswer.push(m(panelBuilder.readOnly ? "div" : "span", { style: panelBuilder.readOnly ? "margin: 0.5em 0 0 0.5em" : "margin: 0" }, answer + " - " + storyCount + storyCountText));
                if (!panelBuilder.readOnly) {
                    if (answersWithOpenChangePanels.indexOf(answer) < 0) {
                        partsForThisAnswer.push(m("button", { id: "moveAnswerUp", onclick: function () { moveAnswerUp(answer); } }, m("span", { class: "buttonWithTextImage upButtonImage" }), "Up"));
                        partsForThisAnswer.push(m("button", { id: "moveAnswerDown", onclick: function () { moveAnswerDown(answer); } }, m("span", { class: "buttonWithTextImage downButtonImage" }), "Down"));
                        partsForThisAnswer.push(m("button", { id: "changeAnswer", onclick: function () { showChangeAnswerPanel(answer); } }, m("span", { class: "buttonWithTextImage changeButtonImage" }), "Change"));
                        partsForThisAnswer.push(m("button", { id: "removeAnswerFromList", onclick: function () { removeAnswer(answer); } }, m("span", { class: "buttonWithTextImage removeButtonImage" }), "Remove"));
                    }
                    else {
                        var inputID_1 = question.annotationQuestion_shortName + "_" + answer + "_change";
                        partsForThisAnswer.push(m("input", { id: inputID_1, style: "margin-left: 1em" }));
                        partsForThisAnswer.push(m("button", { id: "confirmAnswerChange", style: "background-color: #f88a57", onclick: function () { changeAnswer(answer, inputID_1); } }, m("span", { class: "buttonWithTextImage confirmButtonImage" }), "Confirm"));
                        partsForThisAnswer.push(m("button", { id: "cancelAnswerChange", style: "background-color: #ffe1aa", onclick: function () { cancelChangingAnswer(answer); } }, m("span", { class: "buttonWithTextImage cancelButtonImage" }), "Cancel"));
                    }
                }
                parts.push(m("div.narrafirma-annotation-choice-answers-answer", partsForThisAnswer));
            });
        }
        else {
            parts.push(m("div.narrafirma-annotation-choice-answers-answer", '(No answers have been created. Click "Add a New Answer" to create one.)'));
        }
        if (!panelBuilder.readOnly) {
            parts.push(m("button", { id: "addAnswerToList", onclick: function () { addAnswer(); } }, m("span", { class: "buttonWithTextImage addButtonImage" }), "Add a New Answer"));
        }
        return m("div.questionExternal", [m("div.narrafirma-annotation-choice-answers-prompt", sanitizeHTML.generateSanitizedHTMLForMithril(questionPrompt)), parts]);
    }
    return add_choiceQuestionAnswersManagementPanel;
});

define('js/applicationWidgets/add_checkboxQuestionConfigurationPanel',["require", "exports", "mithril", "../sanitizeHTML", "../panelBuilder/valuePathResolver"], function (require, exports, m, sanitizeHTML, valuePathResolver) {
    "use strict";
    "use strict";
    function add_checkboxQuestionConfigurationPanel(panelBuilder, model, fieldSpecification) {
        var storageFunction = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var questionPrompt = "Enter a <strong>label</strong> for the checkbox shown in this question.";
        if (model.indexOf("AnnotationQuestion") >= 0)
            questionPrompt += " <em>You can change this checkbox label after you start using the question.</em>";
        function getValue() {
            var value = storageFunction();
            if (value) {
                var parts_1 = value.split("\n");
                return parts_1[0] || "";
            }
            else {
                return "";
            }
        }
        function setNewValue(value) {
            storageFunction(value);
        }
        var parts = [
            m("div.questionPrompt", sanitizeHTML.generateSanitizedHTMLForMithril(questionPrompt)),
            m("div.questionInternal", [
                m("input[type=checkbox]", { style: "margin-left:1em", id: fieldSpecification.id + "_check", disabled: panelBuilder.readOnly }),
                m("input", { value: getValue(), disabled: panelBuilder.readOnly, onchange: function (event) { setNewValue(event.target.value); } })
            ])
        ];
        return m("div.questionExternal", parts);
    }
    return add_checkboxQuestionConfigurationPanel;
});

define('js/applicationWidgets/add_sliderQuestionConfigurationPanel',["require", "exports", "mithril", "../sanitizeHTML", "../panelBuilder/valuePathResolver", "../panelBuilder/standardWidgets"], function (require, exports, m, sanitizeHTML, valuePathResolver, standardWidgets) {
    "use strict";
    "use strict";
    function add_sliderQuestionConfigurationPanel(panelBuilder, model, fieldSpecification) {
        var ids = [fieldSpecification.id + "_left", fieldSpecification.id + "_right", fieldSpecification.id + "_na"];
        var storageFunction = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var isAnnotationQuestion = model.indexOf("AnnotationQuestion") >= 0;
        var questionPrompt = "Enter the <strong>left and right labels</strong> you want to appear on the slider.";
        if (isAnnotationQuestion)
            questionPrompt += " <em>You can change these slider labels after you start using this question.</em>";
        var naPrompt = "The <strong>checkbox under the slider</strong> gives";
        if (isAnnotationQuestion) {
            naPrompt += " you a way to leave the question unanswered.";
        }
        else {
            naPrompt += " participants a way to say they don't want to answer the question.";
        }
        naPrompt += ' You can set the label for that checkbox here. To use the default label of "Does not apply," leave this field blank.';
        function getValueForIndex(index) {
            var combinedTexts = storageFunction();
            if (combinedTexts) {
                var parts_1 = combinedTexts.split("\n");
                return parts_1[index] || "";
            }
            else {
                return "";
            }
        }
        function setNewValues() {
            var parts = [];
            for (var i = 0; i < 3; i++) {
                parts.push(document.getElementById(ids[i]).value || "");
            }
            var combinedTexts = parts.join("\n");
            storageFunction(combinedTexts);
        }
        function getOrSetSliderValue(index, value) {
            if (value === undefined) {
                return getValueForIndex(index);
            }
            else {
                setNewValues();
            }
        }
        var parts = [
            m("div.questionPrompt", sanitizeHTML.generateSanitizedHTMLForMithril(questionPrompt)),
            m("div.questionInternal", [
                m('input[type="text"]', { id: ids[0],
                    // switched from value to config to avoid clearing field when other user enters different data
                    // value: getValueForIndex(0),
                    config: standardWidgets.standardConfigMethod.bind(null, function (value) { return getOrSetSliderValue(0, value); }),
                    disabled: panelBuilder.readOnly,
                    onchange: function (event) {
                        setNewValues();
                        if (event)
                            event.target.nf_lastRetrievedValue = event.target.value;
                    } }),
                m('input[type="range"]', { disabled: panelBuilder.readOnly }),
                m('input[type="text"]', { id: ids[1],
                    // value: getValueForIndex(1), 
                    config: standardWidgets.standardConfigMethod.bind(null, function (value) { return getOrSetSliderValue(1, value); }),
                    disabled: panelBuilder.readOnly,
                    onchange: function (event) {
                        setNewValues();
                        if (event)
                            event.target.nf_lastRetrievedValue = event.target.value;
                    } })
            ]),
            m("div.questionPrompt", sanitizeHTML.generateSanitizedHTMLForMithril(naPrompt)),
            m("div.questionInternal", [
                m('input[type="text"]', { id: ids[2],
                    // value: getValueForIndex(2), 
                    config: standardWidgets.standardConfigMethod.bind(null, function (value) { return getOrSetSliderValue(2, value); }),
                    disabled: panelBuilder.readOnly,
                    onchange: function (event) {
                        setNewValues();
                        if (event)
                            event.target.nf_lastRetrievedValue = event.target.value;
                    } })
            ])
        ];
        return m("div.questionExternal", parts);
    }
    return add_sliderQuestionConfigurationPanel;
});

define('js/applicationWidgets/add_shortNameQuestionConfigurationPanel',["require", "exports", "mithril", "../sanitizeHTML", "../panelBuilder/valuePathResolver", "../Globals"], function (require, exports, m, sanitizeHTML, valuePathResolver, Globals) {
    "use strict";
    "use strict";
    var changeAnnotationQuestionShortNamePanelIsOpen = false;
    function add_shortNameQuestionConfigurationPanel(panelBuilder, model, fieldSpecification) {
        var project = Globals.project();
        var question = Globals.project().tripleStore.makeObject(model, true);
        var isAnnotationQuestion = model.indexOf("AnnotationQuestion") >= 0;
        var storageFunction = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var questionPrompt = "Enter a <strong>short name</strong> for the question. It will appear in lists and on graphs. It is required and must be unique within the project.";
        if (isAnnotationQuestion)
            questionPrompt += " <em>Changing this question's short name here will change it in this question and in your stories.</em> ";
        // methods that apply to all types of questions
        function existingShortNameThatMatchesNewShortName(newShortName) {
            var allQuestions = Globals.project().collectAllQuestionsOfAnyKind();
            for (var i = 0; i < allQuestions.length; i++) {
                var question_1 = allQuestions[i];
                var shortName = question_1.elicitingQuestion_shortName || question_1.storyQuestion_shortName || question_1.participantQuestion_shortName || question_1.annotationQuestion_shortName;
                if (shortName === newShortName && question_1.id != model) {
                    return shortName;
                }
            }
            return null;
        }
        function setNewShortName(newShortName) {
            var newShortNameTrimmed = newShortName.trim();
            var existingShortName = existingShortNameThatMatchesNewShortName(newShortNameTrimmed);
            if (existingShortName) {
                alert('The short name "' + existingShortName + '" has already been used in this project. Please choose another short name.');
            }
            else {
                storageFunction(newShortNameTrimmed);
            }
        }
        // methods that only apply to annotation questions
        function openChangeAnnotationQuestionShortNamePanel() {
            changeAnnotationQuestionShortNamePanelIsOpen = true;
        }
        function cancelChangingAnnotationQuestionShortName() {
            changeAnnotationQuestionShortNamePanelIsOpen = false;
        }
        function changeAnnotationQuestionShortName() {
            if (!isAnnotationQuestion)
                return;
            var newAnswer = document.getElementById(fieldSpecification.id).value;
            var prompt = 'You are about to change this question\'s short name from "'
                + question.annotationQuestion_shortName + '" to "' + newAnswer
                + '." This will affect all of the stories in the project.';
            prompt += "\n\nThis action CANNOT be undone. Are you CERTAIN that you want to change this question's short name?";
            if (confirm(prompt)) {
                changeAnnotationQuestionShortNameInQuestionAndInStories(newAnswer);
                changeAnnotationQuestionShortNamePanelIsOpen = false;
            }
        }
        function changeAnnotationQuestionShortNameInQuestionAndInStories(newShortName) {
            if (!newShortName)
                return;
            if (!isAnnotationQuestion)
                return;
            var existingShortName = existingShortNameThatMatchesNewShortName(newShortName);
            if (existingShortName) {
                alert('The short name "' + existingShortName + '" has already been used in this project. Please choose another short name.');
            }
            else {
                var oldQuestionID_1 = "A_" + question.annotationQuestion_shortName;
                var newQuestionID_1 = "A_" + newShortName;
                var allStories = project.allStoriesInProject();
                allStories.forEach(function (story) {
                    // the old value is left in the story just in case of a mistake
                    // the stored value will never be referenced again (unless the question name is changed back to what it was)
                    var value = story.fieldValue(oldQuestionID_1);
                    story.fieldValue(newQuestionID_1, value);
                    project.tripleStore.addTriple(story.storyID(), newQuestionID_1, value);
                });
                question.annotationQuestion_shortName = newShortName;
                project.tripleStore.addTriple(model, "annotationQuestion_shortName", question.annotationQuestion_shortName);
            }
        }
        var parts = [m("div.questionPrompt", sanitizeHTML.generateSanitizedHTMLForMithril(questionPrompt))];
        if (isAnnotationQuestion) {
            var value = storageFunction();
            if (value === undefined) {
                parts.push(m("div.questionInternal", [
                    m("input", {
                        id: fieldSpecification.id,
                        class: "narrafirma-textbox-required",
                        style: "width: 20em;",
                        // not using config function here because it conflicts with validation
                        // also, the probability of two users writing different names for the same item at the same time seems vanishingly small 
                        value: storageFunction() || "",
                        disabled: panelBuilder.readOnly,
                        onchange: function (event) { if (event)
                            setNewShortName(event.target.value); }
                    })
                ]));
            }
            else {
                if (!changeAnnotationQuestionShortNamePanelIsOpen) {
                    var readOnlyStyle = "display: block; margin: 0.5em 0 0 1em";
                    var editingStyle = "margin-left: 1em";
                    parts.push(m("span", { style: panelBuilder.readOnly ? readOnlyStyle : editingStyle }, sanitizeHTML.generateSanitizedHTMLForMithril(value)));
                    if (!panelBuilder.readOnly)
                        parts.push(m("button", { id: "openChangeShortNamePanel", onclick: function () { openChangeAnnotationQuestionShortNamePanel(); } }, m("span", { class: "buttonWithTextImage changeButtonImage" }), "Change"));
                }
                else {
                    parts.push(m("input", { id: fieldSpecification.id, class: "narrafirma-textbox-short-required", value: storageFunction() || "", disabled: panelBuilder.readOnly }));
                    if (!panelBuilder.readOnly) {
                        parts.push(m("button", { id: "confirmShortNameChange", style: "background-color: #f88a57", onclick: function () { changeAnnotationQuestionShortName(); } }, m("span", { class: "buttonWithTextImage confirmButtonImage" }), "Confirm"));
                        parts.push(m("button", { id: "cancelShortNameChange", style: "background-color: #ffe1aa", onclick: function () { cancelChangingAnnotationQuestionShortName(); } }, m("span", { class: "buttonWithTextImage cancelButtonImage" }), "Cancel"));
                    }
                }
            }
        }
        else {
            parts.push(m("div.questionInternal", [
                m("input", {
                    id: fieldSpecification.id,
                    class: "narrafirma-textbox-required",
                    style: "width: 20em;",
                    // not using config function here because it conflicts with validation
                    // also, the probability of two users writing different names for the same item at the same time seems vanishingly small 
                    value: storageFunction() || "",
                    disabled: panelBuilder.readOnly,
                    onchange: function (event) { if (event)
                        setNewShortName(event.target.value); }
                })
            ]));
        }
        return m("div.questionExternal", parts);
    }
    return add_shortNameQuestionConfigurationPanel;
});

define('js/applicationWidgets/add_catalysisReportGraphTypesChooser',["require", "exports", "mithril", "../panelBuilder/valuePathResolver", "../Globals"], function (require, exports, m, valuePathResolver, Globals) {
    "use strict";
    "use strict";
    function add_catalysisReportGraphTypesChooser(panelBuilder, model, fieldSpecification) {
        var project = Globals.project();
        var catalysisReportIdentifier = Globals.clientState().catalysisReportIdentifier();
        if (!catalysisReportIdentifier)
            return m("div", "Please select a catalysis report");
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var storageFunction = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var allGraphTypes = {
            "bar graphs": true,
            "histograms": true,
            "tables": true,
            "multiple histograms": true,
            "scatterplots": true,
            "contingency-histogram tables": true,
            "multiple scatterplots": true,
            "correlation maps": true,
            "data integrity graphs": true,
            "texts": true,
            "write-in texts": true
        };
        var allGraphTypesThumbnailNames = {
            "bar graphs": "barGraphs",
            "histograms": "histograms",
            "tables": "tables",
            "multiple histograms": "multiHistograms",
            "scatterplots": "scatterPlots",
            "contingency-histogram tables": "contingencyHistograms",
            "multiple scatterplots": "multiScatterPlots",
            "correlation maps": "correlationMaps",
            "data integrity graphs": "dataIntegrity",
            "texts": "texts",
            "write-in texts": "writeInTexts"
        };
        var graphTypesToDisplayNamesMap = {
            "bar graphs": "bar graphs (choices)",
            "histograms": "histograms (scales)",
            "tables": "tables (choices + choices)",
            "multiple histograms": "histogram sets (scales + choices)",
            "scatterplots": "scatterplots (scales + scales)",
            "contingency-histogram tables": "histogram tables (choices + choices + scales)",
            "multiple scatterplots": "scatterplot sets (scales + scales + choices)",
            "correlation maps": "correlation maps (all scales together + choices)",
            "data integrity graphs": "data integrity graphs",
            "texts": "text listings",
            "write-in texts": "write-in text listings"
        };
        var graphTypesToSingularDisplayNamesMap = {
            "bar graphs": "bar graph (choice)",
            "histograms": "histogram (scale)",
            "tables": "table (choice + choice)",
            "multiple histograms": "histogram set (scale + choice)",
            "scatterplots": "scatterplot (scale + scale)",
            "contingency-histogram tables": "histogram table (choice + choice + scale)",
            "multiple scatterplots": "scatterplot set (scale + scale + choice)",
            "correlation maps": "correlation map (all scales together)",
            "data integrity graphs": "data integrity graph",
            "texts": "text listing",
            "write-in texts": "write-in text listing"
        };
        var columnNames = ["One question at a time", "Two-question combinations", "Three or more questions together"];
        var graphTypesInTableColumns = [
            ["bar graphs", "histograms", "texts", "write-in texts"],
            ["tables", "multiple histograms", "scatterplots"],
            ["contingency-histogram tables", "multiple scatterplots", "correlation maps", "data integrity graphs"]
        ];
        function isChecked(shortName, value) {
            if (value === void 0) { value = undefined; }
            var map = storageFunction() || {};
            if (value === undefined) {
                return !!map[shortName];
            }
            map[shortName] = !!value;
            storageFunction(map);
        }
        function buildQuestionCheckbox(aName, id, count) {
            var nameToDisplay;
            if (count == 1) {
                nameToDisplay = " " + count + " " + graphTypesToSingularDisplayNamesMap[id];
            }
            else {
                nameToDisplay = " " + count + " " + aName;
            }
            return m("div", { style: "margin-bottom: 1em" }, [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id, "style": isChecked(id) ? "font-weight: bold" : "font-weight: normal" }, m("span", [
                    m("span", nameToDisplay),
                    m("br"),
                    m("img", {
                        src: 'help/catalysis/graphThumbnail_' + allGraphTypesThumbnailNames[id] + '.png',
                        class: isChecked(id) ? "narrafirma-graph-thumbnail-checked" : "narrafirma-graph-thumbnail-unchecked",
                    }),
                ])),
            ]);
        }
        function selectAll() {
            storageFunction(allGraphTypes);
        }
        function clearAll() {
            storageFunction({});
        }
        var questions = project.allQuestionsThatCouldBeGraphedForCatalysisReport(catalysisReportIdentifier, true);
        var graphTypesToCreate = project.tripleStore.queryLatestC(catalysisReportIdentifier, "graphTypesToCreate");
        var graphMultiChoiceQuestionsAgainstThemselves = project.tripleStore.queryLatestC(catalysisReportIdentifier, "graphMultiChoiceQuestionsAgainstThemselves");
        var hidePatternsWithoutStoryQuestions = project.tripleStore.queryLatestC(catalysisReportIdentifier, "hidePatternsWithoutStoryQuestions");
        var totalGraphCount = 0;
        var columnTDs = [];
        var _loop_1 = function (i) {
            var column = [];
            column.push(m("i", columnNames[i]));
            column.push(m("br"));
            column.push(m("br"));
            graphTypesInTableColumns[i].forEach(function (graphType) {
                var count = graphCountForGraphType(graphType, questions, graphMultiChoiceQuestionsAgainstThemselves, hidePatternsWithoutStoryQuestions);
                var checkbox = buildQuestionCheckbox(graphTypesToDisplayNamesMap[graphType], graphType, count);
                column.push(checkbox);
                if (graphTypesToCreate && graphTypesToCreate[graphType])
                    totalGraphCount += count;
            });
            columnTDs.push(m("td", { "class": "narrafirma-graph-types-chooser-table-td" }, m("fieldset", column)));
        };
        for (var i = 0; i < columnNames.length; i++) {
            _loop_1(i);
        }
        // TODO: Translate
        return m("div.questionExternal", [
            prompt, m("div", [m("table", { "class": "narrafirma-graph-types-chooser-table" }, m("tr", columnTDs))]),
            m("span[style=margin-left: 0.5em]", "Select graph types:"),
            m("button", { onclick: selectAll }, m("span", { class: "buttonWithTextImage selectAllButtonImage" }), "Select all"),
            m("button", { onclick: clearAll }, m("span", { class: "buttonWithTextImage clearButtonImage" }), "Clear all"),
            m("br"),
            m("p" + tipStyleForGraphCount(totalGraphCount), tipForGraphCount(totalGraphCount))
        ]);
    }
    function tipForGraphCount(totalGraphCount) {
        var tip;
        if (totalGraphCount === 1) {
            tip = totalGraphCount + " graph selected";
        }
        else if (totalGraphCount < 5000) {
            tip = totalGraphCount + " graphs selected";
        }
        else if (totalGraphCount < 10000) {
            tip = "You have selected a total of " + totalGraphCount + " graphs. If the Explore patterns page loads slowly, choose fewer graph types and/or questions.";
        }
        else if (totalGraphCount < 50000) {
            tip = "You have selected a total of " + totalGraphCount + " graphs. This will cause the Explore patterns page to load VERY slowly. You might want to choose fewer graph types and/or questions.";
        }
        else {
            tip = "You have selected a total of " + totalGraphCount + " graphs. This will probably cause your browser to stop responding when you open the Explore patterns page. You should choose fewer graph types and/or questions.";
        }
        return tip;
    }
    function tipStyleForGraphCount(totalGraphCount) {
        var tipStyle;
        if (totalGraphCount < 5000) {
            tipStyle = "[style=margin-left:1em]";
        }
        else if (totalGraphCount < 10000) {
            tipStyle = "[style=margin-left:1em]";
        }
        else if (totalGraphCount < 50000) {
            tipStyle = "[style=margin-left:1em;font-weight:bold]";
        }
        else {
            tipStyle = "[style=margin-left:1em;font-weight:bold;color:red]";
        }
        return tipStyle;
    }
    // Question types that have data associated with them for filters and graphs
    var nominalQuestionTypes = ["select", "boolean", "checkbox", "checkboxes", "radiobuttons"];
    function graphCountForGraphType(graphType, questions, graphMultiChoiceQuestionsAgainstThemselves, hidePatternsWithoutStoryQuestions) {
        function hidePatternBecauseItDoesNotGoThroughTheStory(question1, question2, question3) {
            if (question3 === void 0) { question3 = null; }
            if (!hidePatternsWithoutStoryQuestions)
                return false;
            if (question3) {
                return (question1.id.indexOf("S_") < 0 && question2.id.indexOf("S_") < 0 && question3.id.indexOf("S_") < 0);
            }
            else {
                return (question1.id.indexOf("S_") < 0 && question2.id.indexOf("S_") < 0);
            }
        }
        if (!questions)
            return 0;
        if (graphType === "data integrity graphs") {
            return 5; // change if add more data integrity graphs
        }
        var graphCount = 0;
        if (graphType === "texts") {
            questions.forEach(function (question) {
                if (question.displayType === "text" || question.displayType === "textarea") {
                    graphCount++;
                }
            });
            return graphCount;
        }
        if (graphType === "write-in texts") {
            questions.forEach(function (question) {
                if (question.writeInTextBoxLabel) {
                    graphCount++;
                }
            });
            return graphCount;
        }
        var nominalQuestions = [];
        questions.forEach(function (question) {
            if (nominalQuestionTypes.indexOf(question.displayType) !== -1) {
                nominalQuestions.push(question);
            }
        });
        if (graphType === "bar graphs") {
            return nominalQuestions.length;
        }
        var scaleQuestions = [];
        questions.forEach(function (question) {
            if (question.displayType === "slider") {
                scaleQuestions.push(question);
            }
        });
        if (graphType === "histograms") {
            return scaleQuestions.length;
        }
        // when creating question combinations, prevent mirror duplicates (axb, bxa) and self-matching questions (axa)
        // unless they want axa for multi-choice (checkboxes) questions
        var usedQuestions;
        // two choice questions
        if (graphType === "tables") {
            usedQuestions = [];
            nominalQuestions.forEach(function (question1) {
                usedQuestions.push(question1);
                nominalQuestions.forEach(function (question2) {
                    var okayToGraphQuestionAgainstItself = graphMultiChoiceQuestionsAgainstThemselves && question1.displayName === question2.displayName && question2.displayType === "checkboxes";
                    if (!okayToGraphQuestionAgainstItself && usedQuestions.indexOf(question2) !== -1)
                        return;
                    if (hidePatternBecauseItDoesNotGoThroughTheStory(question1, question2))
                        return;
                    graphCount++;
                });
            });
            return graphCount;
        }
        ;
        // two scale questions
        if (graphType === "scatterplots") {
            usedQuestions = [];
            scaleQuestions.forEach(function (question1) {
                usedQuestions.push(question1);
                scaleQuestions.forEach(function (question2) {
                    if (usedQuestions.indexOf(question2) !== -1)
                        return;
                    if (hidePatternBecauseItDoesNotGoThroughTheStory(question1, question2))
                        return;
                    graphCount++;
                });
            });
            return graphCount;
        }
        // one scale question, one choice question
        if (graphType === "multiple histograms") {
            //return scaleQuestions.length * nominalQuestions.length;
            scaleQuestions.forEach(function (question1) {
                nominalQuestions.forEach(function (question2) {
                    if (hidePatternBecauseItDoesNotGoThroughTheStory(question1, question2))
                        return;
                    graphCount++;
                });
            });
            return graphCount;
        }
        // two choice questions, one scale question
        if (graphType === "contingency-histogram tables") {
            usedQuestions = [];
            nominalQuestions.forEach(function (question1) {
                usedQuestions.push(question1);
                nominalQuestions.forEach(function (question2) {
                    var okayToGraphQuestionAgainstItself = graphMultiChoiceQuestionsAgainstThemselves && question1.displayName === question2.displayName && question2.displayType === "checkboxes";
                    if (!okayToGraphQuestionAgainstItself && usedQuestions.indexOf(question2) !== -1)
                        return;
                    scaleQuestions.forEach(function (question3) {
                        if (hidePatternBecauseItDoesNotGoThroughTheStory(question1, question2, question3))
                            return;
                        graphCount++;
                    });
                });
            });
            return graphCount;
        }
        // two scale questions, one choice question
        if (graphType === "multiple scatterplots") {
            usedQuestions = [];
            scaleQuestions.forEach(function (question1) {
                usedQuestions.push(question1);
                scaleQuestions.forEach(function (question2) {
                    if (usedQuestions.indexOf(question2) !== -1)
                        return;
                    nominalQuestions.forEach(function (question3) {
                        if (hidePatternBecauseItDoesNotGoThroughTheStory(question1, question2, question3))
                            return;
                        graphCount++;
                    });
                });
            });
            return graphCount;
        }
        if (graphType === "correlation maps") {
            var scaleQuestions_1 = [];
            questions.forEach(function (question) {
                if (question.displayType === "slider")
                    scaleQuestions_1.push(question);
            });
            if (scaleQuestions_1.length >= 3) {
                return 1 + nominalQuestions.length;
            }
            else {
                return 0;
            }
        }
        console.log("ERROR: Unexpected graph type", graphType);
        alert("ERROR: Unexpected graph type: " + graphType);
        return 0;
    }
    return add_catalysisReportGraphTypesChooser;
});

define('js/applicationWidgets/add_catalysisReportPatternTableColumnsChooser',["require", "exports", "mithril", "../panelBuilder/valuePathResolver", "../Globals"], function (require, exports, m, valuePathResolver, Globals) {
    "use strict";
    "use strict";
    function add_catalysisReportPatternTableColumnsChooser(panelBuilder, model, fieldSpecification) {
        var project = Globals.project();
        var catalysisReportIdentifier = Globals.clientState().catalysisReportIdentifier();
        if (!catalysisReportIdentifier)
            return m("div", "Please select a catalysis report");
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var storageFunction = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var allColumnIDs = {
            "patternName": true,
            "remarkable": true,
            "note": true,
            "q1DisplayName": true,
            "q2DisplayName": true,
            "q3DisplayName": true,
            "graphType": true,
            "statsSummary": true,
            "observation": true,
            "strength": true,
            "interpretations": true,
        };
        var columnIDsToDisplayNamesMap = {
            "patternName": "Name -- appears on graph",
            "remarkable": "Remarkable? -- mark to keep track of progress",
            "note": "Notes -- comments you want to save but not print",
            "q1DisplayName": "Q1 -- first question in pattern (use these to find particular questions)",
            "q2DisplayName": "Q2 -- second question in pattern",
            "q3DisplayName": "Q3 -- third question in pattern",
            "graphType": "Type -- of graph",
            "statsSummary": "Significance -- summary of test results",
            "observation": "Observations -- name(s) of observations(s) you wrote",
            "strength": "Strengths -- strong/medium/weak flag(s) you set to sort observations",
            "interpretations": "Interpretations -- perspectives you explained",
        };
        function isChecked(shortName, value) {
            if (value === void 0) { value = undefined; }
            var map = storageFunction() || {};
            if (value === undefined) {
                return !!map[shortName];
            }
            map[shortName] = !!value;
            storageFunction(map);
        }
        function buildQuestionCheckbox(aName, id) {
            return m("div", [
                m("input[type=checkbox]", { id: id, checked: isChecked(id),
                    style: "margin-left: 1.5em; margin-bottom: 0.3em",
                    onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, aName),
                m("br")
            ]);
        }
        function selectAll() {
            storageFunction(allColumnIDs);
        }
        function clearAll() {
            storageFunction({});
        }
        var columnIDsToShow = project.tripleStore.queryLatestC(catalysisReportIdentifier, "columnIDsToShowInPatternsTable");
        var checkboxes = [];
        Object.keys(allColumnIDs).forEach(function (columnID) {
            var checkbox = buildQuestionCheckbox(columnIDsToDisplayNamesMap[columnID], columnID);
            checkboxes.push(checkbox);
        });
        // TODO: Translate
        return m("div.questionExternal", [prompt, m("fieldset", checkboxes)]);
    }
    return add_catalysisReportPatternTableColumnsChooser;
});

define('js/applicationWidgets/add_storyFormQuestionsChooser',["require", "exports", "mithril", "../Globals"], function (require, exports, m, Globals) {
    "use strict";
    "use strict";
    function add_storyFormQuestionsChooser(panelBuilder, model, fieldSpecification) {
        var project = Globals.project();
        if (!model || !project)
            return m("div");
        var storyForm = project.tripleStore.makeObject(model, true);
        if (!storyForm)
            return m("div");
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        // get all questions in project now so you can look up question texts for "QuestionChoice" objects
        var questionCategory = fieldSpecification.displayConfiguration.toLowerCase();
        var createdQuestions = [];
        if (fieldSpecification.displayConfiguration === "Eliciting") {
            createdQuestions = project.collectAllElicitingQuestions();
        }
        else if (fieldSpecification.displayConfiguration === "Story") {
            createdQuestions = project.collectAllStoryQuestions();
        }
        else if (fieldSpecification.displayConfiguration === "Participant") {
            createdQuestions = project.collectAllParticipantQuestions();
        }
        /////////////////// left side - questions chosen for form
        // these are not questions; they are "QuestionChoice" objects 
        // with only two fields: elicitingQuestion, storyQuestion, or participantQuestion (which is the question's short name); and order
        var questionChoicesSelectBoxID = fieldSpecification.displayConfiguration + "_questions_chosen";
        var questionChoicesInForm = [];
        var setClassName = "questionForm_" + questionCategory + "Questions";
        var questionChoicesSetID = storyForm[setClassName];
        if (questionChoicesSetID) {
            var questionChoicesIDsList = project.tripleStore.getListForSetIdentifier(questionChoicesSetID);
            questionChoicesIDsList.forEach(function (id) {
                var questionChoice = project.tripleStore.makeObject(id, true);
                questionChoice.id = id;
                questionChoicesInForm.push(questionChoice);
            });
        }
        else {
            questionChoicesSetID = project.tripleStore.newIdForSet(setClassName);
            project.tripleStore.addTriple(model, setClassName, questionChoicesSetID);
        }
        questionChoicesInForm.sort(function (a, b) {
            // in legacy data, the "order" field could have letters in it
            if (!isNaN(Number(a.order)) && !isNaN(Number(b.order))) {
                if (Number(a.order) < Number(b.order))
                    return -1;
                if (Number(a.order) > Number(b.order))
                    return 1;
                return 0;
            }
            else {
                if (a.order.toLowerCase() < b.order.toLowerCase())
                    return -1;
                if (a.order.toLowerCase() > b.order.toLowerCase())
                    return 1;
                return 0;
            }
        });
        // create mithril options for list box with question lookup ids
        var questionChoicesInFormSelectOptions = [];
        questionChoicesInForm.forEach(function (questionChoice, index) {
            var shortName = questionChoice[questionCategory + "Question"].trim();
            questionChoicesInFormSelectOptions.push(m("option", { value: questionChoice.id, selected: undefined }, shortName));
        });
        /////////////////// right side - questions available to choose
        // these are questions, not question choices
        var questionsCreatedSelectBoxID = fieldSpecification.displayConfiguration + "_questions_created";
        // only display created questions that are not already in the form
        var createdQuestionsNotInForm = [];
        createdQuestions.forEach(function (createdQuestion) {
            var questionIsAleadyInForm = false;
            questionChoicesInForm.forEach(function (questionChoice) {
                if (questionChoice[questionCategory + "Question"].trim() === createdQuestion[questionCategory + "Question_shortName"].trim()) {
                    questionIsAleadyInForm = true;
                    return;
                }
            });
            if (!questionIsAleadyInForm) {
                createdQuestionsNotInForm.push(createdQuestion);
            }
        });
        // create mithril options for list box with question lookup ids
        var createdQuestionsNotInFormSelectOptions = [];
        createdQuestionsNotInForm.forEach(function (question) {
            var shortName = question[questionCategory + "Question_shortName"].trim();
            createdQuestionsNotInFormSelectOptions.push(m("option", { value: question.id, selected: undefined }, shortName));
        });
        // these up and down methods swap rather than set the "order" fields of the "QuestionChoice" objects
        // because in the past (before NF 1.5.0), the order was typed in by the user and could include letters
        function moveSelectedQuestionChoiceUp() {
            var element = document.getElementById(questionChoicesSelectBoxID);
            if (!element || element.selectedIndex < 0)
                return;
            var selectedOption = element.options[element.selectedIndex];
            var optionAboveSelectedOption = undefined;
            if (element.selectedIndex > 0) {
                optionAboveSelectedOption = element.options[element.selectedIndex - 1];
            }
            if (!optionAboveSelectedOption)
                return;
            var selectedObject = project.tripleStore.makeObject(selectedOption.value, true);
            var objectAboveSelectedObject = project.tripleStore.makeObject(optionAboveSelectedOption.value, true);
            if (!selectedObject || !objectAboveSelectedObject)
                return;
            var oldSelectedObjectOrder = selectedObject.order;
            project.tripleStore.addTriple(selectedOption.value, "order", objectAboveSelectedObject.order);
            project.tripleStore.addTriple(optionAboveSelectedOption.value, "order", oldSelectedObjectOrder);
            if (element.selectedIndex > 0)
                element.selectedIndex--;
        }
        function moveSelectedQuestionChoiceDown() {
            var element = document.getElementById(questionChoicesSelectBoxID);
            if (!element || element.selectedIndex < 0)
                return;
            var selectedOption = element.options[element.selectedIndex];
            var optionBelowSelectedOption = undefined;
            if (element.selectedIndex < element.options.length - 1) {
                optionBelowSelectedOption = element.options[element.selectedIndex + 1];
            }
            if (!optionBelowSelectedOption)
                return;
            var selectedObject = project.tripleStore.makeObject(selectedOption.value, true);
            var objectBelowSelectedObject = project.tripleStore.makeObject(optionBelowSelectedOption.value, true);
            if (!selectedObject || !objectBelowSelectedObject)
                return;
            var oldSelectedObjectOrder = selectedObject.order;
            project.tripleStore.addTriple(selectedOption.value, "order", objectBelowSelectedObject.order);
            project.tripleStore.addTriple(optionBelowSelectedOption.value, "order", oldSelectedObjectOrder);
            if (element.selectedIndex < element.options.length - 1)
                element.selectedIndex++;
        }
        function addSelectedQuestion() {
            function highestOrderInExistingQuestionChoices() {
                var highestOrder = 0;
                questionChoicesInForm.forEach(function (questionChoice) {
                    var orderAsNumber = 0;
                    try {
                        orderAsNumber = Number(questionChoice.order);
                    }
                    catch (err) {
                        orderAsNumber = 0;
                    }
                    if (orderAsNumber > highestOrder) {
                        highestOrder = orderAsNumber;
                    }
                });
                return highestOrder;
            }
            var element = document.getElementById(questionsCreatedSelectBoxID);
            if (!element || element.selectedIndex < 0)
                return;
            var selectedOption = element.options[element.selectedIndex];
            var selectedQuestion = project.tripleStore.makeObject(selectedOption.value, true);
            if (selectedQuestion) {
                var newOrder = highestOrderInExistingQuestionChoices() + 1;
                var template = { "order": newOrder };
                if (questionCategory === "eliciting") {
                    template["elicitingQuestion"] = selectedQuestion["elicitingQuestion_shortName"].trim();
                }
                else if (questionCategory === "story") {
                    template["storyQuestion"] = selectedQuestion["storyQuestion_shortName"].trim();
                }
                else if (questionCategory === "participant") {
                    template["participantQuestion"] = selectedQuestion["participantQuestion_shortName"].trim();
                }
                var itemClassName = fieldSpecification.displayConfiguration + "QuestionChoice";
                project.tripleStore.makeNewSetItem(questionChoicesSetID, itemClassName, template, "id");
            }
        }
        function removeSelectedQuestionChoice() {
            var element = document.getElementById(questionChoicesSelectBoxID);
            if (!element || element.selectedIndex < 0)
                return;
            var selectedOption = element.options[element.selectedIndex];
            project.tripleStore.deleteSetItem(questionChoicesSetID, selectedOption.value.trim());
        }
        var columnTDs = [];
        // left side - questions in form
        columnTDs.push(m("td", { "class": "narrafirma-story-form-questions-chooser-table-td" }, m("fieldset", [
            m("div", fieldSpecification.displayConfiguration + " questions in this form"),
            m("select.narrafirma-story-form-questions-chooser-list", { size: 7, disabled: panelBuilder.readOnly, id: questionChoicesSelectBoxID }, questionChoicesInFormSelectOptions),
            m("br"),
            m("button", { id: "move" + questionCategory + "QuestionChoiceUp", disabled: panelBuilder.readOnly, onclick: moveSelectedQuestionChoiceUp }, "↑"),
            m("button", { id: "move" + questionCategory + "QuestionChoiceDown", disabled: panelBuilder.readOnly, onclick: moveSelectedQuestionChoiceDown }, "↓")
        ])));
        // add, remove buttons
        columnTDs.push(m("td", { "class": "narrafirma-story-form-questions-chooser-table-td-middle" }, [
            m("button", { style: "text-align: center", disabled: panelBuilder.readOnly, onclick: addSelectedQuestion }, "←"),
            m("br"),
            m("button", { style: "text-align: center", disabled: panelBuilder.readOnly, onclick: removeSelectedQuestionChoice }, "→")
        ]));
        // right side - questions created (that are not in the form)
        columnTDs.push(m("td", { "class": "narrafirma-story-form-questions-chooser-table-td" }, m("fieldset", [
            m("div", "Other " + fieldSpecification.displayConfiguration.toLowerCase() + " questions you have created"),
            m("select.narrafirma-story-form-questions-chooser-list", { size: 7, disabled: panelBuilder.readOnly, id: questionsCreatedSelectBoxID }, createdQuestionsNotInFormSelectOptions)
        ])));
        return m("div.questionExternal", [
            prompt, m("div", [m("table", { "class": "narrafirma-questions-chooser-table" }, m("tr", columnTDs))]),
        ]);
    }
    return add_storyFormQuestionsChooser;
});

define('js/applicationWidgets/add_catalysisReportFilterNotice',["require", "exports", "mithril", "../sanitizeHTML", "../Globals"], function (require, exports, m, sanitizeHTML, Globals) {
    "use strict";
    "use strict";
    function add_catalysisReportFilterNotice(panelBuilder, model, fieldSpecification) {
        var project = Globals.project();
        var catalysisReportName = Globals.clientState().catalysisReportName();
        if (!catalysisReportName) {
            return;
        }
        var catalysisReportIdentifier = project.findCatalysisReport(catalysisReportName);
        var filter = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_filter");
        if (filter) {
            var stories = project.storiesForCatalysisReport(catalysisReportIdentifier);
            var storyOrStoriesText = " stories";
            if (stories.length == 1)
                storyOrStoriesText = " story";
            var labelText = 'This catalysis report only pertains to stories that match the filter "' + filter + '" (' + stories.length + storyOrStoriesText + ")";
            return m("div", { "class": "questionExternal narrafirma-question-type-filterNotice" }, sanitizeHTML.generateSanitizedHTMLForMithril(labelText));
        }
        else {
            // it wants a mithril object, so return an empty one
            return m("");
        }
    }
    return add_catalysisReportFilterNotice;
});

define('js/applicationWidgets/add_clusteringDiagram',["require", "exports", "./ClusteringDiagram", "mithril", "../panelBuilder/valuePathResolver"], function (require, exports, ClusteringDiagram, m, valuePathResolver) {
    "use strict";
    "use strict";
    function add_clusteringDiagram(panelBuilder, model, fieldSpecification) {
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var storageFunction = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var clusteringDiagram = m.component(ClusteringDiagram, { key: fieldSpecification.id, configuration: fieldSpecification.displayConfiguration, storageFunction: storageFunction, autosave: true });
        // TODO: Who should be responsible for updating this data? Is redraw called or is that bypassed as an html component?
        return m("div", [prompt, clusteringDiagram]);
    }
    return add_clusteringDiagram;
});

define('js/applicationWidgets/add_dashboardStoryCollectionStatusDisplay',["require", "exports", "../surveyCollection", "mithril", "../Globals"], function (require, exports, surveyCollection, m, Globals) {
    "use strict";
    "use strict";
    function mithrilArrayForListOfThingsAndLink(name, list, page) {
        if (!list || list.length == 0)
            return null;
        var count = list.length;
        var text = "" + count + " " + name;
        if (count != 1)
            text += "s";
        return [m("a.narrafirma-home-page-link", { href: 'javascript:narrafirma_openPage("' + page + '")', title: text, tabindex: 0 }, text)];
    }
    function add_dashboardStoryCollectionStatusDisplay(panelBuilder, model, fieldSpecification) {
        var resultItems = [];
        var tripleStore = Globals.project().tripleStore;
        var newItems = null;
        // eliciting questions
        var elicitingQuestionIdentifiers = Globals.project().getListForField("project_elicitingQuestionsList");
        newItems = mithrilArrayForListOfThingsAndLink("Eliciting question", elicitingQuestionIdentifiers, "page_writeStoryElicitingQuestions");
        if (newItems)
            resultItems = resultItems.concat(newItems);
        // questions about stories
        var storyQuestionIdentifiers = Globals.project().getListForField("project_storyQuestionsList");
        newItems = mithrilArrayForListOfThingsAndLink("Story question", storyQuestionIdentifiers, "page_writeQuestionsAboutStories");
        if (newItems)
            resultItems = resultItems.concat(newItems);
        // questions about participants
        var participantQuestionIdentifiers = Globals.project().getListForField("project_participantQuestionsList");
        newItems = mithrilArrayForListOfThingsAndLink("Participant question", participantQuestionIdentifiers, "page_writeQuestionsAboutParticipants");
        if (newItems)
            resultItems = resultItems.concat(newItems);
        // annotation questions
        var annotationQuestionIdentifiers = Globals.project().getListForField("project_annotationQuestionsList");
        newItems = mithrilArrayForListOfThingsAndLink("Annotation question", annotationQuestionIdentifiers, "page_writeAnnotationsAboutStories");
        if (newItems)
            resultItems = resultItems.concat(newItems);
        // story forms
        var storyFormIdentifiers = Globals.project().getListForField("project_storyForms");
        newItems = mithrilArrayForListOfThingsAndLink("Story form", storyFormIdentifiers, "page_designStoryForms");
        if (newItems)
            resultItems = resultItems.concat(newItems);
        // catalysis reports
        var catalysisReportIdentifiers = Globals.project().getListForField("project_catalysisReports");
        newItems = mithrilArrayForListOfThingsAndLink("Catalysis report", catalysisReportIdentifiers, "page_configureCatalysisReport");
        if (newItems)
            resultItems = resultItems.concat(newItems);
        // story collections
        var storyCollectionsIdentifiers = Globals.project().getListForField("project_storyCollections");
        var storyCollectionItems = [];
        if (storyCollectionsIdentifiers && storyCollectionsIdentifiers.length) {
            var storyCollections = storyCollectionsIdentifiers.map(function (storyCollectionIdentifier) {
                var shortName = tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_shortName");
                var allStoriesInStoryCollection = surveyCollection.getStoriesForStoryCollection(shortName);
                var storyCount = allStoriesInStoryCollection.length;
                var answerCount = 0;
                allStoriesInStoryCollection.map(function (story) { answerCount += story.storyAnswersCount(); });
                var activeOnWeb = tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_activeOnWeb");
                if (activeOnWeb) {
                    console.log("active on web: ", shortName, storyCollectionIdentifier);
                }
                var surveyURL = activeOnWeb ? surveyCollection.urlForSurveyAsString(storyCollectionIdentifier) : "";
                var reviewStoriesURL = surveyCollection.urlForStoryCollectionReview(storyCollectionIdentifier, "reviewIncomingStories");
                var browseGraphsURL = surveyCollection.urlForStoryCollectionReview(storyCollectionIdentifier, "browseGraphs");
                return {
                    id: storyCollectionIdentifier,
                    shortName: shortName,
                    storyCount: storyCount,
                    answerCount: answerCount,
                    activeOnWeb: activeOnWeb,
                    surveyURL: surveyURL,
                    reviewStoriesURL: reviewStoriesURL,
                    browseGraphsURL: browseGraphsURL
                };
            });
            storyCollections.sort(function (a, b) {
                var aName = a.shortName || "";
                var bName = b.shortName || "";
                return aName.localeCompare(bName);
            });
            storyCollectionItems = [
                m("br"),
                m("table", m("tr", [
                    m("th", "Collection"),
                    m("th", "stories"),
                    m("th", "answers"),
                    m("th", "active?")
                ]), storyCollections.map(function (storyCollection) {
                    var collectionNameLine = m("span.narrafirma-dashboard-story-collection-name", storyCollection.shortName);
                    var storiesLine = m("a[id=narrafirma-review-stories-url]", { href: storyCollection.reviewStoriesURL, title: "Click here to view the stories in this collection.", tabindex: 0 }, storyCollection.storyCount);
                    var answersLine = m("a[id=narrafirma-review-graphs-url]", { href: storyCollection.browseGraphsURL, title: "Click here to review graphs in this collection.", tabindex: 0 }, storyCollection.answerCount);
                    var surveyActive = storyCollection.activeOnWeb ? m("a[id=narrafirma-survey-url]", { href: storyCollection.surveyURL, target: "_blank", title: "Click here to launch the survey for this collection.", tabindex: 0 }, "yes") : "no";
                    return m("tr", [
                        m("td", collectionNameLine),
                        m("td", { style: "text-align: center;" }, storiesLine),
                        m("td", { style: "text-align: center;" }, answersLine),
                        m("td", { style: "text-align: center;" }, surveyActive),
                    ]);
                }))
            ];
        }
        resultItems = resultItems.concat(storyCollectionItems);
        if (resultItems.length && resultItems[0]) {
            resultItems.unshift(m("p", { style: "margin-top: 0" }, "Quick links for: " + Globals.project().projectNameOrNickname()));
        }
        // section links (to use if can't click on image)
        var sectionLinks = [
            m("p"),
            m("a.narrafirma-home-page-section-link", { href: 'javascript:narrafirma_openPage("page_planning")', title: "Go to planning section", tabindex: 0 }, "Planning"), m("span", "| "),
            m("a.narrafirma-home-page-section-link", { href: 'javascript:narrafirma_openPage("page_collection")', title: "Go to collection section", tabindex: 0 }, "Collection"), m("span", "| "),
            m("a.narrafirma-home-page-section-link", { href: 'javascript:narrafirma_openPage("page_catalysis")', title: "Go to catalysis section", tabindex: 0 }, "Catalysis"), m("span", "| "),
            m("a.narrafirma-home-page-section-link", { href: 'javascript:narrafirma_openPage("page_sensemaking")', title: "Go to sensemaking section", tabindex: 0 }, "Sensemaking"), m("span", "| "),
            m("a.narrafirma-home-page-section-link", { href: 'javascript:narrafirma_openPage("page_intervention")', title: "Go to intervention section", tabindex: 0 }, "Intervention"), m("span", "| "),
            m("a.narrafirma-home-page-section-link", { href: 'javascript:narrafirma_openPage("page_return")', title: "Go to return section", tabindex: 0 }, "Return"),
        ];
        resultItems = resultItems.concat(sectionLinks);
        // project admin
        resultItems = resultItems.concat([m("p"), m("a.narrafirma-home-page-link", { href: 'javascript:narrafirma_openPage("page_administration")', title: "Project administration", tabindex: 0 }, "Project administration")]);
        // choose another project
        var chooseProjectLink;
        var isWordPressAJAX = !!window["ajaxurl"];
        if (!isWordPressAJAX) {
            chooseProjectLink = "\\";
        }
        else {
            chooseProjectLink = "../webapp/narrafirma.html";
        }
        resultItems = resultItems.concat([m("a.narrafirma-home-page-link", { href: chooseProjectLink, title: "Choose another project", tabindex: 0 }, "Choose another project")]);
        // site admin
        if (Globals.project().currentUserIsSuperUser) {
            // no need to get WordPress URL because superuser account does not exist there
            resultItems = resultItems.concat([m("a.narrafirma-home-page-link", { href: "\\admin.html", title: "Site administration", tabindex: 0 }, "Site administration"), m("br")]);
        }
        return m("div.narrafirma-dashboard-story-collection-status", resultItems);
    }
    return add_dashboardStoryCollectionStatusDisplay;
});

define('js/applicationWidgets/GraphBrowser',["require", "exports", "./charting", "../questionnaireGeneration", "../surveyCollection", "../panelBuilder/dialogSupport", "../Project", "../Globals", "mithril"], function (require, exports, charting, questionnaireGeneration, surveyCollection, dialogSupport, Project, Globals, m) {
    "use strict";
    "use strict";
    function questionForID(questions, id) {
        if (!id)
            return null;
        for (var index in questions) {
            var question = questions[index];
            if (question.id === id)
                return question;
        }
        console.log("ERROR: question not found for id", id, questions);
        return null;
    }
    var showAnswersCheckboxID = 101;
    var GraphBrowser = (function () {
        function GraphBrowser(args) {
            this.project = null;
            this.xAxisSelectValue = null;
            this.yAxisSelectValue = null;
            this.questions = [];
            this.choices = [];
            this.collectionIDs = [];
            this.displayCollections = {};
            this.selectedStories = [];
            this.showAnswers = false;
            this.project = Globals.project();
            this.collectionIDs = Globals.project().listOfAllStoryCollectionNames();
            for (var _i = 0, _a = this.collectionIDs; _i < _a.length; _i++) {
                var id = _a[_i];
                this.displayCollections[id] = false;
            }
            // sometimes the user clicked on a story count on the main dashboard table
            var preselectedCollection = Globals.clientState().storyCollectionName();
            if (preselectedCollection) {
                this.displayCollections[preselectedCollection] = true;
            }
            this.graphHolder = {
                graphResultsPane: charting.createGraphResultsPane("narrafirma-graph-results-pane chartEnclosure"),
                chartPanes: [],
                allStories: [],
                currentGraph: null,
                currentSelectionExtentPercentages: null,
                minimumStoryCountRequiredForTest: Project.default_minimumStoryCountRequiredForTest,
                minimumStoryCountRequiredForGraph: Project.default_minimumStoryCountRequiredForGraph,
                numHistogramBins: Project.default_numHistogramBins,
                numScatterDotOpacityLevels: Project.default_numScatterDotOpacityLevels,
                scatterDotSize: Project.default_scatterDotSize,
                correlationMapShape: Project.default_correlationMapShape,
                correlationMapIncludeScaleEndLabels: Project.default_correlationMapIncludeScaleEndLabels,
                correlationMapCircleDiameter: Project.default_correlationMapCircleDiameter,
                correlationLineChoice: Project.default_correlationLineChoice,
                customLabelLengthLimit: Project.default_customLabelLengthLimit,
                customGraphWidth: Project.default_customDisplayGraphWidth,
                customGraphHeight: Project.default_customDisplayGraphHeight,
                customGraphPadding: Project.default_customGraphPadding,
                hideNumbersOnContingencyGraphs: false,
                patternDisplayConfiguration: { hideNoAnswerValues: false, useLumpingCommands: true },
                graphTypesToCreate: {},
                lumpingCommands: {}
            };
            this.updateForChangeToDisplayedStoryCollections();
        }
        GraphBrowser.controller = function (args) {
            return new GraphBrowser(args);
        };
        GraphBrowser.view = function (controller, args) {
            return controller.calculateView(args);
        };
        GraphBrowser.prototype.isChecked = function (id, value) {
            if (value === void 0) { value = undefined; }
            if (value !== undefined) {
                var oldValue = this.displayCollections[id];
                this.displayCollections[id] = value;
                if (value !== oldValue) {
                    this.updateForChangeToDisplayedStoryCollections();
                }
            }
            else {
                return this.displayCollections[id];
            }
        };
        GraphBrowser.prototype.buildCollectionCheckbox = function (id) {
            var self = this;
            return m("div.graphBrowserCheckboxDiv", [
                m("input[type=checkbox].graphBrowserCheckbox", {
                    id: id,
                    checked: this.isChecked(id),
                    onchange: function (event) { self.isChecked(id, event.target.checked); }
                }),
                m("label", { "for": id }, id),
                m("br")
            ]);
        };
        GraphBrowser.prototype.calculateView = function (args) {
            var _this = this;
            var parts = [];
            if (this.collectionIDs.length === 0) {
                parts.push(m("div.graphBrowserCollectionsIntro", "There are no story collections to show."));
            }
            else {
                parts.push(m("div.graphBrowserCollectionsIntro", "Select one or more story collections to view."));
                var checkboxDivs = [];
                for (var _i = 0, _a = this.collectionIDs; _i < _a.length; _i++) {
                    var collectionID = _a[_i];
                    checkboxDivs.push(this.buildCollectionCheckbox(collectionID));
                }
                parts.push(m("div.graphBrowserCheckboxesDiv", checkboxDivs));
                var moreParts = [
                    m("div.graphBrowserQuestionsIntro", "Select one or two questions to view."),
                    m("select.graphBrowserSelect", { onchange: function (event) { _this.xAxisSelectValue = event.target.value; _this.updateGraph(); } }, this.calculateOptionsForChoices(this.xAxisSelectValue)),
                    m("span.narrafirma-graphbrowser-versus", "versus"),
                    m("select.graphBrowserSelect", { onchange: function (event) { _this.yAxisSelectValue = event.target.value; _this.updateGraph(); } }, this.calculateOptionsForChoices(this.yAxisSelectValue)),
                    m("br"),
                    m("div", { config: this.insertGraphResultsPaneConfig.bind(this) }),
                    (this.selectedStories.length > 0) ?
                        m("div.narrafirma-graphbrowser-heading", "Selected stories (" + this.selectedStories.length + ")")
                        : m("div.narrafirma-graphbrowser-select-stories-tip", "Click and drag in the graph(s) above to select stories to view."),
                    (this.selectedStories.length > 0) ?
                        m("div.narrafirma-graphbrowser-showstories-buttons", [
                            m("button.narrafirma-graphbrowser-show-stories-button", { onclick: this.showAllSelectedStoriesInSeparateWindow.bind(this) }, "Show in separate window"),
                            m("button.narrafirma-graphbrowser-show-stories-button", { onclick: this.showRandom10SelectedStories.bind(this) }, "Sample 10"),
                            m("button.narrafirma-graphbrowser-show-stories-button", { onclick: this.showRandom20SelectedStories.bind(this) }, "20"),
                            m("button.narrafirma-graphbrowser-show-stories-button", { onclick: this.showRandom30SelectedStories.bind(this) }, "30"),
                            m("input[type=checkbox]", { id: showAnswersCheckboxID, checked: this.showAnswers, onchange: this.changeShowAnswers.bind(this) }),
                            m("label", { "for": showAnswersCheckboxID }, "Show answers to questions"),
                        ]) : m("div"),
                    this.selectedStories.map(function (story) {
                        return m("div", [
                            m("div.narrafirma-graphbrowser-story-number-and-name", story.indexInStoryCollection() + ". " + story.storyName()),
                            m("div.narrafirma-graphbrowser-story-text", story.storyText()),
                            m("div.narrafirma-graphbrowser-answers", (_this.showAnswers) ? story.storyAnswersDisplay() : "")
                        ]);
                    })
                ];
                parts = parts.concat(moreParts);
            }
            return m("div.graphBrowserOverallDiv", parts);
        };
        GraphBrowser.prototype.insertGraphResultsPaneConfig = function (element, isInitialized, context) {
            if (!isInitialized) {
                element.appendChild(this.graphHolder.graphResultsPane);
            }
        };
        GraphBrowser.prototype.storiesSelected = function (selectedStories) {
            this.selectedStories = selectedStories;
        };
        GraphBrowser.prototype.calculateOptionsForChoices = function (currentValue) {
            var options = this.choices.map(function (option) {
                var optionOptions = { value: option.value, selected: undefined };
                if (currentValue === option.value)
                    optionOptions.selected = 'selected';
                return m("option", optionOptions, option.label);
            });
            var hasNoSelection = (currentValue === null || currentValue === undefined || currentValue === "") || undefined;
            options.unshift(m("option", { value: "", selected: hasNoSelection }, "--- select ---"));
            return options;
        };
        GraphBrowser.prototype.updateForChangeToDisplayedStoryCollections = function () {
            this.questions = [];
            if (this.collectionIDs.length > 0) {
                var selectedCollections = [];
                for (var _i = 0, _a = this.collectionIDs; _i < _a.length; _i++) {
                    var collectionID = _a[_i];
                    if (this.displayCollections[collectionID]) {
                        selectedCollections.push(collectionID);
                    }
                }
                if (selectedCollections.length > 0) {
                    // built-in questions should be the same for all story collections, so just use the first one chosen
                    var elicitingQuestion = this.project.elicitingQuestionForStoryCollection(selectedCollections[0]);
                    if (elicitingQuestion)
                        this.questions.push(elicitingQuestion);
                    var numStoriesToldQuestions = this.project.numStoriesToldQuestionForStoryCollection(selectedCollections[0]);
                    var storyLengthQuestions = this.project.storyLengthQuestionForStoryCollection(selectedCollections[0]);
                    var collectionDateQuestions = this.project.collectionDateQuestionForStoryCollection(selectedCollections[0]);
                    var languageQuestions = this.project.languageQuestionForStoryCollection(selectedCollections[0]);
                    // annotations are not per collection/questionnaire
                    var annotationQuestions = questionnaireGeneration.convertEditorQuestions(this.project.collectAllAnnotationQuestions(), "A_");
                    // for questions that could vary, combine all questions with the same short names
                    var storyQuestions = [];
                    var participantQuestions = [];
                    for (var _b = 0, selectedCollections_1 = selectedCollections; _b < selectedCollections_1.length; _b++) {
                        var collectionID = selectedCollections_1[_b];
                        var storyQuestionsForThisCollection = this.project.storyQuestionsForStoryCollection(collectionID);
                        for (var _c = 0, storyQuestionsForThisCollection_1 = storyQuestionsForThisCollection; _c < storyQuestionsForThisCollection_1.length; _c++) {
                            var thisQuestion = storyQuestionsForThisCollection_1[_c];
                            var foundQuestion = false;
                            for (var _d = 0, storyQuestions_1 = storyQuestions; _d < storyQuestions_1.length; _d++) {
                                var existingQuestion = storyQuestions_1[_d];
                                if (existingQuestion.id === thisQuestion.id) {
                                    foundQuestion = true;
                                }
                            }
                            if (!foundQuestion) {
                                storyQuestions.push(thisQuestion);
                            }
                        }
                        var participantQuestionsForThisCollection = this.project.participantQuestionsForStoryCollection(collectionID);
                        for (var _e = 0, participantQuestionsForThisCollection_1 = participantQuestionsForThisCollection; _e < participantQuestionsForThisCollection_1.length; _e++) {
                            var thisQuestion = participantQuestionsForThisCollection_1[_e];
                            var foundQuestion = false;
                            for (var _f = 0, participantQuestions_1 = participantQuestions; _f < participantQuestions_1.length; _f++) {
                                var existingQuestion = participantQuestions_1[_f];
                                if (existingQuestion.id === thisQuestion.id) {
                                    foundQuestion = true;
                                }
                            }
                            if (!foundQuestion) {
                                participantQuestions.push(thisQuestion);
                            }
                        }
                    }
                    this.questions = this.questions.concat(storyQuestions, participantQuestions, annotationQuestions, numStoriesToldQuestions, storyLengthQuestions, collectionDateQuestions, languageQuestions);
                    this.choices = surveyCollection.optionsForAllQuestions(this.questions, "excludeTextQuestions");
                }
            }
            // update all stories for the specific collection and update graph
            this.loadLatestStories();
        };
        GraphBrowser.prototype.loadLatestStories = function () {
            var allStories = [];
            for (var _i = 0, _a = this.collectionIDs; _i < _a.length; _i++) {
                var collectionID = _a[_i];
                if (this.displayCollections[collectionID]) {
                    var storiesForThisCollection = surveyCollection.getStoriesForStoryCollection(collectionID);
                    allStories = allStories.concat(storiesForThisCollection);
                }
            }
            this.graphHolder.allStories = allStories;
            this.updateGraph();
        };
        GraphBrowser.prototype.updateGraph = function () {
            var xAxisQuestionID = this.xAxisSelectValue;
            var yAxisQuestionID = this.yAxisSelectValue;
            // Remove old graph(s)
            while (this.graphHolder.chartPanes.length) {
                var chartPane = this.graphHolder.chartPanes.pop();
                this.graphHolder.graphResultsPane.removeChild(chartPane);
                // TODO: Do these need to be destroyed or freed somehow?
            }
            // Need to remove the float end node, if any        
            while (this.graphHolder.graphResultsPane.firstChild) {
                this.graphHolder.graphResultsPane.removeChild(this.graphHolder.graphResultsPane.firstChild);
            }
            this.selectedStories = [];
            var selectedCollections = [];
            for (var _i = 0, _a = this.collectionIDs; _i < _a.length; _i++) {
                var collectionID = _a[_i];
                if (this.displayCollections[collectionID]) {
                    selectedCollections.push(collectionID);
                }
            }
            if (selectedCollections.length === 0) {
                return;
            }
            // TODO: Translated or improve checking or provide alternate handling if only one selected
            if (!xAxisQuestionID && !yAxisQuestionID)
                return; // alert("Please select a question for one or both graph axes");
            var xAxisQuestion = questionForID(this.questions, xAxisQuestionID);
            var yAxisQuestion = questionForID(this.questions, yAxisQuestionID);
            // Ensure xAxisQuestion is always defined
            if (!xAxisQuestion) {
                xAxisQuestion = yAxisQuestion;
                yAxisQuestion = null;
            }
            if (!xAxisQuestion)
                return;
            var xType = "choice";
            var yType = null;
            if (xAxisQuestion.displayType === "slider") {
                xType = "scale";
            }
            if (yAxisQuestion) {
                if (yAxisQuestion.displayType === "slider") {
                    yType = "scale";
                }
                else {
                    yType = "choice";
                }
            }
            if (xType === "choice" && yType === null) {
                this.graphHolder.currentGraph = charting.d3BarChartForQuestion(this.graphHolder, xAxisQuestion, this.storiesSelected.bind(this), true);
            }
            else if (xType === "choice" && yType === "choice") {
                this.graphHolder.currentGraph = charting.d3ContingencyTable(this.graphHolder, xAxisQuestion, yAxisQuestion, null, this.storiesSelected.bind(this), true);
            }
            else if (xType === "choice" && yType === "scale") {
                this.graphHolder.currentGraph = charting.multipleHistograms(this.graphHolder, xAxisQuestion, yAxisQuestion, this.storiesSelected.bind(this), true);
            }
            else if (xType === "scale" && yType === null) {
                this.graphHolder.currentGraph = charting.d3HistogramChartForQuestion(this.graphHolder, xAxisQuestion, null, null, this.storiesSelected.bind(this), true);
            }
            else if (xType === "scale" && yType === "choice") {
                this.graphHolder.currentGraph = charting.multipleHistograms(this.graphHolder, yAxisQuestion, xAxisQuestion, this.storiesSelected.bind(this), true);
            }
            else if (xType === "scale" && yType === "scale") {
                this.graphHolder.currentGraph = charting.d3ScatterPlot(this.graphHolder, xAxisQuestion, yAxisQuestion, null, null, this.storiesSelected.bind(this), true);
            }
            else {
                console.log("ERROR: Unexpected graph type");
                alert("ERROR: Unexpected graph type");
                return;
            }
        };
        GraphBrowser.prototype.changeShowAnswers = function (event) {
            this.showAnswers = event.target.checked;
        };
        GraphBrowser.prototype.showSelectedStoriesInSeparateWindow = function (stories, windowTitle, textTitle) {
            var text = textTitle + "\n";
            var header = "\n----------------------------------------------------------------------------------------------------\n";
            for (var i = 0; i < stories.length; i++) {
                text += "\n" + stories[i].indexInStoryCollection() + ". " + stories[i].storyName();
                text += header + stories[i].storyText() + "\n\n";
                if (this.showAnswers) {
                    text += stories[i].storyAnswersDisplay() + "\n";
                }
            }
            dialogSupport.openTextEditorDialog(text, windowTitle, "Close", "Copy to Clipboard", this.closeCopyStoriesDialogClicked.bind(this), false, true);
        };
        GraphBrowser.prototype.closeCopyStoriesDialogClicked = function (text, hideDialogMethod) {
            hideDialogMethod();
        };
        GraphBrowser.prototype.showAllSelectedStoriesInSeparateWindow = function (event) {
            this.showSelectedStoriesInSeparateWindow(this.selectedStories, "Selected stories", "Selected stories");
        };
        GraphBrowser.prototype.sampleSelectedStories = function (sampleSize) {
            var stories = this.selectedStories;
            if (!stories.length) {
                alert("Please select some stories to show.");
                return;
            }
            var sampledStories = [];
            if (stories.length <= sampleSize) {
                sampledStories = sampledStories.concat(stories);
            }
            else {
                var sampledStoryIDs = [];
                while (sampledStoryIDs.length < sampleSize) {
                    var randomIndex = Math.max(0, Math.min(stories.length - 1, Math.round(Math.random() * stories.length) - 1));
                    if (sampledStoryIDs.indexOf(randomIndex) < 0) {
                        sampledStoryIDs.push(randomIndex);
                    }
                }
                sampledStoryIDs.forEach(function (id) {
                    sampledStories.push(stories[id]);
                });
            }
            sampledStories.sort(function (a, b) {
                if (a.indexInStoryCollection() < b.indexInStoryCollection())
                    return -1;
                if (a.indexInStoryCollection() > b.indexInStoryCollection())
                    return 1;
                return 0;
            });
            var title = "Random sample of " + sampledStories.length + " stories from selection of " + this.selectedStories.length;
            this.showSelectedStoriesInSeparateWindow(sampledStories, title, title);
        };
        GraphBrowser.prototype.showRandom10SelectedStories = function (event) {
            this.sampleSelectedStories(10);
        };
        GraphBrowser.prototype.showRandom20SelectedStories = function (event) {
            this.sampleSelectedStories(20);
        };
        GraphBrowser.prototype.showRandom30SelectedStories = function (event) {
            this.sampleSelectedStories(30);
        };
        return GraphBrowser;
    }());
    return GraphBrowser;
});

define('js/applicationWidgets/add_graphBrowser',["require", "exports", "mithril", "./GraphBrowser"], function (require, exports, m, GraphBrowser) {
    "use strict";
    "use strict";
    function add_graphBrowser(panelBuilder, model, fieldSpecification) {
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var graphBrowser = m.component(GraphBrowser, { key: fieldSpecification.id, panelBuilder: panelBuilder, model: model, fieldSpecification: fieldSpecification });
        return m("div", [prompt, graphBrowser]);
    }
    return add_graphBrowser;
});

define('js/applicationWidgets/AnnotationGraphBrowser',["require", "exports", "./charting", "../questionnaireGeneration", "../surveyCollection", "../panelBuilder/valuePathResolver", "../Project", "../Globals", "mithril"], function (require, exports, charting, questionnaireGeneration, surveyCollection, valuePathResolver, Project, Globals, m) {
    "use strict";
    "use strict";
    function questionForID(questions, id) {
        if (!id)
            return null;
        for (var index in questions) {
            var question = questions[index];
            if (question.id === id)
                return question;
        }
        console.log("ERROR: question not found for id", id, questions);
        return null;
    }
    var AnnotationGraphBrowser = (function () {
        function AnnotationGraphBrowser(args) {
            this.project = null;
            this.selectValue = null;
            this.questions = [];
            this.choices = [];
            this.storyCollectionIdentifier = null;
            this.selectedStories = [];
            this.project = Globals.project();
            this.graphHolder = {
                graphResultsPane: charting.createGraphResultsPane("narrafirma-graph-results-pane"),
                chartPanes: [],
                allStories: [],
                currentGraph: null,
                currentSelectionExtentPercentages: null,
                minimumStoryCountRequiredForTest: Project.default_minimumStoryCountRequiredForTest,
                minimumStoryCountRequiredForGraph: 0,
                numHistogramBins: Project.default_numHistogramBins,
                numScatterDotOpacityLevels: Project.default_numScatterDotOpacityLevels,
                scatterDotSize: Project.default_scatterDotSize,
                correlationMapShape: Project.default_correlationMapShape,
                correlationMapIncludeScaleEndLabels: Project.default_correlationMapIncludeScaleEndLabels,
                correlationMapCircleDiameter: Project.default_correlationMapCircleDiameter,
                correlationLineChoice: Project.default_correlationLineChoice,
                customLabelLengthLimit: Project.default_customLabelLengthLimit,
                customGraphWidth: Project.default_customDisplayGraphWidth,
                customGraphHeight: Project.default_customDisplayGraphHeight,
                customGraphPadding: 0,
                hideNumbersOnContingencyGraphs: false,
                patternDisplayConfiguration: { hideNoAnswerValues: true, useLumpingCommands: true },
                graphTypesToCreate: {},
                lumpingCommands: {}
            };
        }
        AnnotationGraphBrowser.controller = function (args) {
            return new AnnotationGraphBrowser(args);
        };
        AnnotationGraphBrowser.view = function (controller, args) {
            return controller.calculateView(args);
        };
        AnnotationGraphBrowser.prototype.calculateView = function (args) {
            var _this = this;
            // Handling of caching of questions and stories
            var storyCollectionIdentifier = valuePathResolver.newValuePathForFieldSpecification(args.model, args.fieldSpecification)();
            if (storyCollectionIdentifier !== this.storyCollectionIdentifier) {
                // TODO: Maybe need to handle tracking if list changed so can keep sorted list?
                this.storyCollectionIdentifier = storyCollectionIdentifier;
                this.currentStoryCollectionChanged(this.storyCollectionIdentifier);
            }
            this.updateGraph();
            var parts;
            if (this.storyCollectionIdentifier) {
                parts = [
                    m("select.narrafirma-annotation-counts-graph-select", { onchange: function (event) { _this.selectValue = event.target.value; _this.updateGraph(); } }, this.calculateOptionsForChoices(this.selectValue)),
                    m("div.narrafirma-annotation-counts-graph", { config: this.insertGraphResultsPaneConfig.bind(this) })
                ];
            }
            return m("div", parts);
        };
        AnnotationGraphBrowser.prototype.insertGraphResultsPaneConfig = function (element, isInitialized, context) {
            if (!isInitialized) {
                element.appendChild(this.graphHolder.graphResultsPane);
            }
        };
        AnnotationGraphBrowser.prototype.storiesSelected = function (selectedStories) {
            this.selectedStories = selectedStories;
        };
        AnnotationGraphBrowser.prototype.calculateOptionsForChoices = function (currentValue) {
            var options = this.choices.map(function (option) {
                var optionOptions = { value: option.value, selected: undefined };
                if (currentValue === option.value)
                    optionOptions.selected = 'selected';
                return m("option", optionOptions, option.label);
            });
            var hasNoSelection = (currentValue === null || currentValue === undefined || currentValue === "") || undefined;
            options.unshift(m("option", { value: "", selected: hasNoSelection }, "--- select ---"));
            return options;
        };
        AnnotationGraphBrowser.prototype.currentStoryCollectionChanged = function (storyCollectionIdentifier) {
            this.storyCollectionIdentifier = storyCollectionIdentifier;
            this.questions = questionnaireGeneration.convertEditorQuestions(this.project.collectAllAnnotationQuestions(), "A_");
            this.choices = surveyCollection.optionsForAllQuestions(this.questions, "excludeTextQuestions");
            this.loadLatestStories();
        };
        AnnotationGraphBrowser.prototype.loadLatestStories = function () {
            this.graphHolder.allStories = surveyCollection.getStoriesForStoryCollection(this.storyCollectionIdentifier);
            this.updateGraph();
        };
        AnnotationGraphBrowser.prototype.updateGraph = function () {
            var questionID = this.selectValue;
            // Remove old graph(s)
            while (this.graphHolder.chartPanes.length) {
                var chartPane = this.graphHolder.chartPanes.pop();
                this.graphHolder.graphResultsPane.removeChild(chartPane);
            }
            // Need to remove the float end node, if any        
            while (this.graphHolder.graphResultsPane.firstChild) {
                this.graphHolder.graphResultsPane.removeChild(this.graphHolder.graphResultsPane.firstChild);
            }
            this.selectedStories = [];
            if (!questionID)
                return;
            var question = questionForID(this.questions, questionID);
            if (!question)
                return;
            var type = "choice";
            if (question.displayType === "slider")
                type = "scale";
            if (type === "choice") {
                charting.d3BarChartForQuestion(this.graphHolder, question, this.storiesSelected.bind(this), true);
            }
            else if (type === "scale") {
                charting.d3HistogramChartForQuestion(this.graphHolder, question, null, null, this.storiesSelected.bind(this), true);
            }
            else {
                console.log("ERROR: Unexpected graph type");
                alert("ERROR: Unexpected graph type");
                return;
            }
        };
        return AnnotationGraphBrowser;
    }());
    return AnnotationGraphBrowser;
});

define('js/applicationWidgets/add_annotationGraphBrowser',["require", "exports", "mithril", "./AnnotationGraphBrowser"], function (require, exports, m, AnnotationGraphBrowser) {
    "use strict";
    "use strict";
    function add_annotationGraphBrowser(panelBuilder, model, fieldSpecification) {
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var graphBrowser = m.component(AnnotationGraphBrowser, { key: fieldSpecification.id, panelBuilder: panelBuilder, model: model, fieldSpecification: fieldSpecification });
        // insertGraphBrowser(panelBuilder, model, fieldSpecification);
        return m("div", [
            prompt,
            graphBrowser
        ]);
    }
    return add_annotationGraphBrowser;
});

define('js/applicationWidgets/add_questionAnswer',["require", "exports", "../panelBuilder/translate", "mithril", "../sanitizeHTML", "../panelBuilder/valuePathResolver"], function (require, exports, translate, m, sanitizeHTML, valuePathResolver) {
    "use strict";
    "use strict";
    function div_for_value(value) {
        if (value === undefined || value === null)
            value = "";
        return '<div class="narrafirma-question-type-questionAnswer">' + value + '</div>';
    }
    /* TODO: This is only really needed for translation which is not fully worked out, but maybe OK enough without it?
    function calculate_questionAnswer(panelBuilder: PanelBuilder, model, referencedQuestionID) {
        let value = panelBuilder.project.tripleStore.getLastestC(model, referencedQuestionID);
        if (value === undefined) {
            console.log("ERROR: missing question: ", referencedQuestionID);
            // throw new Error("ERROR: missing question: " + referencedQuestionID);
            value = null;
        }
        
        // if (value === null) value = translate("#question_not_yet_answered|(Not yet answered)");
        if (value === null) value = "";
            
        // This collection could be null during testing
        const panelSpecificationCollection = panelBuilder.panelSpecificationCollection;
        if (!panelSpecificationCollection) {
            const errorMessage = "ERROR: panelBuilder.panelSpecificationCollection is null";
            console.log("ERROR", errorMessage);
            return errorMessage;
        }
        
        const fieldSpecification = panelSpecificationCollection.getFieldSpecificationForFieldID(referencedQuestionID);
        if (fieldSpecification) {
            if (fieldSpecification.displayType === "select" ||  fieldSpecification.displayType === "checkboxes" || fieldSpecification.displayType === "radiobuttons") {
                // TODO: This may not translate correctly for checkboxes; may need to be translated individually
                // TODO: Possible issue here with incorrect translation if values leading "#" and then have a pipe bar in them
                value = translate(value, value);
            }
        } else {
            console.log("calculate_questionAnswer: missing fieldSpecification definition for: ", referencedQuestionID);
        }
        
        return div_for_value(value);
    }
    */
    // TODO: This will not work when questions are on other pages with newer system
    function add_questionAnswer(panelBuilder, model, fieldSpecification) {
        var referencedQuestionID = fieldSpecification.displayConfiguration;
        if (!referencedQuestionID)
            throw new Error("missing referencedQuestionID for field: " + fieldSpecification.id + " all: " + JSON.stringify(fieldSpecification));
        var calculate = function () {
            var valueProperty = valuePathResolver.newValuePath(model, referencedQuestionID);
            var value = valueProperty();
            if (value === undefined || value === null)
                value = "";
            if (fieldSpecification.displayTransformValue)
                value = fieldSpecification.displayTransformValue(value, model, fieldSpecification, panelBuilder);
            if (fieldSpecification.displayURLValue)
                value = fieldSpecification.displayURLValue(value, model);
            return value;
        };
        // const label = panelBuilder._add_calculatedText(panelBuilder, fieldSpecification, function() {return div_for_value(calculate());});
        // TODO: Recalculating next two variables wheres they are also calculated in _add_calculatedText
        var baseText = translate(fieldSpecification.id + "::prompt", fieldSpecification.displayPrompt);
        // const updateInfo = {"id": fieldSpecification.id, "label": label, "baseText": baseText, "calculate": calculate};
        // TODO: Who should track this data with Mithril? This component? Or should redraw be called automatically (or manually) on data change?
        //const watcher = panelBuilder.project.watchFieldValue(referencedQuestionID, function(triple, message) {
        //    panelBuilder.updateLabelUsingCalculation(updateInfo);
        //});
        // Klugde to get the contentPane to free the watcher by calling remove when it is destroyed
        // This would not work if the content pane continued to exist when replacing this component
        // contentPane.own(watcher);
        // TODO: Fix styling
        if (fieldSpecification.displayURLValue) {
            return m("div", { "class": "questionExternal narrafirma-question-type-questionAnswer" }, [
                sanitizeHTML.generateSanitizedHTMLForMithril(fieldSpecification.displayPrompt),
                m("div", { "class": "narrafirma-survey-link" }, calculate())
            ]);
        }
        else {
            return m("div", { "class": "questionExternal narrafirma-question-type-questionAnswer" }, [
                sanitizeHTML.generateSanitizedHTMLForMithril(fieldSpecification.displayPrompt),
                m("div[class=narrafirma-questionAnswer]", calculate())
            ]);
        }
    }
    return add_questionAnswer;
});

define('js/applicationWidgets/add_quizScoreResult',["require", "exports", "../panelBuilder/translate", "mithril", "../sanitizeHTML", "../Globals"], function (require, exports, translate, m, sanitizeHTML, Globals) {
    "use strict";
    "use strict";
    function calculate_quizScoreResult(panelSpecificationCollection, modelFunction, dependsOn) {
        if (!panelSpecificationCollection)
            return "ERROR in calculate_quizScoreResult: panelSpecificationCollection is not set";
        var total = 0;
        for (var dependsOnIndex = 0; dependsOnIndex < dependsOn.length; dependsOnIndex++) {
            var questionID = dependsOn[dependsOnIndex];
            var questionAnswer = modelFunction(questionID);
            var answerWeight = 0;
            var index = 0;
            if (questionAnswer) {
                var choices = panelSpecificationCollection.getFieldSpecificationForFieldID(questionID).valueOptions;
                index = choices.indexOf(questionAnswer);
                if (index === choices.length - 1) {
                    answerWeight = 0;
                }
                else {
                    answerWeight = index;
                }
                if (answerWeight < 0)
                    answerWeight = 0;
                total += answerWeight;
            }
        }
        var possibleTotal = dependsOn.length * 3;
        var percent = Math.round(100 * total / possibleTotal);
        var template = translate("#calculate_quizScoreResult_template", "{{total}} of {{possibleTotal}} ({{percent}}%)");
        var response = template.replace("{{total}}", total).replace("{{possibleTotal}}", possibleTotal).replace("{{percent}}", "" + percent);
        return response;
    }
    function add_quizScoreResult(panelBuilder, model, fieldSpecification) {
        var dependsOn = fieldSpecification.displayConfiguration;
        var modelFunction = Globals.project().tripleStore.makeModelFunction(model);
        var calculateResult = calculate_quizScoreResult(panelBuilder.panelSpecificationCollection, modelFunction, dependsOn);
        var baseText = translate(fieldSpecification.id + "::prompt", fieldSpecification.displayPrompt);
        var labelText = panelBuilder.substituteCalculatedResultInBaseText(baseText, calculateResult);
        return m("div", { "class": "questionExternal narrafirma-question-type-quizScoreResult" }, sanitizeHTML.generateSanitizedHTMLForMithril(labelText));
    }
    return add_quizScoreResult;
});

define('js/RecommendationsParser',["require", "exports"], function (require, exports) {
    "use strict";
    // Process Recommendations CSV file 
    // File should have category header line to define categories with "# SECTION" to define sections and blank items between sections
    // Each row should have a header (# SECTION) or item with entries for every regular column with a blank line between sections
    /* Example:
    "",    "#Q1", "a1", "a2", "", "#Q2", "a1", "a2"
    "#C1",    "",   "",   "", "",    "",   "",   ""
    "op1",    "",  "1",  "2", "",    "",  "2",  "1"
    "op2",    "",  "3",  "4", "",    "",  "4",  "3"
       "",    "",   "",   "", "",    "",   "",   ""
    "#C2",    "",   "",   "", "",    "",   "",   ""
    "op1",    "",  "1",  "4", "",    "",  "3",   "1"
    "op2",    "",  "3",  "2", "",    "",  "4",   "1"
    */
    /* The JSON output looks like:
    {
      "Q1": {
        "op1": {
          "C1": {
            "Ven1": "1",
            "Ven2": "2"
          },
          "C2": {
            "Way1": "2",
            "Way2": "1"
          }
        },
        "op2": {
          "C1": {
            "Ven1": "3",
            "Ven2": "4"
          },
          "C2": {
            "Way1": "4",
            "Way2": "3"
          }
        }
      },
      "Q2": {
        "op1": {
          "C1": {
            "Ven1": "1",
            "Ven2": "4"
          },
          "C2": {
            "Way1": "3",
            "Way2": "1"
          }
        },
        "op2": {
          "C1": {
            "Ven1": "3",
            "Ven2": "2"
          },
          "C2": {
            "Way1": "4",
            "Way2": "1"
          }
        }
      }
    }
    */
    function startsWith(str, prefix) {
        return str.lastIndexOf(prefix, 0) === 0;
    }
    function endsWith(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    var RecommendationsParser = (function () {
        function RecommendationsParser(csvText) {
            this.matrix = [];
            this.matrixColumnCount = 0;
            this.matrixRowCount = 0;
            this.categories = null;
            this.questions = null;
            this.recommendations = null;
            this.parse(csvText);
        }
        RecommendationsParser.prototype.getMatrixValue = function (row, column) {
            if (row > this.matrixRowCount)
                return null;
            if (column > this.matrixColumnCount)
                return null;
            var line = this.matrix[row];
            if (column > line.length)
                return "";
            return line[column];
        };
        RecommendationsParser.prototype.loadMatrixFromCSVText = function (csvText) {
            // Load matrix
            this.matrix = [];
            this.matrixColumnCount = 0;
            this.matrixRowCount = 0;
            var lines = csvText.split("\r");
            for (var lineIndex in lines) {
                var line = lines[lineIndex];
                // TODO: Will not handle embedded commas
                var splitLine = line.split(",");
                var lineItems = [];
                for (var index = 0; index < splitLine.length; index++) {
                    var item = splitLine[index].trim();
                    if (startsWith(item, '"') && endsWith(item, '"')) {
                        item = item.substring(1, item.length - 1);
                        // Replace escaped double quotes
                        item = item.replace(/\"\"/, '"');
                    }
                    lineItems.push(item);
                }
                this.matrix.push(lineItems);
                // if (lineItems.length > matrixColumnCount) matrixColumnCount = lineItems.length;
            }
            this.matrixRowCount = this.matrix.length;
            if (this.matrixRowCount > 0)
                this.matrixColumnCount = this.matrix[0].length;
        };
        RecommendationsParser.prototype.addRecommendation = function (recommendations, columnCategory, columnField, rowCategory, rowField, item) {
            var question = recommendations[columnCategory];
            if (!question) {
                question = {};
                recommendations[columnCategory] = question;
            }
            var option = question[columnField];
            if (!option) {
                option = {};
                question[columnField] = option;
            }
            var category = option[rowCategory];
            if (!category) {
                category = {};
                option[rowCategory] = category;
            }
            category[rowField] = item;
        };
        RecommendationsParser.prototype.processRecommendationsMatrix = function () {
            var header = this.matrix[0];
            var columnCategory = null;
            var columnField = null;
            var rowCategory = null;
            var rowField = null;
            var recommendations = {};
            for (var lineIndex = 1; lineIndex < this.matrixRowCount; lineIndex++) {
                rowField = this.getMatrixValue(lineIndex, 0).trim();
                if (rowField === "")
                    continue;
                if (startsWith(rowField, "#")) {
                    rowCategory = rowField.substring(1).trim();
                    if (rowCategory === "collectionSessions #sensemakingSessions")
                        rowCategory = "sessions";
                    rowField = null;
                    continue;
                }
                for (var columnIndex = 1; columnIndex < this.matrixColumnCount; columnIndex++) {
                    columnField = header[columnIndex].trim();
                    if (columnField === "")
                        continue;
                    if (startsWith(columnField, "#")) {
                        columnCategory = columnField.substring(1).trim();
                        columnField = null;
                        continue;
                    }
                    var item = this.getMatrixValue(lineIndex, columnIndex).trim();
                    this.addRecommendation(recommendations, columnCategory, columnField, rowCategory, rowField, item);
                }
            }
            return recommendations;
        };
        RecommendationsParser.prototype.buildCategories = function () {
            var result = {};
            var rowCategory = null;
            var rowField = null;
            for (var lineIndex = 1; lineIndex < this.matrixRowCount; lineIndex++) {
                rowField = this.getMatrixValue(lineIndex, 0).trim();
                if (rowField === "")
                    continue;
                if (startsWith(rowField, "#")) {
                    rowCategory = rowField.substring(1).trim();
                    if (rowCategory === "collectionSessions #sensemakingSessions")
                        rowCategory = "sessions";
                    rowField = null;
                    result[rowCategory] = [];
                    continue;
                }
                result[rowCategory].push(rowField);
            }
            return result;
        };
        RecommendationsParser.prototype.buildQuestions = function () {
            var result = {};
            var columnCategory = null;
            var columnField = null;
            for (var columnIndex = 1; columnIndex < this.matrixColumnCount; columnIndex++) {
                columnField = this.getMatrixValue(0, columnIndex).trim();
                if (columnField === "")
                    continue;
                if (startsWith(columnField, "#")) {
                    columnCategory = columnField.substring(1).trim();
                    columnField = null;
                    result[columnCategory] = [];
                    continue;
                }
                result[columnCategory].push(columnField);
            }
            return result;
        };
        RecommendationsParser.prototype.parse = function (csvText) {
            this.loadMatrixFromCSVText(csvText);
            this.categories = this.buildCategories();
            this.questions = this.buildQuestions();
            this.recommendations = this.processRecommendationsMatrix();
        };
        RecommendationsParser.recommendations = function () {
            // Lazy parsing of recommendaitons
            if (!RecommendationsParser.recommendationsObject) {
                var recommendationsText = window["narraFirma_recommendationsText"];
                RecommendationsParser.recommendationsObject = new RecommendationsParser(recommendationsText);
            }
            return RecommendationsParser.recommendationsObject;
        };
        RecommendationsParser.recommendationsIntervention = function () {
            // Lazy parsing of recommendaitons
            if (!RecommendationsParser.recommendationsInterventionObject) {
                var recommendationsInterventionText = window["narraFirma_recommendationsInterventionText"];
                RecommendationsParser.recommendationsInterventionObject = new RecommendationsParser(recommendationsInterventionText);
            }
            return RecommendationsParser.recommendationsInterventionObject;
        };
        return RecommendationsParser;
    }());
    return RecommendationsParser;
});

define('js/applicationWidgets/add_recommendationTable',["require", "exports", "../panelBuilder/dialogSupport", "../RecommendationsParser", "../panelBuilder/translate", "mithril", "../Globals"], function (require, exports, dialogSupport, RecommendationsParser, translate, m, Globals) {
    "use strict";
    "use strict";
    function add_recommendationTable(panelBuilder, model, fieldSpecification) {
        var dialogConfiguration = {
            fieldSpecification: fieldSpecification,
            dialogModel: model,
            dialogTitle: "#title_recommendationsTable|Recommendations table",
            dialogClass: "wide",
            dialogConstructionFunction: build_recommendationTable.bind(null, panelBuilder),
            dialogOKButtonLabel: "Close"
        };
        return dialogSupport.addButtonThatLaunchesDialog(fieldSpecification, dialogConfiguration);
    }
    function tagForRecommendationValue(recommendation) {
        if (recommendation === "no") {
            return "recommendationNo";
        }
        else if (recommendation === "maybe") {
            return "recommendationLow";
        }
        else if (recommendation === "good") {
            return "recommendationMedium";
        }
        else if (recommendation === "excellent") {
            return "recommendationHigh";
        }
        console.log("ERROR: Unexpected recommendation value", recommendation);
        return "";
    }
    function makeTableForParticipantGroup(categoryName, project, participantGroupIdentifier) {
        var recommendationsObject;
        if (categoryName === "interventions") {
            recommendationsObject = RecommendationsParser.recommendationsIntervention();
        }
        else {
            recommendationsObject = RecommendationsParser.recommendations();
        }
        // recommendations -> Question -> Answer -> Category -> Option
        var optionsForCategory = recommendationsObject.categories[categoryName];
        if (!optionsForCategory) {
            console.log("ERROR: No data for recommendationTable category: ", categoryName);
            optionsForCategory = [];
        }
        var table = m("table.recommendationsTable", 
        // Do the header
        m("tr", [[
                m("th.wwsRecommendationsTable-valueCell", { colspan: 4, align: "right" }, m("i", "Question")),
                m("th.wwsRecommendationsTable-valueCell", { colspan: 2, align: "right" }, m("i", "Your answer"))
            ], optionsForCategory.map(function (headerFieldName) {
                return m("th.wwsRecommendationsTable-valueCell", m("i", { colspan: 1, align: "right" }, headerFieldName));
            })]), 
        // Now do one data row for each question considered in the recommendation
        // TODO: Maybe keys should be sorted somehow?
        Object.keys(recommendationsObject.questions).map(function (questionName) {
            // TODO: Possible should improve this translation default, maybe by retrieving fieldSpecification for question and getting displayPrompt?
            var questionText = translate(questionName + "::shortName", questionName);
            var yourAnswer = project.tripleStore.queryLatestC(participantGroupIdentifier, questionName);
            if (yourAnswer === undefined)
                yourAnswer = project.getFieldValue(questionName);
            if (yourAnswer === undefined)
                yourAnswer = "";
            // Don't put rows where there is no answer
            if (!yourAnswer)
                return [];
            // Drill down into the recommentations if they exist for questioName, yourAnswer, and categoryName
            var recommendationsForAnswer = recommendationsObject.recommendations[questionName];
            if (recommendationsForAnswer)
                recommendationsForAnswer = recommendationsForAnswer[yourAnswer];
            if (recommendationsForAnswer)
                recommendationsForAnswer = recommendationsForAnswer[categoryName];
            return m("tr", [[
                    m("th.wwsRecommendationsTable-valueCell", { colspan: 4, align: "right" }, questionText),
                    m("th.wwsRecommendationsTable-valueCell", { colspan: 2, align: "right" }, yourAnswer)
                ], optionsForCategory.map(function (optionName, index) {
                    var recommendationForOption = "???";
                    if (recommendationsForAnswer) {
                        recommendationForOption = recommendationsForAnswer[optionName];
                    }
                    else {
                        console.log("Missing recommendations for", questionName, yourAnswer);
                    }
                    if (!recommendationForOption) {
                        if (categoryName === "interventions") {
                            recommendationForOption = "maybe";
                        }
                        else {
                            recommendationForOption = "good";
                        }
                    }
                    if (recommendationForOption === "very good")
                        recommendationForOption = "excellent";
                    // TODO: Translate recommendation name 
                    var theClass = tagForRecommendationValue(recommendationForOption);
                    return m("td.wwsRecommendationsTable-labelCell", { colspan: 1, align: "right", "class": theClass }, recommendationForOption);
                })]);
        }));
        return table;
    }
    function build_recommendationTable(panelBuilder, dialogConfiguration, hideDialogCallback) {
        var model = dialogConfiguration.dialogModel;
        var fieldSpecification = dialogConfiguration.fieldSpecification;
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var categoryName = fieldSpecification.displayConfiguration;
        var participantGroups;
        var participantGroupNameFieldIdentifier;
        if (categoryName === "interventions") {
            participantGroups = Globals.project().getListForField("project_outcomesList");
            participantGroupNameFieldIdentifier = "outcomes_group";
            // TODO: Translate
            if (!participantGroups || !participantGroups.length)
                return m("div", "Please enter at least one project outcome so we can choose which recommendations to show you.");
        }
        else {
            participantGroups = Globals.project().getListForField("project_participantGroupsList");
            participantGroupNameFieldIdentifier = "participantGroup_name";
            // TODO: Translate
            if (!participantGroups || !participantGroups.length)
                return m("div", "Please enter at least one participant group so we can choose which recommendations to show you.");
        }
        // TODO: Set class on div
        return m("div", { "class": "narrafirma-recommendations-table " + categoryName }, [
            prompt,
            participantGroups.map(function (participantGroupIdentifier) {
                var participantGroupName = Globals.project().tripleStore.queryLatestC(participantGroupIdentifier, participantGroupNameFieldIdentifier);
                return m("div", [
                    m("b", participantGroupName),
                    m("br"),
                    m("br"),
                    makeTableForParticipantGroup(categoryName, Globals.project(), participantGroupIdentifier),
                    m("br"),
                    m("br")
                ]);
            })
        ]);
    }
    return add_recommendationTable;
});

define('js/applicationWidgets/add_storiesList',["require", "exports", "mithril", "../Globals"], function (require, exports, m, Globals) {
    "use strict";
    "use strict";
    function add_storiesList(panelBuilder, model, fieldSpecification) {
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var tripleStore = Globals.project().tripleStore;
        // TODO: Generalize this so it can handle more complex value paths than just a project field name
        var storyIdentifierList = Globals.project().getListForField(fieldSpecification.valuePath);
        var storyNameField = "projectStory_name";
        var storyTextField = "projectStory_text";
        storyIdentifierList.sort(function (a, b) {
            var aName = tripleStore.queryLatestC(a, storyNameField) || "";
            var bName = tripleStore.queryLatestC(b, storyNameField) || "";
            return aName.localeCompare(bName);
        });
        return m("div.narrafirma-stories-list", [
            prompt,
            // m("div.narrafirma-stories-list-title", "Project stories:"),
            //m("br"),
            m("table", [
                m("tr", [m("th", "Story name"), m("th", "Story text")]),
                storyIdentifierList.map(function (storyIdentifier) {
                    return [
                        m("tr"),
                        [m("td", tripleStore.queryLatestC(storyIdentifier, storyNameField)),
                            m("td", tripleStore.queryLatestC(storyIdentifier, storyTextField))]
                    ];
                })
            ])
        ]);
    }
    return add_storiesList;
});

define('js/applicationWidgets/StoryBrowser',["require", "exports", "../storyCardDisplay", "../questionnaireGeneration", "../surveyCollection", "../panelBuilder/valuePathResolver", "../Globals", "mithril", "../panelBuilder/GridWithItemPanel"], function (require, exports, storyCardDisplay, questionnaireGeneration, surveyCollection, valuePathResolver, Globals, m, GridWithItemPanel) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    //import questionAndAnswerChooserSupport = require("questionAndAnswerChooserSupport");
    "use strict";
    // story browser support
    // TODO: Need to update answer counts in filters if change value in story that affectes selected filter question
    // TODO: Translate
    var unansweredIndicator = "No answer";
    function isMatch(story, questionChoice, selectedAnswerChoices) {
        if (!questionChoice)
            return true;
        var questionAnswer = story.fieldValue(questionChoice.id);
        if (questionAnswer === undefined || questionAnswer === null || questionAnswer === "") {
            questionAnswer = unansweredIndicator;
        }
        else if (typeof questionAnswer === "object") {
            // checkboxes
            for (var key in questionAnswer) {
                if (selectedAnswerChoices[key] && questionAnswer[key])
                    return true;
            }
            return false;
        }
        questionAnswer = "" + questionAnswer;
        return !!selectedAnswerChoices[questionAnswer];
    }
    function optionsFromQuestion(question, stories) {
        // TODO: Translate text for options, at least booleans?
        var options = [];
        if (!question)
            return options;
        // Compute how many of each answer -- assumes typically less than 200-1000 stories
        var totals = {};
        stories.forEach(function (story) {
            var choice = story.fieldValue(question.id);
            if (choice === undefined || choice === null || choice === "") {
                // Do not include "0" as unanswered
                choice = unansweredIndicator;
            }
            var oldValue;
            if (question.displayType === "checkboxes") {
                for (var key in choice) {
                    oldValue = totals[key];
                    if (!oldValue)
                        oldValue = 0;
                    if (choice[key])
                        totals[key] = oldValue + 1;
                }
            }
            else {
                oldValue = totals[choice];
                if (!oldValue)
                    oldValue = 0;
                totals[choice] = oldValue + 1;
            }
        });
        var count;
        if (["select", "radiobuttons", "checkboxes"].indexOf(question.displayType) >= 0) {
            var answersAlreadyConsidered = [];
            for (var i = 0; i < question.valueOptions.length; i++) {
                var answer = question.valueOptions[i];
                if (answersAlreadyConsidered.indexOf(answer) >= 0)
                    continue; // hide duplicate options, if any, due to lumping during import
                answersAlreadyConsidered.push(answer);
                count = totals[answer];
                if (!count)
                    count = 0;
                options.push({ label: answer + " - " + count, value: answer });
            }
        }
        else if (question.displayType === "slider") {
            for (var sliderTick = 0; sliderTick <= 100; sliderTick++) {
                count = totals[sliderTick];
                if (!count)
                    count = 0;
                var sliderTickText = "" + sliderTick;
                options.push({ label: sliderTickText + " - " + count, value: sliderTick });
            }
        }
        else if (question.displayType === "boolean") {
            [true, false].forEach(function (each) {
                count = totals["" + each];
                if (!count)
                    count = 0;
                options.push({ label: each + " - " + count, value: each });
            });
        }
        else if (question.displayType === "checkbox") {
            [true, false].forEach(function (each) {
                count = totals["" + each];
                if (!count)
                    count = 0;
                options.push({ label: each + " - " + count, value: each });
            });
        }
        else if (question.displayType === "text") {
            for (var eachTotal in totals) {
                if (totals.hasOwnProperty(eachTotal)) {
                    count = totals[eachTotal];
                    if (!count)
                        count = 0;
                    if (eachTotal !== unansweredIndicator)
                        options.push({ label: eachTotal + " - " + count, value: eachTotal });
                }
            }
        }
        else {
            console.log("ERROR: question type not supported: ", question.displayType, question);
            options.push({ label: "*ALL*" + " - " + stories.length, value: "*ALL*" });
        }
        count = totals[unansweredIndicator];
        if (!count)
            count = 0;
        options.push({ label: unansweredIndicator + " - " + count, value: unansweredIndicator });
        return options;
    }
    function getSelectedOptions(select) {
        var selectedOptions = {};
        // select.selectedOptions is probably not implemented widely enough, so use this looping code instead over all options
        for (var i = 0; i < select.options.length; i++) {
            var option = select.options[i];
            if (option.selected) {
                selectedOptions[option.value] = option;
            }
        }
        return selectedOptions;
    }
    function getQuestionDataForSelection(questions, event) {
        var newValue = event.target.value;
        var question = null;
        for (var index = 0; index < questions.length; index++) {
            var questionToCheck = questions[index];
            if (questionToCheck.id === newValue) {
                question = questionToCheck;
                break;
            }
        }
        if (!question && newValue)
            console.log("Could not find question for id", newValue);
        return question;
    }
    var Filter = (function () {
        function Filter(args) {
            this.name = null;
            this.storyBrowser = null;
            this.selectedQuestion = null;
            this.answerOptionsForSelectedQuestion = [];
            this.selectedAnswers = {};
            this.storyBrowser = args.storyBrowser;
            this.name = args.name;
        }
        Filter.controller = function (args) {
            return new Filter(args);
        };
        Filter.view = function (controller, args) {
            return controller.calculateView(args);
        };
        Filter.prototype.hasQuestionAndAnswers = function () {
            return this.selectedQuestion && Object.keys(this.selectedAnswers).length;
        };
        Filter.prototype.hasQuestion = function () {
            return this.selectedQuestion;
        };
        Filter.prototype.displayInformation = function () {
            var result = "";
            if (this.hasQuestionAndAnswers()) {
                result += "[ " + this.selectedQuestion.displayName + ": ";
                result += Object.keys(this.selectedAnswers).join(", ") + " ]";
            }
            else if (this.hasQuestion()) {
                result += "[ " + this.selectedQuestion.displayName + " (no choice) " + " ]";
            }
            return result;
        };
        Filter.prototype.calculateView = function (args) {
            var _this = this;
            var choices = this.storyBrowser.choices || [];
            var selectOptions = choices.map(function (option) {
                var optionOptions = { value: option.value, selected: undefined };
                if (_this.selectedQuestion === option.value)
                    optionOptions.selected = 'selected';
                return m("option", optionOptions, option.label);
            });
            var isNoSelection = (this.selectedQuestion === null) || undefined;
            selectOptions.unshift(m("option", { value: "", selected: isNoSelection }, "--- no filter ---"));
            var multiselectOptions = this.answerOptionsForSelectedQuestion.map(function (option) {
                var optionOptions = { value: option.value, selected: undefined };
                if (_this.selectedAnswers[option.value])
                    optionOptions.selected = 'selected';
                return m("option", optionOptions, option.label);
            });
            var isClearButtonDisabled = (this.selectedQuestion === null) || undefined;
            var displayOrNotText = (multiselectOptions.length > 0) ? "" : "[style='display:none']";
            return m("div.filter", [
                this.name,
                m("br"),
                m("select", { onchange: this.filterPaneQuestionChoiceChanged.bind(this) }, selectOptions),
                m("button", { disabled: isClearButtonDisabled, onclick: this.clearFilterPane.bind(this) }, m("span", { class: "buttonWithTextImage clearButtonImage" }), "Clear"),
                m("br"),
                m("select" + displayOrNotText, { onchange: this.filterPaneAnswerChoiceChanged.bind(this), multiple: "multiple" }, multiselectOptions)
            ]);
        };
        Filter.prototype.filterPaneQuestionChoiceChanged = function (event) {
            var question = getQuestionDataForSelection(this.storyBrowser.questions, event);
            this.selectedQuestion = question;
            this.answerOptionsForSelectedQuestion = optionsFromQuestion(this.selectedQuestion, this.storyBrowser.allStories);
            this.selectedAnswers = {};
            this.storyBrowser.setStoryListForCurrentFilters();
        };
        Filter.prototype.filterPaneAnswerChoiceChanged = function (event) {
            this.selectedAnswers = getSelectedOptions(event.target);
            this.storyBrowser.setStoryListForCurrentFilters();
        };
        Filter.prototype.resetChoices = function () {
            this.selectedQuestion = null;
            this.answerOptionsForSelectedQuestion = [];
            this.selectedAnswers = {};
        };
        Filter.prototype.clearFilterPane = function () {
            this.resetChoices();
            this.storyBrowser.setStoryListForCurrentFilters();
        };
        return Filter;
    }());
    var StoryBrowser = (function () {
        function StoryBrowser(args) {
            this.project = null;
            this.storyCollectionIdentifier = null;
            this.questions = [];
            this.choices = [];
            this.allStories = [];
            this.filteredStories = [];
            this.itemPanelSpecification = { id: "temporary", modelClass: "Story", panelFields: [] };
            this.gridFieldSpecification = null;
            this.grid = null;
            this.project = Globals.project();
            this.gridFieldSpecification = {
                id: "stories",
                displayConfiguration: {
                    itemPanelSpecification: this.itemPanelSpecification,
                    gridConfiguration: {
                        idProperty: "storyID",
                        columnsToDisplay: ["indexInStoryCollection", "storyName", "storyText", "ignore"],
                        viewButton: true,
                        editButton: true,
                        navigationButtons: true,
                        navigationButtonsAtBottom: true
                    }
                }
            };
            this.filter1 = new Filter({ key: "First filter", name: "First filter", storyBrowser: this });
            this.filter2 = new Filter({ key: "Second filter", name: "Second filter", storyBrowser: this });
            this.grid = new GridWithItemPanel({ panelBuilder: args.panelBuilder, model: this, fieldSpecification: this.gridFieldSpecification });
        }
        StoryBrowser.controller = function (args) {
            return new StoryBrowser(args);
        };
        StoryBrowser.view = function (controller, args) {
            return controller.calculateView(args);
        };
        StoryBrowser.prototype.calculateView = function (args) {
            var panelBuilder = args.panelBuilder;
            // Handling of caching of questions and stories
            var storyCollectionIdentifier = valuePathResolver.newValuePathForFieldSpecification(args.model, args.fieldSpecification)();
            if (storyCollectionIdentifier !== this.storyCollectionIdentifier) {
                // TODO: Maybe need to handle tracking if list changed so can keep sorted list?
                this.storyCollectionIdentifier = storyCollectionIdentifier;
                this.currentStoryCollectionChanged(this.storyCollectionIdentifier);
                // What to do about resetting the filters?
                this.filter1.resetChoices();
                this.filter2.resetChoices();
                // Need to update grid for change
                this.gridFieldSpecification.displayConfiguration.itemPanelSpecification = this.itemPanelSpecification;
                this.filteredStories = this.allStories;
                this.grid.updateDisplayConfigurationAndData(this.gridFieldSpecification.displayConfiguration);
            }
            var promptText = panelBuilder.addAllowedHTMLToPrompt(args.fieldSpecification.displayPrompt) + " (" + this.allStories.length + ")";
            var prompt = m("span", { "class": "questionPrompt" }, promptText);
            var parts;
            if (!this.storyCollectionIdentifier) {
                parts = [m("div", "Please select a story collection to view")];
            }
            else {
                var filter = m("table.filterTable", m("tr", [
                    m("td", this.filter1.calculateView(args)),
                    m("td", this.filter2.calculateView(args))
                ]));
                var filterInfoString = "Stories (" + this.filteredStories.length + ")";
                var filter1HasSelectedQuestion = this.filter1.hasQuestion();
                var filter2HasSelectedQuestion = this.filter2.hasQuestion();
                if (filter1HasSelectedQuestion || filter2HasSelectedQuestion)
                    filterInfoString += " filtered by ";
                if (filter1HasSelectedQuestion)
                    filterInfoString += this.filter1.displayInformation();
                if (filter1HasSelectedQuestion && filter2HasSelectedQuestion)
                    filterInfoString += " and ";
                if (filter2HasSelectedQuestion)
                    filterInfoString += this.filter2.displayInformation();
                // TODO: Translation
                var filteredCountText = m("div.narrafirma-story-browser-filtered-stories-count", filterInfoString);
                parts = [prompt, filter, filteredCountText, this.grid.calculateView(args)];
            }
            return m("div", { "class": "questionExternal narrafirma-question-type-questionAnswer" }, parts);
        };
        // Not using m.prop for stories property as it makes debugging harder?
        StoryBrowser.prototype.stories = function () {
            return this.filteredStories;
        };
        StoryBrowser.prototype.currentStoryCollectionChanged = function (storyCollectionIdentifier) {
            this.questions = [];
            this.storyCollectionIdentifier = storyCollectionIdentifier;
            this.questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionIdentifier);
            var storyNameAndTextQuestions = questionnaireGeneration.getStoryNameAndTextQuestions();
            var elicitingQuestion = this.project.elicitingQuestionForStoryCollection(this.storyCollectionIdentifier);
            var numStoriesToldQuestion = {
                id: "numStoriesTold",
                displayName: "Number of stories told",
                displayReadOnly: true,
                displayPrompt: "Number of stories told by this participant",
                displayType: "text",
                displayConfiguration: "10"
            };
            var storyLengthQuestion = {
                id: "storyLength",
                displayName: "Story length",
                displayReadOnly: true,
                displayPrompt: "Story length (in characters)",
                displayType: "text",
                displayConfiguration: "10"
            };
            var collectionDateQuestion = {
                id: "collectionDate",
                displayName: "Collection year",
                displayPrompt: "Collection year (format: YYYY-MM-DD)",
                displayType: "text",
                displayConfiguration: "20"
            };
            var languageQuestion = {
                id: "language",
                displayName: "Language",
                displayPrompt: "Language",
                displayType: "text",
                displayConfiguration: "20"
            };
            var storyQuestions = this.project.storyQuestionsForStoryCollection(this.storyCollectionIdentifier);
            var participantQuestions = this.project.participantQuestionsForStoryCollection(this.storyCollectionIdentifier);
            this.questions = this.questions.concat(storyNameAndTextQuestions, [elicitingQuestion], storyQuestions, participantQuestions, [collectionDateQuestion], [languageQuestion], [numStoriesToldQuestion], [storyLengthQuestion]);
            this.choices = surveyCollection.optionsForAllQuestions(this.questions);
            this.allStories = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier, true);
            this.itemPanelSpecification = this.makeItemPanelSpecificationForQuestions(this.questions);
            this.itemPanelSpecification.panelFields.push({
                id: "indexInStoryCollection",
                valueType: "string",
                displayReadOnly: true,
                displayType: "text",
                displayName: "Index",
                displayConfiguration: "10",
                displayPrompt: "Index of story in collection",
                displayClass: "narrafirma-index-in-story-collection"
            });
            this.itemPanelSpecification.panelFields.push({
                id: "ignore",
                valueType: "string",
                displayType: "text",
                displayName: "Ignore",
                displayPrompt: "Reason to ignore story (enter any text here to leave this story out of all graphs and reports)",
                displayClass: "narrafirma-ignore-story"
            });
            this.itemPanelSpecification.panelFields.push({
                id: "showJSON",
                valueType: "none",
                displayType: "button",
                displayIconClass: "showButtonImage",
                displayPrompt: "Show story as raw JSON data",
                displayConfiguration: "showStoryAsJSON"
            });
            /*
            // TODO: What to do about current selection in filter widgets?
            
            // Update item panel in grid
            this.storyList.changeItemPanelSpecification(itemPanelSpecification);
            
            this.loadLatestStories(allStories);
            
            // TODO: Should close up open grid view
            */
        };
        StoryBrowser.prototype.buildStoryDisplayPanel = function (panelBuilder, storyModel) {
            var storyDisplay;
            if (panelBuilder.readOnly) {
                // override questionnaire pointed to by storyModel because it may have been updated using the "update story form" button
                storyDisplay = storyCardDisplay.generateStoryCardContent(storyModel, undefined, {
                    location: "storyBrowser",
                    questionnaire: this.questionnaire,
                    storyTextAtTop: true,
                    includeWriteInAnswers: true
                });
            }
            else {
                storyDisplay = panelBuilder.buildFields(this.questions, storyModel);
            }
            return storyDisplay;
        };
        StoryBrowser.prototype.makeItemPanelSpecificationForQuestions = function (questions) {
            // TODO: add more participant and survey info, like timestamps and participant ID
            var itemPanelSpecification = {
                id: "storyBrowserQuestions",
                modelClass: "Story",
                panelFields: questions,
                buildPanel: this.buildStoryDisplayPanel.bind(this)
            };
            return itemPanelSpecification;
        };
        StoryBrowser.prototype.getFilteredStoryList = function () {
            var question1Choice = this.filter1.selectedQuestion;
            var answers1Choices = this.filter1.selectedAnswers;
            var question2Choice = this.filter2.selectedQuestion;
            var answers2Choices = this.filter2.selectedAnswers;
            var filterFunction = function (item) {
                var match1 = isMatch(item, question1Choice, answers1Choices);
                var match2 = isMatch(item, question2Choice, answers2Choices);
                return match1 && match2;
            };
            var filteredResults = this.allStories.filter(filterFunction);
            return filteredResults;
        };
        StoryBrowser.prototype.setStoryListForCurrentFilters = function () {
            var filteredResults = this.getFilteredStoryList();
            this.filteredStories = filteredResults;
            this.grid.updateData();
        };
        return StoryBrowser;
    }());
    exports.StoryBrowser = StoryBrowser;
});

define('js/applicationWidgets/add_storyBrowser',["require", "exports", "mithril", "./StoryBrowser"], function (require, exports, m, storyBrowser) {
    "use strict";
    "use strict";
    function add_storyBrowser(panelBuilder, model, fieldSpecification) {
        return m.component(storyBrowser.StoryBrowser, { key: fieldSpecification.id, panelBuilder: panelBuilder, model: model, fieldSpecification: fieldSpecification });
    }
    return add_storyBrowser;
});

define('js/applicationWidgets/StoryAnnotationBrowser',["require", "exports", "../storyCardDisplay", "../questionnaireGeneration", "../surveyCollection", "../panelBuilder/valuePathResolver", "../Globals", "mithril", "../panelBuilder/GridWithItemPanel"], function (require, exports, storyCardDisplay, questionnaireGeneration, surveyCollection, valuePathResolver, Globals, m, GridWithItemPanel) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    // TODO: Translate
    var unansweredIndicator = "No answer";
    var StoryAnnotationBrowser = (function () {
        function StoryAnnotationBrowser(args) {
            this.project = null;
            this.storyCollectionIdentifier = null;
            this.annotationQuestions = [];
            this.gridColumnQuestions = [];
            this.storyQuestions = [];
            this.participantQuestions = [];
            this.allStories = [];
            this.itemPanelSpecification = { id: "temporary", modelClass: "Story", panelFields: [] };
            this.gridFieldSpecification = null;
            this.grid = null;
            this.project = Globals.project();
            this.gridFieldSpecification = {
                id: "stories",
                displayConfiguration: {
                    itemPanelSpecification: this.itemPanelSpecification,
                    gridConfiguration: {
                        idProperty: "storyID",
                        viewButton: true,
                        editButton: true,
                        navigationButtons: true,
                        navigationButtonsAtBottom: true,
                        randomButton: true,
                        maxColumnCount: 13 // three for index, name, and text, 10 more for annotation questions
                    }
                }
            };
            this.grid = new GridWithItemPanel({ panelBuilder: args.panelBuilder, model: this, fieldSpecification: this.gridFieldSpecification });
        }
        StoryAnnotationBrowser.controller = function (args) {
            return new StoryAnnotationBrowser(args);
        };
        StoryAnnotationBrowser.view = function (controller, args) {
            return controller.calculateView(args);
        };
        StoryAnnotationBrowser.prototype.calculateView = function (args) {
            var panelBuilder = args.panelBuilder;
            var storyCollectionIdentifier = valuePathResolver.newValuePathForFieldSpecification(args.model, args.fieldSpecification)();
            if (storyCollectionIdentifier !== this.storyCollectionIdentifier) {
                this.storyCollectionIdentifier = storyCollectionIdentifier;
                this.currentStoryCollectionChanged(this.storyCollectionIdentifier);
                this.gridFieldSpecification.displayConfiguration.itemPanelSpecification = this.itemPanelSpecification;
                this.grid.updateDisplayConfigurationAndData(this.gridFieldSpecification.displayConfiguration);
            }
            var promptText = panelBuilder.addAllowedHTMLToPrompt(args.fieldSpecification.displayPrompt)
                + " (" + this.allStories.length + "). Click on a story to annotate it.";
            var prompt = m("span", { "class": "questionPrompt" }, promptText);
            var parts;
            if (!this.storyCollectionIdentifier) {
                parts = [m("div", "Please select a story collection to annotate.")];
            }
            else {
                parts = [prompt, this.grid.calculateView(args)];
            }
            return m("div", { "class": "questionExternal narrafirma-question-type-questionAnswer" }, parts);
        };
        StoryAnnotationBrowser.prototype.stories = function () {
            return this.allStories;
        };
        StoryAnnotationBrowser.prototype.currentStoryCollectionChanged = function (storyCollectionIdentifier) {
            this.storyCollectionIdentifier = storyCollectionIdentifier;
            this.annotationQuestions = [];
            this.storyQuestions = [];
            this.participantQuestions = [];
            this.annotationQuestions = questionnaireGeneration.convertEditorQuestions(this.project.collectAllAnnotationQuestions(), "A_");
            this.storyQuestions = this.project.storyQuestionsForStoryCollection(this.storyCollectionIdentifier);
            this.participantQuestions = this.project.participantQuestionsForStoryCollection(this.storyCollectionIdentifier);
            this.allStories = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier, true);
            this.updateAnnotationQuestionsForPossibleChange();
            this.itemPanelSpecification = this.makeItemPanelSpecificationForQuestions(this.gridColumnQuestions);
        };
        StoryAnnotationBrowser.prototype.updateAnnotationQuestionsForPossibleChange = function () {
            var headerCount = 0;
            this.annotationQuestions = [];
            this.gridColumnQuestions = [];
            var retrievedQuestions = questionnaireGeneration.convertEditorQuestions(this.project.collectAllAnnotationQuestions(), "A_");
            var orderedShortNamesText = this.project.getFieldValue("project_annotationQuestionsOrder");
            var orderedShortNames = [];
            if (orderedShortNamesText) {
                orderedShortNames = orderedShortNamesText.split("\n").map(function (item) { return item.trim(); });
            }
            if (orderedShortNames.length > 0) {
                var orderedQuestions_1 = [];
                var orderedQuestionsToShowInGrid_1 = [];
                orderedShortNames.map(function (questionShortName) {
                    var foundQuestion = false;
                    var questionShortNameToUse = questionShortName;
                    var showThisQuestionInTheGrid = false;
                    if (questionShortName.indexOf("*") == 0) {
                        showThisQuestionInTheGrid = true;
                        questionShortNameToUse = questionShortName.split("*")[1];
                    }
                    for (var i = 0; i <= retrievedQuestions.length; i++) {
                        if (retrievedQuestions[i] && retrievedQuestions[i].displayName == questionShortNameToUse) {
                            orderedQuestions_1.push(retrievedQuestions[i]);
                            if (showThisQuestionInTheGrid)
                                orderedQuestionsToShowInGrid_1.push(retrievedQuestions[i]);
                            foundQuestion = true;
                            break;
                        }
                    }
                    if (!foundQuestion) {
                        var headerQuestion = { id: "header" + ++headerCount, valueType: "none", displayPrompt: questionShortNameToUse, displayType: "header" };
                        orderedQuestions_1.push(headerQuestion);
                    }
                });
                this.annotationQuestions = this.annotationQuestions.concat(orderedQuestions_1);
                if (orderedQuestionsToShowInGrid_1.length > 0) {
                    this.gridColumnQuestions = this.gridColumnQuestions.concat(orderedQuestionsToShowInGrid_1);
                }
                else {
                    this.gridColumnQuestions = this.gridColumnQuestions.concat(orderedQuestions_1);
                }
            }
            else {
                this.annotationQuestions = this.annotationQuestions.concat(retrievedQuestions);
                this.gridColumnQuestions = this.gridColumnQuestions.concat(retrievedQuestions);
            }
        };
        StoryAnnotationBrowser.prototype.buildStoryDisplayPanel = function (panelBuilder, storyModel) {
            var storyDisplayPanel;
            var readOnlyDisplayPanel;
            var questionsToEdit = [];
            var questionsToDisplay = [];
            this.updateAnnotationQuestionsForPossibleChange();
            if (panelBuilder.readOnly) {
                questionsToEdit = [];
                questionsToDisplay = questionsToDisplay.concat(this.annotationQuestions, this.storyQuestions, this.participantQuestions);
            }
            else {
                questionsToEdit = this.annotationQuestions;
                questionsToDisplay = questionsToDisplay.concat(this.storyQuestions, this.participantQuestions);
            }
            var questionsInDictionaryWithIDs = {};
            questionsToDisplay.map(function (question, index) { questionsInDictionaryWithIDs[question.id] = question; });
            readOnlyDisplayPanel = storyCardDisplay.generateStoryCardContent(storyModel, questionsInDictionaryWithIDs, {
                location: "storyAnnotationBrowser",
                questionnaire: this.questionnaire,
                storyTextAtTop: true,
                includeWriteInAnswers: true
            });
            if (panelBuilder.readOnly) {
                storyDisplayPanel = readOnlyDisplayPanel;
            }
            else {
                storyDisplayPanel = panelBuilder.buildFields(questionsToEdit, storyModel);
                storyDisplayPanel.push(readOnlyDisplayPanel);
            }
            return storyDisplayPanel;
        };
        StoryAnnotationBrowser.prototype.makeItemPanelSpecificationForQuestions = function (questions) {
            // I want these fields to appear as columns, but I don't want them to appear as editable fields 
            var panelFieldsToCreateForGridColumns = [];
            panelFieldsToCreateForGridColumns.push({
                id: "indexInStoryCollection",
                valueType: "string",
                displayType: "text",
                displayName: "Index",
                displayConfiguration: "10",
                displayPrompt: "Index of story in collection",
                displayClass: "narrafirma-index-in-story-collection"
            });
            panelFieldsToCreateForGridColumns.push({
                id: "storyName",
                valueType: "string",
                displayType: "text",
                displayName: "Story name",
                displayConfiguration: "20",
                displayPrompt: "Name of story"
            });
            panelFieldsToCreateForGridColumns.push({
                id: "storyText",
                valueType: "string",
                displayType: "text",
                displayName: "Story text",
                displayPrompt: "Text of story"
            });
            panelFieldsToCreateForGridColumns = panelFieldsToCreateForGridColumns.concat(questions);
            var itemPanelSpecification = {
                id: "storyAnnotationBrowserQuestions",
                modelClass: "Story",
                panelFields: panelFieldsToCreateForGridColumns,
                buildPanel: this.buildStoryDisplayPanel.bind(this)
            };
            return itemPanelSpecification;
        };
        return StoryAnnotationBrowser;
    }());
    exports.StoryAnnotationBrowser = StoryAnnotationBrowser;
});

define('js/applicationWidgets/add_storyAnnotationBrowser',["require", "exports", "mithril", "./StoryAnnotationBrowser"], function (require, exports, m, storyAnnotationBrowser) {
    "use strict";
    "use strict";
    function add_storyAnnotationBrowser(panelBuilder, model, fieldSpecification) {
        return m.component(storyAnnotationBrowser.StoryAnnotationBrowser, { key: fieldSpecification.id, panelBuilder: panelBuilder, model: model, fieldSpecification: fieldSpecification });
    }
    return add_storyAnnotationBrowser;
});

define('js/templates/templates',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // TODO: Fix mixed tabs and spaces and remove part of next line which disables indent check
    /* tslint:disable:max-line-length indent */
    // TODO: Note everything has a shortName; id currently being used in those cases; do we really need both id and shortName?
    var templates = [
        {
            "id": "elicitationQuestions",
            "name": "Elicitation questions",
            "questions": [
                {
                    "id": "topic_timeWhenYouFelt",
                    "shortName": "When you felt",
                    "text": "Was there ever a time when you felt _____? What happened then?",
                    "category": "Topic",
                    "type": "label"
                },
                {
                    "id": "topic_everThought",
                    "shortName": "Ever thought",
                    "text": "Have you ever thought ____? What happened that made you think that?",
                    "category": "Topic",
                    "type": "label"
                },
                {
                    "id": "topic_causedAChange",
                    "shortName": "Caused a change",
                    "text": "Was there ever a change in your ___ about ___? What happened that caused the change?",
                    "category": "Topic",
                    "type": "label"
                },
                {
                    "id": "topic_doingSomethingBecauseYouFelt",
                    "shortName": "Doing something because you felt",
                    "text": "Can you remember ever ____ because you felt ___? What happened that made you feel that way?",
                    "category": "Topic",
                    "type": "label"
                },
                {
                    "id": "topic_aTimeWhenYouSomethingBecauseOf",
                    "shortName": "A time when you something because of",
                    "text": "Think of a time when you ____ because of ____.",
                    "category": "Topic",
                    "type": "label"
                },
                {
                    "id": "time_whatHappenedFirstTime",
                    "shortName": "What happened first time",
                    "text": "What happened the (first, last, most recent) time you ____?",
                    "category": "Point in time (specific)",
                    "type": "label"
                },
                {
                    "id": "time_aboutYourSomething",
                    "shortName": "About your something",
                    "text": "Tell me about your ___. What happened during it?",
                    "category": "Point in time (specific)",
                    "type": "label"
                },
                {
                    "id": "time_whatJustHappened",
                    "shortName": "What just happened",
                    "text": "What just happened? Can you tell us about it?",
                    "category": "Point in time (specific)",
                    "type": "label"
                },
                {
                    "id": "time_mostMemorable",
                    "shortName": "Most memorable",
                    "text": "What was the most memorable ___ during ____?",
                    "category": "Point in time (memorable)",
                    "type": "label"
                },
                {
                    "id": "time_standsOutInMemory",
                    "shortName": "Stands out in memory",
                    "text": "Was there a time during ___ that stands out in your memory?",
                    "category": "Point in time (memorable)",
                    "type": "label"
                },
                {
                    "id": "time_momentWasMostSomething",
                    "shortName": "Moment was most something",
                    "text": "What moment during ___ was most ____ to you? What happened in that moment?",
                    "category": "Point in time (memorable)",
                    "type": "label"
                },
                {
                    "id": "time_happenedThatMadeYouFeel",
                    "shortName": "Happened that made you feel",
                    "text": "During ____, did anything happen that made you feel ___? What was it that happened?",
                    "category": "Point in time (emotion)",
                    "type": "label"
                },
                {
                    "id": "time_mostSomethingHour",
                    "shortName": "Most something hour",
                    "text": "What has been your (most, least) ___ hour as a ____?",
                    "category": "Point in time (emotion)",
                    "type": "label"
                },
                {
                    "id": "time_whenYouFelt",
                    "shortName": "When you felt",
                    "text": "Was there ever a time during ____ when you felt ___? What happened that made you feel that way?",
                    "category": "Point in time (emotion)",
                    "type": "label"
                },
                {
                    "id": "time_feltTopicWas",
                    "shortName": "Felt topic was",
                    "text": "Was there ever a moment when you felt that (a project topic) was ___?",
                    "category": "Point in time (topic)",
                    "type": "label"
                },
                {
                    "id": "time_foundYourselfMost",
                    "shortName": "Found yourself most",
                    "text": "At what point during ____ did you find yourself the most (project topic)?",
                    "category": "Point in time (topic)",
                    "type": "label"
                },
                {
                    "id": "time_emotionWasInState",
                    "shortName": "Emotion was in state",
                    "text": "Recall for us a moment when (an emotion) was (in a state) during ____.",
                    "category": "Point in time (topic)",
                    "type": "label"
                },
                {
                    "id": "event_standsOut",
                    "shortName": "Stands out",
                    "text": "What event most stands out in your mind during ____?",
                    "category": "Event (memorable)",
                    "type": "label"
                },
                {
                    "id": "event_willRemember",
                    "shortName": "Will remember",
                    "text": "Did anything happen (today, this week, etc) that you will remember for a long time?",
                    "category": "Event (memorable)",
                    "type": "label"
                },
                {
                    "id": "event_importantToYou",
                    "shortName": "Important to you",
                    "text": "Can you describe an incident in the past (day, week, etc) that is important to you?",
                    "category": "Event (memorable)",
                    "type": "label"
                },
                {
                    "id": "event_causedToFeel",
                    "shortName": "Caused to feel",
                    "text": "Did any particular event or incident cause you to feel ___ during ____?",
                    "category": "Event (emotion)",
                    "type": "label"
                },
                {
                    "id": "event_feltSomething",
                    "shortName": "Felt something",
                    "text": "Tell me about a time when you felt ____. What happened?",
                    "category": "Event (emotion)",
                    "type": "label"
                },
                {
                    "id": "event_feltSomethingWasSomething",
                    "shortName": "Felt something was something",
                    "text": "Can you recall a situation when you felt that ____ was _____?",
                    "category": "Event (emotion)",
                    "type": "label"
                },
                {
                    "id": "event_proverb",
                    "shortName": "Proverb",
                    "text": "When you consider the (motto, saying, proverb) ____, was there a moment during ____ when you felt that this (motto, saying, proverb) was especially ____?",
                    "category": "Event (topic)",
                    "type": "label"
                },
                {
                    "id": "event_situationInWhich",
                    "shortName": "Situation in which",
                    "text": "Could you tell us about a situation in which ___ was ____?",
                    "category": "Event (topic)",
                    "type": "label"
                },
                {
                    "id": "event_madeYouThink",
                    "shortName": "Made you think",
                    "text": "Did you ever experience anything that made you think ____? What happened?",
                    "category": "Event (topic)",
                    "type": "label"
                },
                {
                    "id": "extreme_highOrLowPoint",
                    "shortName": "High or low point",
                    "text": "Can you recall the (highlight, lowest point) of ___?",
                    "category": "Extreme (in general)",
                    "type": "label"
                },
                {
                    "id": "extreme_bestOrWorstThing",
                    "shortName": "Best or worst thing",
                    "text": "What was the (best, worst) thing that ever happened during ____?",
                    "category": "Extreme (in general)",
                    "type": "label"
                },
                {
                    "id": "extreme_bestOrWorstMoment",
                    "shortName": "Best or worst moment",
                    "text": "What was the (best, worst) moment of ____?",
                    "category": "Extreme (in general)",
                    "type": "label"
                },
                {
                    "id": "extreme_feltTheMost",
                    "shortName": "Felt the most",
                    "text": "During ____, when did you feel the most ___? What happened that made you feel that way?",
                    "category": "Extreme (emotion)",
                    "type": "label"
                },
                {
                    "id": "extreme_saidToYourself",
                    "shortName": "Said to yourself",
                    "text": "During ____, did you ever say to yourself, \"This the ____ moment in this ____?\" What happened during that moment?",
                    "category": "Extreme (emotion)",
                    "type": "label"
                },
                {
                    "id": "extreme_highOrLowLevel",
                    "shortName": "High or low level",
                    "text": "What was the (highest, lowest) level of ____ you felt during ____? What happened when you felt that?",
                    "category": "Extreme (emotion)",
                    "type": "label"
                },
                {
                    "id": "extreme_thinkBackOver",
                    "shortName": "Think back over",
                    "text": "Think back over ___. When was ___ the most ____? What happened then?",
                    "category": "Extreme (topic)",
                    "type": "label"
                },
                {
                    "id": "extreme_neverSeenSuch",
                    "shortName": "Never seen such",
                    "text": "Did you ever think, \"I've never seen such ___\"? What happened that made you think that?",
                    "category": "Extreme (topic)",
                    "type": "label"
                },
                {
                    "id": "extreme_momentYouCanRecall",
                    "shortName": "Moment you can recall",
                    "text": "As you look back on ____, what is the ____ moment you can recall with respect to ____? What happened during that moment?",
                    "category": "Extreme (topic)",
                    "type": "label"
                },
                {
                    "id": "surprise_timeWhenSurprised",
                    "shortName": "Time when surprised",
                    "text": "Can you remember a time when you were surprised at how ____?",
                    "category": "Surprise",
                    "type": "label"
                },
                {
                    "id": "surprise_somethingSurprisedYou",
                    "shortName": "Something surprised you",
                    "text": "As you remember ____, can you think of a time when ___ surprised you?",
                    "category": "Surprise",
                    "type": "label"
                },
                {
                    "id": "surprise_aSurprisingSomething",
                    "shortName": "A surprising something",
                    "text": "Can you tell us about a surprising ____ during ____?",
                    "category": "Surprise",
                    "type": "label"
                },
                {
                    "id": "change_momentOfChange",
                    "shortName": "Moment of change",
                    "text": "Was there ever a moment during ___ when ___ changed? What happened?",
                    "category": "Change",
                    "type": "label"
                },
                {
                    "id": "change_feelAChange",
                    "shortName": "Feel a change",
                    "text": "Did you ever feel a change in ____? What caused you to feel that a change was taking place?",
                    "category": "Change",
                    "type": "label"
                },
                {
                    "id": "change_turningPoint",
                    "shortName": "Turning point",
                    "text": "Looking back over ____, can you pick out a turning point in ____? What happened during that turning point?",
                    "category": "Change",
                    "type": "label"
                },
                {
                    "id": "person_whenMetPerson",
                    "shortName": "When met person",
                    "text": "What was it like the ____ time you met ___? What happened?",
                    "category": "Person",
                    "type": "label"
                },
                {
                    "id": "person_timeYouDidSomethingWithPerson",
                    "shortName": "Time you did something with person",
                    "text": "Can you tell us about the ___ when you ___ with ___?",
                    "category": "Person",
                    "type": "label"
                },
                {
                    "id": "person_bestExplains",
                    "shortName": "Best explains",
                    "text": "What experience with ____ best explains ____?",
                    "category": "Person",
                    "type": "label"
                },
                {
                    "id": "group_joinedOrLeft",
                    "shortName": "Joined or left",
                    "text": "Do you remember the ___ when you (joined, left, did something with) ___? What happened during that ___?",
                    "category": "Group",
                    "type": "label"
                },
                {
                    "id": "group_decisionTo",
                    "shortName": "Decision to",
                    "text": "Can you remember making the decision to ___ with ____? What were you thinking about at the time?",
                    "category": "Group",
                    "type": "label"
                },
                {
                    "id": "group_standsOut",
                    "shortName": "Stands out",
                    "text": "Recall a ___ with ___ that stands out in your memory.",
                    "category": "Group",
                    "type": "label"
                },
                {
                    "id": "place_didSomethingAt",
                    "shortName": "Did something at",
                    "text": "Do you remember the ___ time you ___ at ___? What happened?",
                    "category": "Place",
                    "type": "label"
                },
                {
                    "id": "place_rememberHappening",
                    "shortName": "Remember happening",
                    "text": "When you (arrived at, left, did something at) ____, what do you remember happening?",
                    "category": "Place",
                    "type": "label"
                },
                {
                    "id": "place_madeYouThink",
                    "shortName": "Made you think",
                    "text": "Did anything ever happen at ___ that made you think: that's what this place is like? What was it?",
                    "category": "Place",
                    "type": "label"
                },
                {
                    "id": "object_momentSpringsToMind",
                    "shortName": "Moment springs to mind",
                    "text": "When you look at this ___, what moment springs to mind?",
                    "category": "Object",
                    "type": "label"
                },
                {
                    "id": "object_whatWereYouThinking",
                    "shortName": "What were you thinking",
                    "text": "When you first saw ____, what were you thinking? What happened during that encounter?",
                    "category": "Object",
                    "type": "label"
                },
                {
                    "id": "object_especiallySomethingMoments",
                    "shortName": "Especially something moments",
                    "text": "Can you recall any especially _____ moments (using, holding, etc) this ____?",
                    "category": "Object",
                    "type": "label"
                },
                {
                    "id": "scenario_aboutTo",
                    "shortName": "About to",
                    "text": "If someone told you that they were about to ___, what story about your experiences with ___ would you tell them?",
                    "category": "Fictional scenario",
                    "type": "label"
                },
                {
                    "id": "scenario_someoneTellsYou",
                    "shortName": "Someone tells you",
                    "text": "Say someone tells you that ___. Say you want to ___. What would you tell them about your experiences with ___ to ___ them?",
                    "category": "Fictional scenario",
                    "type": "label"
                },
                {
                    "id": "scenario_yearsInThe",
                    "shortName": "Years in the",
                    "text": "If you found yourself suddenly ____ years in the ___, what would you tell people about your experiences with ____ that would help them understand?",
                    "category": "Fictional scenario",
                    "type": "label"
                }
            ]
        },
        {
            "id": "storyQuestions",
            "name": "Story questions",
            "questions": [
                {
                    "id": "howFeel",
                    "text": "How do you feel about this story?",
                    "shortName": "Feel about",
                    "category": "Value",
                    "type": "select",
                    "options": "happy;sad;angry;relieved;enthused;indifferent;not sure"
                },
                {
                    "id": "emotionalIntensity",
                    "text": "How would you rate the emotional intensity of this story?",
                    "shortName": "Emotional intensity",
                    "category": "Value",
                    "type": "slider",
                    "options": "strongly negative;strongly positive"
                },
                {
                    "id": "howMemorable",
                    "text": "How long do you think you will remember this story?",
                    "shortName": "How memorable",
                    "category": "Value",
                    "type": "slider",
                    "options": "I've already forgotten it;I'll remember it all my life"
                },
                {
                    "id": "howImportantToMe",
                    "text": "How important is this story to you? How much does it matter?",
                    "shortName": "How important to me",
                    "category": "Value",
                    "type": "slider",
                    "options": "trivial;huge"
                },
                {
                    "id": "howImportantToOthers",
                    "text": "How important do you think this story is to (other people, another group) in (the community or organization)? How much does it matter to them?",
                    "shortName": "How important to others",
                    "category": "Value",
                    "type": "slider",
                    "options": "trivial;huge"
                },
                {
                    "id": "desiredImportanceToOthers",
                    "text": "How important would you like this story to be to (other people, another group) in (the community or organization)? How much do you want it to matter to them?",
                    "shortName": "Desired importance to others",
                    "category": "Value",
                    "type": "slider",
                    "options": "trivial;huge"
                },
                {
                    "id": "howLongAgo",
                    "text": "How long ago did the events in this story take place?",
                    "shortName": "How long ago",
                    "category": "Setting",
                    "type": "slider",
                    "options": "ten years;it just happened"
                },
                {
                    "id": "duringHistory",
                    "text": "At what point during the history of your interaction with (the topic) did the events in this story happen?",
                    "shortName": "When during history",
                    "category": "Setting",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "whereTookPlace",
                    "text": "Where did the events of this story take place?",
                    "shortName": "Where took place",
                    "category": "Setting",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "timePeriod",
                    "text": "Over what period of time did the events in this story take place?",
                    "shortName": "Time period",
                    "category": "Setting",
                    "type": "slider",
                    "options": "moments;decades"
                },
                {
                    "id": "whatChanged",
                    "text": "What changed in this story?",
                    "shortName": "What changed",
                    "category": "Change",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "whatDidNotChange",
                    "text": "What did not change in this story?",
                    "shortName": "What did not change",
                    "category": "Change",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "whoWasAffectedByChanges",
                    "text": "Who was affected by the changes in this story?",
                    "shortName": "Who was affected by changes",
                    "category": "Change",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "whoWasUnaffectedByChanges",
                    "text": "Who was unaffected by the changes in this story?",
                    "shortName": "Who was unaffected by changes",
                    "category": "Change",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "storyHoldsTogether",
                    "text": "How well would you say this story holds together? If it were a machine, how well would it work?",
                    "shortName": "Story holds together",
                    "category": "Evaluation",
                    "type": "slider",
                    "options": "horribly;perfectly"
                },
                {
                    "id": "storyHasHoles",
                    "text": "Is there anything missing from this story? Does it have any holes in it?",
                    "shortName": "Story has holes",
                    "category": "Evaluation",
                    "type": "slider",
                    "options": "nothing is missing;there are large gaps in the story"
                },
                {
                    "id": "storyRingsTrue",
                    "text": "Does this story ring true? Does it match with other stories you know about?",
                    "shortName": "Story rings true",
                    "category": "Evaluation",
                    "type": "slider",
                    "options": "it connects perfectly with all other experience;something about it doesn't seem right"
                },
                {
                    "id": "elementsConflictHowMuch",
                    "text": "How much conflict do you see in this story?",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsConflictDescribe",
                    "text": "Describe any conflicts you see in this story.",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsCooperationHowMuch",
                    "text": "How much cooperation do you see in this story?",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsCooperationDescribe",
                    "text": "Describe any cooperation you see in this story.",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsDangerHowMuch",
                    "text": "How much danger do you see in this story?",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsDangerDescribe",
                    "text": "Describe any dangers you see in this story.",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsOpportunityHowMuch",
                    "text": "How much opportunity do you see in this story?",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsOpportunityDescribe",
                    "text": "Describe any opportunities you see in this story.",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "whyTold",
                    "text": "Why was this story told?",
                    "shortName": "Why told",
                    "category": "Origin",
                    "type": "select",
                    "options": "to educate;to explain;to inform;to persuade;to reminisce;to complain;to entertain;not sure"
                },
                {
                    "id": "whereCameFrom",
                    "text": "Where did this story come from?",
                    "shortName": "Where came from",
                    "category": "Origin",
                    "type": "select",
                    "options": "it happened to me;it happened to someone I know;it happened to someone I don't know;I heard about it;it's a rumor;it's made up;not sure"
                },
                {
                    "id": "howTrue",
                    "text": "How factually true is this story?",
                    "shortName": "How true",
                    "category": "Origin",
                    "type": "slider",
                    "options": "it happened just as it was told;it's totally made up"
                },
                {
                    "id": "whyStoryChosen",
                    "text": "Why do you think this particular story was chosen to be told just when it was?",
                    "shortName": "Why story chosen",
                    "category": "Origin",
                    "type": "select",
                    "options": "it seemed to fit;it followed another story;it needed to be told;the teller wanted to tell it;it seemed helpful;not sure"
                },
                {
                    "id": "commonOrRare",
                    "text": "Based on what you know of (the community or organization or topic), do you consider the events described in this story to be common or rare?",
                    "shortName": "Common or rare",
                    "category": "Community",
                    "type": "slider",
                    "options": "happens to everyone;happens to one in a million"
                },
                {
                    "id": "scopeInvolved",
                    "text": "What scope of (the community or organization) is involved in this story?",
                    "shortName": "Scope involved",
                    "category": "Community",
                    "type": "slider",
                    "options": "one person;everyone"
                },
                {
                    "id": "rolesInvolved",
                    "text": "Which of these roles were involved in this story?",
                    "shortName": "Roles involved",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "groupsInvolved",
                    "text": "Which groups of people were involved in this story?",
                    "shortName": "Groups involved",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "strengthOfImpactIfHeard",
                    "text": "If this story was more widely heard, how strong would its impact be on (the community or organization)?",
                    "shortName": "Strength of impact if heard",
                    "category": "Community",
                    "type": "slider",
                    "options": "no impact;it would change everything"
                },
                {
                    "id": "impactIfHeard",
                    "text": "If this story was more widely heard, what impact would that have on (the community or organization)?",
                    "shortName": "Impact if heard",
                    "category": "Community",
                    "type": "textarea",
                    "options": ""
                },
                {
                    "id": "groupsNeedToHearStory",
                    "text": "Which of these groups particularly need to hear this story?",
                    "shortName": "Groups need to hear story",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "groupsHaveNotHeardStory",
                    "text": "Which of these groups is not likely to have ever heard this type of story before?",
                    "shortName": "Groups have never heard story",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "groupsWillNotHearStory",
                    "text": "In which of these groups will people refuse to hear this story?",
                    "shortName": "Groups will not hear story",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "groupsWillGetNewEnergy",
                    "text": "To which of these groups will this story give new energy to solve problems?",
                    "shortName": "Groups will get new energy",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "groupsWillLoseEnergy",
                    "text": "For which of these groups will this story drain their energy?",
                    "shortName": "Groups will lose energy",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "storySaysAbout",
                    "text": "What does this story say to you about (rules, cooperation, trust, power, etc)?",
                    "shortName": "Story says about",
                    "category": "Community",
                    "type": "textarea",
                    "options": ""
                },
                {
                    "id": "storySaysToOthersAbout",
                    "text": "What do you think this story says to (other people, another group) about (rules, cooperation, trust, power, etc)?",
                    "shortName": "Story says to others about",
                    "category": null,
                    "type": "textarea",
                    "options": ""
                },
                {
                    "id": "otherViewsOnValue",
                    "text": "Do you think (other people, another group) in (the community or organization) would say that this story turned out well?",
                    "shortName": "Other views on value",
                    "category": "Other views",
                    "type": "slider",
                    "options": "they would say it turned out horribly;they would say it turned out perfectly"
                },
                {
                    "id": "otherViewsOnCommonality",
                    "text": "Do you think (other people, another group) in (the community or organization) would say the events in this story were common?",
                    "shortName": "Other views on commonality",
                    "category": "Other views",
                    "type": "slider",
                    "options": "they would say it was common;they would say it was rare"
                },
                {
                    "id": "otherViewsOnWhyTold",
                    "text": "Why do you think (other people, another group) in (the community or organization) would say this story was told?",
                    "shortName": "Other views on why told",
                    "category": "Other views",
                    "type": "select",
                    "options": "to educate;to explain;to inform;to persuade;to reminisce;to complain;to entertain;not sure"
                },
                {
                    "id": "otherViewsOnMemorability",
                    "text": "How long do you think (other people, another group) in (the community or organization) would remember this story?",
                    "shortName": "Other views on memorability",
                    "category": "Other views",
                    "type": "slider",
                    "options": "they would have forgotten it already;they would remember it all of their lives"
                },
                {
                    "id": "feelingsAboutOtherViewsOnValue",
                    "text": "Would you like (other people, another group) in (the community or organization) to say that this story turned out well?",
                    "shortName": "Feelings about other views on value",
                    "category": "Feelings about other views",
                    "type": "slider",
                    "options": "I would like them to say that it turned out horribly;I would like them to say that it turned out perfectly"
                },
                {
                    "id": "feelingsAboutOtherViewsOnCommonality",
                    "text": "Would you like (other people, another group) in (the community or organization) to say that the events in this story were common?",
                    "shortName": "Feelings about other views on commonality",
                    "category": "Feelings about other views",
                    "type": "slider",
                    "options": "I would like them to say it was common;I would like them to say it was rare"
                },
                {
                    "id": "feelingsAboutOtherViewsOnWhyTold",
                    "text": "What would you like (other people, another group) in (the community or organization) to say about why this story was told?",
                    "shortName": "Feelings about other views on why told",
                    "category": "Feelings about other views",
                    "type": "select",
                    "options": "to educate;to explain;to inform;to persuade;to reminisce;to complain;to entertain;not sure"
                },
                {
                    "id": "feelingsAboutOtherViewsOnMemorability",
                    "text": "How long would you like (other people, another group) in (the community or organization) to remember this story?",
                    "shortName": "Feelings about other views on memorability",
                    "category": "Feelings about other views",
                    "type": "slider",
                    "options": "I would like them have forgotten it already;I would like them to remember it all of their lives"
                },
                {
                    "id": "topicWouldYouSay",
                    "text": "Would you say that the people in this story ____?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "topicFeltAbout",
                    "text": "What do you think the people in this story felt about ____?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "topicMoreOrLess",
                    "text": "Did this story make you feel more or less ___ about ___?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "topicSayToYou",
                    "text": "What does this story say to you about ____?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "topicChangeHowYouSee",
                    "text": "Does this story change how you see ___? If so, how?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "topicChooseAStory",
                    "text": "If you were to choose a story to tell about ____, would you choose this one? Why or why not?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "mainCharacter",
                    "text": "Who (or what) was the main character in this story? Who was it about?",
                    "shortName": "Main character",
                    "category": "Main character",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "endedWell",
                    "text": "From the perspective of this story's main character, would you say the story ended well or badly?",
                    "shortName": "Ended well",
                    "category": "Main character",
                    "type": "slider",
                    "options": "horribly;perfectly"
                },
                {
                    "id": "wantOrNeed",
                    "text": "In this story, what did the main character want or need?",
                    "shortName": "Want or need",
                    "category": "Main character",
                    "type": "select",
                    "options": "resources;help;support;information;respect;trust;not sure"
                },
                {
                    "id": "strengthOfWant",
                    "text": "How much did the story's main character want or need what they wanted or needed?",
                    "shortName": "Strength of want",
                    "category": "Main character",
                    "type": "slider",
                    "options": "not at all;too much"
                },
                {
                    "id": "gotWhatWanted",
                    "text": "Did the story's main character get what they wanted or needed?",
                    "shortName": "Got what wanted",
                    "category": "Main character",
                    "type": "slider",
                    "options": "nothing at all;too much"
                },
                {
                    "id": "whoHelped",
                    "text": "Who or what helped the story's main character get what they wanted or needed?",
                    "shortName": "Helped",
                    "category": "Main character",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "amountOfHelp",
                    "text": "How much help did the main character get?",
                    "shortName": "Amount of help",
                    "category": "Main character",
                    "type": "slider",
                    "options": "none;more than they needed"
                },
                {
                    "id": "whoHindered",
                    "text": "Who or what hindered the story's main character in getting what they wanted or needed?",
                    "shortName": "Hindered",
                    "category": "Main character",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure"
                },
                {
                    "id": "amountOfHindrance",
                    "text": "How much hindrance did the main character face in getting what they needed?",
                    "shortName": "Amount of hindrance",
                    "category": "Main character",
                    "type": "slider",
                    "options": "none;a crushing amount"
                },
                {
                    "id": "thingsThatWouldHaveHelped",
                    "text": "Which of these things, if they had been available to the main character of the story, would have helped them to get what they wanted or needed?",
                    "shortName": "Would have helped",
                    "category": "Main character",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure"
                }
            ]
        },
        {
            "id": "participantQuestions",
            "name": "Participant questions",
            "questions": [
                // opinions
                {
                    "id": "supportForPolicy",
                    "text": "To what extent do you support [the/our] policy [of/on] ___?",
                    "shortName": "Support",
                    "category": "Opinions",
                    "type": "slider",
                    "options": "I fully support it;I am actively working to change it"
                },
                {
                    "id": "feelAboutIssue",
                    "text": "How do you feel about ___?",
                    "shortName": "Feel about issue scale",
                    "category": "Opinions",
                    "type": "slider",
                    "options": "It is harmful;It is helpful"
                },
                {
                    "id": "feelAboutIssueChoices",
                    "text": "Which of these statements best describes how you feel about ___?",
                    "shortName": "Feel about issue",
                    "category": "Opinions",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "ifCouldWriteLaw",
                    "text": "If you could write a law or agreement regulating ___, what would it say?",
                    "shortName": "Law",
                    "category": "Opinions",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "whatCausesProblem",
                    "text": "What do you think causes ___?",
                    "shortName": "Cause",
                    "category": "Opinions",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "whatCouldSolveProblem",
                    "text": "What do you think would solve the problem of ___?",
                    "shortName": "Solution",
                    "category": "Opinions",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "futureCourse",
                    "text": "What do you think ___ will be like in ___ years?",
                    "shortName": "Future course",
                    "category": "Opinions",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "pastOrFuture",
                    "text": "With regard to ___, do you think ___ is more focused on the past or the future?",
                    "shortName": "Past or future",
                    "category": "Opinions",
                    "type": "slider",
                    "options": "Deep in the past;far into the future"
                },
                {
                    "id": "listening",
                    "text": "Do people in ___ listen to each other, in your experience?",
                    "shortName": "Listening",
                    "category": "Opinions",
                    "type": "slider",
                    "options": "No, never;Yes, always"
                },
                {
                    "id": "cooperating",
                    "text": "Do people in ___ cooperate with each other, in your experience?",
                    "shortName": "Cooperating",
                    "category": "Opinions",
                    "type": "slider",
                    "options": "No, never;Yes, always"
                },
                {
                    "id": "conflict",
                    "text": "How much conflict have you seen in ___, in general?",
                    "shortName": "Cooperating",
                    "category": "Opinions",
                    "type": "slider",
                    "options": "No conflict at all;Crippling amounts of conflict"
                },
                {
                    "id": "innovation",
                    "text": "In your experience, [is/are] ___ an innovative ___ with regard to ___?",
                    "shortName": "Innovation",
                    "category": "Opinions",
                    "type": "slider",
                    "options": "Not at all;Perfectly innovative"
                },
                {
                    "id": "openness",
                    "text": "In your experience, [is/are] ___ open to new ideas?",
                    "shortName": "Innovation",
                    "category": "Opinions",
                    "type": "slider",
                    "options": "No, never;Yes, perfectly open"
                },
                // situation
                {
                    "id": "satisfaction",
                    "text": "How happy are you with your current ___?",
                    "shortName": "Satisfaction",
                    "category": "Situation",
                    "type": "slider",
                    "options": "I never want it to change;I am actively seeking change"
                },
                {
                    "id": "reasonsToStayOrLeave",
                    "text": "If you want to stay or leave in ___, why is that?",
                    "shortName": "Reasons to stay or leave",
                    "category": "Situation",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "position",
                    "text": "What is your position in ___?",
                    "category": "Situation",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "officialPosition",
                    "text": "What is your official position in ___?",
                    "shortName": "Official position",
                    "category": "Situation",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "unofficialPosition",
                    "text": "Do you hold an unofficial position in ___?",
                    "shortName": "Unofficial position",
                    "category": "Situation",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "aloneOrTogether",
                    "text": "Do you ___ alone or with other people?",
                    "shortName": "Alone or together",
                    "category": "Situation",
                    "type": "slider",
                    "options": "only by myself;only with others"
                },
                {
                    "id": "aloneOrTogetherPreference",
                    "text": "Which do you like better, ___ alone or together?",
                    "shortName": "Alone or together preference",
                    "category": "Preferences",
                    "type": "slider",
                    "options": "only by myself;only with others"
                },
                {
                    "id": "independence",
                    "text": "When it comes to ___, do you decide what will happen next, or does someone else decide that?",
                    "shortName": "Independence",
                    "category": "Situation",
                    "type": "slider",
                    "options": "I decide everything;I decide nothing"
                },
                {
                    "id": "independencePreference",
                    "text": "When it comes to ___, to what extent do you prefer to ___ independently?",
                    "shortName": "Independence preference",
                    "category": "Preferences",
                    "type": "slider",
                    "options": "I want to decide everything;I want to have others decide for me"
                },
                {
                    "id": "manageOthers",
                    "text": "Do you [manage, supervise, take care of] other people? If so, how?",
                    "shortName": "Manage others",
                    "category": "Situation",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "manageNumber",
                    "text": "How many people do you [manage, supervise, take care of]?",
                    "shortName": "Manage number",
                    "category": "Situation",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "structure",
                    "text": "How structured is your [work/life/___]?",
                    "shortName": "Structure",
                    "category": "Situation",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "freedomToChoose",
                    "text": "With regard to ___, do you feel that you have a lot of freedom to make your own choices?",
                    "shortName": "Freedom to choose",
                    "category": "Situation",
                    "type": "slider",
                    "options": "I have complete freedom;I have no freedom"
                },
                // demographics
                {
                    "id": "ageRange",
                    "text": "Which age range do you fall into?",
                    "shortName": "Age",
                    "category": "Demographics",
                    "type": "select",
                    "options": "<25;25-34;35-44;45-64;65-74;75+"
                },
                {
                    "id": "gender",
                    "text": "What is your gender?",
                    "category": "Demographics",
                    "type": "select",
                    "options": "male;female"
                },
                {
                    "id": "rentOrOwn",
                    "text": "Do you rent or own your home?",
                    "shortName": "Rent or own",
                    "category": "Demographics",
                    "type": "select",
                    "options": "rent;own"
                },
                {
                    "id": "incomeLevel",
                    "text": "What is your income level?",
                    "shortName": "Income level",
                    "category": "Demographics",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "educationLevel",
                    "text": "How much formal education have you completed?",
                    "shortName": "Formal education",
                    "category": "Demographics",
                    "type": "select",
                    "options": "no formal schooling;a little;elementary school;high school;college;post-graduate;trade;other;rather not say"
                },
                {
                    "id": "informalEducation",
                    "text": "How much informal education have you had?",
                    "shortName": "Informal education",
                    "category": "Demographics",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "experience",
                    "text": "How much experience have you had with ___?",
                    "shortName": "Experience",
                    "category": "Demographics",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "maritalStatus",
                    "text": "What is your marital status?",
                    "shortName": "Marital status",
                    "category": "Demographics",
                    "type": "select",
                    "options": "single;living together;married;widowed;divorced;other"
                },
                {
                    "id": "children",
                    "text": "How many children do you have?",
                    "shortName": "How many children",
                    "category": "Demographics",
                    "type": "select",
                    "options": "none;1;2;3;4;5;6;7;8;9;10;other"
                },
                {
                    "id": "describeChildren",
                    "text": "How would you describe your children?",
                    "shortName": "Children description",
                    "category": "Demographics",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "profession",
                    "text": "What is your profession?",
                    "shortName": "Profession",
                    "category": "Demographics",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "location",
                    "text": "Where do you live?",
                    "shortName": "Location",
                    "category": "Demographics",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                {
                    "id": "ethnicBackground",
                    "text": "What is your ethnic background?",
                    "shortName": "Background",
                    "category": "Demographics",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure;rather not say"
                },
                // personality
                {
                    "id": "opennessToExperience",
                    "text": "Do you like trying new things?",
                    "shortName": "Openness to experience",
                    "category": "Personality",
                    "type": "slider",
                    "options": "I like things to stay the same;if it's new I'm for it"
                },
                {
                    "id": "selfDisciplined",
                    "text": "Would you call yourself self-disciplined?",
                    "shortName": "Self-disciplined",
                    "category": "Personality",
                    "type": "slider",
                    "options": "I always do exactly what I should;I have no control over myself"
                },
                {
                    "id": "introvertOrExtravert",
                    "text": "Are you more of an extravert or an introvert?",
                    "shortName": "Introvert or extravert",
                    "category": "Personality",
                    "type": "slider",
                    "options": "introverted;extraverted"
                },
                {
                    "id": "agreeableness",
                    "text": "How do you feel about other people?",
                    "shortName": "Agreeableness",
                    "category": "Personality",
                    "type": "slider",
                    "options": "heaven is other people;hell is other people"
                },
                {
                    "id": "neuroticism",
                    "text": "How much do you worry?",
                    "shortName": "Neuroticism",
                    "category": "Personality",
                    "type": "slider",
                    "options": "constantly;me? never"
                },
                {
                    "id": "sensingVsIntuition",
                    "text": "Do you prefer to think of abstract, \"big picture\" ideas, or do you like concrete, practical applications?",
                    "shortName": "Sensing vs intuition",
                    "category": "Personality",
                    "type": "slider",
                    "options": "I like the big picture;give me concrete details"
                },
                {
                    "id": "thinkingVsFeeling",
                    "text": "Does logic or emotion have more impact on your decisions?",
                    "shortName": "Thinking vs feeling",
                    "category": "Personality",
                    "type": "slider",
                    "options": "logic and reason only;my values and feelings are my guide"
                },
                {
                    "id": "judgingVsPerceiving",
                    "text": "How do you feel about rules?",
                    "shortName": "Judging vs perceiving",
                    "category": "Personality",
                    "type": "slider",
                    "options": "rules keep life working;rules are for breaking"
                }
            ]
        },
        {
            "id": "annotationQuestions",
            "name": "Annotation questions",
            "questions": [
                {
                    "id": "typeOfText",
                    "text": "Was this story a recounting of events? If not, what was it?",
                    "shortName": "Type of text",
                    "category": "Narrative analysis",
                    "type": "select",
                    "options": "recounting;situation;scenario;fact;explanation;argument;opinion"
                },
                {
                    "id": "greimas_subject",
                    "text": "The actantial model of narrative analysis (by A.J. Greimas) proposes that every story has six facets, called actants, divided into axial pairs. \n                    On the axis of desire are the subject (who the story is about) and the object (what that person wants).\n                    Who or what did the storyteller represent as the subject in this story? (fill in answers as you go)",
                    "shortName": "Subject",
                    "category": "Narrative analysis",
                    "type": "select",
                    "options": ""
                },
                {
                    "id": "greimas_object",
                    "text": "The actantial model of narrative analysis (by A.J. Greimas) proposes that every story has six facets, called actants, divided into axial pairs. \n                    On the axis of desire are the subject (who the story is about) and the object (what that person wants).\n                    Who or what did the storyteller represent as the object in this story? (fill in answers as you go)",
                    "shortName": "Object",
                    "category": "Narrative analysis",
                    "type": "select",
                    "options": ""
                },
                {
                    "id": "greimas_sender",
                    "text": "The actantial model of narrative analysis (by A.J. Greimas) proposes that every story has six facets, called actants, divided into axial pairs. \n                    On the axis of knowledge are the sender (who initiates the action of the story) and the receiver (who profits from the action of the story).\n                    Who or what did the storyteller represent as the sender in this story? (fill in answers as you go)",
                    "shortName": "Sender",
                    "category": "Narrative analysis",
                    "type": "select",
                    "options": ""
                },
                {
                    "id": "greimas_receiver",
                    "text": "The actantial model of narrative analysis (by A.J. Greimas) proposes that every story has six facets, called actants, divided into axial pairs. \n                    On the axis of knowledge are the sender (who initiates the action of the story) and the receiver (who profits from the action of the story).\n                    Who or what did the storyteller represent as the receiver in this story? (fill in answers as you go)",
                    "shortName": "Receiver",
                    "category": "Narrative analysis",
                    "type": "select",
                    "options": ""
                },
                {
                    "id": "greimas_helper",
                    "text": "The actantial model of narrative analysis (by A.J. Greimas) proposes that every story has six facets, called actants, divided into axial pairs. \n                    On the axis of power are the helper (who helps the subject achieve or obtain the object) and the opponent (who tries to prevent this).\n                    Who or what did the storyteller represent as the helper in this story? (fill in answers as you go)",
                    "shortName": "Helper",
                    "category": "Narrative analysis",
                    "type": "select",
                    "options": ""
                },
                {
                    "id": "greimas_opponent",
                    "text": "The actantial model of narrative analysis (by A.J. Greimas) proposes that every story has six facets, called actants, divided into axial pairs. \n                    On the axis of power are the helper (who helps the subject achieve or obtain the object) and the opponent (who tries to prevent this).\n                    Who or what did the storyteller represent as the opponent in this story? (fill in answers as you go)",
                    "shortName": "Opponent",
                    "category": "Narrative analysis",
                    "type": "select",
                    "options": ""
                },
                {
                    "id": "scope",
                    "text": "How many people were mentioned in this story?",
                    "shortName": "Scope",
                    "category": "Facts",
                    "type": "select",
                    "options": "individual;pair;team;group;department;division;organization;industry;street;neighborhood;community;society"
                },
                {
                    "id": "roles",
                    "text": "What sorts of official roles were mentioned in this story? (fill in answers as you go)",
                    "shortName": "Roles",
                    "category": "Facts",
                    "type": "checkboxes",
                    "options": ""
                },
                {
                    "id": "leaders",
                    "text": "What leaders were mentioned in this story? (fill in answers as you go)",
                    "shortName": "Leaders",
                    "category": "Facts",
                    "type": "checkboxes",
                    "options": ""
                },
                {
                    "id": "groups",
                    "text": "What groups of people were mentioned in this story?  (fill in answers as you go)",
                    "shortName": "Groups",
                    "category": "Facts",
                    "type": "checkboxes",
                    "options": ""
                },
                {
                    "id": "locations",
                    "text": "What locations were mentioned in this story?  (fill in answers as you go)",
                    "shortName": "Locations",
                    "category": "Facts",
                    "type": "checkboxes",
                    "options": ""
                },
                {
                    "id": "rules",
                    "text": "What rules or procedures were mentioned in this story?  (fill in answers as you go)",
                    "shortName": "Rules",
                    "category": "Facts",
                    "type": "checkboxes",
                    "options": ""
                },
                {
                    "id": "forces",
                    "text": "What forces or factors were mentioned in this story?  (fill in answers as you go)",
                    "shortName": "Forces",
                    "category": "Facts",
                    "type": "checkboxes",
                    "options": ""
                },
                {
                    "id": "formality",
                    "text": "How formal or informal was the wording in this story?",
                    "shortName": "Formality",
                    "category": "Affect",
                    "type": "slider",
                    "options": "extremely formal;casual, slang"
                },
                {
                    "id": "emotion",
                    "text": "How strongly worded was this story?",
                    "shortName": "Emotion",
                    "category": "Affect",
                    "type": "slider",
                    "options": "dull, bland;very strongly worded"
                },
                {
                    "id": "evaluation",
                    "text": "To what extent did the storyteller include meta-level proof or evaluation statements in the story?",
                    "shortName": "Evaluation",
                    "category": "Affect",
                    "type": "select",
                    "options": "not at all;a little;some;a lot;an extreme amount"
                },
                {
                    "id": "value",
                    "text": "Did the storyteller seem to think the story turned out well or poorly?",
                    "shortName": "Value",
                    "category": "Affect",
                    "type": "slider",
                    "options": "horribly;perfectly"
                },
                {
                    "id": "hesitation",
                    "text": "To what extent did it seem like the storyteller struggled with how they wanted to tell the story? How often or much did they seem to rephrase or rethink what they said?",
                    "shortName": "Hesitation",
                    "category": "Affect",
                    "type": "select",
                    "options": "not at all;a little;some;a lot;an extreme amount"
                },
                {
                    "id": "importantWords",
                    "text": "Were there any words in the story that seemed especially important to the storyteller?",
                    "shortName": "Important words",
                    "category": "Affect",
                    "type": "text",
                    "options": ""
                },
                {
                    "id": "themes",
                    "text": "What overall themes seemed to be important to the storyteller?  (fill in answers as you go)",
                    "shortName": "Themes",
                    "category": "Emergent characteristics",
                    "type": "checkboxes",
                    "options": ""
                },
                {
                    "id": "behaviors",
                    "text": "What sorts of behaviors seemed to be important to the storyteller? (fill in answers as you go)",
                    "shortName": "Behaviors",
                    "category": "Emergent characteristics",
                    "type": "checkboxes",
                    "options": ""
                },
                {
                    "id": "situations",
                    "text": "What sorts of situations seemed to be important to the storyteller? (fill in answers as you go)",
                    "shortName": "Situations",
                    "category": "Emergent characteristics",
                    "type": "checkboxes",
                    "options": ""
                },
                {
                    "id": "values",
                    "text": "What sorts of values seemed to be important to the storyteller? (fill in answers as you go)",
                    "shortName": "Values",
                    "category": "Emergent characteristics",
                    "type": "checkboxes",
                    "options": ""
                },
                {
                    "id": "conflicts",
                    "text": "What sorts of conflicts seemed to be important to the storyteller? (fill in answers as you go)",
                    "shortName": "Conflicts",
                    "category": "Emergent characteristics",
                    "type": "checkboxes",
                    "options": ""
                }
            ]
        },
        {
            "id": "storyCollectionActivities",
            "name": "Story Collection Activities",
            "questions": [
                {
                    "id": "twoTrueStoriesAndATallTale",
                    "shortName": "Two true stories and a tall tale",
                    "type": "ice-breaker",
                    "plan": "Ask people to break into small groups, and one by one, tell two true stories about themselves and one made-up fiction. Others in the group must guess which of the stories is fiction.",
                    "optionalParts": "Afterwards, have groups tell their favorite stories (true or fictional) to the larger group.",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "quickInterviews",
                    "shortName": "Quick interviews",
                    "type": "ice-breaker",
                    "plan": "Divide into groups of three. Interview each other using one simple question, like \"When have you felt proud?\"",
                    "optionalParts": "Afterwards, have groups summarize the stories they heard to the larger group",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "commonExperiences",
                    "shortName": "Common experiences",
                    "type": "ice-breaker",
                    "plan": "In small groups, find one experience everyone has had in common. If people know each other, the experience has to be surprising.",
                    "optionalParts": "Afterwards, have groups tell about their shared experience.",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "haveYouEver",
                    "shortName": "Have you ever...",
                    "type": "ice-breaker",
                    "plan": "People say whether they've had experiences on a printed list. Each group is challenged to come up with some surprises about the experiences people have had.",
                    "optionalParts": "Afterwards, have groups explain what surprised them about their experiences.",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "thatRemindsMeOf",
                    "shortName": "That reminds me of...",
                    "type": "ice-breaker",
                    "plan": "Each group gets a copy of a newspaper or magazine. Each member must come up with some experience they are reminded of by the paper. The group compares their experiences.",
                    "optionalParts": "Afterwards, have groups explain what surprised them about their experiences.",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "twentyQuestions",
                    "shortName": "Twenty questions",
                    "type": "ice-breaker",
                    "plan": "In small groups, each person should think of an experience they've had. The others try to guess what happened by asking twenty questions.",
                    "optionalParts": "Afterwards, have groups explain what surprised them about their experiences.",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "sharingStoriesNoTask",
                    "shortName": "Sharing stories",
                    "type": "sharing stories (no task)",
                    "plan": "Ask people in small groups to simply and naturally share stories about a topic.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "respondToQuestions",
                    "shortName": "Respond to questions",
                    "type": "sharing stories (simple task)",
                    "plan": "Give people (in small groups) a set of 3-5 questions related to the topic." +
                        "Ask them to one by one choose a question they want to answer and tell a story about it" +
                        "to the group. Ask them to try to cover all of the questions between them.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "bothSides",
                    "shortName": "Both sides",
                    "type": "sharing stories (simple task)",
                    "plan": "Give people (in small groups) a set of 3-4 statements related to the topic." +
                        "The statements should be summaries of \"what happens,\" like \"People in our community " +
                        "take care of each other.\" Ask people to tell stories that describe experiences on both sides of each " +
                        "statement. The challenge for the group is to provide balancing examples for each statement.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "simpleRanking",
                    "shortName": "Simple ranking",
                    "type": "sharing stories (simple task)",
                    "plan": "Ask people in small groups to share stories, either with just a named topic," +
                        "or with a list of 3-5 questions about the topic. As people tell stories, ask them to " +
                        "name each story and write the name on a sticky note. Have people arrange the sticky notes " +
                        "along some axis they have defined. It can be anything that has meaning to the group, such as " +
                        "how much impact the story would have if it were widely known, or how positive or negative " +
                        "the story is, or when it happened, or whether it turned out well. Stories should not be ranked by quality." +
                        "Ask people to fill in empty spaces along their axis, if they can.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "remindings",
                    "shortName": "Remindings",
                    "type": "sharing stories (simple task)",
                    "plan": "Ask people in small groups to share stories, either with just a named topic," +
                        "or with a list of 3-5 questions about the topic. After the first story is told, ask people " +
                        "to respond with another story the first story reminds them of. When people run out of " +
                        "remindings, they can return to the list. The challenge to the group is to create chains " +
                        "of reminding.",
                    "optionalParts": "If people like the idea, you can have groups compete over how long their " +
                        "reminding chains grow.",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "words",
                    "shortName": "Words",
                    "type": "sharing stories (simple task)",
                    "plan": "Give small groups cards with words important to the project written on them." +
                        "Mix together words that bring to mind things like behaviors (helpful, deceitful), situations " +
                        "(conflict, cooperation), values (fairness, equality), and concrete places or objects " +
                        "familiar to people (the town square, the factory floor)." +
                        "Ask people to shuffle the cards, then deal out cards so that each person gets a random " +
                        "selection. Ask people to remember and tell about things that have happened that their " +
                        "cards remind them of. Other group members can also tell stories those stories remind " +
                        "them of.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "twiceToldStories",
                    "shortName": "Twice-told stories",
                    "type": "twice-told stories exercise",
                    "plan": "1. (5 min) Introduction. Ask people to form groups of three to four people. Turn on audio recorders. " +
                        "2. (5 min) Criteria. Each small group should choose a criterion by which they will choose a story they " +
                        "will tell to the larger group afterward." +
                        "3. (25 min) Exchange. Small groups exchange stories. As they do this they name the stories, " +
                        "say the names on the recording, and note them down on their forms. " +
                        "4. (5 min) Question forms. Each person fills out a question form for each story they told. " +
                        "5. (15 min) Retelling. One person from each small group retells their chosen story " +
                        "to the whole session. " +
                        "6. (5 min) Discussion. Wrap-up and general discussion of all stories told and the topic.",
                    "optionalParts": "Ask people to fill out question sheets about the stories they heard as well as those " +
                        "they told.",
                    "duration": "One hour",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "None required",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch to make sure people are paying attention to the exercise (choosing stories to retell), " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "twiceToldStoriesShort",
                    "shortName": "Twice-told stories (short version)",
                    "type": "twice-told stories exercise",
                    "plan": "1. (5 min) Introduction and criteria. Ask people to form groups of three to four people. Turn on audio recorders. " +
                        "Also, each small group should choose a criterion by which they will choose a story they " +
                        "will tell to the larger group afterward." +
                        "2. (20 min) Exchange. Small groups exchange stories. As they do this they name the stories, " +
                        "say the names on the recording, and note them down on their forms. " +
                        "3. (5 min) Question forms. Each person fills out a question form for each story they told. " +
                        "4. (10 min) Retelling. One person from each small group retells their chosen story " +
                        "to the whole session. " +
                        "5. (5 min) Discussion. Wrap-up and general discussion of all stories told and the topic.",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "None required",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch to make sure people are paying attention to the exercise (choosing stories to retell), " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "timeline",
                    "shortName": "Timeline",
                    "type": "timeline exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Turn on audio recorders. " +
                        "2. (5 min) Topic and dates. Ask each group to agree on a topic their timeline will explore. " +
                        "Ask each group to choose starting and ending dates for their timeline " +
                        "and mark these dates with sticky notes. " +
                        "3. (10 min) Start and end. Ask each group to tell at least three stories that describe the end of the timeline. They should " +
                        "write a brief title for each story and build a cluster of these notes at the end of the timeline. " +
                        "Have them do the same for the start of the timeline. " +
                        "They should also write the story titles on their question answering sheets. " +
                        "4. (40 min) Filling in. Have each group work backwards through time, telling stories along the way. " +
                        "Also ask people to mark turning points, or times when things changed in significant ways, on their timeline. " +
                        "5. (10 min) Question forms. Ask everyone to fill out question forms for every story they told. " +
                        "6. (10 min). Visiting. Ask everyone to walk around the room looking over all of the timelines created. " +
                        "7. (10 min). Discussion. Bring everyone together into a discussion of all the timelines.",
                    "optionalParts": "People can create utopian and dystopian timelines, working backward from perfect or " +
                        "horrible ending states, linking to the factual timeline at some point. (See WWS for details.)",
                    "duration": "90 minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Sticky notes; spaces to work on (tables, walls, floor)",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch out for people going into too much detail; people leaving large blank spaces " +
                        "(perhaps in times they don't want to think about); and people listing facts without telling stories."
                },
                {
                    "id": "timelineShort",
                    "shortName": "Timeline (short version)",
                    "type": "timeline exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Turn on audio recorders. " +
                        "2. (5 min) Topics and dates. Ask each group to agree on a topic their timeline will explore. " +
                        "Ask each group to choose starting and ending dates for their timeline " +
                        "and mark these dates with sticky notes. " +
                        "3. (5 min) Start and end. Ask each group to tell at least three stories that describe the end of the timeline. They should " +
                        "write a brief title for each story and build a cluster of these notes at the end of the timeline. " +
                        "Have them do the same for the start of the timeline. " +
                        "They should also write the story titles on their question answering sheets. " +
                        "4. (20 min) Filling in. Have each group work backwards through time, telling stories along the way. " +
                        "Also ask people to mark turning points, or times when things changed in significant ways, on their timeline. " +
                        "5. (5 min) Question forms. Ask everyone to fill out question forms for every story they told. " +
                        "6. (5 min). Visiting. Ask everyone to walk around the room looking over all of the timelines created.",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders " +
                        "don't pick up too much background noise); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for people going into too much detail; people leaving large blank spaces " +
                        "(perhaps in times they don't want to think about); and people listing facts without telling stories."
                },
                {
                    "id": "landscape",
                    "shortName": "Landscape",
                    "type": "landscape exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Turn on audio recorders. " +
                        "2. (5-15 min) Dimensions and corners. Ask each group to mark each axis of the space using dimensions you have chosen. " +
                        "Ask people to label each corner point with descriptions of how the two dimensions come together " +
                        "at that corner." +
                        "3. (40 min) Filling in. Having defined their space, each group will now fill it up with stories. " +
                        "4. (10 min) Features. After groups have populated their spaces, ask them to mark out features of the landscape. " +
                        "5. (10 min) Question forms. Now ask people to pause in their building and answer questions about each story they told. " +
                        "6. (10 min) Visiting. Ask everyone to walk around the room looking over all of the landscapes created and " +
                        "talking about the experiences described there. " +
                        "7. (10 min). Discussion. Bring everyone together into a discussion of all the landscapes.",
                    "optionalParts": "Consider a third dimension; consider multiple perspectives; " +
                        "ask people to create their own dimensions (see WWS for details).",
                    "duration": "90 minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders " +
                        "don't pick up too much background noise); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for confusion about the dimensions (and have some on hand in case the first " +
                        "set doesn't resonate); people leaving some spaces empty; people drawing category boxes " +
                        "in the space; people listing dry facts just to cover up the space."
                },
                {
                    "id": "landscapeShort",
                    "shortName": "Landscape (short version)",
                    "type": "landscape exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Turn on audio recorders. " +
                        "2. (5 min) Dimensions and corners. Ask each group to mark each axis of the space using dimensions you have chosen. " +
                        "Ask people to label each corner point with descriptions of how the two dimensions come together " +
                        "at that corner." +
                        "3. (20 min) Filling in. Having defined their space, each group will now fill it up with stories. " +
                        "4. (5 min) Features. After groups have populated their spaces, ask them to mark out features of the landscape. " +
                        "5. (5 min) Question forms. Now ask people to pause in their building and answer questions about each story they told. " +
                        "6. (5 min) Visiting. Ask everyone to walk around the room looking over all of the landscapes created and " +
                        "talking about the experiences described there.",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders " +
                        "don't pick up too much background noise); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for confusion about the dimensions (and have some on hand in case the first " +
                        "set doesn't resonate); people leaving some spaces empty; people drawing category boxes " +
                        "in the space; people listing dry facts just to cover up the space."
                }
            ]
        },
        {
            "id": "sensemakingActivities",
            "name": "Sensemaking Activities",
            "questions": [
                {
                    "id": "encounterStories",
                    "shortName": "Encounter stories",
                    "type": "encountering stories (no task)",
                    "plan": "Give each small group some stories to consider. If the stories are printed, " +
                        "ask them to read the stories, either quietly or aloud. If the stories are in audio or video form, " +
                        "ask them to listen to or watch the stories together.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "None required",
                    "materials": "Printed, audio, or video stories",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the stories, " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "simpleRanking",
                    "shortName": "Simple ranking",
                    "type": "encountering stories (simple task)",
                    "plan": "Ask each small group to draw a line across a large sheet of paper, or simply use " +
                        "sticky notes to mark the start and end of a line across the table. " +
                        "Give each small group some stories to consider. As they read or listen to each story, " +
                        "ask them to place it somewhere along the line. When they have gone through all the stories, " +
                        "ask them to talk about the pattern they have created with their placements. ",
                    "optionalParts": "If particular groups finish early, ask them to create a second line, " +
                        "then move their stories from one line to the other. Then ask them to consider " +
                        "what they learned from the repositioning of the stories.",
                    "duration": "Ten to thirty minutes",
                    "recording": "None required",
                    "materials": "Printed, audio, or video stories; a surface (wall, table, or floor) to place stories on; paper and/or sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the stories, " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "bothSides",
                    "shortName": "Both sides",
                    "type": "encountering stories (simple task)",
                    "plan": "Give each group some stories to consider. Ask them to try to find groups of stories " +
                        "in which the same question is answered differently. " +
                        "Example questions might be \"How does a citizen behave?\" and \"What is education?\" " +
                        "Ask people to write these questions " +
                        "on sticky notes and surround them with the stories that answer them differently. " +
                        "If a story stands alone, people should still write a question it answers. " +
                        "If two stories answer the same question in the same way, they can be stacked together. " +
                        "When all of the stories have been considered, people can stand back and look over " +
                        "the patterns they have created.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "None required",
                    "materials": "Printed, audio, or video stories; a surface (wall, table, or floor) to place stories on; sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the stories, " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "remindings",
                    "shortName": "Remindings",
                    "type": "encountering stories (simple task)",
                    "plan": "Give each small group some stories to consider. As they encounter each story, " +
                        "ask them to think of any other stories it reminds them of. When they find such a " +
                        "reminding pair, have them place the two stories next to each other, with a sticky note " +
                        "between them explaining what links the two stories. It might be something simple, like " +
                        "that they are both about fathers, or something complex, like that in both stories trust " +
                        "is lacking. When the group has worked their way through all of their stories, ask them " +
                        "to stand back and look at the pattern they have created.",
                    "optionalParts": "After creating their remindings pattern, people can talk about why some stories " +
                        "are not connected to any others. What do the unrelated stories have in common?",
                    "duration": "Ten to thirty minutes",
                    "recording": "None required",
                    "materials": "Printed, audio, or video stories; a surface (wall, table, or floor) to place stories on; sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the stories, " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "resonance",
                    "shortName": "Resonance",
                    "type": "encountering stories (simple task)",
                    "plan": "Give each small group some stories to consider. As they encounter eacy story, " +
                        "ask each person to choose some number of stories (perhaps three, five, or seven) they will take " +
                        "special care to represent in later exercises during the session. They should choose " +
                        "stories that resonate with their own experiences; stories they want to make sure are " +
                        "well represented in what is considered; stories whose voices they want to amplify. When the group " +
                        "has worked their way through all the stories, ask them to talk about the stories they " +
                        "(each) chose and why they chose them.",
                    "optionalParts": "If there is time, people can also talk about the stories nobody chose, " +
                        "and why nobody felt those stories resonated with them, and what that might mean.",
                    "duration": "Ten to thirty minutes",
                    "recording": "None required",
                    "materials": "Printed, audio, or video stories; a surface (wall, table, or floor) to place stories on; sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the stories, " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "twiceToldStories",
                    "shortName": "Twice-told stories",
                    "type": "twice-told stories exercise",
                    "plan": "1. (5 min) Introduction. Ask people to form groups of two to four people. " +
                        "2. (5 min) Criteria. Each small group should choose a criterion by which they will choose a story they " +
                        "will tell to the larger group afterward." +
                        "3. (5 min) Critique. Groups present their criteria to the room for critique. " +
                        "4. (20 min) Encounter. Small groups read or listen to stories. As they do this, they choose which story " +
                        "they will retell to the larger group. " +
                        "5. (20 min) Retelling. One person from each small group retells their chosen story " +
                        "to the whole session. " +
                        "6. (5 min) Discussion. Wrap-up and general discussion of all stories told and the topic.",
                    "optionalParts": "None",
                    "duration": "One hour",
                    "recording": "None required",
                    "materials": "None required",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the exercise (choosing stories to retell), " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "twiceToldStoriesShort",
                    "shortName": "Twice-told stories (short version)",
                    "type": "twice-told stories exercise",
                    "plan": "1. (5 min) Introduction and criteria. Ask people to form groups of two to four people. " +
                        "Also, each small group should choose a criterion by which they will choose a story they " +
                        "will tell to the larger group afterward." +
                        "2. (20 min) Encounter. Small groups read or listen to stories. As they do this, they choose which story " +
                        "they will retell to the larger group. " +
                        "3. (15 min) Retelling. One person from each small group retells their chosen story " +
                        "to the whole session. " +
                        "4. (5 min) Discussion. Wrap-up and general discussion of all stories told and the topic.",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "None required",
                    "materials": "None required",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the exercise (choosing stories to retell), " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "timeline",
                    "shortName": "Timeline",
                    "type": "timeline exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. " +
                        "2. (5 min) Topics and dates. Ask each group to agree on a topic their timeline will explore. " +
                        "Ask each group to choose starting and ending dates for their timeline " +
                        "and mark these dates with sticky notes. " +
                        "3. (10 min) Start and end. Ask each group to choose at least three stories that describe the end of the timeline. They should " +
                        "write the title of each story on a sticky note, and build a cluster of these notes at the end of the timeline. " +
                        "They should do the same for the timeline start." +
                        "4. (25 min) Filling in. Have each group work backwards through time, adding stories (from those they have been given) to the timeline along the way. " +
                        "5. (5 min) Turning points. Ask groups to mark turning points, or times when things changed in significant ways, on their timeline. " +
                        "6. (10 min). Review. Ask each group to review their timeline, looking for interesting or useful features. " +
                        "7. (10 min). Visiting. Ask everyone to walk around the room looking over all of the timelines created. " +
                        "8. (10 min). Finishing. Ask each group to finish their timeline, taking into consideration things visitors said about it. " +
                        "9. (10 min). Discussion. Bring everyone together into a discussion of all the timelines.",
                    "optionalParts": "Use whole stories instead of story titles; use vertical space to annotate stories; " +
                        "distinuguish multiple perspectives; mark multiple types of turning point; etc. (See WWS for details.)",
                    "duration": "90 minutes",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for people paying more attention to when things happened than to " +
                        "what that might mean. Especially when they are finding turning points and looking for larger " +
                        "patterns, eople should be negotiating meaning, " +
                        "not just mapping events."
                },
                {
                    "id": "timelineShort",
                    "shortName": "Timeline (short version)",
                    "type": "timeline exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. " +
                        "2. (5 min) Topics and dates. Ask each group to agree on a topic their timeline will explore. " +
                        "Ask each group to choose starting and ending dates for their timeline " +
                        "and mark these dates with sticky notes. " +
                        "3. (5 min) Start and end. Ask each group to choose at least three stories that describe the end of the timeline. They should " +
                        "write the title of each story on a sticky note, and build a cluster of these notes at the end of the timeline. " +
                        "They should do the same for the timeline start." +
                        "4. (20 min) Filling in. Have each group work backwards through time, adding stories (from those they have been given) to the timeline along the way. " +
                        "5. (5 min) Turning points. Ask groups to mark turning points, or times when things changed in significant ways, on their timeline. " +
                        "5. (10 min). Visiting. Ask everyone to walk around the room looking over all of the timelines created. ",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for people paying more attention to when things happened than to " +
                        "what that might mean. Especially when they are finding turning points and looking for larger " +
                        "patterns, eople should be negotiating meaning, " +
                        "not just mapping events."
                },
                {
                    "id": "landscape",
                    "shortName": "Landscape",
                    "type": "landscape exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. " +
                        "2. (5 min) Dimensions and corners. Ask each group to mark each axis of the space using dimensions you have chosen. " +
                        "Ask people to label each corner point with descriptions of how the two dimensions come together " +
                        "at that corner." +
                        "3. (40 min) Filling in. Having defined their space, each group will now fill it up with the stories they were given. " +
                        "4. (25 min) Features. After groups have populated their spaces, ask them to mark out features of the landscape. " +
                        "5. (15 min) Review. Ask each group to work together on the story their landscape tells and what discoveries they find in it. " +
                        "6. (10 min) Visiting. Ask everyone to walk around the room looking over all of the landscapes created and " +
                        "talking about the experiences described there. " +
                        "7. (10 min) Finishing. Groups should add a legend explaining all annotations to their landscape as well as a summary of its major features. " +
                        "8. (10 min). Discussion. Bring everyone together into a discussion of all the landscapes.",
                    "optionalParts": "Consider a third dimension; consider multiple perspectives; " +
                        "ask people to create their own dimensions (see WWS for details).",
                    "duration": "two hours",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for categorization; too-precise or too-sloppy placement; " +
                        "hesitation; dimensions that don't fit the stories (have extras on hand)."
                },
                {
                    "id": "landscapeShort",
                    "shortName": "Landscape (short version)",
                    "type": "landscape exercise (short version)",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. " +
                        "2. (5 min) Dimensions and corners. Ask each group to mark each axis of the space using dimensions you have chosen. " +
                        "Ask people to label each corner point with descriptions of how the two dimensions come together " +
                        "at that corner." +
                        "3. (20 min) Filling in. Having defined their space, each group will now fill it up with the stories they were given. " +
                        "4. (10 min) Features. After groups have populated their spaces, ask them to mark out features of the landscape. " +
                        "5. (5 min) Visiting. Ask everyone to walk around the room looking over all of the landscapes created and " +
                        "talking about the experiences described there. ",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for categorization; too-precise or too-sloppy placement; " +
                        "hesitation; dimensions that don't fit the stories (have extras on hand)."
                },
                {
                    "id": "storyElements",
                    "shortName": "Story elements",
                    "type": "story elements exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Explain the question " +
                        "people will be asking about stories (like 'What is going on in this story?'). Split into small " +
                        "groups of three or four people each. " +
                        "2. (20 min) Filling in. Each group should consider the stories they were given and " +
                        "answer the question (you told them about in the introduction) about it a few times. " +
                        "They should write the answers on sticky notes." +
                        "3. (15 min) Clustering. Ask each group to put away the stories and consider only the answers. " +
                        "On a large blank space, groups should place similar items together, like with like, until " +
                        "groups form. " +
                        "4. (10 min) Describing clusters. Groups should list two to four good and bad attributes " +
                        "about each cluster. " +
                        "5. (10 min) Second clustering. Ask groups to cluster the attributes (all of them together, " +
                        "regardless of which cluster they came from) in exactly the same way in which they clustered " +
                        "the original answers. " +
                        "6. (10 min) Review. Ask each group to talk together about what they have discovered. " +
                        "7. (5 min) Visiting. Ask everyone to walk around the room looking over all of the story elements that have been created. " +
                        "8. (5 min) Finishing. Groups should create a summary that describes, in their own words, what each story element means " +
                        "to them and what they have learned from it. " +
                        "9. (10 min) Discussion. Bring everyone together into a discussion of all the story elements.",
                    "optionalParts": "xxx",
                    "duration": "90 minutes",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for categorization (remind people that clustering is open-ended); " +
                        "weak response; bad story element names (e.g., proper nouns)."
                },
                {
                    "id": "storyElementsShort",
                    "shortName": "Story elements (short version)",
                    "type": "story elements exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Explain the question " +
                        "people will be asking about stories (like 'What is going on in this story?'). Split into small " +
                        "groups of three or four people each. " +
                        "2. (20 min) Filling in. Each group should consider the stories they were given and " +
                        "answer the question (you told them about in the introduction) about it a few times. " +
                        "They should write the answers on sticky notes." +
                        "3. (15 min) Clustering. Ask each group to put away the stories and consider only the answers. " +
                        "On a large blank space, groups should place similar items together, like with like, until " +
                        "groups form. " +
                        "4. (10 min) Describing clusters. Groups should list two to four good and bad attributes " +
                        "about each cluster. " +
                        "5. (5 min) Second clustering. Ask groups to cluster the attributes (all of them together, " +
                        "regardless of which cluster they came from) in exactly the same way in which they clustered " +
                        "the original answers. " +
                        "to them and what they have learned from it. " +
                        "6. (5 min) Discussion. Bring everyone together into a discussion of all the story elements.",
                    "optionalParts": "Use more than one element type; create association trails; find exemplar stories; " +
                        "compare story elements to published models (see WWS for details).",
                    "duration": "one hour",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for categorization (remind people that clustering is open-ended); " +
                        "weak response; bad story element names (e.g., proper nouns)."
                },
                {
                    "id": "compositeStories",
                    "shortName": "Composite stories",
                    "type": "composite stories exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Make sure you have at least three groups in total. " +
                        "2. (5 min) Choosing a message. Each group should agree on a message they want their constructed story to deliver. " +
                        "3. (20 min) Filling in the template. Introduce a story template. Groups should place stories into spaces on the " +
                        "template where they seem to fit and support the overall message. " +
                        "4. (20 min) Forming the story. In this step the focus of each group should move from assembling " +
                        "stories to creating one new fictional story inspired by the assembled stories. " +
                        "5. (10 min) First telling. Now each storyteller should visit another group, tell their group’s story, " +
                        "and listen to feedback. " +
                        "6. (15 min) Preparation for second telling. Storytellers should report on how the storytelling went, " +
                        "then the group should go back and improve on their story in preparation for a second telling. " +
                        "7. (10 min) Second telling. Now the same storytellers should proceed to another group " +
                        "(not the one they told the story to the first time) and tell the story again. Again they " +
                        "should gather feedback. " +
                        "8. (15 min) Finishing. Again the groups should improve their stories. If desired, " +
                        "they should record the story now. " +
                        "9. (10 min) Group discussion. Now that each story has been told, retold, and possibly recorded, " +
                        "it is time for groups to discuss what they have learned by building the story. " +
                        "10. (10 min) Discussion. Now bring everyone in the room into one large discussion about all the stories and the entire process.",
                    "optionalParts": "Add more up-front story choices (topic, genre, subtext, etc); " +
                        "tell the story three times; use repetition and recursion to make the story more complex; " +
                        "have two people play out the story; etc. (See WWS for details.)",
                    "duration": "two hours",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "None required, though people might like to place their sticky notes onto a space to prepare their story",
                    "facilitation": "Watch out for people not understanding the template (have others on hand); " +
                        "people not liking the idea of making things up; people going through the process " +
                        "mechanically; people paying too much attention to story quality."
                },
                {
                    "id": "compositeStoriesShort",
                    "shortName": "Composite stories (short version)",
                    "type": "composite stories exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Make sure you have at least three groups in total. " +
                        "Also, each group should agree on a message they want their constructed story to deliver. " +
                        "2. (20 min) Filling in the template. Introduce a story template. Groups should place stories into spaces on the " +
                        "template where they seem to fit and support the overall message. " +
                        "3 (20 min) Forming the story. In this step the focus of each group should move from assembling " +
                        "stories to creating one new fictional story inspired by the assembled stories. " +
                        "4. (5 min) First telling. Now each storyteller should visit another group, tell their group’s story, " +
                        "and listen to feedback. " +
                        "5. (10 min) Preparation for second telling. Storytellers should report on how the storytelling went, " +
                        "then the group should go back and improve on their story in preparation for a second telling. " +
                        "6. (5 min) Second telling. Now the same storytellers should proceed to another group " +
                        "(not the one they told the story to the first time) and tell the story again. Again they " +
                        "should gather feedback. " +
                        "7. (10 min) Finishing. Again the groups should improve their stories. If desired, " +
                        "they should record the story now. " +
                        "8. (5 min) Group discussion. Now that each story has been told, retold, and possibly recorded, " +
                        "it is time for groups to discuss what they have learned by building the story. " +
                        "9. (10 min) Discussion. Now bring everyone in the room into one large discussion about all the stories and the entire process.",
                    "optionalParts": "None",
                    "duration": "90 minutes",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "None required, though people might like to place their sticky notes onto a space to prepare their story",
                    "facilitation": "Watch out for people not understanding the template (have others on hand); " +
                        "people not liking the idea of making things up; people going through the process " +
                        "mechanically; people paying too much attention to story quality."
                }
            ]
        }
    ];
    function convertSemicolonsToNewlinesForOptions(section) {
        var questions = section.questions;
        for (var questionIndex in questions) {
            var question = questions[questionIndex];
            if (question.options) {
                question.options = question.options.replace(/;/g, "\n");
            }
        }
        return section;
    }
    exports.elicitationQuestions = convertSemicolonsToNewlinesForOptions(templates[0]);
    exports.storyQuestions = convertSemicolonsToNewlinesForOptions(templates[1]);
    exports.participantQuestions = convertSemicolonsToNewlinesForOptions(templates[2]);
    exports.annotationQuestions = convertSemicolonsToNewlinesForOptions(templates[3]);
    exports.storyCollectionActivities = convertSemicolonsToNewlinesForOptions(templates[4]);
    exports.sensemakingActivities = convertSemicolonsToNewlinesForOptions(templates[5]);
});

define('js/applicationWidgets/add_templateList',["require", "exports", "../panelBuilder/dialogSupport", "../templates/templates", "../panelBuilder/GridWithItemPanel", "mithril", "../Globals"], function (require, exports, dialogSupport, templates, GridWithItemPanel, m, Globals) {
    "use strict";
    "use strict";
    function add_templateList(panelBuilder, model, fieldSpecification) {
        var dialogConfiguration = {
            dialogModel: model,
            dialogTitle: "#title_chooseATemplate|Choose a template",
            dialogClass: undefined,
            dialogConstructionFunction: makeTemplateListChooser.bind(null, panelBuilder),
            dialogOKButtonLabel: "Cancel",
            fieldSpecification: fieldSpecification
        };
        return dialogSupport.addButtonThatLaunchesDialog(fieldSpecification, dialogConfiguration);
    }
    var add_templateList_elicitationQuestions = [
        { id: "category", valueType: "string", displayType: "text" },
        { id: "text", valueType: "string", displayType: "textarea" }
    ];
    var add_templateList_storyOrParticipantOrAnnotationQuestions = [
        { id: "category", valueType: "string", displayType: "text" },
        { id: "text", valueType: "string", displayType: "textarea" },
        { id: "type", valueType: "string", displayType: "text" },
        { id: "options", valueType: "string", displayType: "textarea" }
    ];
    var add_templateList_activityQuestions = [
        { id: "shortName", valueType: "string", displayType: "text" },
        { id: "type", valueType: "string", displayType: "text" },
        { id: "duration", valueType: "string", displayType: "text" },
        { id: "plan", valueType: "string", displayType: "textarea" }
    ];
    function useButtonClicked(panelBuilder, templateListChoice, model, hideDialogCallback, gridWithItemPanel) {
        var selectedTemplate = gridWithItemPanel.getSelectedItem();
        var storeValueInModel = Globals.project().tripleStore.makeModelFunction(model);
        if (selectedTemplate) {
            // TODO: not sure whether to confirm?
            // TODO: Translate
            dialogSupport.confirm("Copy selected template '" + selectedTemplate.shortName + "' into question definition?", function () {
                var uniqueName = selectedTemplate.shortName || selectedTemplate.id || "";
                if (templateListChoice === "elicitationQuestions") {
                    storeValueInModel("elicitingQuestion_text", selectedTemplate.text || "");
                    storeValueInModel("elicitingQuestion_shortName", uniqueName);
                    // TODO: No data for type, and would need to copy over settings for checkboxes if such data existed
                    // modelFunction("storyQuestion_type", selectedTemplate.text);
                    storeValueInModel("elicitingQuestion_type", {});
                }
                else if (templateListChoice === "storyQuestions") {
                    storeValueInModel("storyQuestion_text", selectedTemplate.text || "");
                    storeValueInModel("storyQuestion_type", selectedTemplate.type || "");
                    storeValueInModel("storyQuestion_shortName", uniqueName);
                    storeValueInModel("storyQuestion_options", selectedTemplate.options || "");
                }
                else if (templateListChoice === "participantQuestions") {
                    storeValueInModel("participantQuestion_text", selectedTemplate.text || "");
                    storeValueInModel("participantQuestion_type", selectedTemplate.type || "");
                    storeValueInModel("participantQuestion_shortName", uniqueName);
                    storeValueInModel("participantQuestion_options", selectedTemplate.options || "");
                }
                else if (templateListChoice === "annotationQuestions") {
                    storeValueInModel("annotationQuestion_text", selectedTemplate.text || "");
                    storeValueInModel("annotationQuestion_type", selectedTemplate.type || "");
                    storeValueInModel("annotationQuestion_shortName", uniqueName);
                    storeValueInModel("annotationQuestion_options", selectedTemplate.options || "");
                }
                else if (templateListChoice === "storyCollectionActivities") {
                    storeValueInModel("collectionSessionActivity_name", uniqueName);
                    storeValueInModel("collectionSessionActivity_type", selectedTemplate.type || "");
                    storeValueInModel("collectionSessionActivity_plan", selectedTemplate.plan || "");
                    storeValueInModel("collectionSessionActivity_optionalParts", selectedTemplate.optionalParts || "");
                    storeValueInModel("collectionSessionActivity_duration", selectedTemplate.duration || "");
                    storeValueInModel("collectionSessionActivity_recording", selectedTemplate.recording || "");
                    storeValueInModel("collectionSessionActivity_materials", selectedTemplate.materials || "");
                    storeValueInModel("collectionSessionActivity_spaces", selectedTemplate.spaces || "");
                    storeValueInModel("collectionSessionActivity_facilitation", selectedTemplate.facilitation || "");
                }
                else if (templateListChoice === "sensemakingActivities") {
                    storeValueInModel("sensemakingSessionPlan_activity_name", uniqueName);
                    storeValueInModel("sensemakingSessionPlan_activity_type", selectedTemplate.type || "");
                    storeValueInModel("sensemakingSessionPlan_activity_plan", selectedTemplate.plan || "");
                    storeValueInModel("sensemakingSessionPlan_activity_optionalParts", selectedTemplate.optionalParts || "");
                    storeValueInModel("sensemakingSessionPlan_activity_duration", selectedTemplate.duration || "");
                    storeValueInModel("sensemakingSessionPlan_activity_recording", selectedTemplate.recording || "");
                    storeValueInModel("sensemakingSessionPlan_activity_materials", selectedTemplate.materials || "");
                    storeValueInModel("sensemakingSessionPlan_activity_spaces", selectedTemplate.spaces || "");
                    storeValueInModel("sensemakingSessionPlan_activity_facilitation", selectedTemplate.facilitation || "");
                }
                else {
                    var message = "ERROR: unsupported template type:" + templateListChoice;
                    console.log(message);
                    alert(message);
                }
                hideDialogCallback();
            });
        }
        else {
            // TODO: Translate
            alert("No template was selected");
        }
    }
    function makeTemplateListChooser(panelBuilder, dialogConfiguration, hideDialogCallback) {
        var fieldSpecification = dialogConfiguration.fieldSpecification;
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var templateListChoice = fieldSpecification.displayConfiguration;
        var templateCollection = templates[templateListChoice];
        var templateQuestions;
        if (templateCollection) {
            templateQuestions = templateCollection.questions;
        }
        else {
            console.log("No templates defined yet for templateListChoice", templateListChoice);
            // alert("Unsupported templateListChoice: " + templateListChoice);
            templateQuestions = [];
        }
        var pageQuestions;
        if (templateListChoice === "elicitationQuestions") {
            pageQuestions = add_templateList_elicitationQuestions;
        }
        else if (templateListChoice === "storyQuestions" || templateListChoice === "participantQuestions" || templateListChoice === "annotationQuestions") {
            pageQuestions = add_templateList_storyOrParticipantOrAnnotationQuestions;
        }
        else if (templateListChoice === "storyCollectionActivities" || templateListChoice === "sensemakingActivities") {
            pageQuestions = add_templateList_activityQuestions;
        }
        else {
            var message = "ERROR: unsupported template type:" + templateListChoice;
            console.log(message);
            alert(message);
            pageQuestions = [];
        }
        function buildPanel(builder, model) {
            return builder.buildFields(pageQuestions, model);
        }
        var itemPanelSpecification = {
            id: "panel_template",
            modelClass: "Template",
            displayType: "panel",
            isHeader: false,
            panelFields: pageQuestions,
            buildPanel: buildPanel
        };
        var customButtonDefinition = {
            id: "useTemplate",
            customButtonLabel: "#button_UseTemplate|Use template",
            callback: useButtonClicked.bind(null, panelBuilder, templateListChoice, dialogConfiguration.dialogModel, hideDialogCallback)
        };
        var model = { templates: templateQuestions };
        var gridFieldSpecification = {
            id: "templates",
            displayConfiguration: {
                itemPanelSpecification: itemPanelSpecification,
                gridConfiguration: {
                    idProperty: "id",
                    columnsToDisplay: false,
                    // viewButton: true,
                    customButton: customButtonDefinition,
                    navigationButtons: true
                }
            }
        };
        // TODO: Set class on div
        return m("div", [
            prompt,
            m.component(GridWithItemPanel, { key: fieldSpecification.id + "_templatesListChooser", panelBuilder: panelBuilder, fieldSpecification: gridFieldSpecification, model: model })
            // m("button", {onclick: hideDialogCallback}, "Cancel")
        ]);
    }
    return add_templateList;
});

define('js/applicationWidgets/add_patternExplorer',["require", "exports", "mithril", "./PatternExplorer"], function (require, exports, m, PatternExplorer) {
    "use strict";
    "use strict";
    function add_patternExplorer(panelBuilder, model, fieldSpecification) {
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var patternBrowser = m.component(PatternExplorer, { key: fieldSpecification.id, panelBuilder: panelBuilder, model: model, fieldSpecification: fieldSpecification });
        return m("div", [prompt, patternBrowser]);
    }
    return add_patternExplorer;
});

define('js/applicationWidgets/loadAllApplicationWidgets',["require", "exports", "./add_catalysisReportQuestionChooser", "./add_printStoryCardsQuestionChooser", "./add_questionTypeChooser", "./add_translationDictionaryEditorPanel", "./add_choiceQuestionAnswersManagementPanel", "./add_checkboxQuestionConfigurationPanel", "./add_sliderQuestionConfigurationPanel", "./add_shortNameQuestionConfigurationPanel", "./add_catalysisReportGraphTypesChooser", "./add_catalysisReportPatternTableColumnsChooser", "./add_storyFormQuestionsChooser", "./add_catalysisReportFilterNotice", "./add_clusteringDiagram", "./add_dashboardStoryCollectionStatusDisplay", "./add_graphBrowser", "./add_annotationGraphBrowser", "./add_questionAnswer", "./add_quizScoreResult", "./add_recommendationTable", "./add_storiesList", "./add_storyBrowser", "./add_storyAnnotationBrowser", "./add_templateList", "./add_patternExplorer"], function (require, exports, add_catalysisReportQuestionChooser, add_printStoryCardsQuestionChooser, add_questionTypeChooser, add_translationDictionaryEditorPanel, add_choiceQuestionAnswersManagementPanel, add_checkboxQuestionConfigurationPanel, add_sliderQuestionConfigurationPanel, add_shortNameQuestionConfigurationPanel, add_catalysisReportGraphTypesChooser, add_catalysisReportPatternTableColumnsChooser, add_storyFormQuestionsChooser, add_catalysisReportFilterNotice, add_clusteringDiagram, add_dashboardStoryCollectionStatusDisplay, add_graphBrowser, add_annotationGraphBrowser, add_questionAnswer, add_quizScoreResult, add_recommendationTable, add_storiesList, add_storyBrowser, add_storyAnnotationBrowser, add_templateList, add_patternExplorer) {
    "use strict";
    "use strict";
    function loadAllApplicationWidgets(PanelBuilder) {
        PanelBuilder.addPlugin("catalysisReportQuestionChooser", add_catalysisReportQuestionChooser);
        PanelBuilder.addPlugin("printStoryCardsQuestionChooser", add_printStoryCardsQuestionChooser);
        PanelBuilder.addPlugin("questionTypeChooser", add_questionTypeChooser);
        PanelBuilder.addPlugin("translationDictionaryEditorPanel", add_translationDictionaryEditorPanel);
        PanelBuilder.addPlugin("choiceQuestionAnswersManagementPanel", add_choiceQuestionAnswersManagementPanel);
        PanelBuilder.addPlugin("checkboxQuestionConfigurationPanel", add_checkboxQuestionConfigurationPanel);
        PanelBuilder.addPlugin("sliderQuestionConfigurationPanel", add_sliderQuestionConfigurationPanel);
        PanelBuilder.addPlugin("shortNameQuestionConfigurationPanel", add_shortNameQuestionConfigurationPanel);
        PanelBuilder.addPlugin("catalysisReportFilterNotice", add_catalysisReportFilterNotice);
        PanelBuilder.addPlugin("catalysisReportGraphTypesChooser", add_catalysisReportGraphTypesChooser);
        PanelBuilder.addPlugin("catalysisReportPatternTableColumnsChooser", add_catalysisReportPatternTableColumnsChooser);
        PanelBuilder.addPlugin("storyFormQuestionsChooser", add_storyFormQuestionsChooser);
        PanelBuilder.addPlugin("clusteringDiagram", add_clusteringDiagram);
        PanelBuilder.addPlugin("dashboardStoryCollectionStatusDisplay", add_dashboardStoryCollectionStatusDisplay);
        PanelBuilder.addPlugin("graphBrowser", add_graphBrowser);
        PanelBuilder.addPlugin("annotationGraphBrowser", add_annotationGraphBrowser);
        PanelBuilder.addPlugin("questionAnswer", add_questionAnswer);
        PanelBuilder.addPlugin("quizScoreResult", add_quizScoreResult);
        PanelBuilder.addPlugin("recommendationTable", add_recommendationTable);
        PanelBuilder.addPlugin("storiesList", add_storiesList);
        PanelBuilder.addPlugin("storyBrowser", add_storyBrowser);
        PanelBuilder.addPlugin("storyAnnotationBrowser", add_storyAnnotationBrowser);
        PanelBuilder.addPlugin("templateList", add_templateList);
        PanelBuilder.addPlugin("patternExplorer", add_patternExplorer);
    }
    return loadAllApplicationWidgets;
});

define('js/panelBuilder/loadAllPanelSpecifications',["require", "exports"], function (require, exports) {
    "use strict";
    // Setup all the panels from TypeScript files specified in navigationSections array
    // see navigation.ts for an example of the format
    // The "panels" are child panels used by grids and similar widgets on the page (including recursively)
    /*
     [
         {
            "section": "planning",
            "sectionName": "Planning",
            "pages": [
                "page_planning",
                 "page_participantGroups",
                 ...
            ],
            "panels": [
                "panel_addParticipantGroup",
                ...
            ]
         }, ...
     ]
     */
    function loadAllPanelSpecifications(panelSpecificationCollection, navigationSections, loadingBase, callback) {
        var navigationModules = navigationSections["navigationModules"];
        var panelSpecification;
        for (var sectionIndex = 0; sectionIndex < navigationSections.length; sectionIndex++) {
            var sectionInfo = navigationSections[sectionIndex];
            for (var pageIndex = 0; pageIndex < sectionInfo.pages.length; pageIndex++) {
                var pageID = sectionInfo.pages[pageIndex];
                panelSpecification = navigationModules[pageID];
                if (panelSpecification.id !== pageID) {
                    console.log("pageID mismatch; expected:", pageID, panelSpecification);
                    throw new Error("pageID does not match id in file for pae: " + pageID);
                }
                panelSpecification.section = sectionInfo.section;
                panelSpecification.isHeader = pageIndex === 0 || false;
                panelSpecification.displayType = "page";
                panelSpecificationCollection.addPanelSpecification(panelSpecification);
            }
            if (sectionInfo.panels) {
                for (var extraPanelIndex = 0; extraPanelIndex < sectionInfo.panels.length; extraPanelIndex++) {
                    var extraPanelID = sectionInfo.panels[extraPanelIndex];
                    panelSpecification = navigationModules[extraPanelID];
                    if (panelSpecification.id !== extraPanelID) {
                        console.log("panelID mismatch; expected:", extraPanelID, panelSpecification);
                        throw new Error("panelID does not match id in file for panel: " + extraPanelID);
                    }
                    panelSpecification.section = sectionInfo.section;
                    panelSpecification.isHeader = extraPanelIndex === 0 || false;
                    panelSpecification.displayType = "panel";
                    panelSpecificationCollection.addPanelSpecification(panelSpecification);
                }
            }
        }
        // TODO: Legacy: Used to be asynchronous require, but now page and panel modules are loaded at startup
        callback();
    }
    return loadAllPanelSpecifications;
});

define('js/panelBuilder/PanelBuilder',["require", "exports", "./browser", "./translate", "mithril", "./GridWithItemPanel", "./standardWidgets", "../sanitizeHTML", "lodash"], function (require, exports, browser, translate, m, GridWithItemPanel, standardWidgets, sanitizeHTML, _) {
    "use strict";
    "use strict";
    // Developer local debug flag to cause an Exception if a widget type is missing instead of put in placeholder panel
    var debugFailIfMissingWidgets = false;
    // This is the tag to put into prompting text for functionResult items where you want the result to go
    var ResultTagToReplace = "{{result}}";
    // TODO: Need a better approach for calling JavaScript function than this
    window["narraFirma_launchApplication"] = browser.launchApplication;
    // TODO: Think about how to load plugins only as needed at runtime.
    // Asynchronous callbacks are nice, until you realize you would need
    // to refactor a lot to introduce one deep down in your application.
    // In this case, it would be nice to load plugin functions only at runtime as panels require them.
    // However, to use the AMD approach, that would mean everything that asked the builder
    // to do anything would have to wait on a callback for the builder to finish.
    function addButton(panelBuilder, model, fieldSpecification, callback) {
        if (!callback)
            callback = panelBuilder.buttonClicked.bind(panelBuilder, model, fieldSpecification);
        var options = { onclick: callback };
        if (fieldSpecification.displayClass)
            options.class = fieldSpecification.displayClass;
        var displayPrompt = fieldSpecification.displayPrompt;
        if (typeof fieldSpecification.displayPrompt === "function")
            displayPrompt = displayPrompt(this, model, fieldSpecification);
        // TODO: Translate and changing display prompt won't mix well
        var text = m("span", { "class": "button-text" }, translate(fieldSpecification.id + "::prompt", displayPrompt));
        var parts = [text];
        if (fieldSpecification.displayIconClass) {
            var displayIconClass = fieldSpecification.displayIconClass;
            if (typeof fieldSpecification.displayIconClass === "function")
                displayIconClass = displayIconClass(this, model, fieldSpecification);
            var icon = m("span", { "class": "buttonWithTextImage " + displayIconClass });
            if (fieldSpecification.displayIconPosition === "right") {
                parts.push(icon);
            }
            else {
                parts.unshift(icon);
            }
        }
        var button = m("button", options, parts);
        if (fieldSpecification.displayPreventBreak)
            return button;
        return [button, m("br")];
    }
    function add_html(panelBuilder, model, fieldSpecification, callback) {
        // add_html should only be called for NarraFirma application-supplied code, so trusting this should be OK
        var divClass = "htmlWidget";
        if (fieldSpecification.displayPrompt.indexOf("<input") >= 0) {
            divClass = "hiddenHtmlWidget";
        }
        return m("div." + divClass, { key: fieldSpecification.id, class: fieldSpecification.displayClass }, m.trust(fieldSpecification.displayPrompt));
    }
    function add_image(panelBuilder, model, fieldSpecification, callback) {
        var imageSource = fieldSpecification.displayConfiguration;
        var questionText = translate(fieldSpecification.id + "::prompt", fieldSpecification.displayPrompt || "");
        return m("div.narrafirma-image", { key: fieldSpecification.id }, [
            panelBuilder.addAllowedHTMLToPrompt(questionText),
            m("br"),
            m("img", {
                src: panelBuilder.applicationDirectory + imageSource,
                alt: "Image for question: " + questionText
            })
        ]);
    }
    function add_functionResult(panelBuilder, model, fieldSpecification, callback) {
        var baseText = translate(fieldSpecification.id + "::prompt", fieldSpecification.displayPrompt);
        var calculatedText = panelBuilder.calculateFunctionResult(model, fieldSpecification);
        var newLabelText = panelBuilder.substituteCalculatedResultInBaseText(baseText, calculatedText);
        return m("div.functionResult", panelBuilder.addAllowedHTMLToPrompt(newLabelText));
    }
    function add_grid(panelBuilder, model, fieldSpecification) {
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        return m("div", { "class": "narrafirma-question-type-grid-plus-prompt" }, [
            prompt,
            m.component(GridWithItemPanel, { key: fieldSpecification.id, panelBuilder: panelBuilder, model: model, fieldSpecification: fieldSpecification, readOnly: panelBuilder.readOnly })
        ]);
    }
    function addStandardPlugins() {
        // shared with survey builder
        var displayQuestion = standardWidgets.displayQuestion;
        PanelBuilder.addPlugin("boolean", displayQuestion);
        PanelBuilder.addPlugin("checkbox", displayQuestion);
        PanelBuilder.addPlugin("checkboxes", displayQuestion);
        PanelBuilder.addPlugin("header", displayQuestion);
        PanelBuilder.addPlugin("label", displayQuestion);
        PanelBuilder.addPlugin("radiobuttons", displayQuestion);
        PanelBuilder.addPlugin("select", displayQuestion);
        PanelBuilder.addPlugin("slider", displayQuestion);
        PanelBuilder.addPlugin("text", displayQuestion);
        PanelBuilder.addPlugin("textarea", displayQuestion);
        // other
        PanelBuilder.addPlugin("button", addButton);
        PanelBuilder.addPlugin("functionResult", add_functionResult);
        PanelBuilder.addPlugin("grid", add_grid);
        PanelBuilder.addPlugin("html", add_html);
        PanelBuilder.addPlugin("image", add_image);
    }
    var buildingFunctions = {};
    // This class builds panels from field specifications.
    // Field specifications define what widget to display and how to hook that widget to a model.
    var PanelBuilder = (function () {
        function PanelBuilder(application) {
            this.application = application;
            this.panelSpecificationCollection = null;
            this.buttonClickedCallback = null;
            this.calculateFunctionResultCallback = null;
            this.addHelpIcons = false;
            this.currentHelpPage = null;
            this.currentHelpSection = null;
            // TODO: Should this be an absolute path based on whether running as WordPress plugin or NodeJS?
            this.applicationDirectory = "";
            this.idsMade = {};
            this.idCount = 0;
            this.readOnly = false;
        }
        PanelBuilder.addPlugin = function (name, callback) {
            buildingFunctions[name] = callback;
        };
        // provide a way to find definitions needed to  build internal panels for some widgets like the GridWithItemPanel
        PanelBuilder.prototype.setPanelSpecifications = function (panelSpecificationCollection) {
            this.panelSpecificationCollection = panelSpecificationCollection;
        };
        // Convert arbitrary text to ids
        PanelBuilder.prototype.getIdForText = function (text) {
            if (!this.idsMade["$" + text]) {
                this.idsMade["$" + text] = this.idCount++;
            }
            return "panelField_" + this.idsMade["$" + text];
        };
        PanelBuilder.prototype.addMissingWidgetPlaceholder = function (panelBuilder, model, fieldSpecification) {
            var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
            return m("div", [
                prompt,
                m("b", "Unsupported widget type: " + fieldSpecification.displayType + " for: " + fieldSpecification.id)
            ]);
        };
        PanelBuilder.prototype.buildField = function (model, fieldSpecification) {
            var displayVisible = fieldSpecification.displayVisible;
            if (displayVisible === undefined)
                displayVisible = true;
            if (typeof displayVisible === "function")
                displayVisible = displayVisible(this, model, fieldSpecification);
            if (!displayVisible)
                return m("div");
            var addFunction = buildingFunctions[fieldSpecification.displayType];
            if (!addFunction) {
                if (debugFailIfMissingWidgets) {
                    // Would be thrown if you forget to call "PanelBuilder.addStandardPlugins();" or similar at the beginning of your application
                    var error = "ERROR: unsupported field display type: " + fieldSpecification.displayType;
                    console.log(error);
                    throw new Error(error);
                }
                addFunction = this.addMissingWidgetPlaceholder.bind(this);
            }
            if (_.isString(addFunction)) {
                var addFunctionName = addFunction;
                addFunction = this[addFunctionName];
                if (!addFunction) {
                    var error2 = "ERROR: missing addFunction for: " + addFunctionName + " for field display type: " + fieldSpecification.displayType;
                    console.log(error2);
                    throw new Error(error2);
                }
            }
            try {
                return addFunction(this, model, fieldSpecification);
            }
            catch (e) {
                console.log("Exception creating widget", fieldSpecification, e);
                return m("div", { style: "border: 1px solid red; margin: 10px; padding: 10px" }, ["Problem creating widget type: " + fieldSpecification.displayType + " :: id: " + fieldSpecification.id, m("br"), "Exception: " + e]);
            }
        };
        // Returns array of widgets built from the fieldSpecifications
        PanelBuilder.prototype.buildFields = function (fieldSpecifications, model) {
            if (!fieldSpecifications) {
                throw new Error("fieldSpecifications are not defined");
            }
            var fields = [];
            for (var fieldSpecificationIndex = 0; fieldSpecificationIndex < fieldSpecifications.length; fieldSpecificationIndex++) {
                var fieldSpecification = fieldSpecifications[fieldSpecificationIndex];
                var widget = this.buildField(model, fieldSpecification);
                fields.push(widget);
            }
            return fields;
        };
        // Build an entire panel; panel can be either a string ID referring to a panel or it can be a panel definition itself
        PanelBuilder.prototype.buildPanel = function (panelOrPanelID, model) {
            var fieldSpecifications;
            if (_.isString(panelOrPanelID)) {
                var panel = this.getPanelDefinitionForPanelID(panelOrPanelID);
                fieldSpecifications = panel.panelFields;
            }
            else if (panelOrPanelID.buildPanel) {
                // Call explicit constructor function
                return panelOrPanelID.buildPanel(this, model);
            }
            else {
                fieldSpecifications = panelOrPanelID.panelFields;
            }
            return this.buildFields(fieldSpecifications, model);
        };
        // Set this correctly before building a page to provide default help when it is not in a field specification
        PanelBuilder.prototype.setCurrentHelpPageAndSection = function (helpPage, helpSection) {
            this.currentHelpPage = helpPage;
            this.currentHelpSection = helpSection;
        };
        /// Suport functions
        PanelBuilder.prototype.getPanelDefinitionForPanelID = function (panelID) {
            if (!this.panelSpecificationCollection) {
                throw new Error("No panelSpecificationCollection set in PanelBuilder so can not resolve panelID: " + panelID);
            }
            var panelSpecification = this.panelSpecificationCollection.getPanelSpecificationForPanelID(panelID);
            if (!panelSpecification) {
                throw new Error("No panelSpecification found by PanelBuilder for panelID: " + panelID);
            }
            return panelSpecification;
        };
        // Convenience method for most common case of finding page specification
        PanelBuilder.prototype.getPageSpecificationForPageID = function (pageID) {
            if (!this.panelSpecificationCollection) {
                throw new Error("No panelSpecificationCollection set in PanelBuilder so can not resolve pageID: " + pageID);
            }
            var pageSpecification = this.panelSpecificationCollection.getPageSpecificationForPageID(pageID);
            if (!pageSpecification) {
                throw new Error("No pageSpecification found by PanelBuilder for pageID: " + pageID);
            }
            return pageSpecification;
        };
        // Provide a way to tell buttons what to do when clicked
        PanelBuilder.prototype.setButtonClickedCallback = function (callback) {
            this.buttonClickedCallback = callback;
        };
        PanelBuilder.prototype.buttonClicked = function (model, fieldSpecification, event) {
            if (_.isFunction(fieldSpecification.displayConfiguration)) {
                // Do callback; this can't be defined in JSON, but can be defined in an application
                fieldSpecification.displayConfiguration();
                return;
            }
            if (!this.buttonClickedCallback) {
                console.log("No buttonClickedCallback set in panelBuilder", this, fieldSpecification);
                throw new Error("No buttonClickedCallback set for PanelBuilder");
            }
            this.buttonClickedCallback(this, model, fieldSpecification, event);
        };
        PanelBuilder.prototype.setCalculateFunctionResultCallback = function (callback) {
            this.calculateFunctionResultCallback = callback;
        };
        PanelBuilder.prototype.calculateFunctionResult = function (model, fieldSpecification) {
            if (_.isFunction(fieldSpecification.displayConfiguration)) {
                // Do callback; this can't be defined in JSON, but can be defined in an application
                return fieldSpecification.displayConfiguration();
            }
            if (!this.calculateFunctionResultCallback) {
                console.log("No calculateFunctionResultCallback set in panelBuilder", this, fieldSpecification);
                throw new Error("No calculateFunctionResultCallback set for PanelBuilder");
            }
            return this.calculateFunctionResultCallback(this, model, fieldSpecification, fieldSpecification.displayConfiguration);
        };
        // This will only be valid during the building process for a page
        PanelBuilder.prototype.helpPageURLForField = function (fieldSpecification) {
            var section = fieldSpecification.helpSection;
            if (!section)
                section = this.currentHelpSection;
            var pageID = fieldSpecification.helpPage;
            if (!pageID)
                pageID = this.currentHelpPage;
            var helpID = fieldSpecification.helpID;
            if (!helpID)
                helpID = fieldSpecification.id;
            var url = "";
            if (section && pageID) {
                url = '/help/' + section + "/help_" + pageID + '.html';
                if (helpID)
                    url += '#' + helpID;
            }
            return url;
        };
        // TODO: Fix all this so attaching actual JavaScript function not text to be interpreted
        PanelBuilder.prototype.htmlForInformationIcon = function (url) {
            if (!url)
                return "";
            var template = '<img src="{iconFile}" height=16 width=16 title="{title}" onclick="window.narraFirma_launchApplication(\'{url}\', \'help\')">';
            var replacements = {
                // TODO: Remove unused images from project
                // "/images/Info_blauw.png"
                // "/images/Blue_question_mark_icon.svg"
                iconFile: this.applicationDirectory + 'images/Information_icon4.svg',
                title: "Click to open help system window on this topic...",
                url: url
            };
            function replace(template, values) {
                var result = template;
                for (var key in replacements) {
                    result = result.split('{' + key + '}').join(replacements[key]);
                    // result = result.replace(new RegExp('{' + key + '}', 'gi'), replacements[key]);
                }
                return result;
            }
            return replace(template, replacements);
        };
        PanelBuilder.prototype.addAllowedHTMLToPrompt = function (text) {
            try {
                var result = sanitizeHTML.generateSanitizedHTMLForMithril(text);
                return result;
            }
            catch (error) {
                alert(error);
                return text;
            }
        };
        PanelBuilder.prototype.substituteCalculatedResultInBaseText = function (baseText, calculatedText) {
            var newLabelText;
            if (baseText.indexOf(ResultTagToReplace) !== -1) {
                newLabelText = baseText.replace(ResultTagToReplace, calculatedText);
            }
            else {
                newLabelText = baseText + " " + calculatedText;
            }
            return newLabelText;
        };
        PanelBuilder.prototype.buildQuestionLabel = function (fieldSpecification) {
            // TODO: Generalize this css class name
            var prompt = fieldSpecification.displayPrompt;
            prompt = this.addAllowedHTMLToPrompt(prompt);
            var displayClass = "questionPrompt";
            if (fieldSpecification.displayClass)
                displayClass += " " + fieldSpecification.displayClass;
            var result = [m("span", { "class": displayClass, "style": prompt ? "display: block" : "display: none" }, prompt)];
            return result;
        };
        return PanelBuilder;
    }());
    addStandardPlugins();
    return PanelBuilder;
});

define('js/applicationPanelSpecifications/dashboard/page_dashboard',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_dashboard",
        displayName: "Home",
        panelFields: [
            {
                id: "project_homepage_label",
                valueType: "none",
                displayType: "html",
                displayPrompt: "This is the home page of your <a href=\"//www.workingwithstories.org\" target=\"_blank\">participatory narrative inquiry</a> project. \n                Click on any of the colored boxes below to work on that phase of your project."
            },
            {
                id: "project_mainDashboardPNIPhasesDiagram",
                valueType: "none",
                displayType: "html",
                displayPrompt: "\n            <img class=\"narrafirma-pni-phases-image\" src=\"images/PNIPhasesDiagram-trimmed.png\" alt=\"NarraFirma sections (click to navigate)\" usemap=\"#pniphasesmap\"></img>\n            <map name=\"pniphasesmap\">\n            <area shape=\"rect\" coords=\"2,116,132,236\" href=\"javascript:narrafirma_openPage('page_planning')\" alt=\"Planning\" \n            title=\"Click here to make decisions about how your project will proceed.\">\n            \n            <area shape=\"rect\" coords=\"285,20,415,138\" href=\"javascript:narrafirma_openPage('page_collection')\" alt=\"Collection\" \n            title=\"Click here to choose story collection methods, write questions, design sessions and forms, and collect stories.\">\n            \n            <area shape=\"rect\" coords=\"563,115,694,235\" href=\"javascript:narrafirma_openPage('page_catalysis')\" alt=\"Catalysis\" \n            title=\"Click here to look for patterns in stories and answers to questions.\">\n            \n            <area shape=\"rect\" coords=\"413,170,542,287\" href=\"javascript:narrafirma_openPage('page_sensemaking')\" alt=\"Sensemaking\" \n            title=\"Click here to help people use stories and patterns to think together.\">\n            \n            <area shape=\"rect\" coords=\"284,324,414,443\" href=\"javascript:narrafirma_openPage('page_intervention')\" alt=\"Intervention\" \n            title=\"Click here to plan and record interventions in the narrative life of the community or organization.\">\n            \n            <area shape=\"rect\" coords=\"152,171,282,289\" href=\"javascript:narrafirma_openPage('page_return')\" alt=\"Return\" \n            title=\"Click here to reflect on the project and support the return of stories to the community or organization.\">\n            </map>"
            },
            {
                id: "project_mainDashboardStoryCollectionStatus",
                valueType: "none",
                displayType: "dashboardStoryCollectionStatusDisplay",
                displayPrompt: "Story collections"
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/administration/page_administration',["require", "exports", "../../versions"], function (require, exports, versions) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_administration",
        displayName: "Administration",
        panelFields: [
            {
                id: "administrationVersionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "NarraFirma version: " + versions.narrafirmaApplication
            },
            {
                id: "administrationIntroLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In this section you can do house-keeping tasks like backing up your data."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/administration/page_projectOptions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_projectOptions",
        displayName: "Project options",
        pageExplanation: "Change options that affect your entire project.",
        pageCategories: "manage",
        headerAbove: "Manage",
        panelFields: [
            {
                id: "projectOptions_header",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can set project-wide options."
            },
            {
                id: "projectOptions_generalsettings_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "General options"
            },
            {
                id: "projectOptions_projectNickname",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Nickname",
                displayPrompt: "Enter a <strong>project nickname</strong> you want to appear on within-the-project pages and reports.\n                (The project's real name will still appear in your browser's address bar and development console, \n                in the list of projects you see before you open the project, in any exported files, and in the project's stored files.\n                If you want to change this project's actual name, export its full history, create a new project with a different name,\n                and import the project file to that empty project.)"
            },
            {
                id: "projectOptions_showPageExplanations",
                valueType: "string",
                displayType: "radiobuttons",
                valueOptions: ["yes", "no"],
                displayName: "Verbose",
                displayPrompt: "Would you like to see an <strong>explanation</strong> of each page \n                next to its link on the section page where it appears? \n                (If no choice is made here, explanations will be shown.)"
            },
            {
                id: "projectOptions_showPageCategoryIcons",
                valueType: "string",
                displayType: "radiobuttons",
                valueOptions: ["yes", "no"],
                displayName: "Page category icons",
                displayPrompt: "When showing page explanations, would you also like to see an <strong>icon</strong> for each page,\n                so you can see what type of page it is? \n                (The categories are: manage, plan, enter, review, journal, export.) \n                (If no choice is made here, page-type icons will be shown.)"
            },
            {
                id: "projectOptions_showTips",
                valueType: "string",
                displayType: "radiobuttons",
                valueOptions: ["yes", "no"],
                displayName: "Tips",
                displayPrompt: "Would you like to see <strong>tips</strong> at the bottom of each page? \n                (If no choice is made here, tips will be shown.)"
            },
            {
                id: "projectOptions_regionalsettings_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Regional settings"
            },
            {
                id: "projectOptions_csvDelimiter",
                valueType: "string",
                displayType: "radiobuttons",
                valueOptions: ["comma", "semicolon", "tab"],
                displayName: "CSV delimiter",
                displayPrompt: "How do you want CSV files to be <strong>delimited</strong>? \n                That is, what character do you want to use to mark boundaries between cells?\n                (If no choice is made here, a comma delimiter will be used.)"
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/administration/page_importExport',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_importExport",
        displayName: "Import & Export",
        pageExplanation: "Backup or restore project data, or copy it from one project to another.",
        pageCategories: "manage",
        headerAbove: "Integrate",
        panelFields: [
            {
                id: "importExport_header",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can import project data (into an empty project), export project data (for backup or transfer), or reset (empty) a project."
            },
            // import
            {
                id: "importExport_importHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Import"
            },
            {
                id: "importExport_importLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "Importing should only be done if the current project is empty. It requires administrator permission."
            },
            {
                id: "importExport_importType",
                valueType: "string",
                displayType: "radiobuttons",
                valueOptions: ["project snapshot (with or without stories)", "project history with stories"],
                displayName: "Import type",
                displayPrompt: "How would you like to <strong>import a previously exported project</strong>? \n                If you aren't sure which option to pick, check your project file name. \n                The name of a snapshot file will include the words \"current state.\""
            },
            {
                id: "importExport_importProject",
                valueType: "none",
                displayType: "button",
                displayIconClass: "importButtonImage",
                displayConfiguration: "importProject",
                displayPrompt: "Import project"
            },
            {
                id: "importExport_otherImports",
                valueType: "none",
                displayType: "html",
                displayPrompt: "<p style=\"margin: 0\">You can also import <a href=\"javascript:narrafirma_openPage('page_designStoryForms')\">story forms</a> and \n                <a href=\"javascript:narrafirma_openPage('page_enterStories')\">stories</a>.\n                See the <a href=\"help/collection/help_page_importGuide.html\" target=\"_blank\">Import guide</a> for details.</p>"
            },
            // export
            {
                id: "importExport_exportHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Export"
            },
            {
                id: "importExport_exportType",
                valueType: "string",
                displayType: "radiobuttons",
                valueOptions: ["project snapshot without stories", "project snapshot with stories", "project history with stories"],
                displayName: "Export type",
                displayPrompt: "How would you like to <strong>export the current project</strong>? \n                A project snapshot is a copy of the project's current state, leaving out data that is no longer being used. \n                A project history is a complete backup of everything that was added to the project since its creation."
            },
            {
                id: "importExport_exportProject",
                valueType: "none",
                displayType: "button",
                displayIconClass: "exportButtonImage",
                displayConfiguration: "exportProject",
                displayPrompt: "Export project"
            },
            {
                id: "importExport_otherExports",
                valueType: "none",
                displayType: "html",
                displayPrompt: "<p style=\"margin: 0\">You can also export <a href=\"javascript:narrafirma_openPage('page_exportStories')\">story forms</a> and\n                    <a href=\"javascript:narrafirma_openPage('page_exportStories')\">story collections</a>.</p>"
            },
            // check
            {
                id: "importExport_checkHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Check"
            },
            {
                id: "importExport_showDeletedStoryCollections_label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "Deleted story collections leave disconnected stories behind.\n                If you delete many story collections, you may encounter slowdowns or memory problems.\n                Click here to see a list of the story collections you have deleted.\n                You can remove disconnected stories by exporting, resetting, and re-importing the project. Click the Help button for details.\n                "
            },
            {
                id: "importExport_showDeletedStoryCollections",
                valueType: "none",
                displayType: "button",
                displayIconClass: "showButtonImage",
                displayConfiguration: "showListOfRemovedStoryCollections",
                displayPrompt: "Show removed story collections"
            },
            // reset
            {
                id: "importExport_resetHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Reset"
            },
            {
                id: "importExport_resetLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                Resetting a project empties it out, removing all of its content. Be careful!\n                Click the Help button for details.\n                This action requires administrator permission."
            },
            {
                id: "importExport_resetProject",
                valueType: "none",
                displayType: "button",
                displayIconClass: "removeButtonImage",
                displayConfiguration: "resetProject",
                displayPrompt: "Reset project"
            },
            {
                id: "project_projectFileUploaderForForm",
                valueType: "none",
                displayType: "html",
                displayPrompt: '<input type="file" id="projectFileUploader" name="files" title="Import Project from JSON File" style="display:none"/>'
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/administration/page_print',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_print",
        displayName: "Print",
        pageExplanation: "Generate a whole-project report that displays everything you entered into NarraFirma so you can use it elsewhere.",
        pageCategories: "export",
        panelFields: [
            {
                id: "print_header",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can print a project report, and you can follow links to all the other pages where you can print things."
            },
            {
                id: "print_printLabel",
                valueType: "none",
                displayType: "html",
                displayPrompt: "A project report is a summary of <strong>everything you typed</strong> into NarraFirma.\n                It does not include stories (which you can export from the <a href=\"javascript:narrafirma_openPage('page_exportStories')\">Export stories or story forms</a> page) or\n                graphs (which you can export from the <a href=\"javascript:narrafirma_openPage('page_printCatalysisReport')\">Print catalysis report</a> page).\n                "
            },
            {
                id: "print_printProjectReport",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "printProjectReport",
                displayIconClass: "printButtonImage",
                displayPrompt: "Print project report"
            },
            {
                id: "print_otherThingsToPrint",
                valueType: "none",
                displayType: "html",
                displayPrompt: "<p>Other things you can print:</p>\n                <ul>\n                    <li><a href=\"javascript:narrafirma_openPage('page_planStoryCollectionSessions')\">A story collection session agenda</a></li>\n                    <li><a href=\"javascript:narrafirma_openPage('page_printQuestionForms')\">A story form</a></li>\n                    <li><a href=\"javascript:narrafirma_openPage('page_printCatalysisReport')\">A catalysis report</a></li>\n                    <li><a href=\"javascript:narrafirma_openPage('page_printStoryCards')\">Story cards</a></li>\n                    <li><a href=\"javascript:narrafirma_openPage('page_planSensemakingSessions')\">A sensemaking session agenda</a></li>\n                    <li><a href=\"javascript:narrafirma_openPage('page_prepareProjectPresentation')\">An outline for a project presentation</a></li>\n                </ul>"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_planning',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_planning",
        displayName: "Planning",
        panelFields: [
            {
                id: "project_projectPlanningDescriptionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In this phase of PNI, you decide what you are going to do. \n                You consider your goals, topic, and participants; ponder opportunities and dangers; and firm up your plans."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_projectFacts',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_projectFacts",
        displayName: "Describe your project",
        pageExplanation: "Record some initial background information.",
        pageCategories: "plan",
        headerAbove: "Orient",
        panelFields: [
            {
                id: "project_projectFacts",
                valueType: "none",
                displayType: "label",
                displayPrompt: "Use this page to enter some information about your project that you might want to look back on later.\n                All of these questions are optional. Just answer any of them that seem useful to you.\n                (Note: For more information on this or any other page, click the Help button in the upper-right hand corner of the page.)"
            },
            {
                id: "projectFacts_factsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Facts"
            },
            {
                id: "project_startAndEndDates",
                valuePath: "project_startAndEndDates",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Project start and end",
                displayPrompt: "What are the project's starting and ending <strong>dates</strong>?"
            },
            {
                id: "project_numberOfPeopleInvolved",
                valuePath: "project_numberOfPeopleInvolved",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Number of people involved",
                displayPrompt: "How many <strong>people</strong> will be involved?"
            },
            {
                id: "project_numberOfStoriesInvolved",
                valuePath: "project_numberOfStoriesInvolved",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Number of stories involved",
                displayPrompt: "How many <strong>stories</strong> do you plan (or hope) to collect?"
            },
            {
                id: "project_eventsInvolved",
                valuePath: "project_eventsInvolved",
                valueType: "string",
                displayType: "textarea",
                displayName: "Events involved",
                displayPrompt: "Are there any particular <strong>events</strong> or time periods that are important to the project?"
            },
            {
                id: "project_locationsInvolved",
                valuePath: "project_locationsInvolved",
                valueType: "string",
                displayType: "textarea",
                displayName: "Locations involved",
                displayPrompt: "What about <strong>locations</strong>? Are there any places that matter to the project?"
            },
            {
                id: "projectFacts_peopleHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "People"
            },
            {
                id: "project_facilitators",
                valuePath: "project_facilitators",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project facilitators",
                displayPrompt: "Who is <strong>facilitating</strong> this project? Are you working alone or in a team? How is everyone involved?"
            },
            {
                id: "project_helpers",
                valuePath: "project_helpers",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project helpers",
                displayPrompt: "Is there anyone who is <strong>helping</strong> you to do this project?"
            },
            {
                id: "project_funders",
                valuePath: "project_funders",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project funders",
                displayPrompt: "Who is <strong>funding</strong> the project or allowing it to happen? Is there anyone you need to satisfy or impress?"
            },
            {
                id: "projectFacts_communityOrOrganizationHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Community or Organization"
            },
            {
                id: "project_communityOrOrganizationName",
                valuePath: "project_communityOrOrganizationName",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community/organization name",
                displayPrompt: "Describe the <strong>community or organization</strong> in which this project is taking place. What is like? (Or is it more than one?)"
            },
            {
                id: "project_communityOrOrganizationHistory",
                valuePath: "project_communityOrOrganizationHistory",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community/organization history",
                displayPrompt: "Is there anything about the <strong>history</strong> of this community or organization that is particularly important to this project?"
            },
            {
                id: "project_communityOrOrganizationCurrentState",
                valuePath: "project_communityOrOrganizationCurrentState",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community/organization state",
                displayPrompt: "What about the <strong>current state</strong> of the community or organization? What about that matters to the project?"
            },
            {
                id: "project_communityOrOrganizationConflicts",
                valuePath: "project_communityOrOrganizationConflicts",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community/organization conflicts",
                displayPrompt: "Does the project hope to address any <strong>conflicts</strong> within the community or organization?"
            },
            {
                id: "project_communityOrOrganizationDecisions",
                valuePath: "project_communityOrOrganizationDecisions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community/organization decisions",
                displayPrompt: "What about upcoming <strong>decisions</strong>? Do you hope to help the community or organization make any of those?"
            },
            {
                id: "project_communityOrOrganizationFuture",
                valuePath: "project_communityOrOrganizationFuture",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community/organization future",
                displayPrompt: "How about the <strong>future</strong>? If your project is concerned with the future, can you describe that concern?"
            },
            {
                id: "projectNotes_goalsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Goals"
            },
            {
                id: "project_goals_originStory",
                valuePath: "project_goals_originStory",
                valueType: "string",
                displayType: "textarea",
                displayName: "Origin story",
                displayPrompt: "What is the <strong>origin story</strong> of this project? What led you to do it? How did it get started? Is it part of something larger?"
            },
            {
                id: "project_goals_sourceOfEnergy",
                valuePath: "project_goals_sourceOfEnergy",
                valueType: "string",
                displayType: "textarea",
                displayName: "Source of energy",
                displayPrompt: "What is the <strong>source of energy</strong> in this project? What is its driving force?"
            },
            {
                id: "project_goals_ultimateGoal",
                valuePath: "project_goals_ultimateGoal",
                valueType: "string",
                displayType: "textarea",
                displayName: "Ultimate goal",
                displayPrompt: "What is the <strong>ultimate goal</strong> of this project? What do you hope to achieve?"
            },
            {
                id: "projectNotes_expectationsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Expectations"
            },
            {
                id: "project_expectations_prediction",
                valuePath: "project_expectations_prediction",
                valueType: "string",
                displayType: "textarea",
                displayName: "Predication",
                displayPrompt: "What is your <strong>prediction</strong> for this project? What do you think is most likely to happen in it?"
            },
            {
                id: "project_expectations_worries",
                valuePath: "project_expectations_worries",
                valueType: "string",
                displayType: "textarea",
                displayName: "Worries",
                displayPrompt: "Do you have any <strong>worries</strong> or concerns about the project?"
            },
            {
                id: "project_expectations_assumptions",
                valuePath: "project_expectations_assumptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Assumptions",
                displayPrompt: "What <strong>assumptions</strong> are you making about the project?"
            },
            {
                id: "project_expectations_experiments",
                valuePath: "project_expectations_experiments",
                valueType: "string",
                displayType: "textarea",
                displayName: "Experiments",
                displayPrompt: "Is there anything you are <strong>experimenting with</strong> in this project?"
            },
            {
                id: "project_expectations_hopes",
                valuePath: "project_expectations_hopes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Hopes",
                displayPrompt: "What do you <strong>hope</strong> will happen in this project?"
            },
            {
                id: "projectNotes_learningHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Learning"
            },
            {
                id: "project_learning_previous",
                valuePath: "project_learning_previous",
                valueType: "string",
                displayType: "textarea",
                displayName: "Previous learnings",
                displayPrompt: "What <strong>previous learnings</strong> (about anything) do you intend to rely on as you do this project?"
            },
            {
                id: "project_learning_wantToLearn",
                valuePath: "project_learning_wantToLearn",
                valueType: "string",
                displayType: "textarea",
                displayName: "Want to learn",
                displayPrompt: "What do you <strong>want to learn</strong> in this project? What do you want to know when it's done that you don't know now?"
            },
            {
                id: "project_learning_resources",
                valuePath: "project_learning_resources",
                valueType: "string",
                displayType: "textarea",
                displayName: "Resources",
                displayPrompt: "Are there any particular <strong>learning resources</strong> you intend to rely on as you carry out this project?"
            },
            {
                id: "project_learning_mentors",
                valuePath: "project_learning_mentors",
                valueType: "string",
                displayType: "textarea",
                displayName: "Mentors",
                displayPrompt: "Do you have any <strong>mentors or teachers</strong> who are helping you learn in this project? What do you hope they will do for you?"
            },
            {
                id: "project_learning_students",
                valuePath: "project_learning_students",
                valueType: "string",
                displayType: "textarea",
                displayName: "Students",
                displayPrompt: "Is there anyone you are <strong>teaching</strong> in this project? What do you hope they will learn from you?"
            },
            {
                id: "projectNotes_miscHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Miscellaneous"
            },
            {
                id: "project_title",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Project name",
                displayPrompt: "If you were to <strong>sum up this whole project</strong> into one short phrase, what would it be?"
            },
            {
                id: "project_topic",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Project topic",
                displayPrompt: "If you were to <strong>sum up the project's topic</strong> into one short phrase, what would that phrase be?"
            },
            {
                id: "project_reportStartText",
                valueType: "string",
                displayType: "textarea",
                displayName: "General notes",
                displayPrompt: "Enter any <strong>additional notes</strong> you want to remember about this project."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_planningQuestionsDraft',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_planningQuestionsDraft",
        displayName: "Answer PNI planning questions",
        pageExplanation: "Describe your project's goals, relationships, focus, range, scope, and emphasis.",
        pageCategories: "plan",
        panelFields: [
            {
                id: "project_draftQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use this page to answer some <strong>planning questions</strong> about your project: \n                its goals, relationships, focus, range, scope, and emphasis. \n                If you don't have good answers for these questions right now, don't worry; these are only <strong>draft answers</strong>.\n                You will have a chance to revise them later."
            },
            {
                id: "project_pniQuestions_goal_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project goal",
                displayPrompt: "What is the <strong>goal</strong> of the project? Why are you doing it? What will be achieved if it succeeds?"
            },
            {
                id: "project_pniQuestions_relationships_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project relationships",
                displayPrompt: "What <strong>relationships</strong> are important to the project? Who will connect with whom, how, and why? Who will tell stories, listen to stories, make sense of stories, facilitate, and so on?"
            },
            {
                id: "project_pniQuestions_focus_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project focus",
                displayPrompt: "What is the <strong>focus</strong> of the project? What is it about? What is its subject matter?"
            },
            {
                id: "project_pniQuestions_range_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project range",
                displayPrompt: "What <strong>range</strong> (or ranges) of experience will the project cover? Which perspectives will be explored? (Perhaps multiple groups, or locations, or time frames.)"
            },
            {
                id: "project_pniQuestions_scope_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project scope",
                displayPrompt: "What is the project's <strong>scope</strong>? How many people will be involved? How many stories? How many questions? How many sessions?"
            },
            {
                id: "project_pniQuestions_emphasis_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project emphasis",
                displayPrompt: "What is the project's <strong>emphasis</strong>? Which phases of PNI (planning, collection, catalysis, sensemaking, intervention, return) will be important to the project?"
            },
            {
                id: "project_pniQuestions_reminders_from_previous_project",
                valueType: "string",
                displayType: "textarea",
                displayName: "Reminders from previous project",
                displayPrompt: "If you copied any <strong>reminders</strong> from your reflections on a previous project (on the \"Reflect on the project\" page), you can paste them here."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_participantGroups',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_participantGroups",
        displayName: "Describe participant groups",
        pageExplanation: "Answer questions about your storytellers. Your answers will drive recommendations that appear on other pages.",
        pageCategories: "plan",
        headerAbove: "Contemplate",
        panelFields: [
            {
                id: "project_aboutParticipantGroups",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can think about groups of <strong>participants</strong> you want to involve in your project. \n            (Examples might be: doctors and patients; staff and customers; natives, immigrants, and tourists.)."
            },
            {
                id: "project_participantGroupsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addParticipantGroup",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Participant groups",
                displayPrompt: "Please add participant <strong>groups</strong> in the list below (typically up to three groups)."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_describeYourResources',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_describeYourResources",
        pageExplanation: "Answer questions about your resources. Your answers will drive recommendations that appear on other pages.",
        pageCategories: "plan",
        displayName: "Describe your resources",
        panelFields: [
            {
                id: "project_aboutYou",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page are a few questions about the <strong>resources</strong> available to you in carrying out your PNI project."
            },
            {
                id: "aboutYou_experience",
                valueType: "string",
                valueOptions: [
                    "none",
                    "a little",
                    "some",
                    "a lot"
                ],
                displayType: "select",
                displayName: "Experience",
                displayPrompt: "How much <strong>experience</strong> do you have facilitating PNI projects?"
            },
            {
                id: "aboutYou_help",
                valueType: "string",
                valueOptions: [
                    "none",
                    "a little",
                    "some",
                    "a lot"
                ],
                displayType: "select",
                displayName: "Help",
                displayPrompt: "How much <strong>help</strong> will you have carrying out this project?"
            },
            {
                id: "aboutYou_tech",
                valueType: "string",
                valueOptions: [
                    "none",
                    "a little",
                    "some",
                    "a lot"
                ],
                displayType: "select",
                displayName: "Technology",
                displayPrompt: "How many <strong>technological resources</strong> will you be able to use in carrying out this project?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_projectStories',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_projectStories",
        displayName: "Tell project stories",
        pageExplanation: "Go through a small story-sharing exercise that will help you imagine your project.",
        pageCategories: "plan",
        headerAbove: "Brainstorm",
        panelFields: [
            {
                id: "project_projectStories",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use this page to tell yourself some <strong>project stories</strong> about how your project might play out. \n                Project stories help you think through your project's goals and consider its risks and opportunities."
            },
            {
                id: "project_projectStoriesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_projectStory",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Project stories",
                displayPrompt: "These are the project stories you have told so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_observeStorySharing',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_observeStorySharing",
        displayName: "Observe story sharing",
        pageExplanation: "Listen to conversations and ponder how stories flow.",
        pageCategories: "plan",
        panelFields: [
            {
                id: "observeStorySharing_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use this page to think about \n                <strong>how people share stories</strong> in conversation,\n                either in general or with respect to your community or organization.\n                Here's how to use it.\n                Sit down in a group of people and watch how stories are flowing in the conversation (or not).\n                Try to encourage the flow of stories. Then answer some questions about what you saw."
            },
            {
                id: "project_storySharingObservationsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addStorySharingObservation",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Story sharing observations",
                displayPrompt: "These are the observations you have added. \n                Each one represents a conversation in which you observed and supported story sharing. \n                Click on an observation to edit it."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_createProjectStoryElements',["require", "exports"], function (require, exports) {
    "use strict";
    // TODO: Maybe store one set of diagrams for each type of question?
    // TODO: Maybe remove storiesList use and also supporting code?
    var panel = {
        id: "page_createProjectStoryElements",
        displayName: "Create project story elements",
        pageExplanation: "Go through a small sensemaking exercise that will help you plan your project.",
        pageCategories: "plan",
        panelFields: [
            {
                id: "project_storyElements_instructions",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use this page to create <b>story elements</b> based on your project stories. \n                Story elements are abstract representations of the meanings found in stories. \n                Going through this exercise can help you think about what you want to happen in your project. \n                (You can also do this exercise on paper. If you do that, skip to the bottom of this page to enter the story elements you created.)"
            },
            {
                id: "project_storyElements__questionType",
                valueType: "string",
                valueOptions: [
                    { value: "characters", label: "Characters: Who is doing things in this story?" },
                    { value: "situations", label: "Situations: What is going on in this story?" },
                    { value: "values", label: "Values: What matters to the characters in this story?" },
                    { value: "themes", label: "Themes: What is this story about?" },
                    { value: "relationships", label: "Relationships: How are the characters related in this story?" },
                    { value: "motivations", label: "Motivations: Why do the characters do what they do in this story?" },
                    { value: "beliefs", label: "Beliefs: What do people believe in this story?" },
                    { value: "conflicts", label: "Conflicts: Who or what stands in opposition in this story?" }
                ],
                displayDataOptionField: "label",
                displayType: "select",
                displayPrompt: "<b>1</b>. Choose a <b>type</b> of story element to create."
            },
            {
                id: "project_storyElements_storiesList",
                valueType: "object",
                valuePath: "project_projectStoriesList",
                displayType: "storiesList",
                displayPrompt: "\n                <b>2</b>. These are your project stories.\n                Click on the button below to copy them as clusters to the first diagram.\n            "
            },
            {
                id: "project_storyElements_copyButton1",
                valueType: "none",
                displayType: "button",
                displayIconClass: "copyButtonImage",
                displayPrompt: "Copy planning stories to clustering diagram",
                displayConfiguration: "copyPlanningStoriesToClusteringDiagram"
            },
            {
                id: "project_storyElements_answersClusteringDiagram",
                valueType: "object",
                displayType: "clusteringDiagram",
                displayPrompt: "\n                <b>3</b>. For each story, come up with as many <b>answers</b> to the above question as you can.\n                For each answer, choose <b>Create new answer</b> from the list below, then click <b>Do it</b>.\n            "
            },
            {
                id: "project_storyElements_copyButton2Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                <b>4</b>. When you have considered all of your project stories,\n                press the button below to copy your answers to the next clustering diagram. \n            "
            },
            {
                id: "project_storyElements_copyButton2",
                valueType: "none",
                displayType: "button",
                displayIconClass: "copyButtonImage",
                displayPrompt: "Copy new answers to next clustering diagram",
                displayConfiguration: "copyAnswersToClusteringDiagram"
            },
            {
                id: "project_storyElements_answerClustersClusteringDiagram",
                valueType: "object",
                displayType: "clusteringDiagram",
                displayPrompt: "\n                <b>5</b>. Now <b>cluster</b> your answers together. \n                Drag the circles to place like with like.<br> \n                <b>6</b>. Give each cluster of answers a <b>name</b> (choose <b>Create new cluster name</b>, then click <b>Do it</b>).\n            "
            },
            {
                id: "project_storyElements_copyButton3Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                <b>7</b>. Press the button below to copy your cluster names to the next diagram. \n            "
            },
            {
                id: "project_storyElements_copyButton3",
                valueType: "none",
                displayType: "button",
                displayIconClass: "copyButtonImage",
                displayPrompt: "Copy new answers to next clustering diagram",
                displayConfiguration: "copyAnswerClustersToClusteringDiagram"
            },
            {
                id: "project_storyElements_attributesClusteringDiagram",
                valueType: "object",
                displayType: "clusteringDiagram",
                displayPrompt: "\n                <b>8</b>. Describe each cluster by adding <b>attributes</b> to it.\n                Ask yourself: What is good and bad about this cluster? What helps you, and what works against you? \n                Where is the opportunity, and where is the challenge? Create at least two positive and two negative \n                attributes for each cluster. For each attribute, choose <b>Create new answer</b>, then click <b>Do it</b>.\n                (If you can't think of both positive and negative attributes, keep trying. \n                The exercise depends on the attributes being balanced.)\n            "
            },
            {
                id: "project_storyElements_copyButton4Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                <b>9</b>. Press the button below to copy your attributes to the next diagram. \n            "
            },
            {
                id: "project_storyElements_copyButton4",
                valueType: "none",
                displayType: "button",
                displayIconClass: "copyButtonImage",
                displayPrompt: "Copy new attributes to next clustering diagram",
                displayConfiguration: "copyAttributesToClusteringDiagram"
            },
            {
                id: "project_storyElements_attributeClustersClusteringDiagram",
                valueType: "object",
                displayType: "clusteringDiagram",
                displayPrompt: "\n                <b>10</b>. <b>Rearrange</b> the attributes into new, different clusters, placing like with like, as you did before.<br>\n                <b>11</b>. <b>Create new clusters</b> with new names and descriptions. These are your story elements.\n            "
            },
            {
                id: "project_storyElements_reflection_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Questions for reflection"
            },
            {
                id: "project_storyElements_reflection_do",
                valueType: "string",
                displayType: "textarea",
                displayName: "Things to do based on story elements exercise",
                displayPrompt: "What does this exercise tell you that you should <strong>remember to do</strong> in your project?"
            },
            {
                id: "project_storyElements_reflection_avoid",
                valueType: "string",
                displayType: "textarea",
                displayName: "Things to avoid based on story elements exercise",
                displayPrompt: "What does this exercise tell you that you should <strong>remember to avoid</strong> in your project?"
            },
            {
                id: "project_storyElements_reflection_otherNotes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other notes on story elements exercise",
                displayPrompt: "Is there <strong>anything else</strong> you would like to remember about this exercise?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_assessStorySharing',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_assessStorySharing",
        displayName: "Assess story sharing",
        pageExplanation: "Use an assessment quiz to consider how stories flow in your community or organization.",
        pageCategories: "plan",
        panelFields: [
            {
                id: "assessment_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use this page to think about the <strong>story sharing culture</strong> of your community or organization.\n                Before you answer these questions, \n                you should spend some time <strong>listening to people</strong> sharing stories together in the places where they normally gather."
            },
            {
                id: "assessment_narrativeFreedom",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Narrative freedom"
            },
            {
                id: "assessment_counterStories",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Countering",
                displayPrompt: "As you listened to people talk, how often did you hear a person respond to a story with another story that <strong>countered</strong> it in some way?"
            },
            {
                id: "assessment_authority",
                valueType: "string",
                valueOptions: [
                    "enthrallment",
                    "strong listening",
                    "partial listening",
                    "nothing special",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Authority",
                displayPrompt: "When someone who was obviously in <strong>authority</strong> was telling stories, how much time and attention did they get?"
            },
            {
                id: "assessment_mistakes",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Mistakes",
                displayPrompt: "How many times did you hear people tell stories about <strong>mistakes</strong>?"
            },
            {
                id: "assessment_silencing",
                valueType: "string",
                valueOptions: [
                    "warning",
                    "caution",
                    "request",
                    "joke",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Stepping in",
                displayPrompt: "When somebody started telling a story and another person <strong>stopped</strong> them, <em>how</em> did they stop them?"
            },
            {
                id: "assessment_conflict",
                valueType: "string",
                valueOptions: [
                    "demand",
                    "criticism",
                    "comment",
                    "joke",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Disagreement",
                displayPrompt: "When somebody was telling a story and another person <strong>disagreed</strong> with the storyteller, <em>how</em> did they disagree?"
            },
            {
                id: "assessment_narrativeFlow",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Narrative flow"
            },
            {
                id: "assessment_remindings",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Reminding",
                displayPrompt: "When you listened to people telling stories, did you ever hear people say \"that reminds me of the time\" and then tell a story <strong>in response</strong>?"
            },
            {
                id: "assessment_retellings",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Passing on stories",
                displayPrompt: "How often did you hear people <strong>pass on</strong> stories they heard from other people?"
            },
            {
                id: "assessment_folklore",
                valueType: "string",
                valueOptions: [
                    "none",
                    "little",
                    "some",
                    "strong",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Folklore",
                displayPrompt: "How much evidence did you find for a <strong>narrative folklore</strong> in your community or organization?"
            },
            {
                id: "assessment_storyTypes",
                valueType: "string",
                valueOptions: [
                    "no",
                    "maybe",
                    "I think so",
                    "definitely",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Story types",
                displayPrompt: "Did you hear these story <strong>genres</strong>: comic stories, tragic stories, epic stories, and funny stories?"
            },
            {
                id: "assessment_sensemaking",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Decision making",
                displayPrompt: "Did you ever see people sharing stories as they prepared to make <strong>decisions</strong>?"
            },
            {
                id: "assessment_narrativeKnowledge",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Narrative knowledge"
            },
            {
                id: "assessment_realStories",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Recountings of events",
                displayPrompt: "Did you see people tell stories that were <strong>recountings of events</strong> based on emotional experiences from particular perspectives?"
            },
            {
                id: "assessment_negotiations",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Vitality",
                displayPrompt: "How often did you see <strong>negotiations</strong> between storytellers and audiences?"
            },
            {
                id: "assessment_cotelling",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Sharing storytelling",
                displayPrompt: "Did you ever see two or more people tell a story <strong>together</strong>?"
            },
            {
                id: "assessment_blunders",
                valueType: "string",
                valueOptions: [
                    "often",
                    "sometimes",
                    "seldom",
                    "never",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Blunders",
                displayPrompt: "How often did you see someone start telling the <strong>wrong</strong> story, to the wrong people, at the wrong time?"
            },
            {
                id: "assessment_accounting",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Accountability",
                displayPrompt: "Did you see people <strong>account</strong> for their actions and choices by telling each other stories?"
            },
            {
                id: "assessment_narrativeUnity",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Narrative unity"
            },
            {
                id: "assessment_commonStories",
                valueType: "string",
                valueOptions: [
                    "impossible",
                    "difficult",
                    "doable",
                    "easy",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Common stories",
                displayPrompt: "How easy would it be to create a list of <strong>common stories</strong>, those any member of your community or organization could be expected to know?"
            },
            {
                id: "assessment_sacredStories",
                valueType: "string",
                valueOptions: [
                    "impossible",
                    "difficult",
                    "doable",
                    "easy",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Sacred stories",
                displayPrompt: "How easy would it be to create a list of <strong>sacred stories</strong>, those important to understanding the community or organization?"
            },
            {
                id: "assessment_condensedStories",
                valueType: "string",
                valueOptions: [
                    "impossible",
                    "difficult",
                    "doable",
                    "easy",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Condensed stories",
                displayPrompt: "How easy would it be to create a list of <strong>condensed stories</strong>, in the form of proverbs or references?"
            },
            {
                id: "assessment_intermingling",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Intermingling",
                displayPrompt: "How often were the stories you heard <strong>intermingled</strong> with each other?"
            },
            {
                id: "assessment_culture",
                valueType: "string",
                valueOptions: [
                    "impossible",
                    "difficult",
                    "doable",
                    "easy",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Culture",
                displayPrompt: "How easy would it be to describe the unique story sharing <strong>culture</strong> of your community or organization?"
            },
            {
                id: "assessment_result_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Your score"
            },
            {
                id: "assessment_result_freedomSubscore",
                valueType: "none",
                displayType: "quizScoreResult",
                displayConfiguration: [
                    "assessment_counterStories",
                    "assessment_authority",
                    "assessment_mistakes",
                    "assessment_silencing",
                    "assessment_conflict"
                ],
                displayPrompt: "Narrative <strong>freedom</strong>:"
            },
            {
                id: "assessment_result_flowSubscore",
                valueType: "none",
                displayType: "quizScoreResult",
                displayConfiguration: [
                    "assessment_remindings",
                    "assessment_retellings",
                    "assessment_folklore",
                    "assessment_storyTypes",
                    "assessment_sensemaking"
                ],
                displayPrompt: "Narrative <strong>flow</strong>:"
            },
            {
                id: "assessment_result_knowledgeSubscore",
                valueType: "none",
                displayType: "quizScoreResult",
                displayConfiguration: [
                    "assessment_realStories",
                    "assessment_negotiations",
                    "assessment_cotelling",
                    "assessment_blunders",
                    "assessment_accounting"
                ],
                displayPrompt: "Narrative <strong>knowledge</strong>:"
            },
            {
                id: "assessment_result_unitySubscore",
                valueType: "none",
                displayType: "quizScoreResult",
                displayConfiguration: [
                    "assessment_commonStories",
                    "assessment_sacredStories",
                    "assessment_condensedStories",
                    "assessment_intermingling",
                    "assessment_culture"
                ],
                displayPrompt: "Narrative <strong>unity</strong>:"
            },
            {
                id: "assessment_result_grandTotal",
                valueType: "none",
                displayType: "quizScoreResult",
                displayConfiguration: [
                    "assessment_counterStories",
                    "assessment_authority",
                    "assessment_mistakes",
                    "assessment_silencing",
                    "assessment_conflict",
                    "assessment_remindings",
                    "assessment_retellings",
                    "assessment_folklore",
                    "assessment_storyTypes",
                    "assessment_sensemaking",
                    "assessment_realStories",
                    "assessment_negotiations",
                    "assessment_cotelling",
                    "assessment_blunders",
                    "assessment_accounting",
                    "assessment_commonStories",
                    "assessment_sacredStories",
                    "assessment_condensedStories",
                    "assessment_intermingling",
                    "assessment_culture"
                ],
                displayPrompt: "Combined score:"
            },
            {
                id: "assessment_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Here you can record some <strong>notes</strong> or comments about this assessment."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_revisePNIPlanningQuestions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_revisePNIPlanningQuestions",
        displayName: "Revise PNI planning questions",
        pageExplanation: "Revisit your project's goals, relationships, focus, range, scope, and emphasis.",
        pageCategories: "plan",
        headerAbove: "Wrap Up",
        panelFields: [
            {
                id: "project_improvePlanningDrafts",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can review and improve your draft answers to the <strong>PNI planning questions</strong>, based on your consideration of project aspects and your project stories."
            },
            {
                id: "project_pniQuestions_copyDraftsButton",
                valueType: "none",
                displayType: "button",
                displayIconClass: "copyButtonImage",
                displayConfiguration: "copyDraftPNIQuestionVersionsIntoAnswers",
                displayPrompt: "Copy your draft versions into any empty answers below"
            },
            {
                id: "project_pniQuestions_goal_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project goal",
                displayPrompt: "What is the <strong>goal</strong> of the project? Why are you doing it? What will be achieved if it succeeds?"
            },
            {
                id: "project_pniQuestions_relationships_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project relationships",
                displayPrompt: "What <strong>relationships</strong> are important to the project? Who will connect with whom, how, and why? Who will tell stories, listen to stories, make sense of stories, facilitate, and so on?"
            },
            {
                id: "project_pniQuestions_focus_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project focus",
                displayPrompt: "What is the <strong>focus</strong> of the project? What is it about? What is its subject matter?"
            },
            {
                id: "project_pniQuestions_range_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project range",
                displayPrompt: "What <strong>range</strong> (or ranges) of experience will the project cover? Which perspectives will be explored? (Perhaps multiple groups, or locations, or time frames.)"
            },
            {
                id: "project_pniQuestions_scope_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project scope",
                displayPrompt: "What is the project's <strong>scope</strong>? How many people will be involved? How many stories? How many questions? How many sessions?"
            },
            {
                id: "project_pniQuestions_emphasis_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project emphasis",
                displayPrompt: "What is the project's <strong>emphasis</strong>? Which phases of PNI (planning, collection, catalysis, sensemaking, intervention, return) will be important to the project?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_writeProjectSynopsis',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_writeProjectSynopsis",
        displayName: "Write project synopsis",
        pageExplanation: 'Write a summary paragraph you can use to explain your project.',
        pageCategories: "plan",
        panelFields: [
            {
                id: "project_synopsis_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can write your project <strong>synopsis</strong>, a one or two sentence summary of what matters most about your project."
            },
            {
                id: "project_synopsis",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project synopsis",
                displayPrompt: "Your synopsis should briefly <strong>summarize</strong> the project, so that anyone who hears about it can quickly understand what you are doing and why."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_buildPrivacyPolicy',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_buildPrivacyPolicy",
        pageExplanation: "Create a policy you can show to participants who have questions about privacy.",
        pageCategories: "plan",
        displayName: "Build privacy policy",
        panelFields: [
            {
                id: "project_topic_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "Use this page to craft a <strong>privacy policy</strong> you can use to show to your participants.\n                You can use simple HTML (b, i, ul/li, etc) to format your answers. For example, you might want to add a bold-faced heading to each section."
            },
            {
                id: "project_privacyPolicy_collect",
                valueType: "string",
                displayType: "textarea",
                displayName: "What will are collecting",
                displayPrompt: "Describe <strong>what you are collecting</strong> and why. \n                (For example: \"We are gathering accounts of experiences of ___ from ___ so we can ___.\")"
            },
            {
                id: "project_privacyPolicy_identification",
                valueType: "string",
                displayType: "textarea",
                displayName: "How people will be identified",
                displayPrompt: "Describe the <strong>identifying information</strong> you are asking people to provide. \n                Explain how you will ensure that no other information will be collected.\n                (For example: \"Your contribution is anonymous. Every question is optional.\")"
            },
            {
                id: "project_privacyPolicy_nondisclosure",
                valueType: "string",
                displayType: "textarea",
                displayName: "What you do not want participants to disclose",
                displayPrompt: "Explain <strong>what you do not want participants to reveal</strong>.\n               (For example: \"Do not include any identifying information about yourself or anyone else, including ___.\")"
            },
            {
                id: "project_privacyPolicy_distribution",
                valueType: "string",
                displayType: "textarea",
                displayName: "How information will be distributed",
                displayPrompt: "Explain how the collected information will be <strong>distributed</strong> and used in the project. \n                Explain who will get to see what, when, how, and why.\n                (For example: \"Your ___ will be read and discussed, along with other ___ gathered from other ___, in ___.\")"
            },
            {
                id: "project_privacyPolicy_invitation",
                valueType: "string",
                displayType: "textarea",
                displayName: "How participants will be invited to make sense of stories",
                displayPrompt: "If you want to <strong>invite the people who tell stories\n                to your sensemaking sessions</strong>, make your invitation explicit.\n                (For example: \"You are invited to join us as we discuss the stories we have gathered in this project. To learn more, ___.\")"
            },
            {
                id: "project_privacyPolicy_permission",
                valueType: "string",
                displayType: "textarea",
                displayName: "Asking for permission",
                displayPrompt: "If you want to <strong>publish</strong> any of your collected stories, ask for explicit permission. \n                (For example: \"If you do not want to give us permission to use your ___ in our ___, please contact ___.\")"
            },
            {
                id: "project_privacyPolicy_review",
                valueType: "string",
                displayType: "textarea",
                displayName: "Methods of review or change",
                displayPrompt: "Explain how your participants can <strong>review or change</strong> any information\n                they have provided to the project. When people know they can change their minds later,\n                it helps them to open up.\n                (For example: \"To review, change, or remove your ___, please contact ___.)"
            },
            {
                id: "project_privacyPolicy_copy",
                valueType: "none",
                displayType: "button",
                displayPreventBreak: true,
                displayConfiguration: "copyPrivacyPolicy",
                displayIconClass: "copyButtonImage",
                displayPrompt: "Copy Privacy Policy",
            },
            {
                id: "project_privacyPolicy_print",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "printPrivacyPolicy",
                displayIconClass: "printButtonImage",
                displayPrompt: "Print Privacy Policy",
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_reflectOnPlanningPhase',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_reflectOnPlanningPhase",
        displayName: "Reflect on the planning phase",
        pageExplanation: "Think about what happened in this part of the project.",
        pageCategories: "journal",
        panelFields: [
            {
                id: "project_phaseReflections_planning_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can answer some <strong>reflective questions</strong> \n                that will help you think about what happened."
            },
            {
                id: "project_phaseReflections_planning_happened",
                valuePath: "project_phaseReflections_planning_happened",
                valueType: "string",
                displayType: "textarea",
                displayName: "What happened",
                displayPrompt: "What <strong>happened</strong> in the planning phase of your project?"
            },
            {
                id: "project_phaseReflections_planning_surprisedAndNot",
                valuePath: "project_phaseReflections_planning_surprisedAndNot",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprised and Not",
                displayPrompt: "What <strong>surprised</strong> you? What didn't?"
            },
            {
                id: "project_phaseReflections_planning_obstaclesAndOpportunities",
                valuePath: "project_phaseReflections_planning_obstaclesAndOpportunities",
                valueType: "string",
                displayType: "textarea",
                displayName: "Obstacles and Opportunities",
                displayPrompt: "Did any <strong>obstacles</strong> or <strong>opportunities</strong> play a part in how things went? \n                Where did they come from? What did you do about them? How did that work out?"
            },
            {
                id: "project_phaseReflections_planning_learned",
                valuePath: "project_phaseReflections_planning_learned",
                valueType: "string",
                displayType: "textarea",
                displayName: "Learned",
                displayPrompt: "What did you <strong>learn</strong> from all of this?"
            },
            {
                id: "project_phaseReflections_planning_newIdeas",
                valuePath: "project_phaseReflections_planning_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "Did any <strong>new ideas</strong> come up that you want to remember in the future?"
            },
            {
                id: "project_phaseReflections_planning_issues",
                valuePath: "project_phaseReflections_planning_issues",
                valueType: "string",
                displayType: "textarea",
                displayName: "Issues",
                displayPrompt: "Are there any unresolved <strong>issues</strong> going forward?"
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/panel_addParticipantGroup',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addParticipantGroup",
        modelClass: "ParticipantGroup",
        panelFields: [
            {
                id: "participantGroup_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Participant group name",
                displayPrompt: "Please <strong>name</strong> this group of participants (for example, \"doctors\", \"students\", \"staff\")."
            },
            {
                id: "participantGroup_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> this group of participants."
            },
            {
                id: "participantGroup_statusHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Status"
            },
            {
                id: "participantGroup_status",
                valueType: "string",
                valueOptions: [
                    "very low",
                    "low",
                    "moderate",
                    "high",
                    "very high",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Status",
                displayPrompt: "What is the <strong>status</strong> of these participants in the community or organization?"
            },
            {
                id: "participantGroup_confidence",
                valueType: "string",
                valueOptions: [
                    "very low",
                    "low",
                    "medium",
                    "high",
                    "very high",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Self-confidence",
                displayPrompt: "How much <strong>self-confidence</strong> do these participants have?"
            },
            {
                id: "participantGroup_abilityHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Ability"
            },
            {
                id: "participantGroup_time",
                valueType: "string",
                valueOptions: [
                    "very little",
                    "little",
                    "some",
                    "a lot",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Free time",
                displayPrompt: "How much free <strong>time</strong> do these participants have?"
            },
            {
                id: "participantGroup_education",
                valueType: "string",
                valueOptions: [
                    "illiterate",
                    "minimal",
                    "moderate",
                    "high",
                    "very high",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Education level",
                displayPrompt: "What is the <strong>education</strong> level of these participants?"
            },
            {
                id: "participantGroup_physicalDisabilities",
                valueType: "string",
                valueOptions: [
                    "none",
                    "minimal",
                    "moderate",
                    "strong",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Physical limitations",
                displayPrompt: "Do these participants have <strong>physical limitations</strong> that will impact their participation?"
            },
            {
                id: "participantGroup_emotionalImpairments",
                valueType: "string",
                valueOptions: [
                    "none",
                    "minimal",
                    "moderate",
                    "strong",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Emotional limitations",
                displayPrompt: "Do these participants have <strong>emotional impairments</strong> that will impact their participation (such as mental illness or traumatic stress)?"
            },
            {
                id: "participantGroup_expectationsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Expectations"
            },
            {
                id: "participantGroup_performing",
                valueType: "string",
                valueOptions: [
                    "very unimportant",
                    "somewhat unimportant",
                    "somewhat important",
                    "very important",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Performance",
                displayPrompt: "For these participants, how important is <strong>performing</strong> well (with \"high marks\")?"
            },
            {
                id: "participantGroup_conforming",
                valueType: "string",
                valueOptions: [
                    "very unimportant",
                    "somewhat unimportant",
                    "somewhat important",
                    "very important",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Conformance",
                displayPrompt: "For these participants, how important is <strong>conforming</strong> (to what is \"normal\" or expected)?"
            },
            {
                id: "participantGroup_promoting",
                valueType: "string",
                valueOptions: [
                    "very unimportant",
                    "somewhat unimportant",
                    "somewhat important",
                    "very important",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Self-promotion",
                displayPrompt: "For these participants, how important is <strong>self-promotion</strong> (competing with others)?"
            },
            {
                id: "participantGroup_venting",
                valueType: "string",
                valueOptions: [
                    "very unimportant",
                    "somewhat unimportant",
                    "somewhat important",
                    "very important",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Speaking out",
                displayPrompt: "For these participants, how important is <strong>speaking out</strong> (having a say, venting, sounding off)?"
            },
            {
                id: "participantGroup_feelingsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Feelings about the project"
            },
            {
                id: "participantGroup_interest",
                valueType: "string",
                valueOptions: [
                    "very little",
                    "a little",
                    "some",
                    "a lot",
                    "extremely",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Motivated",
                displayPrompt: "How <strong>motivated</strong> are these people to participate in the project?"
            },
            {
                id: "participantGroup_feelings_project",
                valueType: "string",
                valueOptions: [
                    "negative",
                    "neutral",
                    "positive",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Feelings about project",
                displayPrompt: "How are these participants likely to <strong>feel</strong> about the project? Will they see it as a good or bad thing?"
            },
            {
                id: "participantGroup_feelings_facilitator",
                valueType: "string",
                valueOptions: [
                    "negative",
                    "neutral",
                    "positive",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Feelings about you",
                displayPrompt: "How do these participants feel about <strong>you</strong>?"
            },
            {
                id: "participantGroup_feelings_stories",
                valueType: "string",
                valueOptions: [
                    "negative",
                    "neutral",
                    "positive",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Feel about stories",
                displayPrompt: "How do these participants feel about the idea of collecting <strong>stories</strong>?"
            },
            {
                id: "participantGroup_topicHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Feelings about the topic"
            },
            {
                id: "participantGroup_topic_feeling",
                valueType: "string",
                valueOptions: [
                    "strongly negative",
                    "negative",
                    "neutral",
                    "positive",
                    "strongly positive",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Experiences with topic",
                displayPrompt: "What experiences have these participants had with the project's <strong>topic</strong>?"
            },
            {
                id: "participantGroup_topic_private",
                valueType: "string",
                valueOptions: [
                    "very private",
                    "medium",
                    "not private",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "How private",
                displayPrompt: "How <strong>private</strong> do these participants consider the topic to be?"
            },
            {
                id: "participantGroup_topic_articulate",
                valueType: "string",
                valueOptions: [
                    "hard",
                    "medium",
                    "easy",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Articulation",
                displayPrompt: "How hard will it be for these participants to <strong>articulate</strong> their feelings about the topic? Do they know how they feel?"
            },
            {
                id: "participantGroup_topic_timeframe",
                valueType: "string",
                valueOptions: [
                    "hours",
                    "days",
                    "months",
                    "years",
                    "decades",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Time period",
                displayPrompt: "How long of a <strong>time period</strong> do you need these participants to look back on?"
            },
            {
                id: "participantGroup_topic_dangerous",
                valueType: "string",
                valueOptions: [
                    "very dangerous",
                    "medium",
                    "not dangerous",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Dangerous",
                displayPrompt: "Do you think these participants will find this topic <strong>dangerous</strong> to talk about?"
            },
            {
                id: "participantGroup_topic_defensive",
                valueType: "string",
                valueOptions: [
                    "very defensive",
                    "medium",
                    "not defensive",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Defensive",
                displayPrompt: "Do you think these participants will feel <strong>defensive</strong> when asked to talk about this topic?"
            },
            {
                id: "participantGroup_topic_complicated",
                valueType: "string",
                valueOptions: [
                    "very complicated",
                    "medium",
                    "not complicated",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Complicated",
                displayPrompt: "Do you think these participants will find this topic <strong>complicated</strong> and hard to understand?"
            },
            {
                id: "participantGroup_notesHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "General notes"
            },
            {
                id: "participantGroup_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter any additional <strong>notes</strong> you want to remember about this group of participants."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/panel_projectStory',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_projectStory",
        modelClass: "ProjectStory",
        panelFields: [
            {
                id: "projectStory_scenario",
                valueType: "string",
                valueOptions: [
                    "ask me anything",
                    "magic ears",
                    "fly on the wall",
                    "because of (something about the project)",
                    "my own scenario type"
                ],
                displayType: "select",
                displayName: "Scenario",
                displayPrompt: "Start by choosing a <strong>scenario</strong> for your project story. (Click \"Help\" for explanations of these scenario types.)"
            },
            {
                id: "projectStory_outcome",
                valueType: "string",
                valueOptions: [
                    "colossal success",
                    "miserable failure",
                    "acceptable outcome",
                    "my own outcome"
                ],
                displayType: "select",
                displayName: "Outcome",
                displayPrompt: "Now choose an <strong>outcome</strong> for your story. How will it end?"
            },
            {
                id: "projectStory_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Story",
                displayPrompt: "Now tell your project story. Tell it as a <strong>future history</strong>, as though it has already happened."
            },
            {
                id: "projectStory_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Project story name",
                displayPrompt: "Please <strong>name</strong> your project story."
            },
            {
                id: "projectStory_surprise",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project story surprise",
                displayPrompt: "What <strong>surprised</strong> you about this story?"
            },
            {
                id: "projectStory_dangers",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project story opportunities or dangers",
                displayPrompt: "Describe any <strong>opportunities</strong> or <strong>dangers</strong> you see in the story."
            },
            {
                id: "projectStory_changes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project story changes",
                displayPrompt: "Now that you've told and thought about this story, are there any <strong>changes</strong> you want to make to your project plans because of it?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/panel_addStorySharingObservation',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addStorySharingObservation",
        modelClass: "StorySharingObservation",
        panelFields: [
            {
                id: "storySharingObservation_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Observation name",
                displayPrompt: "Please give this observation a <strong>name</strong>."
            },
            {
                id: "storySharingObservation_context",
                valueType: "string",
                displayType: "textarea",
                displayName: "Context",
                displayPrompt: "What do you want to remember about the <strong>context</strong> of this conversation?"
            },
            {
                id: "storySharingObservation_surprise",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprise",
                displayPrompt: "What <strong>surprised</strong> you about this conversation?"
            },
            {
                id: "storySharingObservation_drawingOutStories",
                valueType: "string",
                displayType: "textarea",
                displayName: "Drawing out stories",
                displayPrompt: "If you made any attempts to <strong>draw out stories</strong>, what worked, and what didn't?"
            },
            {
                id: "storySharingObservation_storiesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addObservedStory",
                displayName: "Observed stories",
                displayPrompt: "Describe the <strong>stories</strong> you heard."
            },
            {
                id: "observationOfStorySharing_chains",
                valueType: "string",
                displayType: "textarea",
                displayName: "Story chains",
                displayPrompt: "Were there any <strong>story chains</strong> in the conversation? If so, what were they like? "
            },
            {
                id: "storySharingObservation_themes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Themes",
                displayPrompt: "Did you notice any <strong>themes</strong> that ran throughout the stories and the conversation?"
            },
            {
                id: "storySharingObservation_lulls",
                valueType: "string",
                displayType: "textarea",
                displayName: "Lulls",
                displayPrompt: "Did you notice any <strong>lulls</strong> or pauses where people weren't sure of what to say next?"
            },
            {
                id: "storySharingObservation_style",
                valueType: "string",
                displayType: "textarea",
                displayName: "Style",
                displayPrompt: "What did you notice about the story-sharing <strong>style</strong> of the conversation? \n                How did match up with - and depart from - your expectations about what a conversational story is like?"
            },
            {
                id: "storySharingObservation_ownStyle",
                valueType: "string",
                displayType: "textarea",
                displayName: "Your style",
                displayPrompt: "What did you notice about <strong>your own</strong> story-sharing style? \n                How was it the same as, and different from, the styles of the other people in the conversation?"
            },
            {
                id: "storySharingObservation_learn",
                valueType: "string",
                displayType: "textarea",
                displayName: "Learned",
                displayPrompt: "What did you <strong>learn</strong> about conversational story sharing by listening to this conversation? "
            },
            {
                id: "storySharingObservation_help",
                valueType: "string",
                displayType: "textarea",
                displayName: "Learned about helping",
                displayPrompt: "What did you learn about <strong>helping</strong> people share stories? "
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/panel_addObservedStory',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addObservedStory",
        modelClass: "ObservedStory",
        panelFields: [
            {
                id: "observedStory_gist",
                valueType: "string",
                displayType: "textarea",
                displayName: "Gist",
                displayPrompt: "What was the <strong>gist</strong> of the story you heard?"
            },
            {
                id: "observedStory_start",
                valueType: "string",
                displayType: "textarea",
                displayName: "Start",
                displayPrompt: "How did the story <strong>start</strong>? How was its abstract offered and accepted? Did you hear any reframing or negotiation?"
            },
            {
                id: "observedStory_evaluation",
                valueType: "string",
                displayType: "textarea",
                displayName: "Evaluation",
                displayPrompt: "Describe any <strong>evaluation statements</strong> you heard as the story was told."
            },
            {
                id: "observedStory_coda",
                valueType: "string",
                displayType: "textarea",
                displayName: "Coda",
                displayPrompt: "Describe the story's <strong>coda</strong>. How did it end?"
            },
            {
                id: "observedStory_response",
                valueType: "string",
                displayType: "textarea",
                displayName: "Response",
                displayPrompt: "What was the <strong>response</strong> to the story? What happened after it was over?"
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_collection',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_collection",
        displayName: "Collection",
        panelFields: [
            {
                id: "project_collectionPhaseDescriptionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In this phase of PNI, you choose story collection methods, \n                build a library of questions, use them to create story forms, \n                and collect and review your stories."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_chooseCollectionMethods',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_chooseCollectionMethods",
        displayName: "Choose collection methods",
        pageExplanation: "Decide how you will collect stories. Describe your plans. View recommendations based on answers you entered in the Planning section.",
        pageCategories: "plan",
        headerAbove: "Plan",
        panelFields: [
            {
                id: "project_methodsIntro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can plan your story collection <strong>methods</strong>, or the ways you will collect stories."
            },
            {
                id: "SPECIAL_methodRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayConfiguration: "venues",
                displayIconClass: "recommendationsButtonImage",
                displayPrompt: "Method recommendations"
            },
            {
                id: "project_methodsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addStoryCollectionMethod",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true
                    }
                },
                displayName: "Story collection methods",
                displayPrompt: "These are the story collection methods you have added. Click on a method to edit it."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_planStoryCollectionSessions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_planStoryCollectionSessions",
        displayName: "Plan story collection sessions",
        pageExplanation: "Design printable agendas for story-sharing sessions.",
        pageCategories: "plan",
        panelFields: [
            {
                id: "project_collectionSessionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can design group <strong>sessions</strong> in which you will collect stories. (If you don't plan to collect stories using group sessions, you can skip this page.)"
            },
            {
                id: "SPECIAL_collectionSessionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayIconClass: "recommendationsButtonImage",
                displayConfiguration: "sessions",
                displayPrompt: "Recommendations for story collection sessions"
            },
            {
                id: "project_collectionSessionPlansList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addStoryCollectionSession",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true
                    }
                },
                displayName: "Story collection session plans",
                displayPrompt: "These are the session plans you have added. Click on a plan to edit it. (A single plan can be used for multiple sessions.)"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_writeStoryElicitingQuestions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_writeStoryElicitingQuestions",
        displayName: "Write story eliciting questions",
        pageExplanation: "Build a library of questions that help people think of experiences to recount.",
        pageCategories: "enter",
        headerAbove: "Design",
        panelFields: [
            {
                id: "project_elicitingQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can build a \n                <strong>library of questions you will invite people to answer by telling stories</strong>.\n                You will draw on this library as you build your story forms. \n                Each story form must contain at least one story-eliciting question.\n                "
            },
            {
                id: "project_elicitingQuestionsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addElicitingQuestion",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        validateAdd: "requireShortNameAndType",
                        validateEdit: "requireShortNameAndType",
                        duplicateButton: true,
                        navigationButtons: true,
                        columnsToDisplay: ["elicitingQuestion_text", "elicitingQuestion_shortName"]
                    }
                },
                displayName: "Story eliciting questions",
                displayPrompt: "These are the eliciting questions you have added. Click on a question to edit it."
            },
            {
                id: "SPECIAL_elicitingQuestionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayIconClass: "recommendationsButtonImage",
                displayConfiguration: "elicitingQuestions",
                displayPrompt: "Recommendations for eliciting questions"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_writeQuestionsAboutStories',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_writeQuestionsAboutStories",
        displayName: "Write questions about stories",
        pageExplanation: "Build a library of questions that help people interpret their stories.",
        pageCategories: "enter",
        panelFields: [
            {
                id: "project_storyQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can build a <strong>library of questions about stories</strong>.\n                You will draw on this library as you build your story forms. "
            },
            {
                id: "project_storyQuestionsList",
                valueType: "array",
                displayType: "grid",
                displayName: "Story questions",
                displayPrompt: "These are the questions you have added. Click on a question to edit it.",
                displayConfiguration: {
                    itemPanelID: "panel_addStoryQuestion",
                    gridConfiguration: {
                        columnsToDisplay: ["storyQuestion_text", "storyQuestion_type", "storyQuestion_shortName", "storyQuestion_options"],
                        validateAdd: "requireShortNameTypeOptionsAndTrimming",
                        validateEdit: "requireShortNameTypeOptionsAndTrimming",
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                        navigationButtons: true,
                    }
                }
            },
            {
                id: "SPECIAL_storyQuestionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayIconClass: "recommendationsButtonImage",
                displayConfiguration: "storyQuestions",
                displayPrompt: "Recommendations for story questions"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_writeQuestionsAboutParticipants',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_writeQuestionsAboutParticipants",
        displayName: "Write questions about participants",
        pageExplanation: "Build a library of questions about people.",
        pageCategories: "enter",
        panelFields: [
            {
                id: "project_participantQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can build a <strong>library of questions about people</strong>.\n            You will draw on this library as you build your story forms. "
            },
            {
                id: "project_participantQuestionsList",
                valueType: "array",
                displayType: "grid",
                displayName: "Participant questions",
                displayPrompt: "These are the questions you have added. Click on a question to edit it.",
                displayConfiguration: {
                    itemPanelID: "panel_addParticipantQuestion",
                    gridConfiguration: {
                        columnsToDisplay: ["participantQuestion_text", "participantQuestion_type", "participantQuestion_shortName", "participantQuestion_options"],
                        validateAdd: "requireShortNameTypeOptionsAndTrimming",
                        validateEdit: "requireShortNameTypeOptionsAndTrimming",
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                        navigationButtons: true,
                    }
                }
            },
            {
                id: "SPECIAL_participantQuestionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayIconClass: "recommendationsButtonImage",
                displayConfiguration: "participantQuestions",
                displayPrompt: "Recommendations for participant questions"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_designStoryForms',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_designStoryForms",
        displayName: "Build story forms",
        pageExplanation: "Draw from your question libraries to create surveys and interview scripts.",
        pageCategories: "enter",
        panelFields: [
            {
                id: "storyForms_Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can design one or more <strong>story forms</strong> for your project. \n                Choose from the library of questions you already created to create the form your participants \n                will use to tell their stories and answer questions about them.\n                You can also generate a story form using all existing questions or import one from a CSV file."
            },
            {
                id: "project_storyForms",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addStoryForm",
                    gridConfiguration: {
                        validateAdd: "requireShortName",
                        validateEdit: "requireShortName",
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                        navigationButtons: true,
                        columnsToDisplay: ["questionForm_shortName", "questionForm_title", "questionForm_startText"]
                    }
                },
                displayName: "Story forms",
                displayPrompt: "These are the story forms you have added. Click on a story form to edit it."
            },
            {
                id: "storyForms_generate_Header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Generate a story form"
            },
            {
                id: "storyForms_generate_label",
                valueType: "none",
                displayType: "label",
                displayClass: "narrafirma-question-type-label-not-white",
                displayPrompt: "You can start a story form by filling it with <strong>all of the questions you have created</strong>. \n                This will place it into the list above. Afterwards, you can fine-tune its appearance. "
            },
            {
                id: "project_createStoryFormFromCreatedQuestions",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "autoFillStoryForm",
                displayPreventBreak: true,
                displayIconClass: "generateButtonImage",
                displayPrompt: "Generate story form using all existing questions..."
            },
            {
                id: "storyForms_import_Header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Import a story form"
            },
            {
                id: "storyForms_import_label",
                valueType: "none",
                displayType: "label",
                displayClass: "narrafirma-question-type-label-not-white",
                displayPrompt: "You can <strong>import a story form</strong> you created in another project or in a spreadsheet. (For details on the import format, see the help system.) "
            },
            {
                id: "project_csvQuestionOverwriteOption",
                valuePath: "project_csvQuestionOverwriteOption",
                valueType: "string",
                valueOptions: [
                    "always replace existing questions with matching questions from the CSV file",
                    "always keep existing questions; ignore any matching questions in the CSV file",
                    "show me the list of existing questions and ask if I still want to import the file",
                    "ask me whether to replace each existing question",
                    "stop the import if any existing questions are found"
                ],
                displayType: "select",
                displayName: "Question overwrite policy",
                displayPrompt: "During the import process, what do you want to do <strong>when a question already exists</strong> in the project? \n                (Questions match if their short names match. This only applies to story and participant questions. Eliciting questions are always overwritten.)",
            },
            {
                id: "storyForms_import_delimiter_label",
                valueType: "none",
                displayType: "label",
                displayClass: "narrafirma-question-type-label-not-white",
                displayPrompt: "Also note: You can change your CSV delimiter in the \"Project options\" page under \"Project administration."
            },
            {
                id: "project_importStoryFormAndDataFromCSV",
                valueType: "none",
                displayType: "button",
                displayPreventBreak: true,
                displayIconClass: "importButtonImage",
                displayConfiguration: "importCSVQuestionnaire",
                displayPrompt: "Import CSV story form file..."
            },
            {
                id: "storyForms_import_showImportGuide",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showImportGuide",
                displayName: "Show import help",
                displayPreventBreak: true,
                displayIconClass: "showButtonImage",
                displayPrompt: "Show import help"
            },
            {
                id: "project_csvFileUploaderForForm",
                valueType: "none",
                displayType: "html",
                displayPrompt: '<input type="file" id="csvFileLoader" name="files" title="Import Story Form from CSV File" style="display:none"/>'
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_translateStoryForms',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_translateStoryForms",
        displayName: "Translate story forms",
        pageExplanation: "Enter translations so people can read your story form in multiple languages.",
        pageCategories: "enter",
        panelFields: [
            {
                id: "translateStoryForm_Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can <strong>translate</strong> your story forms into additional languages. \n                You can also import and export translations from this page.\n                For details on building multi-lingual story forms, see the help system."
            },
            {
                id: "translateStoryForm_chooseStoryForm",
                valuePath: "/clientState/storyFormName",
                valueType: "string",
                valueOptions: "/project/project_storyForms",
                valueOptionsSubfield: "questionForm_shortName",
                displayType: "select",
                displayName: "Story form",
                displayPrompt: "Please select a <strong>story form</strong> to translate."
            },
            {
                id: "translateStoryForm_defaultLanguage",
                valuePath: "/clientState/storyFormIdentifier/questionForm_defaultLanguage",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Default language",
                displayPrompt: "What is the <strong>default language</strong> of this story form?",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().storyFormIdentifier(); }
            },
            {
                id: "translateStoryForm_languageChoiceQuestion_text",
                valuePath: "/clientState/storyFormIdentifier/questionForm_languageChoiceQuestion_text",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "80",
                displayName: "Language choice question text",
                displayPrompt: "Enter a question participants will answer to <strong>choose a language</strong> in which to view the story form. \n                (This field is required; if it is empty, the story form will not show multiple languages. You can ask the question in multiple languages within the field.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().storyFormIdentifier(); }
            },
            {
                id: "translateStoryForm_languageChoiceQuestion_choices",
                valuePath: "/clientState/storyFormIdentifier/questionForm_languageChoiceQuestion_choices",
                valueType: "string",
                displayType: "textarea",
                displayName: "Languages",
                displayPrompt: "Enter a list of <strong>additional (non-default) languages</strong> participants can choose from.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().storyFormIdentifier(); }
            },
            {
                id: "translateStoryForm_dictionaryEditor",
                valueType: "none",
                displayType: "translationDictionaryEditorPanel",
                displayName: "Translation dictionary",
                displayPrompt: "",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().storyFormIdentifier(); }
            },
            {
                id: "project_csvFileUploaderForTranslations",
                valueType: "none",
                displayType: "html",
                displayPrompt: '<input type="file" id="csvFileLoader" name="files" title="Import Translations from CSV File" style="display:none"/>'
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_startStoryCollection',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_startStoryCollection",
        displayName: "Start story collection",
        pageExplanation: "Create a container that will hold a group of stories. Activate or deactivate a web survey.",
        pageCategories: "manage",
        headerAbove: "Collect",
        panelFields: [
            {
                id: "storyCollection_createCollectionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can create one or more <strong>story collections</strong> for your project. A story collection is a body of stories collected using a specific story form."
            },
            {
                id: "project_storyCollections",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addStoryCollection",
                    gridConfiguration: {
                        removeButton: true,
                        customButton: {
                            customButtonLabel: "Activate or Deactivate Web Form",
                            customButtonIconClass: "buttonWithTextImage activateOrDeactivateButtonImage",
                            callback: "toggleWebActivationOfSurvey"
                        },
                        columnsToDisplay: ["storyCollection_shortName", "storyCollection_questionnaireIdentifier", "storyCollection_activeOnWeb", "storyCollection_notes"],
                        transformDisplayedValues: function (value, fieldName) {
                            if (fieldName !== "storyCollection_activeOnWeb")
                                return value;
                            return value ? "yes" : "no";
                        }
                    }
                },
                displayName: "Story collections",
                displayPrompt: "These are the story collections you have created."
            },
            {
                id: "createNewStoryCollection",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "createNewStoryCollection",
                displayIconClass: "addButtonImage",
                displayPrompt: "Create New Story Collection",
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_printQuestionForms',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_printQuestionForms",
        displayName: "Print story forms",
        pageExplanation: "Generate a plain-text story form to to print or send.",
        pageCategories: "export",
        panelFields: [
            {
                id: "printQuestionsForm_introduction",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                On this page you can print story forms for off-line use. \n                Later, you can enter the completed forms into your story collection (see \"Enter or import stories\").\n                You can change the way your printed story form appears by entering custom CSS on the \"Build story forms\" page.\n                "
            },
            {
                id: "storyCollectionChoice_printing",
                valuePath: "/clientState/storyCollectionName",
                valueType: "string",
                valueOptions: "project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose the <strong>story collection</strong> whose story form you want to print."
            },
            {
                id: "printQuestionsForm_printFormButton",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "printStoryForm",
                displayIconClass: "printButtonImage",
                displayPrompt: "Print Story Form",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_enterStories',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_enterStories",
        displayName: "Enter or import stories",
        pageExplanation: "Input stories you collected outside of NarraFirma.",
        pageCategories: "enter",
        panelFields: [
            {
                id: "enterStories_Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can <strong>enter</strong> or import stories you collected from participants. \n                (When importing stories, please be aware that the import process can take some time, especially if you are communicating with a remote server. \n                If you import stories and you see no stories in the project, wait a minute or two, then check again.)"
            },
            {
                id: "storyCollectionChoice_enterStories",
                valuePath: "/clientState/storyCollectionName",
                valueType: "string",
                valueOptions: "project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose a <strong>story collection</strong> to add a story to."
            },
            {
                id: "project_enterStories",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "enterSurveyResult",
                displayIconClass: "addButtonImage",
                displayPrompt: "Add Story...",
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "project_checkCSVStories",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "checkCSVStories",
                displayPreventBreak: true,
                displayIconClass: "checkButtonImage",
                displayPrompt: "Check stories in CSV file (view log in browser console) ...",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "project_importCSVStories",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "importCSVStories",
                displayIconClass: "importButtonImage",
                displayPrompt: "Import stories from CSV file...",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "project_csvFileUploader",
                valueType: "none",
                displayType: "html",
                displayPrompt: '<input type="file" id="csvFileLoader" name="files" title="Import Data from CSV File" style="display:none"/>',
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_exportStories',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_exportStories",
        displayName: "Export stories or story forms",
        pageExplanation: "Save a story form or collection to a spreadsheet file.",
        pageCategories: "export",
        panelFields: [
            {
                id: "exportStories_Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can <strong>export</strong> the stories (and story form) in a story collection."
            },
            {
                id: "storyCollectionChoice_exportStories",
                valuePath: "/clientState/storyCollectionName",
                valueType: "string",
                valueOptions: "project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose a <strong>story collection</strong> to export from."
            },
            {
                id: "project_exportStoryForm",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportQuestionnaire",
                displayPreventBreak: true,
                displayIconClass: "exportButtonImage",
                displayPrompt: "Export story form (for import to NarraFirma)...",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "project_exportStoryFormForImport",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportQuestionnaireForImport",
                displayIconClass: "exportButtonImage",
                displayPreventBreak: true,
                displayPrompt: "Export story form (for import to other software)...",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "project_exportStories",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportStoryCollection",
                displayIconClass: "exportButtonImage",
                displayPrompt: "Export story collection...",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_reviewIncomingStories',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_reviewIncomingStories",
        displayName: "Review incoming stories",
        pageExplanation: "Look over your collected stories. Clean, trim, fix errors, translate.",
        pageCategories: "review, enter",
        headerAbove: "Review",
        panelFields: [
            {
                id: "collectedStoriesDuringCollectionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can see your <strong>collected stories</strong> as they come in."
            },
            {
                id: "storyCollectionChoiceX",
                valuePath: "/clientState/storyCollectionName",
                valueType: "string",
                valueOptions: "project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose a <strong>story collection</strong> to review."
            },
            {
                id: "webStoryCollection_collectedStoriesDuringCollection",
                valuePath: "/clientState/storyCollectionName",
                valueType: "none",
                displayType: "storyBrowser",
                displayPrompt: "Collected stories",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_browseGraphs',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_browseGraphs",
        displayName: "Review graphs",
        pageExplanation: "Look at patterns in your data. Notice gaps, miscommunications, confounding, other anomalies. ",
        pageCategories: "review",
        panelFields: [
            {
                id: "graphBrowserLabel",
                valueType: "none",
                displayType: "html",
                displayPrompt: "On this page you can <strong>browse through graphs</strong> that show the answers people gave to questions about their stories. \n            (You can also examine these graphs in more detail in the <a href=\"javascript:narrafirma_openPage('page_catalysis')\">Catalysis</a> section.)"
            },
            {
                id: "graphBrowserDisplay",
                valuePath: "/clientState/storyCollectionName",
                valueType: "none",
                displayType: "graphBrowser",
                displayPrompt: "",
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_stopStoryCollection',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_stopStoryCollection",
        displayName: "Stop story collection",
        pageExplanation: 'Deactivate an online survey. You can also do this on the "Start story collection" page.',
        pageCategories: "manage",
        headerAbove: "Wrap Up",
        panelFields: [
            {
                id: "webStoryCollection_stopCollectionLabel2",
                valueType: "none",
                displayType: "label",
                displayPrompt: "If you are doing story collection over the internet, you can click this button to make <em>all</em> of your web surveys <strong>unavailable</strong>. You might want to do this when you have finished collecting stories for your project. You can re-enable story collection by going back to the \"Start story collection\" page."
            },
            {
                id: "webStoryCollection_disableWebStoryFormAfterStoryCollectionButton",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "storyCollectionStop",
                displayIconClass: "activateOrDeactivateButtonImage",
                displayPrompt: "Disable All Web-based Story Collection"
            },
            {
                id: "webStoryCollection_enabledTracker2",
                valueType: "none",
                displayType: "functionResult",
                displayConfiguration: "isStoryCollectingEnabled",
                displayPrompt: "Web story collection enabled: <strong>{{result}}</strong>"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_enterCollectionSessionRecords',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_enterCollectionSessionRecords",
        displayName: "Enter story collection session records",
        pageExplanation: "Answer reflective questions about your story-sharing sessions.",
        pageCategories: "journal",
        panelFields: [
            {
                id: "project_collectionRecordsIntroductionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can enter records for any story collecting interviews or <strong>sessions</strong> you held. (If you did not hold any story collecting sessions, you can skip this page.)"
            },
            {
                id: "project_collectionSessionRecordsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addCollectionSessionRecord",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                        navigationButtons: true,
                    }
                },
                displayName: "Story collection session records",
                displayPrompt: "These are the session records you have added. Click on a record to edit it."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_reflectOnCollectionPhase',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_reflectOnCollectionPhase",
        displayName: "Reflect on the collection phase",
        pageExplanation: "Think about what happened in this part of the project.",
        pageCategories: "journal",
        panelFields: [
            {
                id: "project_phaseReflections_collection_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can answer some <strong>reflective questions</strong> \n                that will help you think about what happened."
            },
            {
                id: "project_phaseReflections_collection_happened",
                valuePath: "project_phaseReflections_collection_happened",
                valueType: "string",
                displayType: "textarea",
                displayName: "What happened",
                displayPrompt: "What <strong>happened</strong> in the colllection phase of your project?"
            },
            {
                id: "project_phaseReflections_collection_surprisedAndNot",
                valuePath: "project_phaseReflections_collection_surprisedAndNot",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprised and Not",
                displayPrompt: "What <strong>surprised</strong> you? What didn't?"
            },
            {
                id: "project_phaseReflections_collection_obstaclesAndOpportunities",
                valuePath: "project_phaseReflections_collection_obstaclesAndOpportunities",
                valueType: "string",
                displayType: "textarea",
                displayName: "Obstacles and Opportunities",
                displayPrompt: "Did any <strong>obstacles</strong> or <strong>opportunities</strong> play a part in how things went? \n                Where did they come from? What did you do about them? How did that work out?"
            },
            {
                id: "project_phaseReflections_collection_learned",
                valuePath: "project_phaseReflections_collection_learned",
                valueType: "string",
                displayType: "textarea",
                displayName: "Learned",
                displayPrompt: "What did you <strong>learn</strong> from all of this?"
            },
            {
                id: "project_phaseReflections_collection_newIdeas",
                valuePath: "project_phaseReflections_collection_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "Did any <strong>new ideas</strong> come up that you want to remember in the future?"
            },
            {
                id: "project_phaseReflections_collection_issues",
                valuePath: "project_phaseReflections_collection_issues",
                valueType: "string",
                displayType: "textarea",
                displayName: "Issues",
                displayPrompt: "Are there any unresolved <strong>issues</strong> going forward?"
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addStoryCollectionMethod',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addStoryCollectionMethod",
        modelClass: "Venue",
        panelFields: [
            {
                id: "storyCollectionMethod_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Story collection method name",
                displayPrompt: "Please give this method plan a <strong>name</strong>."
            },
            {
                id: "storyCollectionMethod_primary_type",
                valueType: "string",
                valueOptions: [
                    "one-on-one expert interviews",
                    "group interviews",
                    "peer interviews",
                    "group story sessions",
                    "surveys",
                    "journals",
                    "narrative incident reports",
                    "gleaned stories",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of method is this?"
            },
            {
                id: "storyCollectionMethod_participantGroups",
                valueType: "string",
                displayType: "textarea",
                displayName: "Participants",
                displayPrompt: "Which <strong>group</strong> (or groups) of participants will tell stories using this method?"
            },
            {
                id: "storyCollectionMethod_timeline",
                valueType: "string",
                displayType: "textarea",
                displayName: "Timeline",
                displayPrompt: "What is your <strong>timeline</strong> for collecting stories using this method?"
            },
            {
                id: "storyCollectionMethod_locations",
                valueType: "string",
                displayType: "textarea",
                displayName: "Locations",
                displayPrompt: "In what <strong>locations</strong> will stories be collected?"
            },
            {
                id: "storyCollectionMethod_participantGroupsMixing",
                valueType: "string",
                displayType: "textarea",
                displayName: "Mixing",
                displayPrompt: "What are your general plans for keeping participant groups <strong>together or apart</strong>?"
            },
            {
                id: "storyCollectionMethod_help",
                valueType: "string",
                displayType: "textarea",
                displayName: "Help",
                displayPrompt: "What <strong>help</strong> will you have collecting stories? What are your plans for organizing your help?"
            },
            {
                id: "storyCollectionMethod_resources",
                valueType: "string",
                displayType: "textarea",
                displayName: "Technology",
                displayPrompt: "What <strong>technologies</strong>, if any, will you use to collect stories?"
            },
            {
                id: "storyCollectionMethod_why",
                valueType: "string",
                displayType: "textarea",
                displayName: "Why",
                displayPrompt: "<strong>Why</strong> did you choose this method? Why is it appropriate for this context?"
            },
            {
                id: "storyCollectionMethod_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "Describe any other <strong>details</strong> of your story collection plans for this method."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addStoryCollectionSession',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addStoryCollectionSession",
        modelClass: "StoryCollectionSessionPlan",
        panelFields: [
            {
                id: "collectionSessionPlan_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Collection session plan name",
                displayPrompt: "Please give this session plan a <strong>name</strong>."
            },
            {
                id: "collectionSessionPlan_groups",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Participant groups",
                displayPrompt: "From which participant <strong>group</strong> (or groups) will people be invited?"
            },
            {
                id: "collectionSessionPlan_repetitions",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Repetitions",
                displayPrompt: "How many <strong>repetitions</strong> of the session will there be?"
            },
            {
                id: "collectionSessionPlan_duration",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Length",
                displayPrompt: "<strong>How long</strong> will each session be?"
            },
            {
                id: "collectionSessionPlan_times",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Time",
                displayPrompt: "<strong>When</strong> will these sessions take place?"
            },
            {
                id: "collectionSessionPlan_location",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Location",
                displayPrompt: "<strong>Where</strong> will these sessions take place?"
            },
            {
                id: "collectionSessionPlan_numPeople",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Number of people",
                displayPrompt: "<strong>How many people</strong> will be invited to each repetition of this session?"
            },
            {
                id: "collectionSessionPlan_participantGroupsMixing",
                valueType: "string",
                displayType: "textarea",
                displayName: "Mixing",
                displayPrompt: "What are your plans for keeping participant groups <strong>together or apart</strong>?"
            },
            {
                id: "collectionSessionPlan_materials",
                valueType: "string",
                displayType: "textarea",
                displayName: "Materials",
                displayPrompt: "What <strong>materials</strong> will this session require?"
            },
            {
                id: "collectionSessionPlan_opportunitiesAndDangers",
                valueType: "string",
                displayType: "textarea",
                displayName: "Opportunities and dangers",
                displayPrompt: "What are some of the <strong>opportunities</strong> and <strong>dangers</strong> you foresee for this session plan?"
            },
            {
                id: "collectionSessionPlan_details",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "Here you can enter other <strong>details</strong> about this session."
            },
            {
                id: "collectionSessionPlan_activitiesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addCollectionSessionActivity",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Story collection activities",
                displayPrompt: "Here you can enter some <strong>activities</strong> you plan for the session. Activities within story collection sessions can be simple instructions or complicated exercises (like the creation of timelines)."
            },
            {
                id: "collectionSessionPlan_exportCollectionSessionAgendaButton",
                valueType: "none",
                displayType: "button",
                displayIconClass: "printButtonImage",
                displayPrompt: "Print session agenda",
                displayConfiguration: "exportCollectionSessionAgenda",
                displayVisible: function (panelBuilder, model) {
                    return panelBuilder.readOnly === false;
                }
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addCollectionSessionActivity',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addCollectionSessionActivity",
        modelClass: "CollectionSessionActivity",
        panelFields: [
            {
                id: "collectionSessionActivity_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Name",
                displayPrompt: "Please give this activity a <strong>name</strong>."
            },
            {
                id: "order",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "6",
                displayName: "Order",
                displayPrompt: "Specify the <strong>order</strong> in which to do this collection activity (e.g., 1, 2a, 2b, 3)."
            },
            {
                id: "collectionSessionActivity_duration",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Length",
                displayPrompt: "<strong>How long</strong> will this activity take?"
            },
            {
                id: "collectionSessionActivity_type",
                valueType: "string",
                valueOptions: [
                    "ice-breaker",
                    "sharing stories (no task)",
                    "sharing stories (simple task)",
                    "discussing stories",
                    "looking for patterns in stories",
                    "twice-told stories exercise",
                    "timeline exercise",
                    "landscape exercise",
                    "my own exercise",
                    "break",
                    "wrap-up",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of activity is this?"
            },
            {
                id: "collectionSessionActivity_plan",
                valueType: "string",
                displayType: "textarea",
                displayName: "Plan",
                displayPrompt: "Describe the <strong>plan</strong> for this activity."
            },
            {
                id: "collectionSessionActivity_optionalParts",
                valueType: "string",
                displayType: "textarea",
                displayName: "Optional elaborations",
                displayPrompt: "Describe any optional <strong>elaborations</strong> you might or might not use in this activity."
            },
            {
                id: "collectionSessionActivity_recording",
                valueType: "string",
                displayType: "textarea",
                displayName: "Recording",
                displayPrompt: "How will stories be <strong>recorded</strong> during this activity?"
            },
            {
                id: "collectionSessionActivity_materials",
                valueType: "string",
                displayType: "textarea",
                displayName: "Materials",
                displayPrompt: "What <strong>materials</strong> will be needed for this activity?"
            },
            {
                id: "collectionSessionActivity_spaces",
                valueType: "string",
                displayType: "textarea",
                displayName: "Spaces",
                displayPrompt: "What <strong>spaces</strong> will be used for this activity?"
            },
            {
                id: "collectionSessionActivity_facilitation",
                valueType: "string",
                displayType: "textarea",
                displayName: "Facilitation",
                displayPrompt: "What sort of <strong>facilitation</strong> will be necessary for this activity?"
            },
            {
                id: "collectionSessionActivity_helping",
                valueType: "string",
                displayType: "textarea",
                displayName: "Helpers",
                displayPrompt: "What will <strong>helpers</strong> do during this activity?"
            },
            {
                id: "SPECIAL_templates_storyCollectionActivities",
                valueType: "none",
                displayType: "templateList",
                displayConfiguration: "storyCollectionActivities",
                displayPrompt: "Copy an activity from a template",
                displayIconClass: "copyButtonImage",
                displayVisible: function (panelBuilder, model) {
                    return panelBuilder.readOnly === false;
                }
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addElicitingQuestion',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addElicitingQuestion",
        modelClass: "ElicitingQuestion",
        panelFields: [
            {
                id: "elicitingQuestion_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Question",
                displayPrompt: "What <strong>question</strong> will you ask? (Remember to write a question whose answer is a story.)"
            },
            {
                id: "elicitingQuestion_shortName",
                valueType: "object",
                displayType: "shortNameQuestionConfigurationPanel",
                displayName: "Short Name",
                displayPrompt: "Enter a short <strong>name</strong> for this question, to use as a reference."
            },
            {
                id: "elicitingQuestion_import_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Import options"
            },
            {
                id: "elicitingQuestion_dataColumnName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Answer cell name",
                displayPrompt: "In your data file, what does it say <strong>in the data cell</strong> when the participant chose this eliciting question?"
            },
            {
                id: "elicitingQuestion_notesHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Your notes"
            },
            {
                id: "elicitingQuestion_type",
                valueType: "dictionary",
                valueOptions: [
                    "what happened",
                    "directed question",
                    "undirected question",
                    "point in time",
                    "event",
                    "extreme",
                    "memorable",
                    "surprise or change",
                    "people, places, things, decisions",
                    "fictional scenario",
                    "other"
                ],
                displayType: "checkboxes",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of question is this? (This choice is for your own reflection; it doesn't affect how the question is asked on the story form.)"
            },
            {
                id: "elicitingQuestion_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "You might want to record some <b>notes</b> about this question: why you want to use it, how you think people will respond, what sorts of experiences you expect it will call to mind, etc."
            },
            {
                id: "SPECIAL_templates_elicitingQuestions",
                valueType: "none",
                displayType: "templateList",
                displayConfiguration: "elicitationQuestions",
                displayPrompt: "Copy a question from a template",
                displayIconClass: "copyButtonImage",
                displayVisible: function (panelBuilder, model) {
                    return panelBuilder.readOnly === false;
                }
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addStoryQuestion',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    function matchQuestionType(model, typesToMatch) {
        var modelObject = Globals.project().tripleStore.makeObject(model, true);
        if (modelObject)
            return (typesToMatch.indexOf(modelObject.storyQuestion_type) >= 0);
        else
            return false;
    }
    function questionAllowsWriteInAnswers(model) {
        var modelObject = Globals.project().tripleStore.makeObject(model, true);
        if (modelObject)
            return (modelObject.storyQuestion_writeInTextBoxLabel && modelObject.storyQuestion_writeInTextBoxLabel != "");
        else
            return false;
    }
    var panel = {
        id: "panel_addStoryQuestion",
        modelClass: "StoryQuestion",
        panelFields: [
            {
                id: "storyQuestion_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Question",
                displayPrompt: "Enter a <strong>question</strong> to ask people about their stories."
            },
            {
                id: "storyQuestion_shortName",
                valueType: "object",
                displayType: "shortNameQuestionConfigurationPanel",
                displayName: "Short name",
                displayPrompt: "Please enter a <strong>short name</strong> we can use to refer to the question. <strong>It must be unique within the project.</strong>"
            },
            {
                id: "storyQuestion_type",
                valueType: "none",
                displayType: "questionTypeChooser",
                displayConfiguration: "story",
                displayName: "Type",
                displayPrompt: "How do you want participants to <strong>answer</strong> this question?"
            },
            {
                id: "storyQuestion_checkbox_config",
                valuePath: "storyQuestion_options",
                valueType: "object",
                displayType: "checkboxQuestionConfigurationPanel",
                displayName: "Checkbox label",
                displayPrompt: "Configure your checkbox question here.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["checkbox"]); }
            },
            {
                id: "storyQuestion_slider_config",
                valuePath: "storyQuestion_options",
                valueType: "object",
                displayType: "sliderQuestionConfigurationPanel",
                displayName: "Slider labels",
                displayPrompt: "Configure your slider question here.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["slider"]); }
            },
            {
                id: "storyQuestion_options",
                valuePath: "storyQuestion_options",
                valueType: "string",
                displayType: "textarea",
                displayName: "Options",
                displayPrompt: "Enter a list of <strong>answers</strong> participants can choose for this question, one answer per line.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["select", "radiobuttons", "checkboxes"]); }
            },
            // buttons to choose advanced options, import options, copy from template 
            {
                id: "storyQuestion_showOrHideAdvancedOptions",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showOrHideAdvancedOptions",
                displayName: "Show/hide advanced options",
                displayPreventBreak: true,
                displayIconClass: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "hideButtonImage" : "showButtonImage"; },
                displayPrompt: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "Hide advanced options" : "Show advanced options"; },
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
            },
            {
                id: "storyQuestion_showOrHideImportOptions",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showOrHideImportOptions",
                displayName: "Show/hide import options",
                displayIconClass: function (panelBuilder, model) { return Globals.clientState().showImportOptions() ? "hideButtonImage" : "showButtonImage"; },
                displayPrompt: function (panelBuilder, model) { return Globals.clientState().showImportOptions() ? "Hide import options" : "Show import options"; },
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
            },
            {
                id: "SPECIAL_templates_storyQuestions",
                valueType: "none",
                displayType: "templateList",
                displayConfiguration: "storyQuestions",
                displayPrompt: "Copy a question from a template",
                displayIconClass: "copyButtonImage",
                displayPreventBreak: false,
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
            },
            // advanced options
            {
                id: "storyQuestion_optionImageLinks",
                valuePath: "storyQuestion_optionImageLinks",
                valueType: "string",
                displayType: "textarea",
                displayName: "Option image links",
                displayPrompt: "If you want to show <strong>images</strong> for each answer, enter a series of web links (URLs) here, one per answer, in the same order as above.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["radiobuttons", "checkboxes"]) && !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "storyQuestion_optionImagesWidth",
                valuePath: "storyQuestion_optionImagesWidth",
                valueType: "string",
                displayType: "select",
                valueOptions: ["20", "30", "40", "50", "60", "70", "80", "90", "100", "110", "120", "130", "140", "150", "160", "170", "180", "190", "200"],
                displayName: "Option images width",
                displayPrompt: "How wide do you want your answer images to be, in pixels?",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["radiobuttons", "checkboxes"]) && !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "storyQuestion_listBoxRows",
                valueType: "string",
                valueOptions: ["2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"],
                displayType: "select",
                displayName: "List box rows",
                displayPrompt: "How many <strong>list box rows</strong> do you want to show for this question? Leave this field blank to show a drop-down list.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["select"]); }
            },
            {
                id: "storyQuestion_textBoxLength",
                valueType: "string",
                valueOptions: ["5", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55", "60", "65", "70", "75", "80", "85", "90", "95", "100"],
                displayType: "select",
                displayName: "Text box length",
                displayPrompt: "<strong>How long</strong> do you want this text box to be, in percentage units? Leave blank for a long text box. \n                (Note that this option only specifies the length of the text box on the screen. It does not limit the number of characters participants can enter.)",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["text"]) && !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "storyQuestion_maxNumAnswers",
                valueType: "string",
                valueOptions: ["2", "3", "4", "5", "6", "7", "8", "9", "10"],
                displayType: "select",
                displayName: "Max number of answers",
                displayPrompt: "What is the <strong>maximum number of checkboxes</strong> a participant can check? (Leave blank for no limit.)",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["checkboxes"]) && !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "storyQuestion_writeInTextBoxLabel",
                valuePath: "storyQuestion_writeInTextBoxLabel",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Write-in answer label",
                displayPrompt: "If you want participants to be able to append an extra <strong>write-in answer</strong> for this question,\n                enter a label for the write-in text box here. (To display a multi-line text area, start the label with two asterisks.)",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["boolean", "checkbox", "checkboxes", "text", "textarea", "select", "radiobuttons", "slider"]) && !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "storyQuestion_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter any <b>notes</b> you want to remember about this question.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            // import options
            {
                id: "storyQuestions_import_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Import options",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "storyQuestion_import_showImportGuide",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showImportGuide",
                displayName: "Show import help",
                displayPreventBreak: true,
                displayIconClass: "showButtonImage",
                displayPrompt: "Show import help",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "storyQuestion_import_columnName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Data column name",
                displayPrompt: "In your data file, what is the <strong>data column header</strong> for this question? (What you write here must match the header in your data file exactly. Extra spaces will be trimmed off.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "storyQuestion_import_valueType",
                valueType: "string",
                valueOptions: [
                    "Single choice",
                    "Single choice indexed",
                    "Scale",
                    "Text",
                    "Multi-choice multi-column texts",
                    "Multi-choice multi-column yes/no",
                    "Multi-choice single-column delimited",
                    "Multi-choice single-column delimited indexed",
                ],
                displayType: "select",
                displayName: "Import type",
                displayPrompt: 'In your data file, how is this question <strong>formatted</strong>? (For an explanation of these import data types, click "Show import help.")',
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "storyQuestion_import_answerNames",
                valueType: "string",
                displayType: "textarea",
                displayName: "Choice names in data file",
                displayPrompt: "If your data file has <strong>choices</strong> for this question, either in the column headers or in the data cells, what are those choices? \n                If they are the same as listed above, or if this is an indexed question type, leave this field blank. \n                If they are different, list the choices NarraFirma will find in your data file <strong>in the same order</strong> as the choices listed above.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "storyQuestion_import_writeInTextsAreInSeparateColumn",
                valueType: "string",
                valueOptions: ["yes", "no"],
                displayType: "select",
                displayName: "Write-in texts are in separate column",
                displayPrompt: "In your data file, are the <strong>write-in answers</strong> for this question in their own column?",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions() && questionAllowsWriteInAnswers(model); }
            },
            {
                id: "storyQuestion_import_minScaleValue",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Min scale value",
                displayPrompt: "What is the <strong>minimum slider value</strong> in this column? (This must be a number. If this field is blank, the default minimum of zero will be used.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions() && matchQuestionType(model, ["slider"]); }
            },
            {
                id: "storyQuestion_import_maxScaleValue",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Max scale value",
                displayPrompt: "What is the <strong>maximum slider value</strong> in this column? (This must be a number. If this field is blank, the default maximum of 100 will be used.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions() && matchQuestionType(model, ["slider"]); }
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addParticipantQuestion',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    function matchQuestionType(model, typesToMatch) {
        var modelObject = Globals.project().tripleStore.makeObject(model, true);
        if (modelObject)
            return (typesToMatch.indexOf(modelObject.participantQuestion_type) >= 0);
        else
            return false;
    }
    function questionAllowsWriteInAnswers(model) {
        var modelObject = Globals.project().tripleStore.makeObject(model, true);
        if (modelObject)
            return (modelObject.participantQuestion_writeInTextBoxLabel && modelObject.participantQuestion_writeInTextBoxLabel != "");
        else
            return false;
    }
    var panel = {
        id: "panel_addParticipantQuestion",
        modelClass: "ParticipantQuestion",
        panelFields: [
            {
                id: "participantQuestion_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Question",
                displayPrompt: "Enter a <strong>question</strong> to ask people about themselves."
            },
            {
                id: "participantQuestion_shortName",
                valueType: "object",
                displayType: "shortNameQuestionConfigurationPanel",
                displayName: "Short name",
                displayPrompt: "Please enter a short <strong>name</strong> we can use to refer to the question. <strong>It must be unique within the project.</strong>"
            },
            {
                id: "participantQuestion_type",
                valueType: "none",
                displayType: "questionTypeChooser",
                displayConfiguration: "participant",
                displayName: "Type",
                displayPrompt: "How do you want participants to <strong>answer</strong> this question?"
            },
            {
                id: "participantQuestion_checkbox_config",
                valuePath: "participantQuestion_options",
                valueType: "object",
                displayType: "checkboxQuestionConfigurationPanel",
                displayName: "Checkbox label",
                displayPrompt: "Configure your checkbox question here.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["checkbox"]); }
            },
            {
                id: "participantQuestion_slider_config",
                valuePath: "participantQuestion_options",
                valueType: "object",
                displayType: "sliderQuestionConfigurationPanel",
                displayName: "Slider labels",
                displayPrompt: "Configure your slider question here.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["slider"]); }
            },
            {
                id: "participantQuestion_options",
                valuePath: "participantQuestion_options",
                valueType: "string",
                displayType: "textarea",
                displayName: "Options",
                displayPrompt: "Enter a list of <strong>answers</strong> participants can choose for this question, one answer per line.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["select", "radiobuttons", "checkboxes"]); }
            },
            // buttons to choose advanced options, import options, copy from template 
            {
                id: "participantQuestion_showOrHideAdvancedOptions",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showOrHideAdvancedOptions",
                displayName: "Show/hide advanced options",
                displayPreventBreak: true,
                displayIconClass: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "hideButtonImage" : "showButtonImage"; },
                displayPrompt: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "Hide advanced options" : "Show advanced options"; },
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
            },
            {
                id: "participantQuestion_showOrHideImportOptions",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showOrHideImportOptions",
                displayName: "Show/hide import options",
                displayIconClass: function (panelBuilder, model) { return Globals.clientState().showImportOptions() ? "hideButtonImage" : "showButtonImage"; },
                displayPrompt: function (panelBuilder, model) { return Globals.clientState().showImportOptions() ? "Hide import options" : "Show import options"; },
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
            },
            {
                id: "SPECIAL_templates_participantQuestions",
                valueType: "none",
                displayType: "templateList",
                displayConfiguration: "participantQuestions",
                displayPrompt: "Copy a question from a template",
                displayIconClass: "copyButtonImage",
                displayVisible: function (panelBuilder, model) {
                    return panelBuilder.readOnly === false;
                }
            },
            // advanced options
            {
                id: "participantQuestion_optionImageLinks",
                valuePath: "participantQuestion_optionImageLinks",
                valueType: "string",
                displayType: "textarea",
                displayName: "Option image links",
                displayPrompt: "If you want to show <strong>images</strong> for each answer, enter a series of web links (URLs) here, one per answer, in the same order as above.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["radiobuttons", "checkboxes"]) && !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "participantQuestion_optionImagesWidth",
                valuePath: "participantQuestion_optionImagesWidth",
                valueType: "string",
                displayType: "select",
                valueOptions: ["20", "30", "40", "50", "60", "70", "80", "90", "100", "110", "120", "130", "140", "150", "160", "170", "180", "190", "200"],
                displayName: "Option images width",
                displayPrompt: "How wide do you want your answer images to be, in pixels?",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["radiobuttons", "checkboxes"]) && !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "participantQuestion_listBoxRows",
                valueType: "string",
                valueOptions: ["2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"],
                displayType: "select",
                displayName: "List box rows",
                displayPrompt: "How many <strong>list box rows</strong> do you want to show for this question? Leave this field blank to show a drop-down list.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["select"]) && !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "participantQuestion_textBoxLength",
                valueType: "string",
                valueOptions: ["5", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55", "60", "65", "70", "75", "80", "85", "90", "95", "100"],
                displayType: "select",
                displayName: "Text box length",
                displayPrompt: "<strong>How long</strong> do you want this text box to be, in percentage units? Leave blank for a long text box. \n                (Note that this option only specifies the length of the text box on the screen. It does not limit the number of characters participants can enter.)",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["text"]) && !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "participantQuestion_maxNumAnswers",
                valueType: "string",
                valueOptions: ["2", "3", "4", "5", "6", "7", "8", "9", "10"],
                displayType: "select",
                displayName: "Max number of answers",
                displayPrompt: "What is the <strong>maximum number of checkboxes</strong> a participant can check? (Leave blank for no limit.)",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["checkboxes"]) && !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "participantQuestion_writeInTextBoxLabel",
                valuePath: "participantQuestion_writeInTextBoxLabel",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Write-in answer label",
                displayPrompt: "If you want participants to be able to append an extra <strong>write-in answer</strong> for this question,\n                enter a label for the write-in text box here. (To display a multi-line text area, start the label with two asterisks.)",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["boolean", "checkbox", "checkboxes", "text", "textarea", "select", "radiobuttons", "slider"]) && !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "participantQuestion_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter any <b>notes</b> you want to remember about this question.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            // import options
            {
                id: "participantQuestions_import_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Import options",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "participantQuestion_import_showImportGuide",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showImportGuide",
                displayName: "Show import help",
                displayPreventBreak: true,
                displayIconClass: "showButtonImage",
                displayPrompt: "Show import help",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "participantQuestion_import_columnName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Data column name",
                displayPrompt: "In your data file, what is the <strong>data column header</strong> for this question? (What you write here must match the header in your data file exactly. Extra spaces will be trimmed off.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "participantQuestion_import_valueType",
                valueType: "string",
                valueOptions: [
                    "Single choice",
                    "Single choice indexed",
                    "Scale",
                    "Text",
                    "Multi-choice multi-column texts",
                    "Multi-choice multi-column yes/no",
                    "Multi-choice single-column delimited",
                    "Multi-choice single-column delimited indexed",
                ],
                displayType: "select",
                displayName: "Import type",
                displayPrompt: 'In your data file, how is this question <strong>formatted</strong>? (For an explanation of these import data types, click "Show import help.)',
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "participantQuestion_import_answerNames",
                valueType: "string",
                displayType: "textarea",
                displayName: "Choice names in data file",
                displayPrompt: "If your data file has <strong>choices</strong> for this question, either in the column headers or in the data cells, what are those choices? \n            If they are the same as listed above, or if this is an indexed question type, leave this field blank. \n                If they are different, list the choices NarraFirma will find in your data file <strong>in the same order</strong> as the choices listed above.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "participantQuestion_import_writeInTextsAreInSeparateColumn",
                valueType: "string",
                valueOptions: ["yes", "no"],
                displayType: "select",
                displayName: "Write-in texts are in separate column",
                displayPrompt: "In your data file, are the <strong>write-in answers</strong> for this question in their own column?",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions() && questionAllowsWriteInAnswers(model); ; }
            },
            {
                id: "participantQuestion_import_minScaleValue",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Min scale value",
                displayPrompt: "What is the <strong>minimum slider value</strong> in this column? (This must be a number. If this field is blank, the default minimum of zero will be used.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions() && matchQuestionType(model, ["slider"]); }
            },
            {
                id: "participantQuestion_import_maxScaleValue",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Max scale value",
                displayPrompt: "What is the <strong>maximum slider value</strong> in this column? (This must be a number. If this field is blank, the default maximum of 100 will be used.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions() && matchQuestionType(model, ["slider"]); }
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addStoryForm',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "panel_addStoryForm",
        modelClass: "StoryForm",
        panelFields: [
            {
                id: "questionForm_shortName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                required: true,
                displayName: "Short name",
                displayPrompt: "Enter a short <strong>name</strong> for the story form. It is required and must be unique within the project."
            },
            // show/hide buttons
            {
                id: "questionForm_preview",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "previewQuestionForm",
                displayName: "Question form preview",
                displayPrompt: "Preview",
                displayIconClass: "previewButtonImage",
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
            },
            {
                id: "questionForm_showOrHideAdvancedOptions",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showOrHideAdvancedOptions",
                displayName: "Show/hide advanced options",
                displayIconClass: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "hideButtonImage" : "showButtonImage"; },
                displayPrompt: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "Hide advanced options" : "Show advanced options"; },
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
            },
            {
                id: "questionForm_showOrHideImportOptions",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showOrHideImportOptions",
                displayName: "Show/hide import options",
                displayIconClass: function (panelBuilder, model) { return Globals.clientState().showImportOptions() ? "hideButtonImage" : "showButtonImage"; },
                displayPrompt: function (panelBuilder, model) { return Globals.clientState().showImportOptions() ? "Hide import options" : "Show import options"; },
                displayPreventBreak: false,
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
            },
            // start - basic
            {
                id: "questionForm_header_start",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Starting out"
            },
            {
                id: "questionForm_image",
                valueType: "string",
                displayType: "text",
                displayName: "Image",
                displayPrompt: "To show an <strong>image</strong> at the top of the form (above the title), enter a web link (URL) here.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_title",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Title",
                displayPrompt: "Enter a <strong>title</strong> to be shown at the top of the story form."
            },
            {
                id: "questionForm_startText",
                valueType: "string",
                displayType: "textarea",
                displayName: "Introduction",
                displayPrompt: "Enter an <strong>introduction</strong> to be shown at the start of the story form, after the title."
            },
            // start - advanced
            {
                id: "questionForm_video",
                valueType: "string",
                displayType: "text",
                displayName: "Video",
                displayPrompt: "To display an <strong>introductory video</strong> (after the text introduction), enter one of two things here.\n                For an <strong>mp4 file</strong> hosted on a web site, enter the video's web link (URL).\n                For a <strong>streaming</strong> video, login to your streaming service (YouTube, Vimeo, etc.), select the video,\n                click Share or Embed, copy the HTML code given to you (it should start with an \"iframe\" tag), and paste it here.\n                (You may have to set embedding permissions for the video.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_textAfterVideo",
                valueType: "string",
                displayType: "textarea",
                displayName: "Introduction",
                displayPrompt: "Enter any text you want to show <strong>after the introductory video</strong> here.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            // choose eliciting question(s) - basic
            {
                id: "questionForm_header_chooseElicitingQuestions",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Choosing a story-eliciting question"
            },
            {
                id: "questionForm_elicitingQuestions",
                valueType: "none",
                displayType: "storyFormQuestionsChooser",
                displayConfiguration: "Eliciting",
                displayName: "Eliciting questions",
                displayPrompt: "Add one or more <strong>eliciting questions</strong> to your story form, choosing from those you have already written."
            },
            // choose eliciting question(s) - advanced
            {
                id: "questionForm_chooseElicitingQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "These questions only apply if you have more than one elicitation question.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_chooseQuestionText",
                valueType: "string",
                displayType: "text",
                displayName: "Choose question text",
                displayPrompt: "How do you want to ask participants to <strong>choose a question to answer</strong>? \n                (Default: \"Please choose a question to which you would like to respond.\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_elicitingQuestionGraphName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Eliciting question graph name",
                displayPrompt: "What do you want to call the graph that shows <strong>which eliciting question people answered</strong>? (Default:  \"Eliciting question.\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_errorMessage_noElicitationQuestionChosen",
                valueType: "string",
                displayType: "text",
                displayName: "Message for no elicitation question chosen",
                displayPrompt: "If the <b>participant does not choose an elicitation question</b>, what do you want the reminder message to say?\n                (Default:  \"Please select the question to which story # is a response.\"\n                with the number sign (#) replaced with the number of the story on the page.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            // tell and name story - basic
            {
                id: "questionForm_header_enterStory",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Writing and naming a story"
            },
            {
                id: "questionForm_enterStoryText",
                valueType: "string",
                displayType: "text",
                displayName: "Enter story text",
                displayPrompt: "How do you want to ask participants to <strong>enter</strong> their story? \n                (Default:  \"Please enter your response in the box below.\")"
            },
            {
                id: "questionForm_nameStoryText",
                valueType: "string",
                displayType: "text",
                displayName: "Name story text",
                displayPrompt: "\n                How do you want to ask participants to <strong>name</strong> their story? \n                (Default: \"Please give your story a name.\")"
            },
            // tell and name story - advanced
            {
                id: "questionForm_errorMessage_noStoryText",
                valueType: "string",
                displayType: "text",
                displayName: "Message for no story text",
                displayPrompt: "If the <b>participant does not enter any text</b> for a story, what do you want the reminder message to say?\n                (Default:  \"Please enter some text for story #.\"\n                with the number sign (#) replaced with the number of the story on the page.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_errorMessage_noStoryName",
                valueType: "string",
                displayType: "text",
                displayName: "Message for no story name",
                displayPrompt: "If a <b>story has no name</b>, what do you want the reminder message to say?\n                (Default:  \"Please give story # a name.\"\n                with the number sign (#) replaced with the number of the story on the page.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            // answer questions about story - basic
            {
                id: "questionForm_header_answerQuestionsAboutStory",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Answering questions about the story"
            },
            {
                id: "questionForm_storyQuestions",
                valueType: "none",
                displayType: "storyFormQuestionsChooser",
                displayConfiguration: "Story",
                displayName: "Story questions",
                displayPrompt: "Add one or more <strong>questions about stories</strong> to your story form, choosing from those you have already written."
            },
            // answer questions about story - advanced
            {
                id: "questionForm_sliderValuePrompt",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Slider value prompt",
                displayPrompt: "\n                What do you want the popup dialog to say if the participant clicks on a <b>slider value</b> to change it? \n                (Default: \"Enter a new value.\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_sliderDoesNotApply",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Slider does-not-apply label",
                displayPrompt: "\n                What do you want the slider <b>does not apply</b> label to say? \n                (Default: \"Does not apply\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_selectNoChoiceName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Select no-choice name",
                displayPrompt: "\n                For a drop-down <strong>select</strong> question, what do you want the choice to say when the participant has made no choice? \n                (Default: \"-- select --\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_booleanYesNoNames",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Boolean yes/no names",
                displayPrompt: "\n                For a <strong>boolean</strong> (yes/no) question, what do you want the yes/no choices to actually say?\n                Please enter them with a forward slash (/) between them. \n                (Default: \"yes/no\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_maxNumAnswersPrompt",
                valueType: "string",
                displayType: "text",
                displayName: "Max number of answers prompt",
                displayPrompt: "\n                For <b>multi-choice questions with a maximum number of answers</b>, \n                how do you want to <i>tell</i> participants how many answers they can choose?\n                Enter what you want the story form to say <i>after</i> each limited-answer question text.\n                Include a hashtag sign (#) where you want the number to appear.\n                If this box is left blank, \"(Please choose up to # answers.)\" will be added to each limited-answer question text.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            // answer questions about participant - basic
            {
                id: "questionForm_header_answerQuestionsAboutParticipant",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Answering questions about the participant"
            },
            {
                id: "questionForm_participantQuestions",
                valueType: "none",
                displayType: "storyFormQuestionsChooser",
                displayConfiguration: "Participant",
                displayName: "Participant questions",
                displayPrompt: "Add one or more <strong>questions about participants</strong> to your story form, choosing from those you have already written."
            },
            // answer questions about participant - advanced
            {
                id: "questionForm_aboutYouText",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "About you text",
                displayPrompt: "\n                How would you like to introduce your <strong>participant questions</strong>? \n                (Default: \"About you\").",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            // tell another story, delete story - basic
            {
                id: "questionForm_header_tellAnotherOrDelete",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Telling another story"
            },
            {
                id: "questionForm_tellAnotherStoryText",
                valueType: "string",
                displayType: "text",
                displayName: "Tell another story text",
                displayPrompt: "\n                How do you want to ask participants if they want to <strong>tell another</strong> story? \n                (Default: \"Would you like to tell another story?\")"
            },
            // tell another story, delete story - advanced
            {
                id: "questionForm_tellAnotherStoryButtonText",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Tell another story button text",
                displayPrompt: "\n                What do you want the <strong>tell another story button</strong> to say? \n                (Default: \"Yes, I'd like to tell another story\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_deleteStoryButtonText",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Delete story button text",
                displayPrompt: "What would you like the <b>delete a story</b> button to say?\n                (Default:  \"Delete this story.\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_deleteStoryDialogPrompt",
                valueType: "string",
                displayType: "text",
                displayName: "Delete story dialog prompt",
                displayPrompt: "What would you like the <b>confirm dialog</b> button to say when somebody wants to delete a story?\n                (Default: \"Are you sure you want to delete this story?\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            // submit survey - basic
            {
                id: "questionForm_submitFormHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Finishing the form"
            },
            {
                id: "questionForm_endText",
                valueType: "string",
                displayType: "textarea",
                displayName: "End of form text",
                displayPrompt: "Please enter some <strong>closing text</strong> to be shown on the form after the survey has been accepted. \n                It might be a thank you or an invitation to participate further.\n                (Default: \"Thank you for taking the survey.\")"
            },
            {
                id: "questionForm_maxNumStories",
                valueType: "string",
                displayType: "select",
                valueOptions: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "no limit"],
                displayName: "Maximum stories",
                displayPrompt: "<b>How many stories</b> should a participant be able to enter in one session?"
            },
            {
                id: "questionForm_showSurveyResultPane",
                valueType: "string",
                displayType: "select",
                valueOptions: ["never", "only on survey", "only on data entry", "always"],
                displayName: "Show survey result pane?",
                displayPrompt: "Should participants to be able to <strong>view and copy</strong> their stories after they have been submitted?"
            },
            // submit survey - advanced
            {
                id: "questionForm_submitSurveyButtonText",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Submit survey button text",
                displayPrompt: "What would you like the button to <b>submit</b> the story form to say?\n                (Default: \"Submit Survey.\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_sendingSurveyResultsText",
                valueType: "string",
                displayType: "text",
                displayName: "Sending survey results text",
                displayPrompt: "When survey results are <b>being sent</b> to the server, what message should the participant see?\n                (Default: \"Now sending survey result to server. Please wait . . .\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_couldNotSaveSurveyText",
                valueType: "string",
                displayType: "text",
                displayName: "Could not save survey text",
                displayPrompt: "If there is a <b>problem connecting</b> to the server, what message should be shown to the participant?\n                (Default:  \"The server could not save your survey. Please try again.\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_resubmitSurveyButtonText",
                valueType: "string",
                displayType: "text",
                displayName: "Re-submit survey button text",
                displayPrompt: "If there has been a problem connecting to the server, what would you like the button to <b>re-submit</b> the story form to say?\n                (Default: \"Resubmit Survey.\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_surveyStoredText",
                valueType: "string",
                displayType: "text",
                displayName: "Survey stored",
                displayPrompt: "How would you like to tell the participant that their <b>survey has been stored</b>?\n                (Default: \"Your survey has been accepted and stored.\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_thankYouPopupText",
                valueType: "string",
                displayType: "textarea",
                displayName: "Thank you text",
                displayPrompt: "Please enter a message to be shown in the <strong>pop-up alert</strong> after the participant submits their story.\n                (Default: \"Your contribution has been added to the story collection. Thank you.\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_surveyResultPaneHeader",
                valueType: "string",
                displayType: "textarea",
                displayName: "Survey result pane header",
                displayPrompt: "What should the <strong>header above the submitted stories</strong> say?  \n            (Default: \"Here are the stories you contributed. You can copy this text and paste it somewhere else to keep your own copy of what you said.\")",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            // other customizations - basic
            {
                id: "questionForm_header_otherCustomizations",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Other customizations",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            {
                id: "questionForm_customCSS",
                valueType: "string",
                displayType: "textarea",
                displayName: "Custom CSS",
                displayPrompt: "You can enter <strong>custom CSS</strong> that modifies the survey elements here. (For more information on how this works, see the help system.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            // other customizations - advanced
            {
                id: "questionForm_customCSSForPrint",
                valueType: "string",
                displayType: "textarea",
                displayName: "Custom CSS for Printing",
                displayPrompt: "You can enter additional custom CSS to use when the story form is <strong>printed</strong>.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showAdvancedOptions(); }
            },
            //  import
            {
                id: "questionForm_import_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Import options",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_showImportGuide",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showImportGuide",
                displayName: "Show import help",
                displayPreventBreak: true,
                displayIconClass: "showButtonImage",
                displayPrompt: "Show import help",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_storyTitleColumnName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Story title column name",
                displayPrompt: "In your data file, what is the data column header for the  <strong>story title</strong>?",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_storyTextColumnName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Story text column name",
                displayPrompt: "What is the data column header for the  <strong>story text</strong>?",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_storyCollectionDateColumnName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Story collection date column name",
                displayPrompt: "What is the data column header for the  <strong>date of story collection</strong>?",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_storyFormLanguageColumnName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Story form language column name",
                displayPrompt: "What is the data column header for the <strong>language</strong> of the survey on which the story was entered?",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_columnsToAppendToStoryText",
                valueType: "string",
                displayType: "textarea",
                displayName: "Columns to append to story text",
                displayPrompt: "If you want to <strong>append additional text columns to your story text</strong>, enter the column names here, one per line. (See the help system for more details.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_textsToWriteBeforeAppendedColumns",
                valueType: "string",
                displayType: "textarea",
                displayName: "Texts in front of columns to append to story text",
                displayPrompt: 'If you entered columns to append to story texts above, enter <strong>introductory texts</strong> to be written before each appended text. (If this box is left blank, the separator " --- " will be used.)',
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_elicitingQuestionColumnName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Eliciting question column name",
                displayPrompt: "What is the data column header for the  <strong>eliciting question</strong>? (If you have only one eliciting question, you can leave this field blank.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_participantIDColumnName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Participant ID column name",
                displayPrompt: "What is the data column header for the  <strong>participant ID</strong> field? (If participants are not identified in your data file, you can leave this field blank.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_minWordsToIncludeStory",
                valueType: "string",
                displayType: "select",
                valueOptions: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "25", "30", "35", "40", "45", "50", "60", "70", "80", "90", "100"],
                displayName: "Minimum words to include story",
                displayPrompt: "<strong>How many words</strong> should a row have in its story text field to be imported?",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_columnsToIgnore",
                valueType: "string",
                displayType: "textarea",
                displayName: "Columns to ignore",
                displayPrompt: "If your story data file has <strong>columns you want to ignore</strong>, enter the column headers here, one per line.",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_stringsToRemoveFromHeaders",
                valueType: "string",
                displayType: "textarea",
                displayName: "Texts to remove from headers",
                displayPrompt: "If your story data file has <strong>texts you need to remove from your column names</strong>, enter the texts here, one per line. (See the help system for an explanation of this function.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_minScaleValue",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Minimum scale value",
                displayPrompt: "In your data file, what is the <strong>minimum value</strong> for your scale questions? (If your scales have different minima, you can enter them separately for each scale question.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_maxScaleValue",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Maximum scale value",
                displayPrompt: "What is the <strong>maximum value</strong> for your scale questions? (If your scales have different maxima, you can enter them separately for each scale question.)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_multiChoiceDelimiter",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Multi choice delimiter",
                displayPrompt: "If you have any questions of the type \"Multi-choice single-column delimited\" or \"Multi-choice single-column delimited indexed\",\n                what text <strong>separates the items</strong> within each cell? (If the separator is a space, don't enter a space here; enter the <i>word</i> \"space\".)",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_multiChoiceYesIndicator",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Multi choice yes indicator",
                displayPrompt: "If you have any questions of the type \"Multi-choice multi-column yes/no\", what text <strong>indicates a \"Yes\" answer</strong>?",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_multiChoiceYesQASeparator",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Multi choice Q-A separator",
                displayPrompt: "If you have any questions of the type \"Multi-choice multi-column yes/no\",\n                your column headers must describe the question and answer to be found in each column. \n                NarraFirma assumes that the question name will come first, followed by some text, followed by the answer name, followed by some text (e.g., \"Feel about [happy]\").\n                What is the text <strong>between the question name and the answer name</strong> in each column header?",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_import_multiChoiceYesQAEnding",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Multi choice Q-A separator",
                displayPrompt: "If you have any questions of the type \"Multi-choice multi-column yes/no\",\n                what is the text <strong>after the answer name</strong> in each column header?",
                displayVisible: function (panelBuilder, model) { return !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_checkCSVDataFile",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "checkCSVDataFileWhileEditingStoryForm",
                displayName: "CSV file check",
                displayIconClass: "checkButtonImage",
                displayPreventBreak: true,
                displayPrompt: "Check stories in CSV file (view log in browser console)...",
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly && !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_exportForm",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportStoryFormWhileEditingIt_NativeFormat",
                displayName: "Export story form",
                displayIconClass: "exportButtonImage",
                displayPrompt: "Export story form for NarraFirma-native import...",
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly && !!Globals.clientState().showImportOptions(); }
            },
            {
                id: "questionForm_exportForm",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportStoryFormWhileEditingIt_ExternalFormat",
                displayName: "Export story form",
                displayIconClass: "exportButtonImage",
                displayPrompt: "Export story form for external import...",
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly && !!Globals.clientState().showImportOptions(); }
            },
            // notes to self
            {
                id: "questionForm_otherNotesHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Notes to yourself"
            },
            {
                id: "questionForm_participantGroups",
                valueType: "string",
                displayType: "text",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>groups</strong> is this story form intended for? (This information will not appear on the form; it's just for your records.)"
            },
            {
                id: "questionForm_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "If you'd like to make any <strong>notes</strong> to yourself about this form, you can make them here. (They won't appear on the form.)"
            },
            // repeat show/hide buttons at bottom
            {
                id: "questionForm_preview_bottom",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "previewQuestionForm",
                displayName: "Question form preview",
                displayPrompt: "Preview",
                displayIconClass: "previewButtonImage",
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
            },
            {
                id: "questionForm_showOrHideAdvancedOptions_bottom",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showOrHideAdvancedOptions",
                displayName: "Show/hide advanced options",
                displayIconClass: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "hideButtonImage" : "showButtonImage"; },
                displayPrompt: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "Hide advanced options" : "Show advanced options"; },
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
            },
            {
                id: "questionForm_showOrHideImportOptions_bottom",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showOrHideImportOptions",
                displayName: "Show/hide import options",
                displayIconClass: function (panelBuilder, model) { return Globals.clientState().showImportOptions() ? "hideButtonImage" : "showButtonImage"; },
                displayPrompt: function (panelBuilder, model) { return Globals.clientState().showImportOptions() ? "Hide import options" : "Show import options"; },
                displayPreventBreak: false,
                displayVisible: function (panelBuilder, model) { return !panelBuilder.readOnly; }
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_chooseElicitingQuestion',["require", "exports"], function (require, exports) {
    "use strict";
    // this file is no longer being used
    var panel = {
        id: "panel_chooseElicitingQuestion",
        modelClass: "ElicitingQuestionChoice",
        panelFields: [
            {
                id: "order",
                valueType: "string",
                displayType: "text",
                displayName: "Order",
                displayPrompt: "Specify the order to present this eliciting question (e.g. 1, 2a, 2b, 3)"
            },
            {
                id: "elicitingQuestion",
                valueType: "string",
                valueOptions: "/project/project_elicitingQuestionsList",
                valueOptionsSubfield: "elicitingQuestion_shortName",
                displayType: "select",
                displayName: "Question choice",
                displayPrompt: "Choose a story-eliciting question."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_chooseStoryQuestion',["require", "exports"], function (require, exports) {
    "use strict";
    // this file is no longer being used
    var panel = {
        id: "panel_chooseStoryQuestion",
        modelClass: "StoryQuestionChoice",
        panelFields: [
            {
                id: "order",
                valueType: "string",
                displayType: "text",
                displayName: "Order",
                displayPrompt: "Specify the order to ask this story question (e.g. 1, 2a, 2b, 3)"
            },
            {
                id: "storyQuestion",
                valueType: "string",
                valueOptions: "/project/project_storyQuestionsList",
                valueOptionsSubfield: "storyQuestion_shortName",
                displayType: "select",
                displayName: "Question choice",
                displayPrompt: "Choose a story question."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_chooseParticipantQuestion',["require", "exports"], function (require, exports) {
    "use strict";
    // this file is no longer being used
    var panel = {
        id: "panel_chooseParticipantQuestion",
        modelClass: "ParticipantQuestionChoice",
        panelFields: [
            {
                id: "order",
                valueType: "string",
                displayType: "text",
                displayName: "Order",
                displayPrompt: "Specify the order to ask this participant question (e.g. 1, 2a, 2b, 3)"
            },
            {
                id: "participantQuestion",
                valueType: "string",
                valueOptions: "/project/project_participantQuestionsList",
                valueOptionsSubfield: "participantQuestion_shortName",
                displayType: "select",
                displayName: "Question choice",
                displayPrompt: "Choose a participant question."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addStoryCollection',["require", "exports", "../../surveyCollection"], function (require, exports, surveyCollection) {
    "use strict";
    "use strict";
    var panel = {
        id: "panel_addStoryCollection",
        modelClass: "StoryCollection",
        panelFields: [
            {
                id: "storyCollection_shortName",
                valueType: "string",
                displayType: "text",
                valuePath: "storyCollection_shortName",
                displayConfiguration: "60",
                displayReadOnly: true,
                displayName: "Story collection name",
                displayPrompt: "The <strong>name</strong> of this story collection is: ",
            },
            {
                id: "storyCollection_activeOnWeb",
                valueType: "none",
                valuePath: "storyCollection_activeOnWeb",
                displayType: "questionAnswer",
                displayName: "Active on web?",
                displayReadOnly: true,
                displayPrompt: "The <strong>web address</strong> (URL) of this story collection is: ",
                displayConfiguration: "storyCollection_activeOnWeb",
                displayURLValue: function (value, model) {
                    if (!value)
                        return "";
                    return surveyCollection.urlForSurvey(model);
                },
            },
            {
                id: "storyCollection_questionnaireIdentifier",
                valueType: "string",
                valueOptions: "/project/project_storyForms",
                valueOptionsSubfield: "questionForm_shortName",
                displayType: "select",
                displayReadOnly: true,
                displayName: "Story form",
                displayPrompt: "The <strong>story form</strong> associated with this story collection is: ",
            },
            {
                id: "storyCollection_copyStoryFormWarning",
                valueType: "string",
                displayType: "label",
                displayName: "About updating",
                displayPrompt: "\n                When you created this story collection,\n                NarraFirma placed into it a <b>snapshot copy</b> of the story form you selected <i>as it existed at that moment</i>.\n                If you have made changes to the form since then, you can update the snapshot copy by clicking the Update button below. \n                However, to avoid data loss, NarraFirma will not update the form if you have changed it in a way that conflicts with your existing data.\n                For details, click the Help button below.\n            "
            },
            {
                id: "storyCollection_checkForDataConflicts",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "checkStoryFormsForDataConflicts",
                displayPrompt: "Check for Data Conflicts",
                displayIconClass: "checkButtonImage",
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) {
                    return panelBuilder.readOnly === false;
                }
            },
            {
                id: "storyCollection_updateStoryForm",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "updateQuestionnaireForStoryCollection",
                displayPrompt: "Update Story Form",
                displayIconClass: "updateButtonImage",
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) {
                    return panelBuilder.readOnly === false;
                }
            },
            {
                id: "storyCollection_helpOnUpdatingStoryForms",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showHelpOnUpdatingStoryFormsInCollections",
                displayPrompt: "Help on Updating Story Forms",
                displayIconClass: "showButtonImage",
                displayVisible: function (panelBuilder, model) {
                    return panelBuilder.readOnly === false;
                }
            },
            {
                id: "storyCollection_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "You can enter <strong>notes</strong> on the story collection here."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/panel_addAnnotationQuestion',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    function matchQuestionType(model, typesToMatch) {
        var modelObject = Globals.project().tripleStore.makeObject(model, true);
        if (modelObject)
            return (typesToMatch.indexOf(modelObject.annotationQuestion_type) >= 0);
        else
            return false;
    }
    var panel = {
        id: "panel_addAnnotationQuestion",
        modelClass: "AnnotationQuestion",
        panelFields: [
            {
                id: "annotationQuestion_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Question",
                displayPrompt: "Enter a <strong>question</strong> you will use to annotate stories. <em>Changing this question text will have no effect on previously entered answers.</em>"
            },
            {
                id: "annotationQuestion_shortName",
                valueType: "object",
                displayType: "shortNameQuestionConfigurationPanel",
                displayName: "Short name",
                displayPrompt: "Please enter a <strong>short name</strong> we can use to refer to the question. <strong>It must be unique within the project.</strong>"
            },
            {
                id: "annotationQuestion_type",
                valueType: "none",
                displayType: "questionTypeChooser",
                displayConfiguration: "annotation",
                displayName: "Type",
                displayPrompt: "How do you want to <strong>answer</strong> this question?\n                <em>If you change this question's type after you start using the question, you may lose any previously entered answers. See the help system for details.</em>"
            },
            {
                id: "annotationQuestion_checkbox_config",
                valuePath: "annotationQuestion_options",
                valueType: "object",
                displayType: "checkboxQuestionConfigurationPanel",
                displayName: "Checkbox label",
                displayPrompt: "Configure your checkbox question here.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["checkbox"]); }
            },
            {
                id: "annotationQuestion_slider_config",
                valuePath: "annotationQuestion_options",
                valueType: "object",
                displayType: "sliderQuestionConfigurationPanel",
                displayName: "Slider labels",
                displayPrompt: "Configure your slider question here.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["slider"]); }
            },
            {
                id: "annotationQuestion_options",
                valuePath: "annotationQuestion_options",
                valueType: "object",
                displayName: "Options",
                displayType: "choiceQuestionAnswersManagementPanel",
                displayPrompt: "You can manage answers for this question here.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["select", "radiobuttons", "checkboxes"]); }
            },
            {
                id: "annotationQuestion_listBoxRows",
                valueType: "string",
                valueOptions: ["2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"],
                displayType: "select",
                displayName: "List box rows",
                displayPrompt: "How many <strong>list box rows</strong> do you want to show for this question? Leave this field blank to show a drop-down list.",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["select"]); }
            },
            {
                id: "annotationQuestion_textBoxLength",
                valueType: "string",
                valueOptions: ["5", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55", "60", "65", "70", "75", "80", "85", "90", "95", "100"],
                displayType: "select",
                displayName: "Text box length",
                displayPrompt: "<strong>How long</strong> do you want this text box to be, in percentage units? Leave blank for a long text box. \n                (Note that this option only specifies the length of the text box on the screen. It does not limit the number of characters you can enter.)",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["text"]); }
            },
            {
                id: "annotationQuestion_maxNumAnswers",
                valueType: "string",
                valueOptions: ["2", "3", "4", "5", "6", "7", "8", "9", "10"],
                displayType: "select",
                displayName: "Max number of answers",
                displayPrompt: "\n            <strong>How many checkboxes</strong> do you want to be able to check? (Leave blank for no limit.) \n                <em>If you change this maximum after you start using this question, it will have no effect on your previous answers.</em>",
                displayVisible: function (panelBuilder, model) { return matchQuestionType(model, ["checkboxes"]); }
            },
            // notes and templates
            {
                id: "annotationQuestion_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter any <b>notes</b> you want to remember about this question."
            },
            {
                id: "SPECIAL_templates_annotationQuestions",
                valueType: "none",
                displayType: "templateList",
                displayConfiguration: "annotationQuestions",
                displayPrompt: "Copy a question from a template",
                displayIconClass: "copyButtonImage",
                displayVisible: function (panelBuilder, model) { return panelBuilder.readOnly === false; }
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addCollectionSessionRecord',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addCollectionSessionRecord",
        modelClass: "CollectionSessionRecord",
        panelFields: [
            {
                id: "collectionSessionRecord_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Collection session record name",
                displayPrompt: "Please give this session record a <strong>name</strong>."
            },
            {
                id: "collectionSessionRecord_whenWhere",
                valueType: "string",
                displayType: "textarea",
                displayName: "When and where",
                displayPrompt: "<strong>When and where</strong> did the session take place?"
            },
            {
                id: "collectionSessionRecord_groups",
                valueType: "string",
                displayType: "textarea",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>groups</strong> were involved in this session?"
            },
            {
                id: "collectionSessionRecord_participants",
                valueType: "string",
                displayType: "textarea",
                displayName: "Who attended",
                displayPrompt: "Describe the <strong>participants</strong> at this session."
            },
            {
                id: "collectionSessionRecord_plan",
                valueType: "string",
                displayType: "textarea",
                displayName: "Plan",
                displayPrompt: "Which of your collection session <strong>plans</strong> did you follow in this session? (And did you stick to the plan?)"
            },
            {
                // moved this from interaction section, but cannot change id due to legacy data
                id: "collectionSessionRecord_reflections_interaction_stories",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories",
                displayPrompt: "What did you notice about the <strong>stories</strong> people told, retold, chose, and worked with during the session?"
            },
            {
                id: "collectionSessionRecord_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter additional <strong>notes</strong> on the session here. Your notes can include links to images or other documents."
            },
            {
                id: "collectionSessionRecord_constructionsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_newCollectionSessionConstruction",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Story collection session constructions",
                displayPrompt: "People in your story collection sessions might have created <strong>constructions</strong> such as timelines or landscapes. You can enter details about those here."
            },
            {
                id: "collectionSessionRecord_reflectionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use the questions below to <strong>reflect</strong> on the session."
            },
            {
                id: "collectionSessionRecord_reflectionsOnChangeHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Change"
            },
            {
                id: "collectionSessionRecord_reflections_change_participantPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in participant perceptions",
                displayPrompt: "How did the perceptions of the <strong>participants</strong> change from the start to the end of the session?"
            },
            {
                id: "collectionSessionRecord_reflections_change_yourPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in facilitator perceptions",
                displayPrompt: "How did <strong>your</strong> perceptions change?"
            },
            {
                id: "collectionSessionRecord_reflections_change_project",
                valueType: "string",
                displayType: "textarea",
                displayName: "Changes to the project",
                displayPrompt: "How has the overall <strong>project</strong> changed as a result of this session?"
            },
            {
                id: "collectionSessionRecord_interactionsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Interactions"
            },
            {
                id: "collectionSessionRecord_reflections_interaction_participants",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions among participants",
                displayPrompt: "Describe the interactions <strong>among participants</strong> in this session."
            },
            {
                id: "collectionSessionRecord_reflections_interaction_participantsAndFacilitator",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions between participants and facilitators",
                displayPrompt: "Describe the interactions <strong>between participants and facilitators</strong>."
            },
            {
                id: "collectionSessionRecord_reflections_interaction_intervention",
                valueType: "string",
                displayType: "textarea",
                displayName: "Intervention",
                displayPrompt: "Did you have to <strong>intervene</strong> at any time during this session, \n                perhaps to guide someone back to story sharing? If so, what happened then?"
            },
            {
                id: "collectionSessionRecord_energyHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Energy"
            },
            {
                id: "collectionSessionRecord_reflections_energy_flowed",
                valueType: "string",
                displayType: "textarea",
                displayName: "Flow of energy",
                displayPrompt: "In what parts of this session would you say <strong>the energy flowed well</strong>?\n                Were there any parts in which the energy of the session got stuck?"
            },
            {
                id: "collectionSessionRecord_reflections_energy_enjoyed",
                valueType: "string",
                displayType: "textarea",
                displayName: "Enjoyment",
                displayPrompt: "Which parts of the session do you think your participants <strong>enjoyed</strong> the most?\n                What about you? Which parts did you enjoy?"
            },
            {
                id: "collectionSessionRecord_learningHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Learning"
            },
            {
                id: "collectionSessionRecord_reflections_learning_special",
                valueType: "string",
                displayType: "textarea",
                displayName: "Unique features",
                displayPrompt: "What was <strong>special</strong> about these people, in this place, on this day?"
            },
            {
                id: "collectionSessionRecord_reflections_learning_surprise",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprise",
                displayPrompt: "What <strong>surprised</strong> you about this session?"
            },
            {
                id: "collectionSessionRecord_reflections_learning_workedWell",
                valueType: "string",
                displayType: "textarea",
                displayName: "Worked and didn't work",
                displayPrompt: "Which parts of your <strong>plans</strong> for this session worked out well? Which parts didn't?"
            },
            {
                id: "collectionSessionRecord_reflections_learning_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "What <strong>new ideas</strong> did you gain from this session? What did you <strong>learn</strong> from it?"
            },
            {
                id: "collectionSessionRecord_reflections_learning_style",
                valueType: "string",
                displayType: "textarea",
                displayName: "Style",
                displayPrompt: "What did this session tell you about your own unique <strong>style</strong> of facilitating story sharing?"
            },
            {
                id: "collectionSessionRecord_reflections_learning_wantToRemember",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "<strong>What else</strong> do you want to remember about this session?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_newCollectionSessionConstruction',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_newCollectionSessionConstruction",
        modelClass: "CollectionSessionConstruction",
        panelFields: [
            {
                id: "collectionSessionRecord_construction_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Collection construction name",
                displayPrompt: "Please give this construction a <strong>name</strong>."
            },
            {
                id: "collectionSessionRecord_construction_type",
                valueType: "string",
                valueOptions: [
                    "timeline",
                    "landscape",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of construction is it?"
            },
            {
                id: "collectionSessionRecord_construction_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> the construction (or include a description given by participants). Your description can include links to images or other documents."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_catalysis',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_catalysis",
        displayName: "Catalysis",
        panelFields: [
            {
                id: "catalysisIntro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In this phase of PNI, you look for patterns\n                in the stories people told and in their answers to questions.\n                Then you prepare the patterns to catalyze sensemaking."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_writeAnnotationsAboutStories',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_writeAnnotationsAboutStories",
        displayName: "Write annotation questions",
        pageExplanation: "Design research questions to answer as you study your collected stories.",
        pageCategories: "enter",
        headerAbove: "Interpret",
        panelFields: [
            {
                id: "project_annotationQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can create <strong>annotation questions</strong> \n               that you will use to add qualitative research codes or tags to your story texts. For details on how annotation works, see the help system."
            },
            {
                id: "project_annotationQuestionsList",
                valueType: "array",
                displayType: "grid",
                displayName: "Annotation questions",
                displayPrompt: "These are the annotation questions you have added. Click on a question to edit it.",
                displayConfiguration: {
                    itemPanelID: "panel_addAnnotationQuestion",
                    gridConfiguration: {
                        columnsToDisplay: ["annotationQuestion_text", "annotationQuestion_type", "annotationQuestion_shortName", "annotationQuestion_options"],
                        validateAdd: "requireShortName",
                        validateEdit: "requireShortName",
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                        navigationButtons: true,
                    }
                }
            },
            {
                id: "project_annotationQuestionsOrder",
                valueType: "string",
                displayType: "textarea",
                displayName: "Annotation questions order",
                displayPrompt: "You can specify the <b>order</b> in which your questions should appear on the \"Annotate stories\" page.\n                Enter each question's (exact) short name, one per line. \n                To add a header (e.g., \"Questions about emotions\"), write it on a line by itself.\n                To include a question as a column in the table of stories, type an asterisk (*) before its name.\n                If you don't type anything here, your questions will appear in the order in which you created them.\n                (Note: This only affects the \"Annotate stories\" page.)"
            },
            {
                id: "project_annotateStories_exportButtonsLabel",
                valueType: "none",
                displayType: "html",
                displayPrompt: "Note: Before you make any widespread (bulk) changes to annotation answers, you might want to \n                <a href=\"javascript:narrafirma_openPage('page_importExport')\">back up your project</a>.",
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_annotateStories',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_annotateStories",
        displayName: "Annotate stories",
        pageExplanation: "Answer the research questions you created.",
        pageCategories: "review, enter",
        panelFields: [
            {
                id: "project_annotateStoriesLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can <strong>answer the annotation questions</strong> you created on the previous page."
            },
            {
                id: "storyCollectionChoiceForAnnotation",
                valuePath: "/clientState/storyCollectionName",
                valueType: "string",
                valueOptions: "project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose a <strong>story collection</strong> to annotate.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().atLeastOneAnnotationQuestionExists();
                }
            },
            {
                id: "project_annotateStories_noAnnotationQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "<em>You have not yet created any annotation questions for this project. Write at least one annotation question, then come back to this page and annotate your stories</em>.",
                displayVisible: function (panelBuilder, model) {
                    return !Globals.clientState().atLeastOneAnnotationQuestionExists();
                }
            },
            {
                id: "project_checkCSVAnnotations",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "checkCSVAnnotations",
                displayIconClass: "checkButtonImage",
                displayPreventBreak: true,
                displayPrompt: "Check before importing",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "project_importCSVAnnotations",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "importCSVAnnotations",
                displayIconClass: "importButtonImage",
                displayPreventBreak: true,
                displayPrompt: "Import from CSV",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "project_exportCSVAnnotations",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportAnnotationsToCSV",
                displayIconClass: "exportButtonImage",
                displayPrompt: "Export annotations to CSV",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "project_csvFileUploader",
                valueType: "none",
                displayType: "html",
                displayPrompt: '<input type="file" id="csvFileLoader" name="files" title="Import Data from CSV File" style="display:none"/>',
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "project_annotateStoriesList",
                valuePath: "/clientState/storyCollectionName",
                valueType: "none",
                displayType: "storyAnnotationBrowser",
                displayPrompt: "Stories in collection",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().atLeastOneAnnotationQuestionExists() && !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "annotationGraphBrowserDisplay",
                valuePath: "/clientState/storyCollectionName",
                valueType: "none",
                displayType: "annotationGraphBrowser",
                displayPrompt: "Choose an annotation question whose counts or values you want to <strong>graph</strong> (for the selected story collection).",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().atLeastOneAnnotationQuestionExists() && !!Globals.clientState().storyCollectionIdentifier();
                }
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_startCatalysisReport',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_startCatalysisReport",
        displayName: "Start catalysis report",
        pageExplanation: "Create a container to hold the patterns, observations, interpretations, and ideas you will use in sensemaking.",
        pageCategories: "manage",
        headerAbove: "Explore",
        panelFields: [
            {
                id: "catalysis_createCatalysisReportLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can create one or more catalysis reports: sets of <strong>observations</strong> and <strong>interpretations</strong> based on <strong>patterns</strong> you find in one or more story collections.<br><br>Note: You should only create a catalysis report when your story collection is complete. Otherwise, the report may be incorrect or incomplete (because new data might change the patterns you see)."
            },
            {
                id: "project_catalysisReports",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addCatalysisReport",
                    gridConfiguration: {
                        validateAdd: "requireShortName",
                        validateEdit: "requireShortName",
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                        navigationButtons: true,
                        columnsToDisplay: ["catalysisReport_shortName", "catalysisReport_notes", "catalysisReport_about", "catalysisReport_conclusion"]
                    }
                },
                displayName: "Catalysis reports",
                displayPrompt: "These are the catalysis reports you have added. Click on a report to edit it."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_configureCatalysisReport',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_configureCatalysisReport",
        displayName: "Configure catalysis report",
        pageExplanation: "Choose how you want to look through your patterns and put together your catalysis report.",
        pageCategories: "manage",
        panelFields: [
            {
                id: "configureCatalysisReport_label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                On this page you can set various options that affect your catalysis report.\n            "
            },
            {
                id: "configureCatalysisReport_chooseReport",
                valuePath: "/clientState/catalysisReportName",
                valueType: "string",
                valueOptions: "project_catalysisReports",
                valueOptionsSubfield: "catalysisReport_shortName",
                displayType: "select",
                displayName: "Catalysis report",
                displayPrompt: "Choose a catalysis <strong>report</strong> to work on."
            },
            {
                id: "configureCatalysisReport_filterNotice",
                valueType: "object",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_filter",
                displayType: "catalysisReportFilterNotice",
                displayPrompt: "",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "configureCatalysisReport_promptToSelectCatalysisReportForInterpretations",
                valueType: "none",
                displayType: "label",
                displayPrompt: "<strong>Please select a catalysis report above to get a list of questions here.</strong>",
                displayVisible: function (panelBuilder, model) {
                    return !Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "configureCatalysisReport_chooseGraphTypes",
                valueType: "object",
                valuePath: "/clientState/catalysisReportIdentifier/graphTypesToCreate",
                displayType: "catalysisReportGraphTypesChooser",
                displayPrompt: "Which <strong>graph types</strong> do you want to see on the \"Explore Patterns\" page?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "configureCatalysisReport_chooseQuestions",
                valueType: "object",
                valuePath: "/clientState/catalysisReportIdentifier/questionsToInclude",
                displayType: "catalysisReportQuestionChooser",
                displayPrompt: "Which <strong>questions</strong> do you want to see on the \"Explore Patterns\" page? (Only questions checked here will be considered in data integrity graphs.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "configureCatalysisReport_showOrHideAdvancedOptions",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showOrHideAdvancedOptions",
                displayName: "Show/hide advanced options",
                displayIconClass: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "hideButtonImage" : "showButtonImage"; },
                displayPrompt: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "Hide advanced options" : "Show advanced options"; },
                displayPreventBreak: false,
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            ////////////////////////////////////////////////////// more things you can show or hide
            {
                id: "configureCatalysisReport_MoreThingsYouCanShowOrHideHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Things you can show or hide",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_columnIDsToShowInPatternsTable",
                valueType: "none",
                valuePath: "/clientState/catalysisReportIdentifier/columnIDsToShowInPatternsTable",
                displayType: "catalysisReportPatternTableColumnsChooser",
                displayConfiguration: "Columns to show in the patterns table",
                displayPrompt: "What <strong>columns</strong> do you want to see in the table of patterns on the \"Explore Patterns\" page?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_graphMultiChoiceQuestionsAgainstThemselves",
                valueType: "boolean",
                valuePath: "/clientState/catalysisReportIdentifier/graphMultiChoiceQuestionsAgainstThemselves",
                displayType: "checkbox",
                displayConfiguration: "Show graphs of multi-choice questions against themselves",
                displayPrompt: "Would you like to <strong>graph multi-choice questions against themselves</strong>?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_hidePatternsWithoutStoryQuestions",
                valueType: "boolean",
                valuePath: "/clientState/catalysisReportIdentifier/hidePatternsWithoutStoryQuestions",
                displayType: "checkbox",
                displayConfiguration: "Hide patterns without story questions",
                displayPrompt: "Would you like to <strong>hide patterns that don't involve any story questions</strong>?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_hideStatsPanelsOnExplorePatternsPage",
                valueType: "boolean",
                valuePath: "/clientState/catalysisReportIdentifier/hideStatsPanelsOnExplorePatternsPage",
                displayType: "checkbox",
                displayConfiguration: "Hide statistical results on Explore patterns page",
                displayPrompt: "Would you prefer to <strong>hide statistical results on the \"Explore Patterns\" page</strong>?\n                (You can still see the results in a pop-up window when you choose \"Show statistical results\" from the \"things you can do\" list under the graph.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_filter",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_filter",
                valueType: "string",
                displayType: "text",
                displayPrompt: "\n            To <strong>filter the stories</strong> used in this report, enter your filter here, \n            using the format [question] == [answer].\n            For details, see the help system.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_lumpingCommands",
                valuePath: "/clientState/catalysisReportIdentifier/lumpingCommands",
                valueType: "string",
                displayType: "textarea",
                displayPrompt: "\n            To use <strong>display lumping</strong>, enter your lumping commands here, one per line,\n            using the format [question] == [answer] || [answer] == [lumped answer].\n            For details, see the help system.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            ////////////////////////////////////////////////////// drawing graphs
            {
                id: "configureCatalysisReport_DrawingGraphsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Drawing graphs (in general)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_minimumStoryCountRequiredForGraph",
                valuePath: "/clientState/catalysisReportIdentifier/minimumStoryCountRequiredForGraph",
                valueType: "string",
                valueOptions: ["1", "5", "10", "15", "20", "25", "30", "35", "40", "45", "50", "60", "70", "80", "90", "100", "120", "140", "160", "180", "200", "250", "300", "350", "400", "450", "500"],
                displayType: "select",
                displayName: "Minimum story count for graph",
                displayPrompt: "<strong>How many stories should a subset have</strong> to draw a graph? \n                    (This choice affects multiple histograms and multiple scatterplots in the application and the printed report.\n                    If no selection is made here, graphs will be drawn if at there is least one story in the subset.\n                    Note that a high number here could create patterns with no graphs in them.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_hideNoAnswerValues",
                valueType: "boolean",
                valuePath: "/clientState/catalysisReportIdentifier/hideNoAnswerValues_reportDefault",
                displayType: "checkbox",
                displayConfiguration: "Hide no-answer counts",
                displayPrompt: "Do you want to <strong>hide the bars/bubbles/boxes that represent \"No answer\" counts</strong> on graphs? \n                (This setting affects graphs in the application and the printed report.\n                You can override this choice for any pattern by choosing \"Toggle display of \"No answer\" values\" in the \"things you can do\" list.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_customDisplayGraphWidth",
                valuePath: "/clientState/catalysisReportIdentifier/customDisplayGraphWidth",
                valueType: "string",
                displayType: "select",
                valueOptions: ["400", "425", "450", "475",
                    "500", "525", "550", "575", "600", "625", "650", "675",
                    "700", "725", "750", "775", "800", "825", "850", "875",
                    "900", "925", "950", "975", "1000", "1025", "1050", "1075",
                    "1100", "1125", "1150", "1175", "1200", "1225", "1250", "1275",
                    "1300", "1325", "1350", "1375", "1400", "1425", "1450", "1475",
                    "1500", "1525", "1550", "1575", "1600", "1625", "1650", "1675",
                    "1700", "1725", "1750", "1725", "1800", "1825", "1850", "1875",
                    "1900", "1925", "1950", "1975", "2000"],
                displayName: "Custom display graph width",
                displayPrompt: "<strong>How wide should graphs be</strong> on the \"Explore patterns\" page, in pixels? \n                (This choice affects graphs in the application only. \n                If no selection is made here, graphs will be 800 pixels wide.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_customDisplayGraphHeight",
                valuePath: "/clientState/catalysisReportIdentifier/customDisplayGraphHeight",
                valueType: "string",
                displayType: "select",
                valueOptions: ["200", "225", "250", "275", "300", "325", "350", "375",
                    "400", "425", "450", "475",
                    "500", "525", "550", "575", "600", "625", "650", "675",
                    "700", "725", "750", "775", "800", "825", "850", "875",
                    "900", "925", "950", "975", "1000", "1025", "1050", "1075",
                    "1100", "1125", "1150", "1175", "1200", "1225", "1250", "1275",
                    "1300", "1325", "1350", "1375", "1400", "1425", "1450", "1475",
                    "1500", "1525", "1550", "1575", "1600", "1625", "1650", "1675",
                    "1700", "1725", "1750", "1725", "1800", "1825", "1850", "1875",
                    "1900", "1925", "1950", "1975", "2000"],
                displayName: "Custom display graph height",
                displayPrompt: "<strong>How tall</strong> should graphs be on the \"Explore patterns\" page, in pixels? \n                (This choice affects graphs in the application only. \n                If no selection is made here, graphs will be 600 pixels tall.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_customGraphPadding",
                valuePath: "/clientState/catalysisReportIdentifier/customGraphPadding",
                valueType: "string",
                displayType: "select",
                valueOptions: ["0", "5", "10", "15", "20", "25", "30", "35", "40", "45", "50", "60", "70", "80", "90", "100", "110", "120", "130", "140", "150", "160", "170", "180", "190", "200", "210", "220", "230", "240", "250", "260", "270", "280", "290", "300"],
                displayName: "Custom graph padding",
                displayPrompt: "Do you want to <strong>add extra pixels</strong> \n                to bar graphs (below) and contingency tables (below and left) \n                to accommodate larger font sizes you set using CSS?\n                (This setting affects bar graphs and contingency tables in the application and the printed report.\n                If no selection is made here, no padding will be added.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_customLabelLengthLimit",
                valuePath: "/clientState/catalysisReportIdentifier/customLabelLengthLimit",
                valueType: "string",
                displayType: "select",
                valueOptions: ["10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60"],
                displayName: "Custom label length limit",
                displayPrompt: "At what length do you want to <strong>truncate labels</strong> on bar graphs, tables, and correlation maps?\n                (This choice affects graphs in the application and the printed report.\n                If no selection is made here, labels will be truncated at 30 characters.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_customGraphCSS",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_customGraphCSS",
                valueType: "string",
                displayType: "textarea",
                displayName: "Custom Graph CSS",
                displayPrompt: "You can enter <strong>custom CSS</strong> to change how graphs are drawn. \n                (This choice affects graphs in the application and the printed report.\n                For details see the help system.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            ////////////////////////////////////////////////////// histograms
            {
                id: "configureCatalysisReport_DrawingHistogramsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Histograms",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_numHistogramBins",
                valuePath: "/clientState/catalysisReportIdentifier/numHistogramBins",
                valueType: "string",
                valueOptions: ["5", "10", "15", "20", "25", "30"],
                displayType: "select",
                displayName: "Number of histogram bins",
                displayPrompt: "How many <strong>histogram bins</strong> should the data be sorted into?\n                (This choice affects graphs in the application and the printed report.\n                If no selection is made here, 20 bins will be used.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            ////////////////////////////////////////////////////// contingency tables
            {
                id: "configureCatalysisReport_DrawingContingencyTablesHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Contingency tables",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_hideNumbersOnContingencyGraphs",
                valueType: "boolean",
                valuePath: "/clientState/catalysisReportIdentifier/hideNumbersOnContingencyGraphs",
                displayType: "checkbox",
                displayConfiguration: "Hide numbers on contingency graphs",
                displayPrompt: "To <strong>hide observed/expected story counts</strong> on continency tables, check this box. \n                (This choice affects graphs in the application and the printed report.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            ////////////////////////////////////////////////////// scatter plots
            {
                id: "configureCatalysisReport_DrawingScatterPlotsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Scatter plots",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_numScatterDotOpacityLevels",
                valuePath: "/clientState/catalysisReportIdentifier/numScatterDotOpacityLevels",
                valueType: "string",
                valueOptions: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"],
                displayType: "select",
                displayName: "Number of scatter plot dot opacity levels",
                displayPrompt: "How many stories should it take to <strong>draw an opaque dot</strong> in a scatter plot? \n                (This choice affects graphs in the application and the printed report. \n                    If no selection is made here, 3 levels will be used.\n                    Set this number high if you have a lot of identical scale values.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_scatterDotSize",
                valuePath: "/clientState/catalysisReportIdentifier/scatterDotSize",
                valueType: "string",
                valueOptions: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"],
                displayType: "select",
                displayName: "Scatter dot size",
                displayPrompt: "<strong>How big should dots be</strong> on scatter plots, in pixels? \n                This choice affects graphs in the application and the printed report.\n                If no selection is made here, a size of 8 will be used.\n                Set this number low if you have a large number of slightly-different data points.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_correlationLineChoice",
                valuePath: "/clientState/catalysisReportIdentifier/correlationLineChoice",
                valueType: "string",
                valueOptions: [
                    "none",
                    "0.01",
                    "0.05"
                ],
                displayType: "select",
                displayName: "Mark correlation lines",
                displayPrompt: "When should <strong>correlation lines</strong> be drawn on scatter plots?\n                (This choice affects graphs in the application and the printed report.\n                If no selection is made here, a limit of 0.05 will be used.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            ////////////////////////////////////////////////////// correlation maps
            {
                id: "configureCatalysisReport_DrawingCorrelationMapsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Correlation maps",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_correlationMapShape",
                valuePath: "/clientState/catalysisReportIdentifier/correlationMapShape",
                valueType: "string",
                valueOptions: ["line with arcs", "circle with lines"],
                displayType: "select",
                displayName: "Correlation map shape",
                displayPrompt: "What <strong>shape</strong> should correlation maps be? \n                (This choice affects graphs in the application and the printed report.\n                If no selection is made here, the \"line with arcs\" choice will be used.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_correlationMapIncludeScaleEndLabels",
                valuePath: "/clientState/catalysisReportIdentifier/correlationMapIncludeScaleEndLabels",
                valueType: "string",
                valueOptions: ["always", "only when there is no choice question", "only when there are 6 or fewer questions", "never"],
                displayType: "select",
                displayName: "Correlation map end labels choice",
                displayPrompt: "For correlation maps, when should the <strong>ends of scales</strong> be labeled? \n                Depending on your project, these could be helpful, irrelevant, or in the way. \n                (This choice affects graphs in the application and the printed report.\n                If no selection is made here, the \"only on main graph\" choice will be used.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_correlationMapCircleDiameter",
                valuePath: "/clientState/catalysisReportIdentifier/correlationMapCircleDiameter",
                valueType: "string",
                valueOptions: ["50", "100", "150", "200", "250", "300", "350", "400", "450", "500", "550", "600", "650", "700", "750", "800", "850", "900", "950", "1000"],
                displayType: "select",
                displayName: "Correlation circle diameter",
                displayPrompt: "For circular correlation maps, what should the \n                <strong>circle diameter</strong> be, in pixels?\n                Circles on subchoice graphs will be half this diameter.\n                (This choice affects graphs in the application and the printed report.\n                If no selection is made here, a diameter of 300 pixels will be used.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            ////////////////////////////////////////////////////// story lengths
            {
                id: "configureCatalysisReport_DrawingStoryLengthsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Story lengths",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_numStoryLengthBins",
                valuePath: "/clientState/catalysisReportIdentifier/numStoryLengthBins",
                valueType: "string",
                valueOptions: ["2", "3", "4", "5", "6", "7", "8", "9", "10"],
                displayType: "select",
                displayName: "Number of story length bins",
                displayPrompt: "<strong>How many story length categories</strong> do you want to graph? \n                (This choice affects graphs in the application and the printed report.\n                If no selection is made here, four categories will be used.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_maxStoryLengthToShow",
                valuePath: "/clientState/catalysisReportIdentifier/maxStoryLengthToShow",
                valueType: "string",
                valueOptions: ["100", "200", "300", "400", "500", "600", "700", "800", "900", "1000", "1100", "1200", "1300", "1400", "1500", "1600", "1700", "1800", "1900", "2000", "2500", "3000", "3500", "4000", "4500", "5000", "6000", "7000", "8000", "9000", "10000"],
                displayType: "select",
                displayName: "Maximum story length to show",
                displayPrompt: "In the story length graph, above what character length do you want to <strong>lump all remaining stories into the last bin</strong>? \n                (This choice affects graphs in the application and the printed report.\n                If no selection is made here, the maximum story length will be drawn from the stories themselves.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            ////////////////////////////////////////////////////// story collection dates
            {
                id: "configureCatalysisReport_DrawingStoryCollectionDatesHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Story collection dates",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_storyCollectionDateUnit",
                valuePath: "/clientState/catalysisReportIdentifier/storyCollectionDateUnit",
                valueType: "string",
                valueOptions: ["years", "quarters", "months", "days"],
                displayType: "select",
                displayName: "Story collection date unit",
                displayPrompt: "For graphing story collection dates, <strong>what time units</strong> do you want to graph? \n                (This choice affects graphs in the application and the printed report.\n                If no selection is made here, days will be used.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            ////////////////////////////////////////////////////// other options
            {
                id: "configureCatalysisReport_moreOptionsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Other options",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_minimumSubsetSize",
                valuePath: "/clientState/catalysisReportIdentifier/minimumSubsetSize",
                valueType: "string",
                valueOptions: ["1", "5", "10", "15", "20", "25", "30", "35", "40", "45", "50", "60", "70", "80", "90", "100", "120", "140", "160", "180", "200", "250", "300", "350", "400", "450", "500"],
                displayType: "select",
                displayName: "Minimum subset size",
                displayPrompt: "<strong>How many stories should a subset have</strong> to be compared to other subsets in a statistical test?\n                (This choice affects multiple histograms and multiple scatterplots in the application and the printed report.\n                If no selection is made here, a 20-story minimum will be used.\n                Note that test results based on low sample sizes (usually less than 30) should be regarded as suggestive rather than conclusive.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_questionShortNamesToShowForSelectedStories",
                valuePath: "/clientState/catalysisReportIdentifier/questionShortNamesToShowForSelectedStories",
                valueType: "string",
                displayType: "textarea",
                displayName: "Fields to show on selections",
                displayPrompt: "\n                What questions do you want to include when you <strong>view selected stories</strong> in a pop-up window on the \"Explore \"Patterns\" page?\n                (Enter the short names of the questions whose answers you want to see, one per line.)\n                ",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            ////////////////////////////////////////////////////// export import
            {
                id: "configureCatalysisReport_exportImportLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can <strong>copy observations, interpretations, themes, and perspectives</strong> from one catalysis report to another (new, empty) report,\n            as long as the question short names are the same. For more information, see the help system.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_importElements",
                valueType: "none",
                displayType: "button",
                displayIconClass: "importButtonImage",
                displayConfiguration: "importCatalysisReportElements",
                displayName: "Import elements",
                displayPreventBreak: true,
                displayPrompt: "Import report elements from CSV",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_exportElements",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportCatalysisReportElements",
                displayName: "Export elements",
                displayIconClass: "exportButtonImage",
                displayPrompt: "Export report elements to CSV",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "project_csvFileUploader",
                valueType: "none",
                displayType: "html",
                displayPrompt: '<input type="file" id="csvFileLoader" name="files" title="Import Data from CSV File" style="display:none"/>',
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_explorePatterns',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_explorePatterns",
        displayName: "Explore patterns",
        pageExplanation: "Look for patterns in your data. Write observations, interpretations, and ideas for use in sensemaking.",
        pageCategories: "review, enter",
        panelFields: [
            {
                id: "explorePatternsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n            On this page you can explore <strong>patterns</strong> in the data you \n            collected, make <strong>observations</strong> on the patterns,\n            and <strong>interpret</strong> the observations. The\n            <strong>catalysis report</strong> you build here can help other people \n            make sense of what the story collection has to say.\n            "
            },
            {
                id: "catalysisReportExplorePatterns",
                valuePath: "/clientState/catalysisReportName",
                valueType: "string",
                valueOptions: "project_catalysisReports",
                valueOptionsSubfield: "catalysisReport_shortName",
                displayType: "select",
                displayName: "Catalysis report",
                displayPrompt: "Choose a catalysis report to work on."
            },
            {
                id: "explorePatterns_filterNotice",
                valueType: "object",
                displayType: "catalysisReportFilterNotice",
                displayPrompt: "",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "explorePatterns_display",
                valuePath: "/clientState/catalysisReportName",
                valueType: "none",
                displayType: "patternExplorer",
                displayPrompt: ""
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_clusterInterpretations',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_clusterInterpretations",
        displayName: "Cluster interpretations and/or observations",
        pageExplanation: "Pull together what you have built into a coherent report.",
        pageCategories: "review, enter",
        headerAbove: "Consolidate",
        panelFields: [
            {
                id: "project_interpretationsClusteringLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                On this page you can <strong>cluster</strong> your interpretations and/or observations into groups that will divide your catalysis report into sections.\n                (If you can't decide whether to cluster by interpretations or observations, see the help system.)"
            },
            {
                id: "catalysisReportClusterInterpretations",
                valuePath: "/clientState/catalysisReportName",
                valueType: "string",
                valueOptions: "project_catalysisReports",
                valueOptionsSubfield: "catalysisReport_shortName",
                displayType: "select",
                displayName: "Catalysis report",
                displayPrompt: "Choose a catalysis report to work on."
            },
            {
                id: "clusterInterpretations_filterNotice",
                valueType: "object",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_filter",
                displayType: "catalysisReportFilterNotice",
                displayPrompt: "",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "promptToSelectCatalysisReportForInterpretations",
                valueType: "none",
                displayType: "label",
                displayPrompt: "<strong>Please select a catalysis report above to see clustering surfaces here.</strong>",
                displayVisible: function (panelBuilder, model) {
                    return !Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "cluster_interpretationsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Cluster interpretations into perspectives",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "cluster_interpretationsIntroLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "To start, click this button to <strong>copy</strong> the interpretations you wrote on the previous page onto the clustering space. \n                If you make any changes to your interpretations, click the button again to <strong>update</strong> the space.",
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "copyInterpretationsButton",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "copyInterpretationsToClusteringDiagram",
                displayIconClass: "copyButtonImage",
                displayPrompt: "Copy or update interpretations",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "cluster_interpretationsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "<strong>Drag similar interpretations together</strong> into clusters. \n                (Shift-click to select multiple interpretations.)\n                <strong>Create a name</strong> for each cluster. Place it in the middle of the cluster. \n                Your cluster names will become the headings of your catalysis report, where they will be called \"Perspectives.\"",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "interpretationsClusteringDiagram",
                valueType: "object",
                valuePath: "/clientState/catalysisReportIdentifier/interpretationsClusteringDiagram",
                displayType: "clusteringDiagram",
                displayPrompt: "",
                displayConfiguration: "interpretations",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "cluster_observationsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Cluster observations into themes",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "cluster_observationsIntroLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "To start, click this button to <strong>copy</strong> the observations you wrote on the previous page onto the clustering space. \n            If you make any changes to your observations, click the button again to <strong>update</strong> the space.",
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "copyObservationsButton",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "copyObservationsToClusteringDiagram",
                displayPrompt: "Copy or update observations",
                displayIconClass: "copyButtonImage",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "cluster_observationsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                <strong>Drag similar observations together</strong> into clusters. \n                (Shift-click to select multiple observations.)\n                <strong>Create a name</strong> for each cluster. Place it in the middle of the cluster. \n                Your cluster names will become the headings of your catalysis report, where they will be called \"Themes.\"",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "observationsClusteringDiagram",
                valueType: "object",
                valuePath: "/clientState/catalysisReportIdentifier/observationsClusteringDiagram",
                displayType: "clusteringDiagram",
                displayPrompt: "",
                displayConfiguration: "observations",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_printCatalysisReport',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_printCatalysisReport",
        displayName: "Print catalysis report",
        pageExplanation: "Export your catalysis report in HTML format.",
        pageCategories: "export",
        panelFields: [
            {
                id: "catalysisReportPrint_label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                On this page you can print a <strong>catalysis report</strong>.\n                You can organize the report by the\n                <strong>perspectives</strong> (clusters of interpretations) or <strong>themes</strong> (clusters of observations)\n                you created on the previous page. The report can also include an introduction and other optional elements.\n                "
            },
            {
                id: "catalysisReportPrint_label_pandoc",
                valueType: "none",
                displayType: "html",
                displayPrompt: "\n                Note: If you would like to edit your catalysis report in a word processor, we strongly recommend you look into \n                <a href=\"https://pandoc.org\" target=\"_blank\">pandoc</a>, \n                which does a great job of converting NarraFirma's HTML reports into many other document formats. \n                "
            },
            {
                id: "catalysisReportPrint_selected",
                valuePath: "/clientState/catalysisReportName",
                valueType: "string",
                valueOptions: "project_catalysisReports",
                valueOptionsSubfield: "catalysisReport_shortName",
                displayType: "select",
                displayName: "Catalysis report",
                displayPrompt: "Choose a catalysis <strong>report</strong> to print."
            },
            {
                id: "catalysisReportPrint_filterNotice",
                valueType: "object",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_filter",
                displayType: "catalysisReportFilterNotice",
                displayPrompt: "",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "catalysisReportPrint_reportType",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReportPrint_reportType",
                valueType: "string",
                valueOptions: [
                    "perspectives (clustered interpretations)",
                    "themes (clustered observations)",
                    "observations (disregarding any clustering)",
                    "observation graphs only",
                    "observation graph data as csv",
                    "observation and interpretation texts as csv"
                ],
                displayType: "select",
                displayPrompt: "<strong>Which type</strong> of report would you like to print?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "catalysisReportPrint_observationStrengths",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReportPrint_observationStrengths",
                valueType: "dictionary",
                valueOptions: ["strong", "medium", "weak", "no strength value set"],
                displayType: "checkboxes",
                displayPrompt: "Which observation <strong>strengths</strong> do you want to include?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "catalysisReportPrint_printButton",
                valuePath: "/clientState/catalysisReportName",
                valueType: "none",
                displayType: "button",
                displayIconClass: "printButtonImage",
                displayPrompt: "Print selected catalysis report",
                displayConfiguration: "printCatalysisReport",
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            {
                id: "printCatalysisReport_showOrHideAdvancedOptions",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showOrHideAdvancedOptions",
                displayName: "Show/hide advanced options",
                displayIconClass: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "hideButtonImage" : "showButtonImage"; },
                displayPrompt: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "Hide advanced options" : "Show advanced options"; },
                displayPreventBreak: false,
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportIdentifier();
                }
            },
            ///////////////////////////////////////////////////// things to show and hide
            {
                id: "catalysisReportPrint_MoreThingsToShowAndHideHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Things you can show or hide",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReportPrint_includeObservationsWithNoInterpretations",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReportPrint_includeObservationsWithNoInterpretations",
                valueType: "boolean",
                displayType: "checkbox",
                displayConfiguration: "Include observations with no interpretations",
                displayPrompt: "Do you want to include observations that have <strong>no interpretations</strong> associated with them?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_showStatsPanelsInReport",
                valueType: "boolean",
                valuePath: "/clientState/catalysisReportIdentifier/showStatsPanelsInReport",
                displayType: "checkbox",
                displayConfiguration: "Include statistics",
                displayPrompt: "Would you like to <strong>print statistical results</strong>?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_printItemIndexNumbers",
                valueType: "boolean",
                valuePath: "/clientState/catalysisReportIdentifier/printItemIndexNumbers",
                displayType: "checkbox",
                displayConfiguration: "Print sequence numbers",
                displayPrompt: "Do you want to <strong>print sequence numbers</strong> for each perspective, theme, observation, and interpretation in the report?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_hideReportCreationInfo",
                valueType: "boolean",
                valuePath: "/clientState/catalysisReportIdentifier/hideReportCreationInfo",
                displayType: "checkbox",
                displayConfiguration: "Hide report creation information",
                displayPrompt: "You can <strong>hide the report creation information</strong> that NarraFirma usually puts at the start of the report.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            ///////////////////////////////////////////////////// other printing options
            {
                id: "catalysisReportPrint_printOptionsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Other printing options",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_outputGraphFormat",
                valuePath: "/clientState/catalysisReportIdentifier/outputGraphFormat",
                valueType: "string",
                valueOptions: ["SVG", "PNG"],
                displayType: "select",
                displayName: "Output graph format",
                displayPrompt: "Which <strong>graph format</strong> do you want to use? (If no choice is made here, SVG format will be used.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_outputFontModifierPercent",
                valuePath: "/clientState/catalysisReportIdentifier/outputFontModifierPercent",
                valueType: "string",
                displayType: "select",
                valueOptions: ["50", "60", "70", "80", "90", "110", "120", "130", "140", "150", "160", "170", "180", "190", "200"],
                displayName: "Output font modifier percent",
                displayPrompt: "If you want to modify the <strong>font sizes</strong> in report graphs, choose a percentage modifier here.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_customReportGraphWidth",
                valuePath: "/clientState/catalysisReportIdentifier/customReportGraphWidth",
                valueType: "string",
                displayType: "select",
                valueOptions: ["400", "425", "450", "475",
                    "500", "525", "550", "575", "600", "625", "650", "675",
                    "700", "725", "750", "775", "800", "825", "850", "875",
                    "900", "925", "950", "975", "1000", "1025", "1050", "1075",
                    "1100", "1125", "1150", "1175", "1200", "1225", "1250", "1275",
                    "1300", "1325", "1350", "1375", "1400", "1425", "1450", "1475",
                    "1500", "1525", "1550", "1575", "1600", "1625", "1650", "1675",
                    "1700", "1725", "1750", "1725", "1800", "1825", "1850", "1875",
                    "1900", "1925", "1950", "1975", "2000"],
                displayName: "Custom report graph width",
                displayPrompt: "<strong>How wide should report graphs be</strong>, in pixels? \n                (This choice affects graphs in the report only. \n                If no selection is made here, graphs will be 800 pixels wide.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "configureCatalysisReport_customReportGraphHeight",
                valuePath: "/clientState/catalysisReportIdentifier/customReportGraphHeight",
                valueType: "string",
                displayType: "select",
                valueOptions: ["200", "225", "250", "275", "300", "325", "350", "375",
                    "400", "425", "450", "475",
                    "500", "525", "550", "575", "600", "625", "650", "675",
                    "700", "725", "750", "775", "800", "825", "850", "875",
                    "900", "925", "950", "975", "1000", "1025", "1050", "1075",
                    "1100", "1125", "1150", "1175", "1200", "1225", "1250", "1275",
                    "1300", "1325", "1350", "1375", "1400", "1425", "1450", "1475",
                    "1500", "1525", "1550", "1575", "1600", "1625", "1650", "1675",
                    "1700", "1725", "1750", "1725", "1800", "1825", "1850", "1875",
                    "1900", "1925", "1950", "1975", "2000"],
                displayName: "Custom report graph width",
                displayPrompt: "<strong>How tall</strong> should report graphs be, in pixels? \n                (This choice affects graphs in the report only. \n                If no selection is made here, graphs will be 600 pixels tall.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReportPrint_useTableForInterpretationsFollowingObservation",
                valuePath: "/clientState/catalysisReportIdentifier/useTableForInterpretationsFollowingObservation",
                valueType: "boolean",
                displayType: "checkbox",
                displayConfiguration: "Show interpretations in a table side by side",
                displayPrompt: "For a clustered-observations report, do you want to show interpretations <strong>side by side</strong>? Or one after another?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            ///////////////////////////////////////////////////// custom texts
            {
                id: "catalysisReportPrint_customTextsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Custom texts",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_customCSS",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_customCSS",
                valueType: "string",
                displayType: "textarea",
                displayName: "Custom CSS",
                displayPrompt: "You can enter <strong>custom CSS</strong> to modify elements of the catalysis report here. \n                (This option does not affect report graphs.\n                Enter custom CSS for graphs on the \"Configure catalysis report\" page. For details on custom CSS, see the help system.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_notes",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Introduction",
                displayPrompt: "\n                This optional <strong>introduction</strong> begins your report. (See the help system to learn about HTML formatting you can use.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_about",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_about",
                valueType: "string",
                displayType: "textarea",
                displayName: "About",
                displayPrompt: "\n                An optional <strong>About this report</strong> section is printed after the introduction.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_tocHeaderFirstLevel",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_tocHeaderFirstLevel",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Contents header (top level, perspectives)",
                displayPrompt: "\n                You can enter a custom <strong>header for the list of perspectives</strong> at the start\n                of your clustered-interpretations report. \n                A number sign (#) will be replaced\n                with the number of perspectives in the report. (If you leave this field blank, the header will read \"Perspectives in this report (#).\")",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_tocHeaderFirstLevel_themes",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_tocHeaderFirstLevel_observations",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Contents header (top level, themes)",
                displayPrompt: "\n                You can enter a custom <strong>header for the list of themes</strong> at the start\n                of your clustered-observations report. \n                A number sign (#) will be replaced\n                with the number of themes in the report. (If you leave this field blank, the header will read \"Themes in this report (#).\")",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_tocHeaderSecondLevel",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_tocHeaderSecondLevel",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Contents header (second level, perspectives)",
                displayPrompt: "\n                You can enter a custom <strong>header for the table of interpretations and observations in each perspective</strong> \n                in a clustered-interpretations report. A number sign (#) will be replaced with the number of interpretations in the perspective. \n                (If you leave this field blank, the header will read \"Interpretations and observations in this perspective (#).\")",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_tocHeaderSecondLevel_observations",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_tocHeaderSecondLevel_observations",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Contents header (second level, themes)",
                displayPrompt: "\n                You can enter a custom <strong>header for the list of observations in each theme</strong> \n                in a clustered-observations report. A number sign (#) will be replaced with the number of observations in the theme. \n                If you leave this field blank, the header will read \"Observations and interpretations in this theme (#).\"",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_perspectiveLabel",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_perspectiveLabel",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Perspective label",
                displayPrompt: "\n            This optional label will appear <strong>before each perspective name</strong> in the report.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_themeLabel",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_themeLabel",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Theme label",
                displayPrompt: "\n            This optional label will appear <strong>before each theme name</strong> in the report.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_interpretationLabel",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_interpretationLabel",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Interpretation label",
                displayPrompt: "\n            This optional label will appear <strong>before each interpretation name</strong> in the report.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_interpretationQuestionsLabel",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_interpretationQuestionsLabel",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Interpretation questions label",
                displayPrompt: "\n            This optional label will appear <strong>before each list of interpretation questions</strong> in the report.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_interpretationIdeaLabel",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_interpretationIdeaLabel",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Interpretation idea label",
                displayPrompt: "\n            This optional label will appear <strong>before each interpretation idea</strong> in the report.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_observationLabel",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_observationLabel",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Observation label",
                displayPrompt: "\n            This optional label will appear <strong>before each observation name</strong> in the report.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_conclusion",
                valuePath: "/clientState/catalysisReportIdentifier/catalysisReport_conclusion",
                valueType: "string",
                displayType: "textarea",
                displayName: "Conclusion",
                displayPrompt: "\n            You can enter a <strong>report conclusion</strong> here.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
            {
                id: "catalysisReport_customStatsTextReplacements",
                valuePath: "/clientState/catalysisReportIdentifier/customStatsTextReplacements",
                valueType: "string",
                displayType: "textarea",
                displayName: "Text replacements",
                displayPrompt: "\n                You can <strong>replace graph and statistical texts</strong> in your report with simpler or translated versions. \n                Enter one text replacement per line. \n                Each line should have the standard text you want to replace, followed by an equals sign, followed by the text you want to replace it with.\n                For example, \"median = m\u00E9diane\" will write \"m\u00E9diane\" in every place where \"median\" would have been written.\n                <br><br>\n                The texts you can replace are (and must <em>exactly</em> match, to the left of the equals sign):\n                <ul>\n                <li>Count</li>\n                <li>Frequency</li>\n                <li>No answer</li>\n                <li>Statistics</li>\n                <li>p</li>\n                <li>n</li>\n                <li>n1</li>\n                <li>n2</li>\n                <li>mean</li>\n                <li>median</li>\n                <li>mode</li>\n                <li>standard deviation</li>\n                <li>skewness</li>\n                <li>kurtosis</li>\n                <li>chi squared (x2)</li>\n                <li>degrees of freedom (k)</li>\n                <li>Spearman's rho</li>\n                <li>Sub-graph</li>\n                <li>Mann-Whitney U</li>\n                <li>Mann-Whitney U test results for multiple histograms, sorted by significance value (p)</li>\n                </ul>\n                These replacements apply only to your printed catalysis report.\n                ",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveCatalysisReportAndShowingAdvancedOptions();
                }
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_reflectOnCatalysisPhase',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_reflectOnCatalysisPhase",
        displayName: "Reflect on the catalysis phase",
        pageExplanation: "Think about what happened in this part of the project.",
        pageCategories: "journal",
        headerAbove: "Wrap up",
        panelFields: [
            {
                id: "project_phaseReflections_catalysis_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can answer some <strong>reflective questions</strong> \n                that will help you think about what happened."
            },
            {
                id: "project_phaseReflections_catalysis_happened",
                valuePath: "project_phaseReflections_catalysis_happened",
                valueType: "string",
                displayType: "textarea",
                displayName: "What happened",
                displayPrompt: "What <strong>happened</strong> in the catalysis phase of your project?"
            },
            {
                id: "project_phaseReflections_catalysis_surprisedAndNot",
                valuePath: "project_phaseReflections_catalysis_surprisedAndNot",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprised and Not",
                displayPrompt: "What <strong>surprised</strong> you? What didn't?"
            },
            {
                id: "project_phaseReflections_catalysis_obstaclesAndOpportunities",
                valuePath: "project_phaseReflections_catalysis_obstaclesAndOpportunities",
                valueType: "string",
                displayType: "textarea",
                displayName: "Obstacles and Opportunities",
                displayPrompt: "Did any <strong>obstacles</strong> or <strong>opportunities</strong> play a part in how things went? \n                Where did they come from? What did you do about them? How did that work out?"
            },
            {
                id: "project_phaseReflections_catalysis_learned",
                valuePath: "project_phaseReflections_catalysis_learned",
                valueType: "string",
                displayType: "textarea",
                displayName: "Learned",
                displayPrompt: "What did you <strong>learn</strong> from all of this?"
            },
            {
                id: "project_phaseReflections_catalysis_newIdeas",
                valuePath: "project_phaseReflections_catalysis_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "Did any <strong>new ideas</strong> come up that you want to remember in the future?"
            },
            {
                id: "project_phaseReflections_catalysis_issues",
                valuePath: "project_phaseReflections_catalysis_issues",
                valueType: "string",
                displayType: "textarea",
                displayName: "Issues",
                displayPrompt: "Are there any unresolved <strong>issues</strong> going forward?"
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/panel_addCatalysisReport',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addCatalysisReport",
        modelClass: "CatalysisReport",
        panelFields: [
            {
                id: "catalysisReport_shortName",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                required: true,
                displayName: "Catalysis report name",
                displayPrompt: "Please give this catalysis report a short <strong>name</strong>.\n                The name is required, must be unique within the project, and must not be changed after you start using the catalysis report."
            },
            {
                id: "catalysisReport_storyCollections",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_chooseStoryCollection",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true
                    }
                },
                displayName: "Story collections",
                displayPrompt: "Add one or more <strong>story collections</strong> to this catalysis report."
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/panel_chooseStoryCollection',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_chooseStoryCollection",
        modelClass: "StoryCollectionChoice",
        panelFields: [
            {
                id: "storyCollection",
                valueType: "string",
                valueOptions: "/project/project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose a story collection."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/panel_addInterpretation',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addInterpretation",
        modelClass: "Interpretation",
        panelFields: [
            {
                id: "interpretation_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "<strong>Describe</strong> this interpretation. What does the pattern mean, from this perspective?"
            },
            {
                id: "interpretation_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Name",
                displayPrompt: 'Give the interpretation a short <strong>name</strong>. This name will represent it during clustering and will be its heading in the printed report.'
            },
            {
                id: "interpretation_questions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Questions",
                displayPrompt: "You might want to record some <strong>questions</strong> that arise from this interpretation. (If you want your questions to appear as an HTML list in the report, write them on separate lines.)"
            },
            {
                id: "interpretation_idea",
                valueType: "string",
                displayType: "textarea",
                displayName: "Idea",
                displayPrompt: "If you like, you can record an <strong>idea</strong> that follows from this interpretation."
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/page_sensemaking',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_sensemaking",
        displayName: "Sensemaking",
        panelFields: [
            {
                id: "sensemakingIntroLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In this phase of PNI, you run group sessions \n                in which participants make use of your collected stories and patterns to think together \n                about the topic of your project."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/page_printStoryCards',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    "use strict";
    var panel = {
        id: "page_printStoryCards",
        displayName: "Print story cards",
        pageExplanation: "Get your stories ready for use in sensemaking.",
        pageCategories: "export",
        headerAbove: "Prepare",
        panelFields: [
            {
                id: "printStoryCards_introduction",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can print or export <strong>story cards</strong>, printed versions \n                of stories that people can arrange and compare as they \n                encounter stories and work on sensemaking exercises.\n                "
            },
            {
                id: "storyCollectionChoice_printing",
                valuePath: "/clientState/storyCollectionName",
                valueType: "string",
                valueOptions: "project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose the <strong>story collection</strong> whose story cards you want to print."
            },
            {
                id: "printStoryCards_output",
                valueType: "none",
                displayType: "label",
                displayPrompt: ""
            },
            {
                id: "printStoryCards_questionsToInclude",
                valueType: "object",
                valuePath: "/clientState/storyCollectionName/printStoryCards_questionsToInclude",
                displayType: "printStoryCardsQuestionChooser",
                displayPrompt: "Which <strong>questions</strong> should be included in the story cards?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "printStoryCards_order",
                valueType: "string",
                valuePath: "/clientState/storyCollectionName/printStoryCards_order",
                valueOptions: [
                    "order on story form, scales separate",
                    "order on story form, scales mixed in",
                    "alphabetical order, scales separate",
                    "alphabetical order, scales mixed in"
                ],
                displayType: "select",
                displayName: "Order",
                displayPrompt: "In what <strong>order</strong> would you like the answers to questions to appear?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "printStoryCards_printFormButton",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "printStoryCards",
                displayIconClass: "printButtonImage",
                displayPrompt: "Print Story Cards",
                displayPreventBreak: true,
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "printStoryCards_showOrHideAdvancedOptions",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "showOrHideAdvancedOptions",
                displayName: "Show/hide advanced options",
                displayIconClass: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "hideButtonImage" : "showButtonImage"; },
                displayPrompt: function (panelBuilder, model) { return Globals.clientState().showAdvancedOptions() ? "Hide advanced options" : "Show advanced options"; },
                displayPreventBreak: false,
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().storyCollectionIdentifier();
                }
            },
            {
                id: "printStoryCards_MoreThingsToShowAndHideHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Things you can show or hide",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_numColumns",
                valuePath: "/clientState/storyCollectionName/printStoryCards_numColumns",
                valueType: "number",
                displayType: "select",
                valueOptions: ["1", "2", "3", "4", "5", "6"],
                displayPrompt: "How many <strong>columns</strong> do you want to use to print your story cards? (If this field is left blank, one column will be used.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_sliderBucketCount",
                valuePath: "/clientState/storyCollectionName/printStoryCards_sliderBucketCount",
                valueType: "number",
                displayType: "select",
                valueOptions: ["20", "30", "40", "50", "60", "70", "80", "90", "100"],
                displayPrompt: "How many characters do you want to use to represent each <strong>slider range</strong>? (If this field is left blank, 50 characters will be used.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_filter",
                valuePath: "/clientState/storyCollectionName/printStoryCards_filter",
                valueType: "string",
                displayType: "text",
                displayPrompt: "\n            If you want to <strong>filter</strong> the stories printed, enter your filter here.\n            (For details on how to use this function, click Help.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_storyTextCutoff",
                valueType: "string",
                valuePath: "/clientState/storyCollectionName/printStoryCards_storyTextCutoff",
                valueOptions: ["no limit", "100", "150", "200", "250", "300", "350", "400", "450", "500", "600", "700", "800", "900", "1000", "1100", "1200", "1300", "1400", "1500", "1600", "1700", "1800", "1900", "2000", "2200", "2400", "2600", "2800", "3000", "3500", "4000"],
                displayType: "select",
                displayName: "Story text length",
                displayPrompt: "At what <strong>length</strong> (number of characters) should stories be truncated?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_storyTextCutoffMessage",
                valueType: "string",
                valuePath: "/clientState/storyCollectionName/printStoryCards_storyTextCutoffMessage",
                displayType: "text",
                displayName: "Story text cutoff message",
                displayPrompt: "What should the story card say <strong>after a story that has been truncated</strong>? (If this field is left blank, it will say \"... (truncated)\".)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_includeIndexInStoryCollection",
                valueType: "boolean",
                valuePath: "/clientState/storyCollectionName/printStoryCards_includeIndexInStoryCollection",
                displayType: "checkbox",
                displayName: "Include index in story collection?",
                displayConfiguration: "Yes, include the story index",
                displayPrompt: "Do you want to <strong>print each story's index</strong> in the story collection before its title?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_hideNonSelectedAnswers",
                valuePath: "/clientState/storyCollectionName/printStoryCards_hideNonSelectedAnswers",
                valueType: "number",
                displayType: "checkbox",
                displayName: "Hide non-selected answers?",
                displayConfiguration: "Yes, hide non-selected answers",
                displayPrompt: "Do you want to hide answers that were <strong>not selected</strong>?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_includeWriteInTexts",
                valueType: "boolean",
                valuePath: "/clientState/storyCollectionName/printStoryCards_includeWriteInTexts",
                displayType: "checkbox",
                displayName: "Include write-in answers?",
                displayConfiguration: "Yes, include write-in answers",
                displayPrompt: "Do you want to <strong>print write-in answers</strong> to questions?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_lumpingCommands",
                valuePath: "/clientState/storyCollectionName/printStoryCards_lumpingCommands",
                valueType: "string",
                displayType: "textarea",
                displayPrompt: "\n            To use <strong>display lumping</strong>, enter your lumping commands here, one per line,\n            using the format [question] == [answer] || [answer] == [lumped answer].\n            For details, see the help system.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_CustomTextsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Custom texts",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_betweenAnswerText",
                valueType: "string",
                valuePath: "/clientState/storyCollectionName/printStoryCards_betweenAnswerText",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Text to print between multi-choice-question answers",
                displayPrompt: "\n                Enter the text to print <strong>between answers</strong> to multiple-choice questions. If empty, the text \" / \" will be used.\n                (Multiple spaces will be collapsed down to one.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_beforeSliderCharacter",
                valueType: "string",
                valuePath: "/clientState/storyCollectionName/printStoryCards_beforeSliderCharacter",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Character to print before slider button",
                displayPrompt: "\n            Enter a character to print <strong>before</strong> (to the left of) the slider \"button\". If empty, the character \"-\" will be used.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_sliderButtonCharacter",
                valueType: "string",
                valuePath: "/clientState/storyCollectionName/printStoryCards_sliderButtonCharacter",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Slider button character",
                displayPrompt: "\n            Enter a character to print as the slider <strong>button</strong>. If empty, the character \"|\" will be used.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_afterSliderCharacter",
                valueType: "string",
                valuePath: "/clientState/storyCollectionName/printStoryCards_afterSliderCharacter",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Character to print after slider button",
                displayPrompt: "\n            Enter a character to print <strong>after</strong> (to the right of) the slider \"button\". If empty, the character \"-\" will be used.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_noAnswerSliderCharacter",
                valueType: "string",
                valuePath: "/clientState/storyCollectionName/printStoryCards_noAnswerSliderCharacter",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Character to print on slider with no answer",
                displayPrompt: "\n            Enter a character to print on the slider space if there was <strong>no answer</strong> to the question. If empty, the character \"-\" will be used.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
            {
                id: "printStoryCards_customCSS",
                valueType: "string",
                valuePath: "/clientState/storyCollectionName/printStoryCards_customCSS",
                displayType: "textarea",
                displayName: "Custom CSS",
                displayPrompt: "You can enter <strong>custom CSS</strong> that modifies elements of your story cards here. (For more information on how this works, see the help system.)",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().haveStoryCollectionAndShowingAdvancedOptions();
                }
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/page_planSensemakingSessions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_planSensemakingSessions",
        displayName: "Plan sensemaking sessions",
        pageExplanation: "Create a printable agenda for your sensemaking sessions.",
        pageCategories: "plan",
        panelFields: [
            {
                id: "project_sensemakingSessionPlansLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can create <strong>plans</strong> for your sensemaking sessions. After a plan is complete, you can print a session agenda and use it to remember what you plan to do, and to coordinate your facilitation with any helpers you might have."
            },
            {
                id: "sensemakingSessionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayIconClass: "recommendationsButtonImage",
                displayConfiguration: "sessions",
                displayPrompt: "Recommendations for sensemaking sessions"
            },
            {
                id: "project_sensemakingSessionPlansList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addSensemakingSessionPlan",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Sensemaking session plans",
                displayPrompt: "These are the session plans you have added. Click on a plan to edit it."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/page_enterSensemakingSessionRecords',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_enterSensemakingSessionRecords",
        displayName: "Enter sensemaking session records",
        pageExplanation: "Answer questions about the sensemaking sessions you held.",
        pageCategories: "journal",
        headerAbove: "Wrap up",
        panelFields: [
            {
                id: "project_sensemakingSessionRecordsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can enter <strong>records</strong> of what happened during your sensemaking sessions."
            },
            {
                id: "project_sensemakingSessionRecordsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addSensemakingSessionRecord",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Sensemaking session records",
                displayPrompt: "These are the session records you have added. Click on a record to edit it."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/page_reflectOnSensemakingPhase',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_reflectOnSensemakingPhase",
        displayName: "Reflect on the sensemaking phase",
        pageExplanation: "Think about what happened in this part of the project.",
        pageCategories: "journal",
        panelFields: [
            {
                id: "project_phaseReflections_sensemaking_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can answer some <strong>reflective questions</strong> \n                that will help you think about what happened."
            },
            {
                id: "project_phaseReflections_sensemaking_happened",
                valuePath: "project_phaseReflections_sensemaking_happened",
                valueType: "string",
                displayType: "textarea",
                displayName: "What happened",
                displayPrompt: "What <strong>happened</strong> in the sensemaking phase of your project?"
            },
            {
                id: "project_phaseReflections_sensemaking_surprisedAndNot",
                valuePath: "project_phaseReflections_sensemaking_surprisedAndNot",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprised and Not",
                displayPrompt: "What <strong>surprised</strong> you? What didn't?"
            },
            {
                id: "project_phaseReflections_sensemaking_obstaclesAndOpportunities",
                valuePath: "project_phaseReflections_sensemaking_obstaclesAndOpportunities",
                valueType: "string",
                displayType: "textarea",
                displayName: "Obstacles and Opportunities",
                displayPrompt: "Did any <strong>obstacles</strong> or <strong>opportunities</strong> play a part in how things went? \n                Where did they come from? What did you do about them? How did that work out?"
            },
            {
                id: "project_phaseReflections_sensemaking_learned",
                valuePath: "project_phaseReflections_sensemaking_learned",
                valueType: "string",
                displayType: "textarea",
                displayName: "Learned",
                displayPrompt: "What did you <strong>learn</strong> from all of this?"
            },
            {
                id: "project_phaseReflections_sensemaking_newIdeas",
                valuePath: "project_phaseReflections_sensemaking_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "Did any <strong>new ideas</strong> come up that you want to remember in the future?"
            },
            {
                id: "project_phaseReflections_sensemaking_issues",
                valuePath: "project_phaseReflections_sensemaking_issues",
                valueType: "string",
                displayType: "textarea",
                displayName: "Issues",
                displayPrompt: "Are there any unresolved <strong>issues</strong> going forward?"
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_addSensemakingSessionPlan',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addSensemakingSessionPlan",
        modelClass: "SensemakingSessionPlan",
        panelFields: [
            {
                id: "sensemakingSessionPlan_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Sensemaking session plan name",
                displayPrompt: "Please give this session plan a <strong>name</strong>."
            },
            {
                id: "sensemakingSessionPlan_groups",
                valueType: "string",
                displayType: "textarea",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>group</strong> (or groups) will be involved?"
            },
            {
                id: "sensemakingSessionPlan_repetitions",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Repetitions",
                displayPrompt: "How many <strong>repetitions</strong> of the session will there be?"
            },
            {
                id: "sensemakingSessionPlan_duration",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Length",
                displayPrompt: "<strong>How long</strong> will this session last?"
            },
            {
                id: "sensemakingSessionPlan_times",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Time",
                displayPrompt: "<strong>When</strong> will the sessions take place?"
            },
            {
                id: "sensemakingSessionPlan_location",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Location",
                displayPrompt: "<strong>Where</strong> will these sessions take place?"
            },
            {
                id: "sensemakingSessionPlan_numPeople",
                valueType: "string",
                displayType: "textarea",
                displayName: "Number of people",
                displayPrompt: "<strong>How many people</strong> will be invited to each repetition of this session?"
            },
            {
                id: "sensemakingSessionPlan_participantGroupsMixing",
                valueType: "string",
                displayType: "textarea",
                displayName: "Mixing",
                displayPrompt: "What are your plans for keeping participant groups <strong>together or apart</strong>?"
            },
            {
                id: "sensemakingSessionPlan_materials",
                valueType: "string",
                displayType: "textarea",
                displayName: "Materials",
                displayPrompt: "What <strong>materials</strong> will this session plan require?"
            },
            {
                id: "sensemakingSessionPlan_smallGroups",
                valueType: "string",
                displayType: "textarea",
                displayName: "Groups",
                displayPrompt: "What sorts of <strong>small groups</strong> will be formed in this session?"
            },
            {
                id: "sensemakingSessionPlan_details",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "Enter other <strong>details</strong> about this session."
            },
            {
                id: "sensemakingSessionPlan_activitiesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addSensemakingSessionActivity",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Sensemaking session activities",
                displayPrompt: "Here you can enter some <strong>activities</strong> you plan to use in the session. Activities can be simple instructions or complicated exercises (like the creation of timelines)."
            },
            {
                id: "sensemakingSessionPlan_printSensemakingSessionAgendaButton",
                valueType: "none",
                displayType: "button",
                displayPrompt: "Print session agenda",
                displayIconClass: "printButtonImage",
                displayConfiguration: "printSensemakingSessionAgenda",
                displayVisible: function (panelBuilder, model) {
                    return panelBuilder.readOnly === false;
                }
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_addSensemakingSessionActivity',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addSensemakingSessionActivity",
        modelClass: "SensemakingSessionActivityPlan",
        panelFields: [
            {
                id: "sensemakingSessionPlan_activity_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Name",
                displayPrompt: "Please give this activity a <strong>name</strong>."
            },
            {
                id: "order",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "10",
                displayName: "Order",
                displayPrompt: "Specify the order in which to do this sensemaking activity (e.g. 1, 2a, 2b, 3)"
            },
            {
                id: "sensemakingSessionPlan_activity_duration",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "30",
                displayName: "Length",
                displayPrompt: "<strong>How long</strong> will this activity take?"
            },
            {
                id: "sensemakingSessionPlan_activity_type",
                valueType: "string",
                valueOptions: [
                    "ice-breaker",
                    "encountering stories (no task)",
                    "encountering stories (simple task)",
                    "discussing stories",
                    "encountering patterns (no task)",
                    "encountering patterns (simple task)",
                    "discussing patterns",
                    "twice-told stories exercise",
                    "timeline exercise",
                    "landscape exercise",
                    "story elements exercise",
                    "composite stories exercise",
                    "my own exercise",
                    "break",
                    "wrap-up",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of activity is this?"
            },
            {
                id: "sensemakingSessionPlan_activity_plan",
                valueType: "string",
                displayType: "textarea",
                displayName: "Plan",
                displayPrompt: "Describe the <strong>plan</strong> for this activity."
            },
            {
                id: "sensemakingSessionPlan_activity_optionalParts",
                valueType: "string",
                displayType: "textarea",
                displayName: "Optional elaborations",
                displayPrompt: "Describe any optional <strong>elaborations</strong> you might or might not use in this activity."
            },
            {
                id: "sensemakingSessionPlan_activity_recording",
                valueType: "string",
                displayType: "textarea",
                displayName: "New stories",
                displayPrompt: "Will new stories be <strong>recorded</strong> during this activity? If so, how?"
            },
            {
                id: "sensemakingSessionPlan_activity_materials",
                valueType: "string",
                displayType: "textarea",
                displayName: "Materials",
                displayPrompt: "What materials (including catalytic materials, e.g., graphs and story cards) will this session plan require?"
            },
            {
                id: "sensemakingSessionPlan_activity_spaces",
                valueType: "string",
                displayType: "textarea",
                displayName: "Spaces",
                displayPrompt: "What <strong>spaces</strong> will be used for this activity?"
            },
            {
                id: "sensemakingSessionPlan_activity_facilitation",
                valueType: "string",
                displayType: "textarea",
                displayName: "Facilitation",
                displayPrompt: "What sort of <strong>facilitation</strong> will be necessary for this activity?"
            },
            {
                id: "sensemakingSessionActivity_helping",
                valueType: "string",
                displayType: "textarea",
                displayName: "Help",
                displayPrompt: "What will <strong>helpers</strong> do during this activity?"
            },
            {
                id: "templates_sensemakingActivities",
                valueType: "none",
                displayType: "templateList",
                displayConfiguration: "sensemakingActivities",
                displayPrompt: "Copy activity from template",
                displayIconClass: "copyButtonImage",
                displayVisible: function (panelBuilder, model) {
                    return panelBuilder.readOnly === false;
                }
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_addSensemakingSessionRecord',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addSensemakingSessionRecord",
        modelClass: "SensemakingSessionRecord",
        panelFields: [
            {
                id: "sensemakingSessionRecord_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Sensemaking session record name",
                displayPrompt: "Please give this session record a <strong>name</strong>."
            },
            {
                id: "sensemakingSessionRecord_whenWhere",
                valueType: "string",
                displayType: "textarea",
                displayName: "When and where",
                displayPrompt: "<strong>When and where</strong> did this session take place?"
            },
            {
                id: "sensemakingSessionRecord_groups",
                valueType: "string",
                displayType: "textarea",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>group</strong> (or groups) attended the session?"
            },
            {
                id: "sensemakingSessionRecord_participants",
                valueType: "string",
                displayType: "textarea",
                displayName: "Who attended",
                displayPrompt: "Describe the <strong>participants</strong> at this session."
            },
            {
                id: "sensemakingSessionRecord_plan",
                valueType: "string",
                displayType: "textarea",
                displayName: "Plan",
                displayPrompt: "Which of your sensemaking <strong>plans</strong> did you follow in this session? (And did you stick to the plan?)"
            },
            {
                id: "sensemakingSessionRecord_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Here you can enter general <strong>notes</strong> on the session. Your notes can include links to images or other documents."
            },
            {
                id: "sensemakingSessionRecord_resonantStoriesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addResonantStory",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Sensemaking session resonant stories",
                displayPrompt: "If you discovered any <strong>resonant stories</strong> (pivot, voice, discovery) in this session, you can enter them here."
            },
            {
                id: "sensemakingSessionRecord_resonantPatternsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addResonantPattern",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Sensemaking session resonant patterns",
                displayPrompt: "If you discovered any <strong>resonant patterns</strong> (pivot, voice, discovery) in this session, you can enter them here."
            },
            {
                id: "sensemakingSessionRecord_outcomesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_newSensemakingSessionOutcome",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Sensemaking session outcomes",
                displayPrompt: "If your session ended with creating lists of <strong>outcomes</strong> (like discoveries and ideas), you can enter them here."
            },
            {
                id: "sensemakingSessionRecord_constructionsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_newSensemakingSessionConstruction",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Sensemaking session constructions",
                displayPrompt: "If your session involve creating any group <strong>constructions</strong> (like landscapes or timelines), you can describe them here."
            },
            {
                id: "sensemakingSessionRecord_reflectionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use the questions below to <strong>reflect</strong> on the session."
            },
            {
                id: "sensemakingSessionRecord_reflectionsOnChangeHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Change"
            },
            {
                id: "sensemakingSessionRecord_reflections_change_participantPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in participant perceptions",
                displayPrompt: "How did the perceptions of the <strong>participants</strong> change from the start to the end of the session?"
            },
            {
                id: "sensemakingSessionRecord_reflections_change_yourPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in facilitator perceptions",
                displayPrompt: "How did <strong>your</strong> perceptions change?"
            },
            {
                id: "sensemakingSessionRecord_reflections_change_project",
                valueType: "string",
                displayType: "textarea",
                displayName: "Changes to the project",
                displayPrompt: "How has the overall <strong>project</strong> changed as a result of this session?"
            },
            {
                id: "sensemakingSessionRecord_interactionsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Interactions"
            },
            {
                id: "sensemakingSessionRecord_reflections_interaction_participants",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions among participants",
                displayPrompt: "Describe the interactions <strong>among participants</strong> in this session."
            },
            {
                id: "sensemakingSessionRecord_reflections_interaction_participantsAndFacilitator",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions between participants and facilitators",
                displayPrompt: "Describe the interactions <strong>between participants and facilitators</strong>."
            },
            {
                id: "sensemakingSessionRecord_reflections_interaction_stories",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories",
                displayPrompt: "What did you notice about the <strong>stories</strong> people told, retold, chose, and worked with during the session?"
            },
            {
                id: "sensemakingSessionRecord_learningHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Learning"
            },
            {
                id: "sensemakingSessionRecord_reflections_learning_special",
                valueType: "string",
                displayType: "textarea",
                displayName: "Unique features",
                displayPrompt: "What was <strong>special</strong> about these people in this place on this day?"
            },
            {
                id: "sensemakingSessionRecord_reflections_learning_surprise",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprise",
                displayPrompt: "What <strong>surprised</strong> you about this session?"
            },
            {
                id: "sensemakingSessionRecord_reflections_learning_workedWell",
                valueType: "string",
                displayType: "textarea",
                displayName: "Worked and didn't work",
                displayPrompt: "Which parts of your <strong>plans</strong> for this session worked out well? Which parts didn't?"
            },
            {
                id: "sensemakingSessionRecord_reflections_learning_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "What <strong>new ideas</strong> did you gain from this session? What did you <strong>learn</strong> from it?"
            },
            {
                id: "sensemakingSessionRecord_reflections_learning_wantToRemember",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "<strong>What else</strong> do you want to remember about this session?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_addResonantStory',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addResonantStory",
        modelClass: "ResonantStory",
        panelFields: [
            {
                id: "sensemakingSessionRecord_resonantStory_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Resonant story name",
                displayPrompt: "What is the <strong>name</strong> of the resonant story?"
            },
            {
                id: "sensemakingSessionRecord_resonantStory_type",
                valueType: "string",
                valueOptions: [
                    "pivot",
                    "voice",
                    "discovery",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "Which <strong>type</strong> of resonant story is this?"
            },
            {
                id: "sensemakingSessionRecord_resonantStory_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Story text",
                displayPrompt: "You can type (or paste) the story <strong>text</strong> (or summary) here."
            },
            {
                id: "sensemakingSessionRecord_resonantStory_reason",
                valueType: "string",
                displayType: "textarea",
                displayName: "Why",
                displayPrompt: "Why did this story <strong>stand out</strong>?"
            },
            {
                id: "sensemakingSessionRecord_resonantStory_peopleSaid",
                valueType: "string",
                displayType: "textarea",
                displayName: "People said",
                displayPrompt: "What did people <strong>say</strong> about this story?"
            },
            {
                id: "sensemakingSessionRecord_resonantStory_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "You can enter any other <strong>notes</strong> about this story here."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_addResonantPattern',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addResonantPattern",
        modelClass: "ResonantPattern",
        panelFields: [
            {
                id: "sensemakingSessionRecord_resonantPattern_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Why",
                displayPrompt: "Please give this resonant pattern a <strong>name</strong>."
            },
            {
                id: "sensemakingSessionRecord_resonantPattern_type",
                valueType: "string",
                valueOptions: [
                    "pivot",
                    "voice",
                    "discovery",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "Which <strong>type</strong> of resonant pattern is this?"
            },
            {
                id: "sensemakingSessionRecord_resonantPattern_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> the pattern."
            },
            {
                id: "sensemakingSessionRecord_resonantPattern_reason",
                valueType: "string",
                displayType: "textarea",
                displayName: "Why",
                displayPrompt: "Why did this pattern <strong>stand out</strong>?"
            },
            {
                id: "sensemakingSessionRecord_resonantPattern_peopleSaid",
                valueType: "string",
                displayType: "textarea",
                displayName: "People said",
                displayPrompt: "What did people <strong>say</strong> about this pattern?"
            },
            {
                id: "sensemakingSessionRecord_resonantPattern_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "You can enter any other <strong>notes</strong> about this pattern here."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_newSensemakingSessionOutcome',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_newSensemakingSessionOutcome",
        modelClass: "SensemakingSessionOutcome",
        panelFields: [
            {
                id: "sensemakingSessionRecord_outcome_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Name",
                displayPrompt: "Please give this outcome a <strong>name</strong>."
            },
            {
                id: "sensemakingSessionRecord_outcome_type",
                valueType: "string",
                valueOptions: [
                    "discovery",
                    "opportunity",
                    "issue",
                    "idea",
                    "recommendation",
                    "perspective",
                    "dilemma",
                    "discussion",
                    "priority",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of session outcome is this?"
            },
            {
                id: "sensemakingSessionRecord_outcome_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "<strong>Describe</strong> the outcome."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_newSensemakingSessionConstruction',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_newSensemakingSessionConstruction",
        modelClass: "SensemakingSessionConstruction",
        panelFields: [
            {
                id: "sensemakingSessionRecord_construction_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Sensemaking construction name",
                displayPrompt: "Please give this construction a <strong>name</strong>."
            },
            {
                id: "sensemakingSessionRecord_construction_type",
                valueType: "string",
                valueOptions: [
                    "timeline",
                    "landscape",
                    "story elements",
                    "composite story",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of construction is it?"
            },
            {
                id: "sensemakingSessionRecord_construction_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> the construction (or include a description given by participants). Your description can include links to images or documents."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/page_intervention',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_intervention",
        displayName: "Intervention",
        panelFields: [
            {
                id: "interventionIntroLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In this phase of PNI, you design, plan, carry out, and reflect on actions\n                you take to change the flow of stories in your community or organization. "
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/page_projectOutcomesForIntervention',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_projectOutcomesForIntervention",
        displayName: "Answer questions about project outcomes",
        pageExplanation: "Describe your project from the perspective of each participant group. Your answers will drive recommendations that appear on the next page.",
        pageCategories: "plan",
        headerAbove: "Plan",
        panelFields: [
            {
                id: "project_outcomes_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In order to choose interventions that will be useful in your project, it will be helpful to think about some of the <strong>outcomes</strong> of your project (so far). Please answer these questions in reference to the <strong>participant groups</strong> you set up in the project planning phase. Enter one set of outcomes for each participant group."
            },
            {
                id: "project_outcomesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_projectOutcome",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Project outcomes",
                displayPrompt: "These are the participant groups for which you have entered outcomes so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/page_designInterventions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_designInterventions",
        displayName: "Design intervention plans",
        pageExplanation: "Decide how you want to intervene in the flow of stories.",
        pageCategories: "plan",
        panelFields: [
            {
                id: "project_interventionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can <strong>design plans</strong> for interventions that change the stories people tell in your community or organization."
            },
            {
                id: "interventionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayIconClass: "recommendationsButtonImage",
                displayConfiguration: "interventions",
                displayPrompt: "Recommendations for intervention plans"
            },
            {
                id: "project_interventionPlansList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addIntervention",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Intervention plans",
                displayPrompt: "These are the intervention plans you have added. Click on a plan to edit it."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/page_recordInterventions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_recordInterventions",
        displayName: "Enter intervention records",
        pageExplanation: "Describe interventions you carried out.",
        pageCategories: "journal",
        headerAbove: "Wrap up",
        panelFields: [
            {
                id: "project_interventionRecordsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can enter <strong>records</strong> of the interventions you have carried out as part of your project."
            },
            {
                id: "project_interventionRecordsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addInterventionRecord",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Intervention records",
                displayPrompt: "These are the intervention records you have added. Click on a record to edit it."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/page_reflectOnInterventionPhase',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_reflectOnInterventionPhase",
        displayName: "Reflect on the intervention phase",
        pageExplanation: "Think about what happened in this part of the project.",
        pageCategories: "journal",
        panelFields: [
            {
                id: "project_phaseReflections_intervention_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can answer some <strong>reflective questions</strong> \n                that will help you think about what happened."
            },
            {
                id: "project_phaseReflections_intervention_happened",
                valuePath: "project_phaseReflections_intervention_happened",
                valueType: "string",
                displayType: "textarea",
                displayName: "What happened",
                displayPrompt: "What <strong>happened</strong> in the intervention phase of your project?"
            },
            {
                id: "project_phaseReflections_intervention_surprisedAndNot",
                valuePath: "project_phaseReflections_intervention_surprisedAndNot",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprised and Not",
                displayPrompt: "What <strong>surprised</strong> you? What didn't?"
            },
            {
                id: "project_phaseReflections_intervention_obstaclesAndOpportunities",
                valuePath: "project_phaseReflections_intervention_obstaclesAndOpportunities",
                valueType: "string",
                displayType: "textarea",
                displayName: "Obstacles and Opportunities",
                displayPrompt: "Did any <strong>obstacles</strong> or <strong>opportunities</strong> play a part in how things went? \n                Where did they come from? What did you do about them? How did that work out?"
            },
            {
                id: "project_phaseReflections_intervention_learned",
                valuePath: "project_phaseReflections_intervention_learned",
                valueType: "string",
                displayType: "textarea",
                displayName: "Learned",
                displayPrompt: "What did you <strong>learn</strong> from all of this?"
            },
            {
                id: "project_phaseReflections_intervention_newIdeas",
                valuePath: "project_phaseReflections_intervention_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "Did any <strong>new ideas</strong> come up that you want to remember in the future?"
            },
            {
                id: "project_phaseReflections_intervention_issues",
                valuePath: "project_phaseReflections_intervention_issues",
                valueType: "string",
                displayType: "textarea",
                displayName: "Issues",
                displayPrompt: "Are there any unresolved <strong>issues</strong> going forward?"
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/panel_projectOutcome',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_projectOutcome",
        displayName: "Project outcomes",
        modelClass: "ProjectOutcome",
        panelFields: [
            {
                id: "outcomes_group",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Participant group",
                displayPrompt: "Which participant <strong>group</strong> is this outcome for?"
            },
            {
                id: "outcomes_hopesHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Hopes"
            },
            {
                id: "outcomes_peopleFeltHeard",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Felt heard",
                displayPrompt: "During your project, did the people in this group say they <strong>felt heard</strong> for the first time?"
            },
            {
                id: "outcomes_peopleFeltInvolved",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Felt involved",
                displayPrompt: "Did they say they <strong>felt involved</strong> for the first time?"
            },
            {
                id: "outcomes_peopleLearnedAboutCommOrg",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Learned about community",
                displayPrompt: "Did they say they <strong>learned about their community or organization</strong>?"
            },
            {
                id: "outcomes_voicesHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Voices"
            },
            {
                id: "outcomes_peopleWantedToTellMoreStories",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Wanted to tell more",
                displayPrompt: "During your story collection, did these people seem to want to <strong>tell more stories</strong> than you collected?"
            },
            {
                id: "outcomes_peopleWantedToShareMoreStoriesWithEachOther",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Wanted to share more",
                displayPrompt: "Did you ever feel that they wanted to <strong>share more experiences</strong> (with each other) than they did?"
            },
            {
                id: "outcomes_peopleFeltStoriesNeededToBeHeard",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Felt that stories needed to be heard",
                displayPrompt: "Did these people feel that some of the stories you collected <strong>needed to be heard</strong> by anyone?"
            },
            {
                id: "outcomes_peopleFeltNobodyCares",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Felt that nobody cares",
                displayPrompt: "Were there any issues that these people thought <strong>nobody cares</strong> about?"
            },
            {
                id: "outcomes_needsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Needs"
            },
            {
                id: "outcomes_peopleFeltNobodyCanMeetNeeds",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Needs could not be met",
                displayPrompt: "Do the people in this group have <strong>needs that nobody can meet</strong>?"
            },
            {
                id: "outcomes_peopleFeltTheyNeedNewStories",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Needed to tell themselves new stories",
                displayPrompt: "Do these people need to start <strong>telling themselves new stories</strong>?"
            },
            {
                id: "outcomes_peopleWantedToKeepExploring",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Wanted more exploration",
                displayPrompt: "Were there any issues about which the people in this group seemed to want to <strong>keep exploring</strong>?"
            },
            {
                id: "outcomes_crisisPointsWereFound",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Crisis points",
                displayPrompt: "Did you discover any <strong>crisis points</strong> where people in this group needed help and didn't get it?"
            },
            {
                id: "outcomes_issuesWereBeyondWords",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Beyond words",
                displayPrompt: "Did you find any issues for this group that were <strong>beyond words</strong>, that no amount of discussion could resolve?"
            },
            {
                id: "outcomes_learningHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Learning"
            },
            {
                id: "outcomes_peopleLearnedAboutTopic",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Learned about topic",
                displayPrompt: "Did these people say that they <strong>learned about the topic</strong> by participating in the project?"
            },
            {
                id: "outcomes_issuesNewMembersStruggleWith",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "New members needed help",
                displayPrompt: "Did you notice that <strong>new members</strong> of the community or organization were having a harder time making sense of things?"
            },
            {
                id: "outcomes_foundInfoWithoutUnderstanding",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Had more information than understanding",
                displayPrompt: "Were there any issues that these people found <strong>difficult to understand</strong>, even though abundant information was available?"
            },
            {
                id: "outcomes_foundOverConfidence",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Had more confidence than skill",
                displayPrompt: "Did you discover any areas in which these people had <strong>more confidence than skill</strong>?"
            },
            {
                id: "outcomes_peopleCuriousAboutStoryWork",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Wanted to learn about story work",
                displayPrompt: "Did any of these participants express an interest in <strong>learning more about story work</strong>?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/panel_addIntervention',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addIntervention",
        displayName: "Plan an intervention",
        modelClass: "InterventionPlan",
        panelFields: [
            {
                id: "interventionPlan_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Intervention plan name",
                displayPrompt: "Please give this intervention plan a <strong>name</strong>."
            },
            {
                id: "interventionPlan_type",
                valueType: "string",
                valueOptions: [
                    "narrative ombudsman",
                    "narrative suggestion box",
                    "story sharing space",
                    "narrative orientation",
                    "narrative learning resource",
                    "narrative simulation",
                    "narrative presentation",
                    "dramatic action",
                    "sensemaking space",
                    "sensemaking pyramid",
                    "narrative mentoring program",
                    "narrative therapy",
                    "participatory theatre",
                    "mixed",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of intervention will this be?"
            },
            {
                id: "interventionPlan_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please describe your <strong>plan</strong> for this intervention."
            },
            {
                id: "interventionPlan_groups",
                valueType: "string",
                displayType: "text",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>group</strong> (or groups) will be involved?"
            },
            {
                id: "interventionPlan_howmany",
                valueType: "string",
                displayType: "text",
                displayName: "How many",
                displayPrompt: "<strong>How many</strong> people will be involved in this intervention?"
            },
            {
                id: "interventionPlan_times",
                valueType: "string",
                displayType: "text",
                displayName: "Time",
                displayPrompt: "<strong>When</strong> will the intervention take place?"
            },
            {
                id: "interventionPlan_locations",
                valueType: "string",
                displayType: "text",
                displayName: "Location",
                displayPrompt: "<strong>Where</strong> will the intervention take place?"
            },
            {
                id: "interventionPlan_help",
                valueType: "string",
                displayType: "textarea",
                displayName: "Help",
                displayPrompt: "What sort of <strong>help</strong> will you need to carry out this intervention?"
            },
            {
                id: "interventionPlan_permission",
                valueType: "string",
                displayType: "textarea",
                displayName: "Permission",
                displayPrompt: "Describe any <strong>permissions</strong> you will need to carry out this intervention."
            },
            {
                id: "interventionPlan_participation",
                valueType: "string",
                displayType: "textarea",
                displayName: "Participation",
                displayPrompt: "How will you <strong>recruit</strong> people to participate in this intervention?"
            },
            {
                id: "interventionPlan_materials",
                valueType: "string",
                displayType: "textarea",
                displayName: "Materials",
                displayPrompt: "What physical <strong>materials</strong> will you need?"
            },
            {
                id: "interventionPlan_space",
                valueType: "string",
                displayType: "textarea",
                displayName: "Spaces",
                displayPrompt: "What <strong>spaces</strong> will you use?"
            },
            {
                id: "interventionPlan_techResources",
                valueType: "string",
                displayType: "textarea",
                displayName: "Technology",
                displayPrompt: "What technological <strong>resources</strong> will you need?"
            },
            {
                id: "interventionPlan_recording",
                valueType: "string",
                displayType: "textarea",
                displayName: "Recording",
                displayPrompt: "How will you <strong>record</strong> the results of this intervention?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/panel_addInterventionRecord',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addInterventionRecord",
        displayName: "Add intervention record",
        modelClass: "InterventionRecord",
        panelFields: [
            {
                id: "interventionRecord_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Intervention record name",
                displayPrompt: "Please give this intervention record a <strong>name</strong>."
            },
            {
                id: "interventionRecord_groups",
                valueType: "string",
                displayType: "text",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>group</strong> (or groups) were involved?"
            },
            {
                id: "interventionRecord_timeandplace",
                valueType: "string",
                displayType: "textarea",
                displayName: "When and where",
                displayPrompt: "<strong>When and where</strong> did the intervention take place?"
            },
            {
                id: "interventionRecord_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> what happened during the intervention, in general."
            },
            {
                id: "interventionRecord_plan",
                valueType: "string",
                displayType: "textarea",
                displayName: "Plan",
                displayPrompt: "Which of your intervention plans did you follow in this intervention? (And did you stick to the plan?)"
            },
            {
                id: "interventionRecord_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter additional <strong>notes</strong> on the intervention here. Your notes can include links to images or other documents."
            },
            {
                id: "interventionRecord_reflectLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use the questions below to <strong>reflect</strong> on the intervention."
            },
            {
                id: "interventionRecord_reflectionsOnChangeHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Change"
            },
            {
                id: "interventionRecord_reflections_change_participantPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in participant perceptions",
                displayPrompt: "How did the perceptions of the <strong>participants</strong> change from the start to the end of the intervention?"
            },
            {
                id: "interventionRecord_reflections_change_yourPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in facilitator perceptions",
                displayPrompt: "How did <strong>your</strong> perceptions change?"
            },
            {
                id: "interventionRecord_reflections_change_project",
                valueType: "string",
                displayType: "textarea",
                displayName: "Changes to the project",
                displayPrompt: "How has the overall <strong>project</strong> changed as a result of this intervention?"
            },
            {
                id: "interventionRecord_interactionsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Interactions"
            },
            {
                id: "interventionRecord_reflections_interaction_participants",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions among participants",
                displayPrompt: "Describe the interactions <strong>among participants</strong> in this intervention."
            },
            {
                id: "interventionRecord_reflections_interaction_participantsAndFacilitator",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions between participants and facilitators",
                displayPrompt: "Describe the interactions <strong>between participants and facilitators</strong>."
            },
            {
                id: "interventionRecord_reflections_interaction_stories",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories",
                displayPrompt: "What did you notice about the <strong>stories</strong> people told, retold, chose, and worked with during the intervention?"
            },
            {
                id: "interventionRecord_learningHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Learning"
            },
            {
                id: "interventionRecord_reflections_learning_special",
                valueType: "string",
                displayType: "textarea",
                displayName: "Unique features",
                displayPrompt: "What was <strong>special</strong> about this intervention?"
            },
            {
                id: "interventionRecord_reflections_learning_surprise",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprise",
                displayPrompt: "What <strong>surprised</strong> you about this intervention?"
            },
            {
                id: "interventionRecord_reflections_learning_workedWell",
                valueType: "string",
                displayType: "textarea",
                displayName: "Worked and didn't work",
                displayPrompt: "Which parts of your <strong>plans</strong> for this intervention worked out well? Which parts didn't?"
            },
            {
                id: "interventionRecord_reflections_learning_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "What <strong>new ideas</strong> did you gain from this intervention? What did you <strong>learn</strong> from it?"
            },
            {
                id: "interventionRecord_reflections_learning_wantToRemember",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "<strong>What else</strong> do you want to remember about this intervention?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/page_return',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_return",
        displayName: "Return",
        panelFields: [
            {
                id: "returnIntroLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In this phase of PNI, you wrap up your project and support the return of stories \n                (stories you collected and stories about the project) to your community or organization."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/page_gatherFeedback',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_gatherFeedback",
        displayName: "Gather feedback",
        pageExplanation: "Make a note of things people told you about the project.",
        pageCategories: "journal",
        headerAbove: "Listen",
        panelFields: [
            {
                id: "project_feedbackLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can record any <strong>feedback</strong> you have gathered about your project."
            },
            {
                id: "project_feedbackItemsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_enterFeedbackPiece",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                        columnsToDisplay: ["feedback_name", "feedback_type", "feedback_text"]
                    },
                },
                displayName: "Feedback pieces",
                displayPrompt: "These are the pieces of feedback you have entered so far."
            },
            {
                id: "feedback_generalNotes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "If you would like to enter any <strong>general notes</strong> on the feedback you've received about the project, you can write them here."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/page_prepareProjectPresentation',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_prepareProjectPresentation",
        displayName: "Prepare outline of project presentation",
        pageExplanation: "Create a simple outline you can use to tell people the story of your project.",
        pageCategories: "journal",
        headerAbove: "Explain",
        panelFields: [
            {
                id: "project_presentationLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "This is a simple page you can use to build a simple outline for a <strong>presentation</strong> about your project. \n                You could also build this outline in a word processor. Writing it here keeps the outline\n                bundled with the rest of your project, so it's easier to look back on later."
            },
            {
                id: "project_presentationElementsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addPresentationElement",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                    }
                },
                displayName: "Statements",
                displayPrompt: "These are the presentation elements you have added. Click on an element to edit it."
            },
            {
                id: "projectPresentation_exportPresentationOutlineButton",
                valueType: "none",
                displayType: "button",
                displayPrompt: "Print presentation outline",
                displayIconClass: "printButtonImage",
                displayConfiguration: "exportPresentationOutline",
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/page_projectRequests',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_projectRequests",
        displayName: "Respond to requests for post-project support",
        pageExplanation: "Manage and record any requests or inquiries you get as your project winds down.",
        pageCategories: "journal",
        panelFields: [
            {
                id: "project_returnRequestsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can keep track of <strong>requests for help</strong> you receive as your project winds down. \n                You could keep a record of your requests elsewhere, but keeping them here helps you find them later when you look at the project again."
            },
            {
                id: "project_returnRequestsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addNewReturnRequest",
                    gridConfiguration: {
                        addButton: true,
                        removeButton: true,
                        duplicateButton: true,
                        columnsToDisplay: ["returnRequest_description", "returnRequest_type", "returnRequest_isMet"]
                    }
                },
                displayName: "Help requests",
                displayPrompt: "These are the requests you have recorded so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/page_reflectOnReturnPhase',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_reflectOnReturnPhase",
        displayName: "Reflect on the return phase",
        pageExplanation: "Think about what happened in this part of the project.",
        pageCategories: "journal",
        headerAbove: "Wrap up",
        panelFields: [
            {
                id: "project_phaseReflections_return_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can answer some <strong>reflective questions</strong> \n                that will help you think about what happened."
            },
            {
                id: "project_phaseReflections_return_happened",
                valuePath: "project_phaseReflections_return_happened",
                valueType: "string",
                displayType: "textarea",
                displayName: "What happened",
                displayPrompt: "What <strong>happened</strong> in the return phase of your project?"
            },
            {
                id: "project_phaseReflections_return_surprisedAndNot",
                valuePath: "project_phaseReflections_return_surprisedAndNot",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprised and Not",
                displayPrompt: "What <strong>surprised</strong> you? What didn't?"
            },
            {
                id: "project_phaseReflections_return_obstaclesAndOpportunities",
                valuePath: "project_phaseReflections_return_obstaclesAndOpportunities",
                valueType: "string",
                displayType: "textarea",
                displayName: "Obstacles and Opportunities",
                displayPrompt: "Did any <strong>obstacles</strong> or <strong>opportunities</strong> play a part in how things went? \n                Where did they come from? What did you do about them? How did that work out?"
            },
            {
                id: "project_phaseReflections_return_learned",
                valuePath: "project_phaseReflections_return_learned",
                valueType: "string",
                displayType: "textarea",
                displayName: "Learned",
                displayPrompt: "What did you <strong>learn</strong> from all of this?"
            },
            {
                id: "project_phaseReflections_return_newIdeas",
                valuePath: "project_phaseReflections_return_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "Did any <strong>new ideas</strong> come up that you want to remember in the future?"
            },
            {
                id: "project_phaseReflections_return_issues",
                valuePath: "project_phaseReflections_return_issues",
                valueType: "string",
                displayType: "textarea",
                displayName: "Issues",
                displayPrompt: "Are there any unresolved <strong>issues</strong> going forward?"
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/page_reflectOnProject',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_reflectOnProject",
        displayName: "Reflect on the project",
        pageExplanation: "Think about what happened in the entire project.",
        pageCategories: "journal",
        panelFields: [
            {
                id: "project_reflectLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can answer some questions to <strong>reflect</strong> in general on the entire project."
            },
            {
                id: "project_reflect_stories_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "The stories you heard"
            },
            {
                id: "project_reflect_stories_surprised",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories surprise",
                displayPrompt: "What <strong>surprised</strong> you about the stories you heard in this project?"
            },
            {
                id: "project_reflect_stories_learned",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories learned",
                displayPrompt: "What do you know <strong>about stories</strong> that you didn't know before this project?"
            },
            {
                id: "project_reflect_stories_definition",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories definition",
                displayPrompt: "Has your <strong>definition</strong> of the word \"story\" changed during this project? If so, how?"
            },
            {
                id: "project_reflect_community_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "The community or organization"
            },
            {
                id: "project_reflect_community_knownow",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community know now",
                displayPrompt: "What do you <strong>know</strong> about the community or organization that you didn't know before the project started?"
            },
            {
                id: "project_reflect_community_dangersoppportunities",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community dangers or opportunities",
                displayPrompt: "Did this project uncover any <strong>dangers or opportunities</strong> about the community or organization? If so, what are they?"
            },
            {
                id: "project_reflect_community_future",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community future",
                displayPrompt: "How will what you have learned about the community or organization impact any <strong>future</strong> projects you do with or for it?"
            },
            {
                id: "project_reflect_yourself_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Yourself"
            },
            {
                id: "project_reflect_yourself_stuck",
                valueType: "string",
                displayType: "textarea",
                displayName: "Yourself stuck",
                displayPrompt: "In any part of this project, did you ever find yourself (personally or as a team) <strong>stuck</strong> in an area in which you thought you had strength?"
            },
            {
                id: "project_reflect_yourself_skills",
                valueType: "string",
                displayType: "textarea",
                displayName: "Yourself skills",
                displayPrompt: "During this project, did you ever find <strong>skills</strong> you didn't know you had? What happened?"
            },
            {
                id: "project_reflect_yourself_team",
                valueType: "string",
                displayType: "textarea",
                displayName: "Yourself team",
                displayPrompt: "If you are working in a <strong>team</strong>: What did you learn about how your team works together during this project? How can you use that knowledge going forward?"
            },
            {
                id: "project_reflect_planning_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Your project planning"
            },
            {
                id: "project_reflect_planning_turnedout",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project turned out",
                displayPrompt: "Did your project plan <strong>turn out</strong> the way you thought it would? What worked as you expected, and what didn't?"
            },
            {
                id: "project_reflect_planning_crises",
                valueType: "string",
                displayType: "textarea",
                displayName: "Planning crises",
                displayPrompt: "Were there any moments during the project where you experienced <strong>crises</strong> because your plan was not working? What happened during those moments?"
            },
            {
                id: "project_reflect_planning_opportunities",
                valueType: "string",
                displayType: "textarea",
                displayName: "Planning opportunities",
                displayPrompt: "Did any unexpected <strong>opportunities</strong> or <strong>new ideas</strong> present themselves during the project? Were there times when you said to yourself, \"I didn't plan on that, but it's a great idea\"?"
            },
            {
                id: "project_reflect_facilitation_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Your facilitation"
            },
            {
                id: "project_reflect_facilitation_highlowpoints",
                valueType: "string",
                displayType: "textarea",
                displayName: "Facilitation high and low points",
                displayPrompt: "If you held any facilitated sessions during this project, what were some of the <strong>high and low points</strong> in your facilitation?"
            },
            {
                id: "project_reflect_facilitation_surprise",
                valueType: "string",
                displayType: "textarea",
                displayName: "Facilitation surprise",
                displayPrompt: "What <strong>surprised</strong> you about your facilitation?"
            },
            {
                id: "project_reflect_facilitation_know",
                valueType: "string",
                displayType: "textarea",
                displayName: "Facilitation know",
                displayPrompt: "What do you know <strong>about facilitation</strong> that you didn't know before this project?"
            },
            {
                id: "project_reflect_ownPNI_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Your own version of PNI"
            },
            {
                id: "project_reflect_ownPNI_challenge",
                valueType: "string",
                displayType: "textarea",
                displayName: "Your PNI challenge",
                displayPrompt: "How did this project <strong>challenge</strong> the way you do PNI? What <strong>limitations</strong> did it expose?"
            },
            {
                id: "project_reflect_ownPNI_experiments",
                valueType: "string",
                displayType: "textarea",
                displayName: "Your PNI experiments",
                displayPrompt: "Did you try any <strong>experiments</strong> with your PNI practice during this project? If so, what happened?"
            },
            {
                id: "project_reflect_ownPNI_know",
                valueType: "string",
                displayType: "textarea",
                displayName: "Your PNI knowledge",
                displayPrompt: "What do you <strong>know</strong> about PNI that you didn't know before this project?"
            },
            {
                id: "project_reflect_ownPNI_change",
                valueType: "string",
                displayType: "textarea",
                displayName: "Your PNI change",
                displayPrompt: "How do you think your PNI practice will <strong>change</strong> because of this project?"
            },
            {
                id: "project_reflect_future_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "The future"
            },
            {
                id: "project_reflect_future_curiousity",
                valueType: "string",
                displayType: "textarea",
                displayName: "Future curiosity",
                displayPrompt: "Are there any aspects of PNI, or of story work in general, that this project makes you <strong>curious</strong> about trying in the future?"
            },
            {
                id: "project_reflect_future_projects",
                valueType: "string",
                displayType: "textarea",
                displayName: "Future projects",
                displayPrompt: "List some <strong>future projects</strong> that you would like to do after this project, if you can. What would you like to do next?"
            },
            {
                id: "project_reflect_reminders_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Reminders"
            },
            {
                id: "project_reflect_reminders",
                valueType: "string",
                displayType: "textarea",
                displayName: "Next project reminders",
                displayPrompt: "Enter any <strong>reminders</strong> (ideas, resolutions, warnings) you want to keep in mind as you plan your next project. (Then, when you start your next project, copy these reminders and paste them into the \"Answer PNI planning questions\" page of the new project.)"
            },
            {
                id: "project_reflect_notes_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Notes"
            },
            {
                id: "project_reflect_future_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter any <strong>general notes</strong> you'd like to remember about the project."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/panel_enterFeedbackPiece',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_enterFeedbackPiece",
        modelClass: "FeedbackPiece",
        panelFields: [
            {
                id: "feedback_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Name",
                displayPrompt: "Please give this piece of feedback a <strong>name</strong>."
            },
            {
                id: "feedback_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "What did someone <strong>say or do</strong>?"
            },
            {
                id: "feedback_type",
                valueType: "string",
                valueOptions: [
                    "a reference to something from the project",
                    "a concern or complaint",
                    "a thank you",
                    "a suggestion",
                    "a hope or wish",
                    "a statement of fact",
                    "an opinion",
                    "a story",
                    "an action",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of feedback was this?"
            },
            {
                id: "feedback_who",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "Source",
                displayPrompt: "<strong>Who</strong> said or did this?"
            },
            {
                id: "feedback_when",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "40",
                displayName: "When",
                displayPrompt: "<strong>When</strong> did this happen?"
            },
            {
                id: "feedback_prompt",
                valueType: "string",
                displayType: "textarea",
                displayName: "What led to it",
                displayPrompt: "What did you say or do (if anything) that <strong>led to</strong> this feedback?"
            },
            {
                id: "feedback_response",
                valueType: "string",
                displayType: "textarea",
                displayName: "What I said back",
                displayPrompt: "What did you say or do (if anything) <strong>in response</strong>?"
            },
            {
                id: "feedback_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Please enter any other <strong>notes</strong> you would like to remember about this piece of feedback."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/panel_addPresentationElement',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addPresentationElement",
        modelClass: "PresentationElement",
        panelFields: [
            {
                id: "projectPresentationElement_name",
                valueType: "string",
                displayType: "text",
                displayConfiguration: "20",
                displayName: "Element name",
                displayPrompt: "Please give this presentation element a <strong>name</strong>."
            },
            {
                id: "projectPresentationElement_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "<strong>Describe</strong> this presentation element. What do you want to tell people about?"
            },
            {
                id: "projectPresentationElement_type",
                valueType: "string",
                valueOptions: [
                    "a background explanation about the project",
                    "a report on what happened",
                    "a project outcome",
                    "something someone said about the project",
                    "something you learned during the project",
                    "how the project affected the community",
                    "a proposal for the future",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of element is this?"
            },
            {
                id: "projectPresentationElement_examples",
                valueType: "string",
                displayType: "textarea",
                displayName: "Examples",
                displayPrompt: "Here you can list some <strong>stories and/or patterns</strong> that illustrate this presentation element."
            },
            {
                id: "projectPresentationElement_QA",
                valueType: "string",
                displayType: "textarea",
                displayName: "Q&A",
                displayPrompt: "What <strong>questions</strong> do you anticipate about this element? How would you like to answer them?"
            },
            {
                id: "projectPresentationElement_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter any other <strong>notes</strong> you want to include about this presentation element."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/panel_addNewReturnRequest',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addNewReturnRequest",
        modelClass: "ReturnRequest",
        panelFields: [
            {
                id: "returnRequest_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> the request."
            },
            {
                id: "returnRequest_type",
                valueType: "string",
                valueOptions: [
                    "help with their own projects",
                    "help with sustaining story exchange",
                    "help with examining this project's stories and results",
                    "help learning about story work",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of request is this?"
            },
            {
                id: "returnRequest_isMet",
                valueType: "boolean",
                displayType: "boolean",
                displayName: "Satisfied",
                displayPrompt: "Do you consider this request to have been <strong>satisfied</strong>?"
            },
            {
                id: "returnRequest_whatHappened",
                valueType: "string",
                displayType: "textarea",
                displayName: "What happened",
                displayPrompt: "<strong>What has happened</strong> in relation to this request? What discussions took place? Who did what?"
            },
            {
                id: "returnRequest_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter any other <strong>notes</strong> about the request here."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/navigation',["require", "exports", "./dashboard/page_dashboard", "./administration/page_administration", "./administration/page_projectOptions", "./administration/page_importExport", "./administration/page_print", "./planning/page_planning", "./planning/page_projectFacts", "./planning/page_planningQuestionsDraft", "./planning/page_participantGroups", "./planning/page_describeYourResources", "./planning/page_projectStories", "./planning/page_observeStorySharing", "./planning/page_createProjectStoryElements", "./planning/page_assessStorySharing", "./planning/page_revisePNIPlanningQuestions", "./planning/page_writeProjectSynopsis", "./planning/page_buildPrivacyPolicy", "./planning/page_reflectOnPlanningPhase", "./planning/panel_addParticipantGroup", "./planning/panel_projectStory", "./planning/panel_addStorySharingObservation", "./planning/panel_addObservedStory", "./collection/page_collection", "./collection/page_chooseCollectionMethods", "./collection/page_planStoryCollectionSessions", "./collection/page_writeStoryElicitingQuestions", "./collection/page_writeQuestionsAboutStories", "./collection/page_writeQuestionsAboutParticipants", "./collection/page_designStoryForms", "./collection/page_translateStoryForms", "./collection/page_startStoryCollection", "./collection/page_printQuestionForms", "./collection/page_enterStories", "./collection/page_exportStories", "./collection/page_reviewIncomingStories", "./collection/page_browseGraphs", "./collection/page_stopStoryCollection", "./collection/page_enterCollectionSessionRecords", "./collection/page_reflectOnCollectionPhase", "./collection/panel_addStoryCollectionMethod", "./collection/panel_addStoryCollectionSession", "./collection/panel_addCollectionSessionActivity", "./collection/panel_addElicitingQuestion", "./collection/panel_addStoryQuestion", "./collection/panel_addParticipantQuestion", "./collection/panel_addStoryForm", "./collection/panel_chooseElicitingQuestion", "./collection/panel_chooseStoryQuestion", "./collection/panel_chooseParticipantQuestion", "./collection/panel_addStoryCollection", "./catalysis/panel_addAnnotationQuestion", "./collection/panel_addCollectionSessionRecord", "./collection/panel_newCollectionSessionConstruction", "./catalysis/page_catalysis", "./catalysis/page_writeAnnotationsAboutStories", "./catalysis/page_annotateStories", "./catalysis/page_startCatalysisReport", "./catalysis/page_configureCatalysisReport", "./catalysis/page_explorePatterns", "./catalysis/page_clusterInterpretations", "./catalysis/page_printCatalysisReport", "./catalysis/page_reflectOnCatalysisPhase", "./catalysis/panel_addCatalysisReport", "./catalysis/panel_chooseStoryCollection", "./catalysis/panel_addInterpretation", "./sensemaking/page_sensemaking", "./sensemaking/page_printStoryCards", "./sensemaking/page_planSensemakingSessions", "./sensemaking/page_enterSensemakingSessionRecords", "./sensemaking/page_reflectOnSensemakingPhase", "./sensemaking/panel_addSensemakingSessionPlan", "./sensemaking/panel_addSensemakingSessionActivity", "./sensemaking/panel_addSensemakingSessionRecord", "./sensemaking/panel_addResonantStory", "./sensemaking/panel_addResonantPattern", "./sensemaking/panel_newSensemakingSessionOutcome", "./sensemaking/panel_newSensemakingSessionConstruction", "./intervention/page_intervention", "./intervention/page_projectOutcomesForIntervention", "./intervention/page_designInterventions", "./intervention/page_recordInterventions", "./intervention/page_reflectOnInterventionPhase", "./intervention/panel_projectOutcome", "./intervention/panel_addIntervention", "./intervention/panel_addInterventionRecord", "./return/page_return", "./return/page_gatherFeedback", "./return/page_prepareProjectPresentation", "./return/page_projectRequests", "./return/page_reflectOnReturnPhase", "./return/page_reflectOnProject", "./return/panel_enterFeedbackPiece", "./return/panel_addPresentationElement", "./return/panel_addNewReturnRequest"], function (require, exports, page_dashboard, page_administration, page_projectOptions, page_importExport, page_print, page_planning, page_projectFacts, page_planningQuestionsDraft, page_participantGroups, page_describeYourResources, page_projectStories, page_observeStorySharing, page_createProjectStoryElements, page_assessStorySharing, page_revisePNIPlanningQuestions, page_writeProjectSynopsis, page_buildPrivacyPolicy, page_reflectOnPlanningPhase, panel_addParticipantGroup, panel_projectStory, panel_addStorySharingObservation, panel_addObservedStory, page_collection, page_chooseCollectionMethods, page_planStoryCollectionSessions, page_writeStoryElicitingQuestions, page_writeQuestionsAboutStories, page_writeQuestionsAboutParticipants, page_designStoryForms, page_translateStoryForms, page_startStoryCollection, page_printQuestionForms, page_enterStories, page_exportStories, page_reviewIncomingStories, page_browseGraphs, page_stopStoryCollection, page_enterCollectionSessionRecords, page_reflectOnCollectionPhase, panel_addStoryCollectionMethod, panel_addStoryCollectionSession, panel_addCollectionSessionActivity, panel_addElicitingQuestion, panel_addStoryQuestion, panel_addParticipantQuestion, panel_addStoryForm, panel_chooseElicitingQuestion, panel_chooseStoryQuestion, panel_chooseParticipantQuestion, panel_addStoryCollection, panel_addAnnotationQuestion, panel_addCollectionSessionRecord, panel_newCollectionSessionConstruction, page_catalysis, page_writeAnnotationsAboutStories, page_annotateStories, page_startCatalysisReport, page_configureCatalysisReport, page_explorePatterns, page_clusterInterpretations, page_printCatalysisReport, page_reflectOnCatalysisPhase, panel_addCatalysisReport, panel_chooseStoryCollection, panel_addInterpretation, page_sensemaking, page_printStoryCards, page_planSensemakingSessions, page_enterSensemakingSessionRecords, page_reflectOnSensemakingPhase, panel_addSensemakingSessionPlan, panel_addSensemakingSessionActivity, panel_addSensemakingSessionRecord, panel_addResonantStory, panel_addResonantPattern, panel_newSensemakingSessionOutcome, panel_newSensemakingSessionConstruction, page_intervention, page_projectOutcomesForIntervention, page_designInterventions, page_recordInterventions, page_reflectOnInterventionPhase, panel_projectOutcome, panel_addIntervention, panel_addInterventionRecord, page_return, page_gatherFeedback, page_prepareProjectPresentation, page_projectRequests, page_reflectOnReturnPhase, page_reflectOnProject, panel_enterFeedbackPiece, panel_addPresentationElement, panel_addNewReturnRequest) {
    "use strict";
    var navigationModules = {};
    navigationModules["page_dashboard"] = page_dashboard;
    navigationModules["page_administration"] = page_administration;
    navigationModules["page_projectOptions"] = page_projectOptions;
    navigationModules["page_importExport"] = page_importExport;
    navigationModules["page_print"] = page_print;
    navigationModules["page_planning"] = page_planning;
    navigationModules["page_projectFacts"] = page_projectFacts;
    navigationModules["page_planningQuestionsDraft"] = page_planningQuestionsDraft;
    navigationModules["page_participantGroups"] = page_participantGroups;
    navigationModules["page_describeYourResources"] = page_describeYourResources;
    navigationModules["page_projectStories"] = page_projectStories;
    navigationModules["page_createProjectStoryElements"] = page_createProjectStoryElements;
    navigationModules["page_observeStorySharing"] = page_observeStorySharing;
    navigationModules["page_assessStorySharing"] = page_assessStorySharing;
    navigationModules["page_revisePNIPlanningQuestions"] = page_revisePNIPlanningQuestions;
    navigationModules["page_reflectOnPlanningPhase"] = page_reflectOnPlanningPhase;
    navigationModules["page_writeProjectSynopsis"] = page_writeProjectSynopsis;
    navigationModules["page_buildPrivacyPolicy"] = page_buildPrivacyPolicy;
    navigationModules["panel_addParticipantGroup"] = panel_addParticipantGroup;
    navigationModules["panel_projectStory"] = panel_projectStory;
    navigationModules["panel_addStorySharingObservation"] = panel_addStorySharingObservation;
    navigationModules["panel_addObservedStory"] = panel_addObservedStory;
    navigationModules["page_collection"] = page_collection;
    navigationModules["page_chooseCollectionMethods"] = page_chooseCollectionMethods;
    navigationModules["page_planStoryCollectionSessions"] = page_planStoryCollectionSessions;
    navigationModules["page_writeStoryElicitingQuestions"] = page_writeStoryElicitingQuestions;
    navigationModules["page_writeQuestionsAboutStories"] = page_writeQuestionsAboutStories;
    navigationModules["page_writeQuestionsAboutParticipants"] = page_writeQuestionsAboutParticipants;
    navigationModules["page_designStoryForms"] = page_designStoryForms;
    navigationModules["page_translateStoryForms"] = page_translateStoryForms;
    navigationModules["page_startStoryCollection"] = page_startStoryCollection;
    navigationModules["page_printQuestionForms"] = page_printQuestionForms;
    navigationModules["page_enterStories"] = page_enterStories;
    navigationModules["page_exportStories"] = page_exportStories;
    navigationModules["page_reviewIncomingStories"] = page_reviewIncomingStories;
    navigationModules["page_browseGraphs"] = page_browseGraphs;
    navigationModules["page_stopStoryCollection"] = page_stopStoryCollection;
    navigationModules["page_enterCollectionSessionRecords"] = page_enterCollectionSessionRecords;
    navigationModules["page_reflectOnCollectionPhase"] = page_reflectOnCollectionPhase;
    navigationModules["panel_addStoryCollectionMethod"] = panel_addStoryCollectionMethod;
    navigationModules["panel_addStoryCollectionSession"] = panel_addStoryCollectionSession;
    navigationModules["panel_addCollectionSessionActivity"] = panel_addCollectionSessionActivity;
    navigationModules["panel_addElicitingQuestion"] = panel_addElicitingQuestion;
    navigationModules["panel_addStoryQuestion"] = panel_addStoryQuestion;
    navigationModules["panel_addParticipantQuestion"] = panel_addParticipantQuestion;
    navigationModules["panel_addStoryForm"] = panel_addStoryForm;
    navigationModules["panel_chooseElicitingQuestion"] = panel_chooseElicitingQuestion;
    navigationModules["panel_chooseStoryQuestion"] = panel_chooseStoryQuestion;
    navigationModules["panel_chooseParticipantQuestion"] = panel_chooseParticipantQuestion;
    navigationModules["panel_addStoryCollection"] = panel_addStoryCollection;
    navigationModules["panel_addAnnotationQuestion"] = panel_addAnnotationQuestion;
    navigationModules["panel_addCollectionSessionRecord"] = panel_addCollectionSessionRecord;
    navigationModules["panel_newCollectionSessionConstruction"] = panel_newCollectionSessionConstruction;
    navigationModules["page_catalysis"] = page_catalysis;
    navigationModules["page_writeAnnotationsAboutStories"] = page_writeAnnotationsAboutStories;
    navigationModules["page_annotateStories"] = page_annotateStories;
    navigationModules["page_startCatalysisReport"] = page_startCatalysisReport;
    navigationModules["page_configureCatalysisReport"] = page_configureCatalysisReport;
    navigationModules["page_explorePatterns"] = page_explorePatterns;
    navigationModules["page_clusterInterpretations"] = page_clusterInterpretations;
    navigationModules["page_printCatalysisReport"] = page_printCatalysisReport;
    navigationModules["page_reflectOnCatalysisPhase"] = page_reflectOnCatalysisPhase;
    navigationModules["panel_addCatalysisReport"] = panel_addCatalysisReport;
    navigationModules["panel_chooseStoryCollection"] = panel_chooseStoryCollection;
    navigationModules["panel_addInterpretation"] = panel_addInterpretation;
    navigationModules["page_sensemaking"] = page_sensemaking;
    navigationModules["page_printStoryCards"] = page_printStoryCards;
    navigationModules["page_planSensemakingSessions"] = page_planSensemakingSessions;
    navigationModules["page_enterSensemakingSessionRecords"] = page_enterSensemakingSessionRecords;
    navigationModules["page_reflectOnSensemakingPhase"] = page_reflectOnSensemakingPhase;
    navigationModules["panel_addSensemakingSessionPlan"] = panel_addSensemakingSessionPlan;
    navigationModules["panel_addSensemakingSessionActivity"] = panel_addSensemakingSessionActivity;
    navigationModules["panel_addSensemakingSessionRecord"] = panel_addSensemakingSessionRecord;
    navigationModules["panel_addResonantStory"] = panel_addResonantStory;
    navigationModules["panel_addResonantPattern"] = panel_addResonantPattern;
    navigationModules["panel_newSensemakingSessionOutcome"] = panel_newSensemakingSessionOutcome;
    navigationModules["panel_newSensemakingSessionConstruction"] = panel_newSensemakingSessionConstruction;
    navigationModules["page_intervention"] = page_intervention;
    navigationModules["page_projectOutcomesForIntervention"] = page_projectOutcomesForIntervention;
    navigationModules["page_designInterventions"] = page_designInterventions;
    navigationModules["page_recordInterventions"] = page_recordInterventions;
    navigationModules["page_reflectOnInterventionPhase"] = page_reflectOnInterventionPhase;
    navigationModules["panel_projectOutcome"] = panel_projectOutcome;
    navigationModules["panel_addIntervention"] = panel_addIntervention;
    navigationModules["panel_addInterventionRecord"] = panel_addInterventionRecord;
    navigationModules["page_return"] = page_return;
    navigationModules["page_gatherFeedback"] = page_gatherFeedback;
    navigationModules["page_prepareProjectPresentation"] = page_prepareProjectPresentation;
    navigationModules["page_projectRequests"] = page_projectRequests;
    navigationModules["page_reflectOnReturnPhase"] = page_reflectOnReturnPhase;
    navigationModules["page_reflectOnProject"] = page_reflectOnProject;
    navigationModules["panel_enterFeedbackPiece"] = panel_enterFeedbackPiece;
    navigationModules["panel_addPresentationElement"] = panel_addPresentationElement;
    navigationModules["panel_addNewReturnRequest"] = panel_addNewReturnRequest;
    var sections = [
        {
            section: "dashboard",
            sectionName: "Dashboard",
            pages: [
                "page_dashboard"
            ],
            panels: []
        },
        {
            section: "administration",
            sectionName: "Administration",
            pages: [
                "page_administration",
                "page_projectOptions",
                "page_importExport",
                "page_print"
            ],
            panels: []
        },
        {
            section: "planning",
            sectionName: "Planning",
            pages: [
                "page_planning",
                "page_projectFacts",
                "page_planningQuestionsDraft",
                "page_participantGroups",
                "page_describeYourResources",
                "page_observeStorySharing",
                "page_assessStorySharing",
                "page_projectStories",
                "page_createProjectStoryElements",
                "page_revisePNIPlanningQuestions",
                "page_writeProjectSynopsis",
                "page_buildPrivacyPolicy",
                "page_reflectOnPlanningPhase"
            ],
            panels: [
                "panel_addParticipantGroup",
                "panel_projectStory",
                "panel_addStorySharingObservation",
                "panel_addObservedStory",
            ]
        },
        {
            section: "collection",
            sectionName: "Collection",
            pages: [
                "page_collection",
                "page_chooseCollectionMethods",
                "page_planStoryCollectionSessions",
                "page_writeStoryElicitingQuestions",
                "page_writeQuestionsAboutStories",
                "page_writeQuestionsAboutParticipants",
                "page_designStoryForms",
                "page_translateStoryForms",
                "page_startStoryCollection",
                "page_printQuestionForms",
                "page_enterStories",
                "page_reviewIncomingStories",
                "page_browseGraphs",
                "page_stopStoryCollection",
                "page_exportStories",
                "page_enterCollectionSessionRecords",
                "page_reflectOnCollectionPhase"
            ],
            panels: [
                "panel_addStoryCollectionMethod",
                "panel_addStoryCollectionSession",
                "panel_addCollectionSessionActivity",
                "panel_addElicitingQuestion",
                "panel_addStoryQuestion",
                "panel_addParticipantQuestion",
                "panel_addStoryForm",
                "panel_chooseElicitingQuestion",
                "panel_chooseStoryQuestion",
                "panel_chooseParticipantQuestion",
                "panel_addStoryCollection",
                "panel_addCollectionSessionRecord",
                "panel_newCollectionSessionConstruction"
            ]
        },
        {
            section: "catalysis",
            sectionName: "Catalysis",
            pages: [
                "page_catalysis",
                "page_writeAnnotationsAboutStories",
                "page_annotateStories",
                "page_startCatalysisReport",
                "page_configureCatalysisReport",
                "page_explorePatterns",
                "page_clusterInterpretations",
                "page_printCatalysisReport",
                "page_reflectOnCatalysisPhase"
            ],
            panels: [
                "panel_addCatalysisReport",
                "panel_addAnnotationQuestion",
                "panel_chooseStoryCollection",
                "panel_addInterpretation"
            ]
        },
        {
            section: "sensemaking",
            sectionName: "Sensemaking",
            pages: [
                "page_sensemaking",
                "page_printStoryCards",
                "page_planSensemakingSessions",
                "page_enterSensemakingSessionRecords",
                "page_reflectOnSensemakingPhase"
            ],
            panels: [
                "panel_addSensemakingSessionPlan",
                "panel_addSensemakingSessionActivity",
                "panel_addSensemakingSessionRecord",
                "panel_addResonantStory",
                "panel_addResonantPattern",
                "panel_newSensemakingSessionOutcome",
                "panel_newSensemakingSessionConstruction"
            ]
        },
        {
            section: "intervention",
            sectionName: "Intervention",
            pages: [
                "page_intervention",
                "page_projectOutcomesForIntervention",
                "page_designInterventions",
                "page_recordInterventions",
                "page_reflectOnInterventionPhase"
            ],
            panels: [
                "panel_projectOutcome",
                "panel_addIntervention",
                "panel_addInterventionRecord"
            ]
        },
        {
            section: "return",
            sectionName: "Return",
            pages: [
                "page_return",
                "page_gatherFeedback",
                "page_prepareProjectPresentation",
                "page_projectRequests",
                "page_reflectOnReturnPhase",
                "page_reflectOnProject",
            ],
            panels: [
                "panel_enterFeedbackPiece",
                "panel_addPresentationElement",
                "panel_addNewReturnRequest",
            ]
        }
    ];
    sections["navigationModules"] = navigationModules;
    return sections;
});

define('js/Application',["require", "exports", "./nls/applicationMessages", "./buttonActions", "./manageStoryCollection", "./csvImportExport", "./panelBuilder/dialogSupport", "./applicationWidgets/loadAllApplicationWidgets", "./panelBuilder/loadAllPanelSpecifications", "./navigationPane", "./pageDisplayer", "./panelBuilder/PanelBuilder", "./pointrel20150417/PointrelClient", "./Project", "./surveyCollection", "./panelBuilder/toaster", "./panelBuilder/translate", "mithril", "./applicationPanelSpecifications/navigation", "./PanelSetup", "./Globals", "./versions", "lodash", "./pointrel20150417/topic"], function (require, exports, applicationMessages, buttonActions, manageStoryCollection, csvImportExport, dialogSupport, loadAllApplicationWidgets, loadAllPanelSpecifications, navigationPane, pageDisplayer, PanelBuilder, PointrelClient, Project, surveyCollection, toaster, translate, m, navigationSections, PanelSetup, Globals, versions, _, topic) {
    "use strict";
    "use strict";
    // TODO: Add page validation
    var narrafirmaProjectPrefix = "NarraFirmaProject-";
    var loadingBase = "js/applicationPanelSpecifications/";
    var Application = (function () {
        function Application() {
            this.readOnly = false;
            /*
            export function project() {
                return _project;
            }
            */
            this.lastServerError = "";
            // The runningAfterIdle falg is used to limit redraws for new project messages until after initial set recevied
            this.runningAfterInitialIdle = false;
            this.pendingRedraw = null;
            this.updateHashTimer = null;
            this.panelBuilder = new PanelBuilder(this);
        }
        // TODO: Think more about how to integrate updatedServerStatus this with Mithril
        Application.prototype.updateServerStatus = function (status, text) {
            // The serverStatusPane may be created only after we start talking to the server
            // if (!serverStatusPane) return;
            var nameDiv = document.getElementById("narrafirma-name");
            if (!nameDiv)
                return;
            // TODO: Translate
            var statusText = "Version: " + versions.narrafirmaApplication;
            statusText += " Project: " + Globals.project().journalIdentifier.substring(narrafirmaProjectPrefix.length) + "; Server status: (" + status + ") " + text;
            if (status === "ok") {
                nameDiv.className = "narrafirma-serverstatus-ok";
                this.lastServerError = "";
            }
            else if (status === "waiting") {
                if (this.lastServerError) {
                    // TODO: Translate
                    nameDiv.className = "narrafirma-serverstatus-waiting-last-error";
                    statusText += "\n" + "Last error: " + this.lastServerError;
                }
                else {
                    nameDiv.className = "narrafirma-serverstatus-waiting";
                }
            }
            else if (status === "failure" || status === "failure-loss") {
                nameDiv.className = "narrafirma-serverstatus-failure";
                this.lastServerError = text;
                console.log("updateServerStatus failure", text);
                if (status === "failure-loss") {
                    // Very serious error with data loss -- alert the user
                    if (this.readOnly) {
                        nameDiv.className = "narrafirma-serverstatus-ok";
                        this.lastServerError = "Read-only OK";
                    }
                    else {
                        toaster.toast("Server lost recent change:\n" + text);
                    }
                }
            }
            else {
                console.log("Unexpected server status", status);
                nameDiv.className = "narrafirma-serverstatus-unexpected";
                console.log("updateServerStatus unexpected", text);
            }
            nameDiv.title = statusText;
            Globals.clientState().serverStatus(nameDiv.className);
            Globals.clientState().serverStatusText(statusText);
            // TODO: Need to make tooltip text ARIA accessible; suggestion in tooltip docs on setting text in tab order
            // statusTooltip.set("label", statusText); 
            // serverStatusPane.set("content", statusText);
        };
        // dispatch the button click
        Application.prototype.buttonClicked = function (panelBuilder, model, fieldSpecification, value) {
            var functionName = fieldSpecification.id;
            if (fieldSpecification.displayConfiguration) {
                if (_.isString(fieldSpecification.displayConfiguration)) {
                    functionName = fieldSpecification.displayConfiguration;
                }
                else {
                    functionName = fieldSpecification.displayConfiguration.action;
                }
            }
            var actualFunction = buttonActions[functionName];
            if (!actualFunction) {
                var message = "Unfinished handling for: " + fieldSpecification.id + " with functionName: " + functionName;
                console.log(message, model, fieldSpecification, value);
                alert(message);
            }
            else {
                actualFunction(model, fieldSpecification, value);
            }
        };
        // Panel builder "functionResult" components will get routed through here to calculate their text.
        Application.prototype.calculateFunctionResultForGUI = function (panelBuilder, model, fieldSpecification, functionName) {
            function validationErrorMessage(itemID, checkName, checkType, checkOptions, checkTrimming) {
                if (checkType === void 0) { checkType = false; }
                if (checkOptions === void 0) { checkOptions = false; }
                if (checkTrimming === void 0) { checkTrimming = false; }
                if (!itemID)
                    return null;
                var success = false;
                if (checkName) {
                    success = buttonActions.checkThatItemHasShortName(itemID);
                    if (!success)
                        return ["You must enter a short name for this item."];
                    success = buttonActions.checkThatItemHasShortNameWithNoForwardSlashInIt(itemID);
                    if (!success)
                        return ["Short names cannot have forward slashes (/) in them."];
                }
                if (checkType) {
                    success = buttonActions.checkThatQuestionHasType(itemID);
                    if (!success)
                        return ["You must enter a question type for this item."];
                }
                if (checkOptions) {
                    success = buttonActions.checkThatItemHasOptionListIfRequired(itemID);
                    if (!success)
                        return ["You must enter at least two options for this type of question."];
                }
                if (checkTrimming) {
                    success = buttonActions.checkThatItemOptionsHaveNoLeadingOrTrailingWhiteSpaceCharacters(itemID);
                    if (!success)
                        return ["For this type of question, the answers in your answer list must not have empty spaces in front of or after them."];
                }
                return null;
            }
            var itemID = fieldSpecification.value;
            if (functionName === "isStoryCollectingEnabled") {
                return surveyCollection.isStoryCollectingEnabled();
            }
            else if (functionName === "requireShortName") {
                return validationErrorMessage(itemID, true);
            }
            else if (functionName === "requireShortNameAndType") {
                return validationErrorMessage(itemID, true, true);
            }
            else if (functionName === "requireShortNameTypeOptionsAndTrimming") {
                return validationErrorMessage(itemID, true, true, true, true);
            }
            else {
                console.log("TODO: calculateFunctionResultForGUI ", functionName, fieldSpecification);
                return "calculateFunctionResultForGUI UNFINISHED: " + functionName + " for: " + fieldSpecification.id;
            }
        };
        Application.prototype.setupGlobalFunctions = function () {
            // Set up global function used by section dashboard links
            window["narrafirma_openPage"] = function (pageIdentifier) {
                if (!pageIdentifier)
                    return;
                if (buttonActions.checkForValidationErrors())
                    return;
                Globals.clientState().pageIdentifier(pageIdentifier);
                Globals.clientState().updateHashIfNeededForChangedClientState();
                // Page displayer will handle cases where the hash is not valid and also optimizing out page redraws if staying on same page
                pageDisplayer.showPage(Globals.clientState().pageIdentifier());
                // document.body.scrollTop = 0;
                // document.documentElement.scrollTop = 0;
                window.scrollTo(0, 0);
            };
            window["narrafirma_logoutClicked"] = function () {
                buttonActions.logoutButtonClicked();
            };
            window["narrafirma_loginClicked"] = function () {
                buttonActions.loginButtonClicked();
            };
            window["narrafirma_helpClicked"] = function (pageIdentifier) {
                buttonActions.helpButtonClicked();
            };
        };
        // The main starting point of the application
        Application.prototype.initialize = function () {
            var _this = this;
            console.log("=======", new Date().toISOString(), "application.initialize() called");
            // TODO: Translate
            document.getElementById("pleaseWaitDiv").innerHTML = "Retrieving user information from server; please wait...";
            // Cast to silence TypeScript warning about use of translate.configure
            translate.configure({}, applicationMessages.root);
            Globals.clientState().initialize();
            this.setupGlobalFunctions();
            // mount Mithril dialog support now, as it may be needed in choosing a project
            dialogSupport.initialize();
            // Throwaway single-use pointrel client instance which does not access a specific journal and for which polling is not started
            var singleUsePointrelClient = new PointrelClient("/api/pointrel20150417", "unused", {});
            singleUsePointrelClient.getCurrentUserInformation(function (error, response) {
                if (error) {
                    console.log("error", error, response);
                    document.getElementById("pleaseWaitDiv").style.display = "none";
                    document.getElementById("pageDiv").innerHTML = "Problem talking to server. Please contact your NarraFirma administrator.";
                    document.getElementById("pageDiv").style.display = "block";
                    alert("Something went wrong determining the current user identifier.");
                    return;
                }
                console.log("initialize response", response);
                var userIdentifier = response.userIdentifier;
                if (userIdentifier === undefined || userIdentifier === null || userIdentifier === false) {
                    userIdentifier = "anonymous";
                }
                _this.userIdentifier = userIdentifier;
                var projects = [];
                for (var key in response.journalPermissions) {
                    if (!_.startsWith(key, narrafirmaProjectPrefix))
                        continue;
                    var permissions = response.journalPermissions[key];
                    if (!permissions.hasOwnProperty("archived") || !permissions.archived) {
                        projects.push({
                            id: key,
                            name: key.substring(narrafirmaProjectPrefix.length),
                            read: permissions.read,
                            write: permissions.write,
                            archived: false,
                            // in node.js this is called "administrate"; in WordPress it is called "admin"
                            admin: permissions.admin || permissions.administrate
                        });
                    }
                }
                if (!projects.length) {
                    document.getElementById("pleaseWaitDiv").style.display = "none";
                    var recoveryText = "Please contact your NarraFirma project administrator.";
                    var loginText = "";
                    if (_this.userIdentifier === "anonymous") {
                        recoveryText = "Please try logging in.";
                        loginText = _this.loginLink();
                    }
                    document.body.innerHTML += '<br><b>No projects. The NarraFirma application cannot run.</b> ' + recoveryText + " " + loginText;
                    alert("There are no projects accessible by the current user (" + _this.userIdentifier + "). " + recoveryText);
                    return;
                }
                _this.chooseAProjectToOpen(response.userIdentifier, projects);
                // for testing field updating
                // setInterval ( ()=> { m.redraw(); console.log("redraw", new Date().toISOString())}, 3000);
            });
        };
        Application.prototype.chooseAProjectToOpen = function (userIdentifierFromServer, projects) {
            var _this = this;
            // Initialize toaster
            toaster.createToasterWidget("toasterDiv");
            loadAllApplicationWidgets(PanelBuilder);
            document.getElementById("pleaseWaitDiv").style.display = "none";
            var userCredentials = {
                userIdentifier: this.userIdentifier
            };
            var projectIdentifierSupplied = Globals.clientState().projectIdentifier();
            console.log("projectIdentifierSupplied", projectIdentifierSupplied);
            if (projectIdentifierSupplied) {
                // TODO: Could put up project chooser if the supplied project is invalid...
                this.openProject(userCredentials, narrafirmaProjectPrefix + projectIdentifierSupplied, projects);
            }
            else {
                // TODO: Translate
                var columns = { name: "Project name", id: "Project journal", write: "Editable" };
                // TODO: Only allow new project button for admins
                var isNewAllowed = false;
                var loginOrOutLink = void 0;
                var message = void 0;
                if (this.userIdentifier === "anonymous") {
                    message = "Please select a NarraFirma project to work on - or ";
                    loginOrOutLink = m("a", { href: this.loginLink("href"), title: "Login" }, "log in");
                }
                else {
                    message = "Hello " + this.userIdentifier + ". Please select a NarraFirma project to work on - or ";
                    loginOrOutLink = m("a", { href: this.logoutLink("href"), title: "Logout" }, "log out");
                }
                var prompt_1 = m("div", [m("span", message), loginOrOutLink ? loginOrOutLink : [], m("span", ".")]);
                var nonArchivedProjects_1 = [];
                projects.forEach(function (project) {
                    if (!project.hasOwnProperty("archived") || !project.archived) {
                        nonArchivedProjects_1.push(project);
                    }
                });
                dialogSupport.openListChoiceDialog(null, nonArchivedProjects_1, columns, "NarraFirma Projects", prompt_1, isNewAllowed, function (projectChoice) {
                    if (!projectChoice)
                        return;
                    _this.projectIdentifier = projectChoice.id;
                    if (!_this.projectIdentifier)
                        return;
                    if (projectChoice.isNew) {
                        Globals.clientState().projectIdentifier(_this.projectIdentifier);
                        _this.projectIdentifier = narrafirmaProjectPrefix + _this.projectIdentifier;
                        _this.journalIdentifier = _this.projectIdentifier;
                        alert("About to make project: " + _this.projectIdentifier);
                        _this.makeNewProject();
                        return;
                    }
                    else {
                        Globals.clientState().projectIdentifier(_this.projectIdentifier.substring(narrafirmaProjectPrefix.length));
                    }
                    _this.openProject(userCredentials, _this.projectIdentifier, projects);
                });
                // Because we are opening a dialog at startup, not caused by a user event, we need to tell Mithril to redraw.
                // Safari 5 seems to sometimes get the event sequence wrong at startup, adding 100ms delay to help ensure the redraw is queued after this event is entirely done
                setTimeout(m.redraw, 100);
            }
        };
        Application.prototype.loginLink = function (hrefOrLink) {
            if (hrefOrLink === void 0) { hrefOrLink = "link"; }
            var isWordPressAJAX = !!window["ajaxurl"];
            var loginURL;
            if (isWordPressAJAX) {
                loginURL = "wordpress/wp-login.php";
            }
            else {
                loginURL = "login";
            }
            if (hrefOrLink === "href") {
                return loginURL;
            }
            else {
                return '<a href="/' + loginURL + '">login</a>';
            }
        };
        Application.prototype.logoutLink = function (hrefOrLink) {
            if (hrefOrLink === void 0) { hrefOrLink = "link"; }
            var isWordPressAJAX = !!window["ajaxurl"];
            var logoutURL;
            if (isWordPressAJAX) {
                logoutURL = "wordpress/wp-login.php?action=logout";
            }
            else {
                logoutURL = "logout";
            }
            if (hrefOrLink === "href") {
                return logoutURL;
            }
            else {
                return '<a href="/' + logoutURL + '">logout</a>';
            }
        };
        Application.prototype.makeNewProject = function () {
            var _this = this;
            console.log("add-journal", this.journalIdentifier);
            var singleUsePointrelClient = new PointrelClient("/api/pointrel20150417", "unused", {});
            singleUsePointrelClient.createJournal(this.journalIdentifier, function (error, response) {
                if (error || !response.success) {
                    console.log("Error creating project", _this.journalIdentifier, error, response);
                    var message = "error";
                    if (response)
                        message = response.description;
                    if (error)
                        message = error.description;
                    toaster.toast("Error: creating project: " + _this.journalIdentifier + " :: " + message);
                    // location.reload();
                }
                else {
                    console.log("Created project", _this.journalIdentifier, response);
                    // allProjectsModel.projects.push({name: this.journalIdentifier.substring(narrafirmaProjectPrefix.length)});
                    console.log("About to trigger page reload for changed project");
                    // Need to call redraw as event changing data was triggered by network
                    // and alert has to be AFTER reload or it is not seen
                    alert("Created project: " + _this.journalIdentifier);
                    location.reload();
                }
            });
        };
        Application.prototype.redrawFromProject = function () {
            var _this = this;
            // The tripleStore may not be updated yet, so this redraw needs to get queued for later by the application
            if (this.runningAfterInitialIdle) {
                if (!this.pendingRedraw) {
                    this.pendingRedraw = setTimeout(function () {
                        Globals.clientState().redrawingDueToIncomingMessage(true);
                        _this.pendingRedraw = null;
                        m.redraw();
                        Globals.clientState().redrawingDueToIncomingMessage(false);
                    }, 0);
                }
            }
        };
        Application.prototype.openProject = function (userCredentials, projectIdentifier, projects) {
            var _this = this;
            document.getElementById("pleaseWaitDiv").style.display = "block";
            // TODO: Should this be managed separately?
            this.journalIdentifier = projectIdentifier;
            Globals.project(new Project(this.journalIdentifier, projectIdentifier, userCredentials, this.updateServerStatus.bind(this), this.redrawFromProject.bind(this)));
            console.log("openProject", Globals.project());
            surveyCollection.setProject(Globals.project());
            // TODO: Translate
            document.getElementById("pleaseWaitDiv").innerHTML = "Retrieving project data from server; please wait...";
            Globals.project().startup(function (error) {
                if (error) {
                    document.getElementById("pleaseWaitDiv").style.display = "none";
                    // TODO: Sanitize journalIdentifier
                    document.body.innerHTML += '<br>Problem connecting to project journal on server for: "<b>' + _this.journalIdentifier + '</b>"';
                    alert("Problem connecting to project journal on server. Application will not run.");
                    return;
                }
                else {
                    projects.forEach(function (project) {
                        if (project.id !== projectIdentifier)
                            return;
                        _this.readOnly = !project.write;
                        Globals.project().readOnly = _this.readOnly;
                        Globals.project().currentUserHasAdminAccess = project.admin;
                        // this.panelBuilder.readOnly = isReadOnly;
                        if (_this.readOnly) {
                            toaster.toast("You have read-only access to this project. \n                            You can make local changes, but they will not be saved to the server \n                            and will be lost when you reload the page.", "Message", 8000);
                            Globals.project().pointrelClient.suspendOutgoingMessages(true);
                        }
                    });
                    _this.loadApplicationDesign();
                }
            });
        };
        Application.prototype.loadApplicationDesign = function () {
            var _this = this;
            var panelSpecificationCollection = PanelSetup.panelSpecificationCollection();
            Globals.panelSpecificationCollection(panelSpecificationCollection);
            // Load the application design
            loadAllPanelSpecifications(panelSpecificationCollection, navigationSections, loadingBase, function () {
                // generateNavigationDataInJSON();
                PanelSetup.processAllPanels();
                // TODO: Only for creating models once
                //printModels();
                //return;
                // Tell the panel builder how to build panels
                _this.panelBuilder.setPanelSpecifications(panelSpecificationCollection);
                // Tell the panelBuilder what do do if a button is clicked
                _this.panelBuilder.setButtonClickedCallback(_this.buttonClicked.bind(_this));
                _this.panelBuilder.setCalculateFunctionResultCallback(_this.calculateFunctionResultForGUI.bind(_this));
                // Initialize different Mithril components which will be mounted using m.mount
                // Note that dialogSupport has already been initialized and that component mounted
                navigationPane.initializeNavigationPane(panelSpecificationCollection, _this.userIdentifier, _this.panelBuilder);
                pageDisplayer.configurePageDisplayer(_this.panelBuilder, Globals.project(), Globals.clientState());
                // Fill out initial hash string if needed
                Globals.clientState().updateHashIfNeededForChangedClientState();
                // TODO: What to do while waiting for data for a project to load from server the first time? Assuming authenticated OK etc.???
                var topicSubscription = topic.subscribe("messageReceived", function () {
                    document.getElementById("pleaseWaitDiv").innerHTML = "Retrieving project information from server (" + Globals.project().pointrelClient.messageReceivedCount + "); please wait...";
                });
                // TODO: This assumes we have picked a project, and are actually loading data and have not errored out
                Globals.project().pointrelClient.idleCallback = function () {
                    topicSubscription.remove();
                    // Now that data is presumably loaded into the Project tripleStore, we can proceed with further initialization
                    buttonActions.initialize(Globals.project(), Globals.clientState());
                    manageStoryCollection.initialize(Globals.project(), Globals.clientState());
                    csvImportExport.initialize(Globals.project());
                    // Ensure the pageDisplayer will display the first page
                    Globals.clientState().urlHashFragmentChanged(pageDisplayer);
                    // Update if the URL hash fragment is changed by hand
                    window.onhashchange = Globals.clientState().urlHashFragmentChanged.bind(Globals.clientState(), pageDisplayer);
                    // turn off initial "please wait" display
                    document.getElementById("pleaseWaitDiv").style.display = "none";
                    document.getElementById("navigationDiv").style.display = "block";
                    document.getElementById("pageDiv").style.display = "block";
                    _this.runningAfterInitialIdle = true;
                    // TODO: Polling for changes by a read-only client should be an option somewhere; hard-coding it for now to reduce server load on NarraFirma.com
                    if (_this.readOnly) {
                        console.log("Shutting down polling for updates by read-only client");
                        Globals.project().pointrelClient.shutdown();
                        // toaster.toast("Reload the page to see changes for read-only client");
                    }
                    // toaster.toast("Started up!!!");
                };
                // From: https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload
                window.addEventListener("beforeunload", function (e) {
                    // TODO: IMPORTANT Ensure the current text field if any does the equivalent of a blur to commit its data...
                    // TODO: But may not be reliable: http://stackoverflow.com/questions/18718494/will-onblur-event-trigger-when-window-closes
                    return null;
                    /* TODO: Need to check for unsaved changes in any grids
                    if (!hasUnsavedChangesForCurrentPage()) return null;
                        
                    const confirmationMessage = "You have unsaved changes";
        
                    (e || window.event).returnValue = confirmationMessage;     // Gecko and Trident
                    return confirmationMessage;
                    */ // Gecko and WebKit
                });
            });
        };
        return Application;
    }());
    return Application;
});

define('js/main',["require", "exports", "./Application"], function (require, exports, Application) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    "use strict";
    function run() {
        console.log("main: starting");
        var application = new Application();
        application.initialize();
        console.log("main: done with initialize");
    }
    exports.run = run;
});

/**
 * @license RequireJS text 2.0.14 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('lib/text',['module'], function (module) {
    'use strict';

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.14',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.lastIndexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'] &&
            !process.versions['atom-shell'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file[0] === '\uFEFF') {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});


define('lib/text!recommendations/recommendations_filledin.csv',[],function () { return ',# participantGroup_status,unknown,very low,low,moderate,high,very high,mixed,,# participantGroup_confidence,unknown,very low,low,medium,high,very high,mixed,,# participantGroup_time,unknown,very little,little,some,a lot,mixed,,# participantGroup_education,unknown,illiterate,minimal,moderate,high,very high,mixed,,# participantGroup_physicalDisabilities,unknown,none,minimal,moderate,strong,mixed,,# participantGroup_emotionalImpairments,unknown,none,minimal,moderate,strong,mixed,,# participantGroup_performing,unknown,very unimportant,somewhat unimportant,somewhat important,very important,mixed,,# participantGroup_conforming,unknown,very unimportant,somewhat unimportant,somewhat important,very important,mixed,,# participantGroup_promoting,unknown,very unimportant,somewhat unimportant,somewhat important,very important,mixed,,# participantGroup_venting,unknown,very unimportant,somewhat unimportant,somewhat important,very important,mixed,,# participantGroup_interest,unknown,very little,a little,some,a lot,extremely,mixed,,# participantGroup_feelings_project,unknown,negative,neutral,positive,mixed,,# participantGroup_feelings_facilitator,unknown,negative,neutral,positive,mixed,,# participantGroup_feelings_stories,unknown,negative,neutral,positive,mixed,,# participantGroup_topic_feeling,unknown,strongly negative,negative,neutral,positive,strongly positive,mixed,,# participantGroup_topic_private,unknown,very private,medium,not private,mixed,,# participantGroup_topic_articulate,unknown,hard,medium,easy,mixed,,# participantGroup_topic_timeframe,unknown,hours,days,months,years,decades,mixed,,# aboutYou_experience,none,a little,some,a lot,,# aboutYou_help,none,a little,some,a lot,,# aboutYou_tech,none,a little,some,a lot\r#elicitingQuestions,What is the status of these participants in the community or organization?,,,,,,,,,How much self-confidence do these participants have?,,,,,,,,,How much free time do these participants have?,,,,,,,,What is the education level of these participants? ,,,,,,,,,Do these participants have physical limitations that will impact their participation? ,,,,,,,,Do these participants have emotional impairments that will impact their participation (such as mental illness or traumatic stress)?,,,,,,,,"For these participants, how important is performing well (with ""high marks"")?",,,,,,,,"For these participants, how important is conforming (to what is ""normal"" or expected)?",,,,,,,,"For these participants, how important is self-promotion (competing with others)?",,,,,,,,"For these participants, how important is speaking out (having a say, venting, sounding off)?",,,,,,,,How motivated are these participants to participate in the project?,,,,,,,,,How are these participants likely to feel about the project? ,,,,,,,How do these participants feel about you?,,,,,,,How do these participants feel about the idea of collecting stories?,,,,,,,What experiences have these participants had with the project\'s topic?,,,,,,,,,How private do these participants consider the topic to be?,,,,,,,How hard will it be for these participants to articulate their feelings about the topic?,,,,,,,How long of a time period do you need these participants to look back on?,,,,,,,,,How much experience do you have facilitating PNI projects?,,,,,,How much help will you have carrying out this project?,,,,,,How many technological resources will you have for carrying out this project?,,,,\rdirected questions,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,maybe,,,maybe,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,maybe,,very good,,,,,no,,,,,,,,,,,,,,no,maybe,,,maybe,maybe,,,,maybe,,,,,,,very good,,very good,,,,,very good,,,,very good,,,,very good,,,,,,very good,,,,,,,,,\rundirected questions,,,no,maybe,,maybe,no,maybe,,,,no,maybe,,,maybe,maybe,,,,no,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,,,maybe,no,,,,,no,maybe,,,very good,,,,,,,maybe,,,,,very good,,maybe,,,,,no,maybe,,maybe,,,,very good,,,,very good,,,,,very good,,,,,,,no,,maybe,no,,,,no,maybe,,maybe,no,maybe,,,no,maybe,,,,,no,maybe,,,,,,,,\rpoint in time,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,\revent,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rextreme,,,maybe,,,,maybe,,,,,maybe,,,maybe,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,maybe,,,,,maybe,,,maybe,,,,,,,maybe,no,,,,,,,maybe,no,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,,,,,very good,,,,,,,no,maybe,,,very good,,,,maybe,,,,,,maybe,,,,,,,,,\rsurprise,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,maybe,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,very good,,,,,maybe,,,,,,,very good,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,\rchange,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,,,,,maybe,,,,,,,no,maybe,,,,,,,,,,,,,,,,,,,,,,\rpeople places things,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,very good,,,,,,,,,no,maybe,,maybe,,,,no,,,,,,,,,,maybe,no,,,,,,,,,,,,,,,,,,,\rfictional scenario,,,no,maybe,,maybe,no,maybe,,,,no,maybe,,maybe,no,maybe,,,,no,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,no,maybe,,,,maybe,,maybe,no,,,,,,,,,,,,,,,maybe,no,,,,,no,maybe,,,very good,no,,,,no,,,no,,,,no,,,no,,,,no,maybe,,no,,,,no,no,maybe,,,no,,,,very good,,,,,,,no,,,,,,,,,,,,,,,no,maybe,,,,,no,maybe,,,,,,,,\rmenu method (choose a question),,,maybe,,,,maybe,very good,,,,maybe,,,,maybe,very good,,,,no,maybe,,,maybe,,,,maybe,maybe,,,,,,,,,,,maybe,very good,,,,,,maybe,maybe,very good,,,,,,,,very good,,,,,,,,very good,,,,,,,,very good,,,,,,,,very good,,,,no,maybe,,,very good,maybe,,,,maybe,,,very good,,,,maybe,,,very good,,,,very good,,,very good,,,,very good,very good,very good,,,very good,,,,very good,very good,,very good,,,,very good,,,very good,,,,,,,,,,,,very good,,,,,,maybe,maybe,,,,,maybe,maybe,,\rmultiple questions per person,,,no,maybe,,maybe,no,maybe,,,,no,maybe,,maybe,no,maybe,,,,no,no,,,no,,,,maybe,maybe,,,,,,,,,,,maybe,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,no,maybe,,,very good,no,,,,no,maybe,,no,,,,no,,,no,,,,maybe,,,maybe,,,,no,no,maybe,,,no,,,,,,,,,,,very good,,,,,,,,,,,,,,,no,maybe,,,,,no,maybe,,,,,maybe,maybe,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\r#storyQuestions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rfew questions (5 or fewer),,,very good,,,,very good,,,,,very good,,,,,,,,,very good,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,no,maybe,,,,,,,,,,,very good,,maybe,maybe,,,,very good,,maybe,maybe,,,,very good,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rsome questions (6-10),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,very good,maybe,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rmany questions (11 or more),,,maybe,,,,maybe,,,,,no,maybe,,,,,,,,no,maybe,,very good,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,maybe,,,,maybe,,,,no,,very good,maybe,,,,no,,very good,maybe,,,,no,,very good,maybe,,,,no,maybe,,,,maybe,,,,no,,,maybe,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,maybe,maybe,,\rquestions about emotion (how do you feel),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,no,noi,,,,,,,very good,,,,,,,,very good,,,,,,,,very good,,,,,,,maybe,no,no,,,,no,maybe,,,very good,maybe,,,,very good,,,,,,,no,,very good,maybe,,,,no,,very good,no,,,,maybe,,,,,maybe,,,,no,,,maybe,,,,very good,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,\rquestions about categorizing (what type of story is this),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,very good,very good,,,,,,,no,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,,very good,,,,,,,,,,,,,,no,,,maybe,,,,very good,,,,,,,very good,,maybe,maybe,,,,very good,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about story form,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,maybe,,,,,,,,very good,,,,,maybe,maybe,,,very good,maybe,,,,,,,,,,,,,,,,,,maybe,,very good,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about story function,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about story phenomenon,,,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,maybe,,,maybe,,,,maybe,,,,,,,maybe,,,,very good,,,,,,,,,,,,,,,,,,,\rquestions using story elements,,,maybe,,,,maybe,,,,,maybe,,,,,maybe,,,,no,,,very good,no,,,,very good,,,,,,,,,,,,maybe,maybe,,,,,,maybe,no,no,,,,,,maybe,maybe,maybe,,,,,,maybe,maybe,maybe,,,,,,,maybe,,,,,,,,very good,,,,,no,maybe,maybe,,very good,no,,,,no,,very good,no,,,,no,,,no,,,,no,,very good,no,,,,,,,,,,,,,very good,,,,,,,very good,,,,,,,,,,,very good,,,,no,maybe,,very good,,,no,maybe,,very good,,,,,,\rchoice list (nominal),,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rchoice list (ordinal with middle option),,,no,,,,maybe,,,,,maybe,,,,,maybe,,,,no,maybe,,,maybe,,,,maybe,maybe,,,,,,,,,,,maybe,maybe,,,,,,maybe,maybe,maybe,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,,maybe,,,,,,,,,,,,,no,maybe,maybe,,,no,,,,no,,,no,,,,no,,,maybe,,,,,,,,,,,,,,,,,,,,no,maybe,,maybe,,,,no,maybe,,maybe,,,,maybe,,,maybe,no,,,,maybe,maybe,,,,,,,,,,,,,,\rchoice list (ordinal without middle option),,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rrange (unipolar),,,maybe,,,,,,,,,maybe,,,,,maybe,,,,,,,,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,\rrange (bipolar),,,maybe,,,,maybe,,,,,maybe,,,,,maybe,,,,no,maybe,,very good,no,,,,maybe,maybe,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,,very good,,,,,,,,very good,,,,,,,,very good,,,,,,,,,,,,,no,maybe,,,very good,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,maybe,,,,very good,,,,,,,,,,,,,,,no,maybe,,,,,maybe,,,,,,,,,\rvisual range,,,very good,,,,,,,,,very good,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,very good,,,,,,,very good,,,,,,,,very good,,,,,,,,,,,,maybe,maybe,,\rword range,,,very good,,,,,,,,,very good,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,maybe,,,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rfree text,,,no,maybe,,,maybe,maybe,,,,no,,,,very good,no,,,,no,maybe,,very good,no,,,,very good,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,very good,,,,,no,maybe,maybe,,very good,no,,,,very good,,,very good,,,,very good,,,,,,,very good,,,,,,,very good,very good,,,,very good,,,,maybe,,,maybe,,,,very good,,,,,,,,,,maybe,no,,,,very good,,,,,,maybe,maybe,,very good,,,maybe,maybe,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\r#participantQuestions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rdetailed questions (your age),,,no,maybe,,,,,,,,no,maybe,,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,no,maybe,,,no,,,,no,,,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,,no,maybe,,no,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,\rbroad questions (your age group),,,very good,,,,,,,,,very good,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,maybe,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,maybe,maybe,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rpersonal questions (your marital status),,,no,maybe,,,,,,,,no,maybe,,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,no,maybe,,,no,,,,no,,,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,,no,maybe,,no,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,\rquestions about demographics,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,maybe,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,maybe,maybe,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about personality,,,,,,,,,,,,maybe,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,maybe,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,maybe,maybe,,maybe,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about role in community,,,maybe,maybe,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,maybe,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,maybe,maybe,,maybe,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about views on issues,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about views on community,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\r#venues,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rindividual interviews,,,very good,,,,very good,,,,,very good,,,,very good,,,,,very good,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,very good,,,,,very good,,,very good,,,,,very good,,,very good,,,,,,,,very good,,,,,maybe,,,very good,,,,,maybe,very good,,maybe,maybe,maybe,,,,,,,,,,,no,,,no,,,,very good,,,,,,,very good,very good,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,no,maybe,,very good,,,maybe,,,very good,,,,,,\rgroup interviews,,,no,maybe,,,maybe,no,,,,,,,,,,,,,maybe,maybe,,,maybe,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,maybe,,,,,,,,maybe,,,,,very good,,,maybe,maybe,,,,maybe,,,very good,,,,,maybe,very good,,,,maybe,,,,maybe,,very good,maybe,,,,maybe,,,maybe,,,,,,very good,,,,,,,,,,,,,,maybe,,,maybe,,,,very good,,,,,,,no,maybe,,,very good,,,,no,maybe,,very good,,,maybe,,,very good,,,,,,\rpeer interviews,,,very good,,,no,no,no,,,,maybe,,,,,,,,,no,maybe,,,no,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,very good,,,maybe,maybe,,,,maybe,,,maybe,,,,,no,maybe,,,very good,maybe,,,,no,,very good,maybe,,,,very good,,,,,,,no,,very good,,,,,maybe,,,,,maybe,,,,maybe,,very good,maybe,,,,very good,,,,,,,no,maybe,,,very good,no,,,,,,,,,,,,,,,maybe,,,\rgroup story sessions,,,maybe,,,maybe,no,no,,,,,,,,,,,,,no,maybe,,very good,no,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,maybe,,,very good,,,,,maybe,,,,very good,,,,,maybe,,very good,maybe,,,,maybe,,,maybe,,,,,,very good,,,,,maybe,,,,,maybe,,,,maybe,,very good,maybe,,,,very good,,,,,,,no,maybe,,,very good,,,,maybe,,very good,very good,,,maybe,,,very good,,,,,,\rsurvey (web),,,,,,no,no,no,,,,maybe,,,,maybe,,,,,maybe,,,maybe,maybe,,,,no,maybe,,,,no,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,,,,maybe,,,,,maybe,,,,,,,,no,maybe,,,,maybe,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,maybe,,,,no,,,no,,,,no,maybe,,no,,,,very good,,,,maybe,,,,maybe,,,,,,,,,,,,no,maybe,,\rsurvey (email),,,,,,no,no,no,,,,maybe,,,,maybe,,,,,maybe,,,maybe,maybe,,,,no,maybe,,,,no,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,,,,maybe,,,,,maybe,,,,,,,,no,maybe,,,,maybe,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,maybe,,,,no,,,no,,,,no,maybe,,no,,,,very good,,,,maybe,,,,maybe,,,,,,no,maybe,,,,,no,maybe,,\rsurvey (paper),,,,,,no,no,no,,,,maybe,,,,maybe,,,,,maybe,,,maybe,maybe,,,,no,maybe,,,,no,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,,,,maybe,,,,,maybe,,,,,,,,no,maybe,,,,maybe,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,maybe,,,,no,,,no,,,,no,maybe,,no,,,,very good,,,,maybe,,,,maybe,,,,,,no,maybe,,,,,,,,\rjournals,,,very good,,,no,no,no,,,,maybe,,,,maybe,,,,,no,maybe,,very good,no,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,maybe,,,very good,,,,,maybe,,,maybe,maybe,,,,very good,,,maybe,,,,,maybe,,,,,,,,no,maybe,,,very good,maybe,,,,no,,very good,maybe,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,no,,,no,,,,maybe,,,,,,,no,,,maybe,maybe,maybe,,,maybe,,,,,,no,maybe,,,,,maybe,,,\rnarrative incident reports,,,,,,no,no,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,,,,,,maybe,,,maybe,maybe,,,,very good,,,maybe,,,,,maybe,,,,,,,,maybe,maybe,,,very good,maybe,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,maybe,,,,maybe,,,maybe,,,,maybe,,,,,,,very good,very good,maybe,no,no,no,,,maybe,,,,,,no,maybe,,,,,maybe,,,\rgleaned stories,,,very good,,,,very good,,,,,,,,,,,,,,very good,,maybe,no,no,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,very good,,,,,very good,,,very good,,,,,,,,very good,,,,,very good,,,,,,,,very good,,,maybe,no,maybe,,,,very good,,,,,,,very good,,,,,,,very good,,,,,,,no,maybe,,,,maybe,,,,no,,,no,,,,,,,,,,,,,,maybe,maybe,maybe,,,very good,,,maybe,,,maybe,,,,,,,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\r#collectionSessions #sensemakingSessions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rinviting via command,,,no,maybe,,,very good,no,,,,,,,,maybe,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,maybe,no,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,no,no,,,,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,very good,very good,,,,,very good,,,,,,,,,\rinviting via networks,,,maybe,,,maybe,maybe,maybe,,,,maybe,,,very good,very good,no,,,,maybe,,,,,,,,very good,very good,,,,,,,,,,,,,,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,very good,,,,,,,no,maybe,,maybe,,,,maybe,very good,,,,,,no,maybe,,,,,,maybe,maybe,,,very good,maybe,,,,maybe,,,maybe,,,,,,,,,,,maybe,maybe,,,very good,,,,,,,,,,very good,,,,,,,,,\rinviting via broadcasting,,,,,,maybe,maybe,maybe,,,,maybe,,,,,,,,,no,maybe,,,maybe,,,,no,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,no,maybe,,,no,,,,maybe,,very good,no,,,,no,,very good,no,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,\rinviting via advertisement,,,very good,,,maybe,no,no,,,,maybe,,,,maybe,maybe,,,,no,no,maybe,,no,,,,no,maybe,,,,maybe,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,maybe,no,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,no,maybe,,,no,,,,,,very good,no,,,,no,,very good,no,,,,maybe,,very good,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,\rinviting via spontaneous sessions,,,maybe,,,maybe,no,no,,,,very good,,,maybe,no,no,,,,maybe,maybe,,,maybe,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,maybe,maybe,,,,,,maybe,no,maybe,,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,very good,very good,very good,,,,,,,very good,very good,maybe,,,,,,,,,,,,very good,,,,,,,maybe,maybe,,,,maybe,,,,maybe,,,,,,,,,,,,,,very good,very good,,,maybe,,,,no,maybe,,,,,maybe,maybe,,,,,very good,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rpaying people to come,,,maybe,maybe,,very good,maybe,maybe,,,,very good,,,,very good,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,maybe,,,,,,,maybe,no,no,,,,very good,very good,,,,,,,,maybe,very good,no,no,,,,no,,maybe,maybe,,,,,,,,,,,no,no,,,,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rgiving people gifts,,,very good,very good,,,,,,,,very good,very good,,,,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,very good,very good,very good,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,very good,,,,,,,,,\rplaying background music,,,,,,maybe,maybe,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,maybe,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,no,maybe,,\rexploring fiction,,,maybe,,,,maybe,maybe,,,,no,maybe,,maybe,no,no,,,,maybe,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,no,maybe,,,,maybe,,,,no,maybe,,maybe,,,,no,,,maybe,,,,maybe,,,,,,,maybe,maybe,,,,maybe,,,,,,,,,,,very good,,,,,,,,,,,,,,,no,maybe,,,,,maybe,maybe,,,,,,,,\rencouraging competition,,,no,maybe,,,maybe,no,,,,no,maybe,,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,no,no,no,,,,,,maybe,no,maybe,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,,,,,,,,maybe,,,,,,,no,,,no,,,,maybe,,,,,,,no,no,,,,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,no,maybe,,,,,maybe,maybe,,,,,,,,\rholding virtual sessions,,,no,maybe,,,maybe,no,,,,no,maybe,,maybe,no,no,,,,,,,,,,,,no,no,maybe,,,no,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,no,maybe,,,,no,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,maybe,,,,,maybe,maybe,,,,,no,no,,\rholding long sessions,,,maybe,maybe,,maybe,no,no,,,,no,maybe,,maybe,no,no,,,,no,no,maybe,,no,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,no,no,maybe,,,no,,,,no,maybe,,no,,,,no,maybe,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,maybe,,,,,maybe,maybe,,,,,,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rhigh facilitation,,,very good,,,,very good,,,,,very good,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,no,,,maybe,,,,,,,,,,,maybe,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,\rintermittent facilitation,,,maybe,,,,maybe,,,,,maybe,,,,maybe,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,maybe,,,,,no,maybe,,,very good,,,,,maybe,,very good,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,,\ravailable facilitation,,,maybe,,,,maybe,maybe,,,,maybe,maybe,,maybe,maybe,maybe,,,,no,maybe,,,no,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,maybe,no,maybe,,,,no,no,,,very good,maybe,,,,maybe,,very good,,,,,,,very good,,,,,maybe,,,,,,,,,,,,,,,,very good,,,,,,,maybe,maybe,,maybe,,,,,,,,maybe,,,,no,maybe,,,,,,,,,,,,,,\rno facilitation,,,no,maybe,,maybe,no,no,,,,no,maybe,,maybe,no,no,,,,no,maybe,,,no,,,,no,no,maybe,,,no,,,,,,maybe,maybe,maybe,,,,,,maybe,no,no,,,,,,maybe,no,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,no,no,maybe,,,no,,,,no,no,,no,,,,maybe,,,maybe,,,,no,maybe,,maybe,,,,,,,,,,,,,maybe,,,maybe,,,,no,maybe,,no,,,,,,,,maybe,,,,maybe,maybe,,,,,,,,,,,maybe,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rvideo recording,,,no,maybe,,maybe,maybe,no,,,,no,no,,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,maybe,no,,,,,,,,maybe,,,,,no,maybe,,,very good,no,,,,no,,,no,,,,no,maybe,,no,,,,,,,,,,,no,,,,,no,,,,no,maybe,,no,,,,very good,,,,,,,,,,,,,,,very good,,,,,,very good,,,,,,no,no,,\raudio recording,,,maybe,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,maybe,,\rnote taking,,,very good,,,maybe,maybe,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,no,maybe,,,,,,,,,,,very good,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rtwice-told stories,,,maybe,,,,maybe,maybe,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,very good,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,very good,,,,,very good,,,,,,,,,\rtimeline,,,maybe,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,no,maybe,,very good,maybe,,,,,,,,,,,,,,,,,,\rlandscape,,,maybe,,,,maybe,maybe,,,,maybe,,,,very good,,,,,maybe,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,maybe,,,,maybe,maybe,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,no,maybe,,,,,maybe,,,,,,,,,\rstory elements,,,maybe,,,,maybe,maybe,,,,maybe,,,,very good,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,maybe,,,,very good,,,,,,,,,,,,,,,,,,,maybe,,,,,,,very good,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rcomposite stories,,,maybe,,,,maybe,maybe,,,,no,maybe,,,very good,no,,,,no,no,,,no,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,no,maybe,,,very good,no,,,,no,maybe,,maybe,,,,maybe,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,no,maybe,,,,,maybe,maybe,,,,,,,,';});


define('lib/text!recommendations/recommendations_intervention_filledin.csv',[],function () { return ',#outcomes_peopleFeltHeard,unknown,never,occasionally,sometimes,often,mixed,#outcomes_peopleFeltInvolved,unknown,never,occasionally,sometimes,often,mixed,#outcomes_peopleLearnedAboutCommOrg,unknown,never,occasionally,sometimes,often,mixed,#outcomes_peopleWantedToTellMoreStories,unknown,never,occasionally,sometimes,often,mixed,#outcomes_peopleWantedToShareMoreStoriesWithEachOther,unknown,never,occasionally,sometimes,often,mixed,#outcomes_peopleFeltStoriesNeededToBeHeard,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleFeltNobodyCares,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleFeltNobodyCanMeetNeeds,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleFeltTheyNeedNewStories,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleWantedToKeepExploring,unknown,not at all,somewhat,definitely,mixed,#outcomes_crisisPointsWereFound,unknown,not at all,somewhat,definitely,mixed,#outcomes_issuesWereBeyondWords,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleLearnedAboutTopic,unknown,never,occasionally,sometimes,often,mixed,#outcomes_issuesNewMembersStruggleWith,unknown,not at all,somewhat,definitely,mixed,#outcomes_foundInfoWithoutUnderstanding,unknown,not at all,somewhat,definitely,mixed,#outcomes_foundOverConfidence,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleCuriousAboutStoryWork,unknown,never,occasionally,sometimes,often,mixed\r#interventions,"During your project, did the people in this group say they felt heard for the first time?",,,,,,,Did they say they felt involved for the first time?,,,,,,,Did they say they learned a lot about their community or organization?,,,,,,,"During your story collection, did these people seem to want to tell more stories than you collected?",,,,,,,Did you ever feel that they wanted to share more experiences with each other than they did?,,,,,,,"Did these people feel that some of the stories you collected ""needed to be heard"" by anyone?",,,,,,"Were there any issues that these people thought ""nobody cares"" about?",,,,,,Do the people in this group have needs that nobody can meet?,,,,,,Do these people need to start telling themselves new stories?,,,,,,Were there any issues about which the people in this group seemed to want to keep exploring?,,,,,,"Did you discover any ""crisis points"" where people in this group needed help and didn\'t get it?",,,,,,"Did you find any issues for this group that were beyond words, that no amount of discussion could resolve?",,,,,,Did these people say that they learned a lot about the topic by participating in the project?,,,,,,,Did you notice that new members of the community or organization were having a harder time making sense of things?,,,,,,"Were there any issues that these people found difficult to understand, even though abundant information was available?",,,,,,Did you discover any areas in which these people had more confidence than skill?,,,,,,Did any of these participants express an interest in learning more about story work?,,,,,,\rnarrative ombudsmen,,,,,good,very good,good,,,,,good,very good,,,,,,,,,,,,,good,good,good,,,,,good,good,good,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,good,very good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rnarrative suggestion boxes,,,,,good,very good,good,,,,,good,good,,,,,,,,,,,,,good,good,good,,,,,good,good,good,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rstory-sharing spaces,,,,,good,very good,good,,,,,,,,,,,,,,,,,,,good,very good,good,,,,,good,very good,good,,,,good,good,good,,,,,,,,,,good,very good,good,,,,good,good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,good,good,good\rnarrative orientations,,,,,,,,,,,,,,,,,,,good,very good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,,,,,,,,,,\rnarrative learning resources,,,,,,,,,,,,,,,,,,,good,very good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,good,good,good,,,,,,,\rnarrative simulation,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,good,very good,good,,,,good,very good,good,,,,,,,\rnarrative presentations,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,good,good,good,,,,,,,,,,,good,good,good\rdramatic action,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,good,very good,good,,,,,,,,,,good,good,good,,,,,,,,,,good,very good,good,,,,good,very good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rsensemaking spaces,,,,,,,,,,,,good,very good,,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,good,good,good,,,,,,,,,,good,good,good,,,,good,very good,good,,,,,,,,,,,,,,,,,good,good,good,,,,good,good,good,,,,good,good,good,,,,good,good,good,,,,,,,\rsensemaking pyramids,,,,,,,,,,,,good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,good,very good,good,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,good,good,good,,,,good,good,good,,,,,good,very good,good\rnarrative mentoring,,,,,good,good,good,,,,,good,good,,,,,,,,,,,,,good,good,good,,,,,good,very good,good,,,,good,good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,,good,good,good,,,,good,very good,good,,,,good,good,good,,,,good,good,good,,,,,good,good,good\rnarrative therapy,,,,,good,good,good,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,good,good,good,,,,good,very good,good,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rparticipatory theatre,,,,,good,good,good,,,,,good,very good,,,,,,,,,,,,,good,good,good,,,,,,,,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,good,very good,good,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,good,good';});

